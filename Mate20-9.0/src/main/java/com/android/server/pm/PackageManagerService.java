package com.android.server.pm;

import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.AppOpsManager;
import android.app.IActivityManager;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.common.HwFrameworkFactory;
import android.common.HwFrameworkMonitor;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.ServiceConnection;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.ChangedPackages;
import android.content.pm.ComponentInfo;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstantAppResolveInfo;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.PackageCleanItem;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageList;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageParser;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.SELinuxUtil;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.content.pm.dex.ArtManager;
import android.content.pm.dex.DexMetadataHelper;
import android.content.pm.dex.IArtManager;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.hardware.biometrics.fingerprint.V2_1.RequestStatus;
import android.hardware.display.DisplayManager;
import android.hdm.HwDeviceManager;
import android.hwtheme.HwThemeManager;
import android.iawareperf.UniPerf;
import android.installerMgr.InstallerMgr;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBackupSessionCallback;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.VolumeInfo;
import android.provider.Settings;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.system.OsConstants;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.ByteStringUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.Flog;
import android.util.Jlog;
import android.util.Log;
import android.util.LogPrinter;
import android.util.LongSparseArray;
import android.util.LongSparseLongArray;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import android.widget.Toast;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IMediaContainerService;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.IParcelFileDescriptorFactory;
import com.android.internal.os.SomeArgs;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.FunctionalUtils;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AttributeCache;
import com.android.server.BatteryService;
import com.android.server.DeviceIdleController;
import com.android.server.EventLogTags;
import com.android.server.HwServiceExFactory;
import com.android.server.HwServiceFactory;
import com.android.server.IntentResolver;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.ServiceThread;
import com.android.server.SmartShrinker;
import com.android.server.SystemConfig;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.UiThread;
import com.android.server.am.HwBroadcastRadarUtil;
import com.android.server.job.controllers.JobStatus;
import com.android.server.lights.LightsManager;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.pm.CompilerStats;
import com.android.server.pm.Installer;
import com.android.server.pm.PackageDexOptimizer;
import com.android.server.pm.ParallelPackageParser;
import com.android.server.pm.Settings;
import com.android.server.pm.dex.ArtManagerService;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.pm.dex.PackageDexUsage;
import com.android.server.pm.permission.BasePermission;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy;
import com.android.server.pm.permission.PermissionManagerInternal;
import com.android.server.pm.permission.PermissionManagerService;
import com.android.server.pm.permission.PermissionsState;
import com.android.server.security.VerityUtils;
import com.android.server.slice.SliceClientPermissions;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.usage.AppStandbyController;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.android.server.utils.PriorityDump;
import com.android.server.zrhung.IZRHungService;
import com.huawei.android.content.pm.IHwPackageManager;
import com.huawei.indexsearch.IIndexClearManager;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import huawei.android.app.HwCustEmergDataManager;
import huawei.android.bootanimation.IBootAnmation;
import huawei.android.security.IHwBehaviorCollectManager;
import huawei.cust.HwCustUtils;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import libcore.io.IoUtils;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends AbsPackageManagerService implements PackageSender, IHwPackageManagerInner {
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    static final int BROADCAST_DELAY = 10000;
    static final int CHECK_PENDING_VERIFICATION = 16;
    private static final long CLEAR_DATA_THRESHOLD_MS = 1000;
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    public static final String COMPRESSED_EXTENSION = ".gz";
    private static final boolean DEBUG_ABI_SELECTION = false;
    private static final boolean DEBUG_APP_DATA = false;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_BACKUP = DEBUG_FLAG;
    private static final boolean DEBUG_BROADCASTS = DEBUG_FLAG;
    public static final boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_DELAPP = false;
    public static final boolean DEBUG_DEXOPT = false;
    static final boolean DEBUG_DOMAIN_VERIFICATION = DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_FILTERS = DEBUG_FLAG;
    static final boolean DEBUG_FLAG = SystemProperties.get("ro.dbg.pms_log", "0").equals("on");
    public static final boolean DEBUG_INSTALL = DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_INSTANT = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_INTENT_MATCHING = DEBUG_FLAG;
    private static final boolean DEBUG_PACKAGE_INFO = DEBUG_FLAG;
    public static final boolean DEBUG_PACKAGE_SCANNING = DEBUG_FLAG;
    public static final boolean DEBUG_PERMISSIONS = DEBUG_FLAG;
    static final boolean DEBUG_PREFERRED = DEBUG_FLAG;
    public static final boolean DEBUG_REMOVE = DEBUG_FLAG;
    static final boolean DEBUG_SD_INSTALL = false;
    public static final boolean DEBUG_SETTINGS = DEBUG_FLAG;
    private static final boolean DEBUG_SHARED_LIBRARIES = DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_SHOW_INFO = DEBUG_FLAG;
    private static final boolean DEBUG_TRIAGED_MISSING = false;
    static final boolean DEBUG_UPGRADE = DEBUG_FLAG;
    /* access modifiers changed from: private */
    public static final boolean DEBUG_VERIFY = DEBUG_FLAG;
    public static final ComponentName DEFAULT_CONTAINER_COMPONENT = new ComponentName(DEFAULT_CONTAINER_PACKAGE, "com.android.defcontainer.DefaultContainerService");
    public static final String DEFAULT_CONTAINER_PACKAGE = "com.android.defcontainer";
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    static final int DEF_CONTAINER_BIND = 21;
    private static final Set<String> DISABLE_SPLIT_PKG = new HashSet(1);
    /* access modifiers changed from: private */
    public static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int END_COPY = 4;
    static final int FIND_INSTALL_LOC = 8;
    private static final int HBS_UID = 5508;
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    protected static final boolean HWFLOW = (Log.HWINFO || (Log.HWModuleLog && Log.isLoggable(TAG, 4)));
    static final int INIT_COPY = 5;
    private static final String INSTALL_PACKAGE_SUFFIX = "-";
    private static final String[] INSTANT_APP_BROADCAST_PERMISSION = {"android.permission.ACCESS_INSTANT_APPS"};
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    static final int MCS_BOUND = 3;
    static final int MCS_GIVE_UP = 11;
    static final int MCS_RECONNECT = 10;
    static final int MCS_UNBIND = 6;
    static final int MSG_LAN_ENGLISH = 256;
    static final int MSG_OPER_DATA_UPDATE = 2;
    static final int MSG_OPER_STOP = 1;
    private static final int NFC_UID = 1027;
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEIVCEOWNER = "com.android.cts.deviceowner";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEVICEANDPROFILEOWNER = "com.android.cts.deviceandprofileowner";
    private static final String PACKAGE_NAME_BASICADMINRECEIVER_CTS_PACKAGEINSTALLER = "com.android.cts.packageinstaller";
    private static final String PACKAGE_PARSER_CACHE_VERSION = "1";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    public static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final int PRIME_DOMAIN_DEFAULT = 0;
    private static final int PRIME_DOMAIN_UPGRADE = 1;
    private static final String PRODUCT_OVERLAY_DIR = "/product/overlay";
    /* access modifiers changed from: private */
    public static final Set<String> PROTECTED_ACTIONS = new ArraySet();
    private static final int RADIO_UID = 1001;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BG_SPEED_DEXOPT = 7;
    public static final int REASON_BOOT = 1;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 7;
    public static final int REASON_SHARED = 6;
    public static final int REASON_UNKNOWN = -1;
    static final int SCAN_AS_FULL_APP = 32768;
    static final int SCAN_AS_INSTANT_APP = 16384;
    static final int SCAN_AS_OEM = 524288;
    public static final int SCAN_AS_PRIVILEGED = 262144;
    static final int SCAN_AS_PRODUCT = 2097152;
    public static final int SCAN_AS_SYSTEM = 131072;
    static final int SCAN_AS_VENDOR = 1048576;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 65536;
    static final int SCAN_BOOTING = 16;
    static final int SCAN_CHECK_ONLY = 1024;
    static final int SCAN_DELETE_DATA_ON_FAILURES = 64;
    static final int SCAN_DONT_KILL_APP = 2048;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 8192;
    static final int SCAN_IGNORE_FROZEN = 4096;
    static final int SCAN_INITIAL = 512;
    static final int SCAN_MOVE = 256;
    static final int SCAN_NEW_INSTALL = 4;
    static final int SCAN_NO_DEX = 1;
    static final int SCAN_REQUIRE_KNOWN = 128;
    static final int SCAN_UPDATE_SIGNATURE = 2;
    static final int SCAN_UPDATE_TIME = 8;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SE_UID = 1068;
    private static final int SHELL_UID = 2000;
    private static final int SPI_UID = 1054;
    static final int START_CLEANING_PACKAGE = 7;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    public static final String STUB_SUFFIX = "-Stub";
    private static final String SUW_FRP_STATE = "hw_suw_frp_state";
    private static final String SYSTEM_ROOT_DIR = "/system";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = 600000;
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    private static boolean isBoPD = SystemProperties.getBoolean("sys.bopd", false);
    static IHwPackageManagerServiceEx mHwPMSEx = null;
    private static final Comparator<ProviderInfo> mProviderInitOrderSorter = new Comparator<ProviderInfo>() {
        public int compare(ProviderInfo p1, ProviderInfo p2) {
            int v1 = p1.initOrder;
            int v2 = p2.initOrder;
            if (v1 > v2) {
                return -1;
            }
            return v1 < v2 ? 1 : 0;
        }
    };
    /* access modifiers changed from: private */
    public static final Comparator<ResolveInfo> mResolvePrioritySorter = new Comparator<ResolveInfo>() {
        public int compare(ResolveInfo r1, ResolveInfo r2) {
            int v1 = r1.priority;
            int v2 = r2.priority;
            int i = 1;
            if (v1 != v2) {
                if (v1 > v2) {
                    i = -1;
                }
                return i;
            }
            int v12 = r1.preferredOrder;
            int v22 = r2.preferredOrder;
            if (v12 != v22) {
                if (v12 > v22) {
                    i = -1;
                }
                return i;
            } else if (r1.isDefault != r2.isDefault) {
                if (r1.isDefault) {
                    i = -1;
                }
                return i;
            } else {
                int v13 = r1.match;
                int v23 = r2.match;
                if (v13 != v23) {
                    if (v13 > v23) {
                        i = -1;
                    }
                    return i;
                } else if (r1.system != r2.system) {
                    if (r1.system) {
                        i = -1;
                    }
                    return i;
                } else if (r1.activityInfo != null) {
                    return r1.activityInfo.packageName.compareTo(r2.activityInfo.packageName);
                } else {
                    if (r1.serviceInfo != null) {
                        return r1.serviceInfo.packageName.compareTo(r2.serviceInfo.packageName);
                    }
                    if (r1.providerInfo != null) {
                        return r1.providerInfo.packageName.compareTo(r2.providerInfo.packageName);
                    }
                    return 0;
                }
            }
        }
    };
    private static final File sAppInstallDir = new File(Environment.getDataDirectory(), "app");
    protected static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), "app-lib");
    private static final Intent sBrowserIntent = new Intent();
    private static final File sDrmAppPrivateInstallDir = new File(Environment.getDataDirectory(), "app-private");
    public static final boolean sIsMygote;
    static UserManagerService sUserManager;
    final ActivityIntentResolver mActivities = new ActivityIntentResolver();
    private ActivityManagerInternal mActivityManagerInternal;
    ApplicationInfo mAndroidApplication;
    final ArtManagerService mArtManagerService;
    @GuardedBy("mAvailableFeatures")
    final ArrayMap<String, FeatureInfo> mAvailableFeatures;
    private File mCacheDir;
    private Map<Integer, ParceledListSlice<PackageInfo>> mCacheInstalledPackages = new HashMap();
    @GuardedBy("mPackages")
    final SparseArray<SparseArray<String>> mChangedPackages = new SparseArray<>();
    @GuardedBy("mPackages")
    int mChangedPackagesSequenceNumber;
    @GuardedBy("mPackages")
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers = new SparseArray<>();
    private final CompilerStats mCompilerStats = new CompilerStats();
    /* access modifiers changed from: private */
    public IMediaContainerService mContainerService = null;
    final Context mContext;
    protected boolean mCotaFlag = false;
    /* access modifiers changed from: private */
    public HwCustPackageManagerService mCustPms = ((HwCustPackageManagerService) HwCustUtils.createObj(HwCustPackageManagerService.class, new Object[0]));
    ComponentName mCustomResolverComponentName;
    /* access modifiers changed from: private */
    public final DefaultContainerConnection mDefContainerConn = new DefaultContainerConnection();
    final int mDefParseFlags;
    @GuardedBy("mPackages")
    boolean mDefaultContainerWhitelisted = false;
    protected final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    /* access modifiers changed from: private */
    public boolean mDeferProtectedFilters = true;
    private DeviceIdleController.LocalService mDeviceIdleController;
    private final DexManager mDexManager;
    @GuardedBy("mPackages")
    private boolean mDexOptDialogShown;
    /* access modifiers changed from: private */
    public ArraySet<Integer> mDirtyUsers = new ArraySet<>();
    /* access modifiers changed from: private */
    public final ArraySet<String> mExistingSystemPackages = new ArraySet<>();
    private final ArrayMap<String, File> mExpectingBetter = new ArrayMap<>();
    PackageManagerInternal.ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    @GuardedBy("mPackages")
    final ArraySet<String> mFrozenPackages = new ArraySet<>();
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    HwInnerPackageManagerService mHwInnerService = new HwInnerPackageManagerService(this);
    IBootAnmation mIBootAnmation = null;
    final Object mInstallLock = new Object();
    @GuardedBy("mInstallLock")
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo = new ResolveInfo();
    /* access modifiers changed from: private */
    public final InstantAppRegistry mInstantAppRegistry;
    final InstantAppResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, PackageParser.Instrumentation> mInstrumentation = new ArrayMap<>();
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates = new SparseArray<>();
    private int mIntentFilterVerificationToken = 0;
    /* access modifiers changed from: private */
    public final IntentFilterVerifier<PackageParser.ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    protected boolean mIsDefaultGoogleCalendar = SystemProperties.getBoolean("ro.default_GoogleCalendar", false);
    protected boolean mIsDefaultPreferredActivityChanged = false;
    boolean mIsPackageScanMultiThread = SystemProperties.getBoolean("ro.config.hw_packagescan_multi", false);
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsPrePUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy("mPackages")
    final SparseIntArray mIsolatedOwners = new SparseIntArray();
    /* access modifiers changed from: private */
    public List<String> mKeepUninstalledPackages;
    final ArrayMap<String, Set<String>> mKnownCodebase = new ArrayMap<>();
    @GuardedBy("mLoadedVolumes")
    final ArraySet<String> mLoadedVolumes = new ArraySet<>();
    private boolean mMediaMounted = false;
    final DisplayMetrics mMetrics;
    private HwFrameworkMonitor mMonitor = HwFrameworkFactory.getHwFrameworkMonitor();
    /* access modifiers changed from: private */
    public final MoveCallbacks mMoveCallbacks;
    public boolean mNeedClearDeviceForCTS = false;
    int mNextInstallToken = 1;
    private AtomicInteger mNextMoveId = new AtomicInteger();
    /* access modifiers changed from: private */
    public final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    protected final PackageDexOptimizer mPackageDexOptimizer;
    /* access modifiers changed from: private */
    @GuardedBy("mPackages")
    public final ArraySet<PackageManagerInternal.PackageListObserver> mPackageListObservers = new ArraySet<>();
    final PackageParser.Callback mPackageParserCallback = new PackageParserCallback();
    private final PackageUsage mPackageUsage = new PackageUsage();
    @GuardedBy("mPackages")
    final ArrayMap<String, PackageParser.Package> mPackages = new ArrayMap<>();
    final ParallelPackageParserCallback mParallelPackageParserCallback = new ParallelPackageParserCallback();
    final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts();
    final SparseArray<PackageVerificationState> mPendingVerification = new SparseArray<>();
    /* access modifiers changed from: private */
    public int mPendingVerificationToken = 0;
    protected PermissionManagerInternal.PermissionCallback mPermissionCallback = new PermissionManagerInternal.PermissionCallback() {
        public void onGidsChanged(final int appId, final int userId) {
            PackageManagerService.this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
                }
            });
        }

        public void onPermissionGranted(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }

        public void onInstallPermissionGranted() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionRevoked(int uid, int userId) {
            PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
            }
            PackageManagerService.this.killUid(UserHandle.getAppId(uid), userId, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
        }

        public void onInstallPermissionRevoked() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
            synchronized (PackageManagerService.this.mPackages) {
                for (int userId : updatedUserIds) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, sync);
                }
            }
        }

        public void onInstallPermissionUpdated() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.scheduleWriteSettingsLocked();
            }
        }

        public void onPermissionRemoved() {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    protected final PermissionManagerInternal mPermissionManager;
    final boolean mPermissionReviewRequired;
    PackageParser.Package mPlatformPackage;
    private ArrayList<Message> mPostSystemReadyMessages;
    private Future<?> mPrepareAppDataFuture;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy("mProtectedBroadcasts")
    final ArraySet<String> mProtectedBroadcasts = new ArraySet<>();
    /* access modifiers changed from: private */
    public final List<PackageParser.ActivityIntentInfo> mProtectedFilters = new ArrayList();
    final ProtectedPackages mProtectedPackages;
    final ProviderIntentResolver mProviders = new ProviderIntentResolver();
    final ArrayMap<String, PackageParser.Provider> mProvidersByAuthority = new ArrayMap<>();
    final ActivityIntentResolver mReceivers = new ActivityIntentResolver();
    final String mRequiredInstallerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity = new ActivityInfo();
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo = new ResolveInfo();
    boolean mResolverReplaced = false;
    final SparseArray<PostInstallData> mRunningInstalls = new SparseArray<>();
    volatile boolean mSafeMode;
    final int mSdkVersion = Build.VERSION.SDK_INT;
    final String[] mSeparateProcesses;
    final ServiceIntentResolver mServices = new ServiceIntentResolver();
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy("mPackages")
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, LongSparseArray<SharedLibraryEntry>> mSharedLibraries = new ArrayMap<>();
    final String mSharedSystemSharedLibraryPackageName;
    private long mStartTimer = 0;
    final ArrayMap<String, LongSparseArray<SharedLibraryEntry>> mStaticLibsByDeclaringPackage = new ArrayMap<>();
    private StorageEventListener mStorageListener = new StorageEventListener() {
        public void onVolumeStateChanged(VolumeInfo vol, int oldState, int newState) {
            if (vol.type != 1) {
                return;
            }
            if (vol.state == 2) {
                String volumeUuid = vol.getFsUuid();
                PackageManagerService.sUserManager.reconcileUsers(volumeUuid);
                PackageManagerService.this.reconcileApps(volumeUuid);
                PackageManagerService.this.mInstallerService.onPrivateVolumeMounted(volumeUuid);
                PackageManagerService.this.loadPrivatePackages(vol);
            } else if (vol.state == 5) {
                PackageManagerService.this.unloadPrivatePackages(vol);
            }
        }

        public void onVolumeForgotten(String fsUuid) {
            if (TextUtils.isEmpty(fsUuid)) {
                Slog.e(PackageManagerService.TAG, "Forgetting internal storage is probably a mistake; ignoring");
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageSetting ps : PackageManagerService.this.mSettings.getVolumePackagesLPr(fsUuid)) {
                    Slog.d(PackageManagerService.TAG, "Destroying " + ps.name + " because volume was forgotten");
                    PackageManagerService.this.deletePackageVersioned(new VersionedPackage(ps.name, -1), new PackageManager.LegacyPackageDeleteObserver(null).getBinder(), 0, 2);
                    AttributeCache.instance().removePackage(ps.name);
                }
                PackageManagerService.this.mSettings.onVolumeForgotten(fsUuid);
                PackageManagerService.this.mSettings.writeLPr();
            }
        }
    };
    final String mStorageManagerPackage;
    volatile boolean mSystemReady;
    final String mSystemTextClassifierPackage;
    protected ArrayList<PackageParser.Package> mTempPkgList = new ArrayList<>();
    private int mTimerCounter = 0;
    final ArraySet<String> mTransferedPackages = new ArraySet<>();
    private UserManagerInternal mUserManagerInternal;
    SparseBooleanArray mUserNeedsBadging = new SparseBooleanArray();
    /* access modifiers changed from: private */
    public volatile boolean mWebInstantAppsDisabled;
    int tSdkVersion = -1;

    final class ActivityIntentResolver extends IntentResolver<PackageParser.ActivityIntentInfo, ResolveInfo> {
        /* access modifiers changed from: private */
        public final ArrayMap<ComponentName, PackageParser.Activity> mActivities = new ArrayMap<>();
        private int mFlags;

        public class ActionIterGenerator extends IterGenerator<String> {
            public ActionIterGenerator() {
                super();
            }

            public Iterator<String> generate(PackageParser.ActivityIntentInfo info) {
                return info.actionsIterator();
            }
        }

        public class AuthoritiesIterGenerator extends IterGenerator<IntentFilter.AuthorityEntry> {
            public AuthoritiesIterGenerator() {
                super();
            }

            public Iterator<IntentFilter.AuthorityEntry> generate(PackageParser.ActivityIntentInfo info) {
                return info.authoritiesIterator();
            }
        }

        public class CategoriesIterGenerator extends IterGenerator<String> {
            public CategoriesIterGenerator() {
                super();
            }

            public Iterator<String> generate(PackageParser.ActivityIntentInfo info) {
                return info.categoriesIterator();
            }
        }

        public class IterGenerator<E> {
            public IterGenerator() {
            }

            public Iterator<E> generate(PackageParser.ActivityIntentInfo info) {
                return null;
            }
        }

        public class SchemesIterGenerator extends IterGenerator<String> {
            public SchemesIterGenerator() {
                super();
            }

            public Iterator<String> generate(PackageParser.ActivityIntentInfo info) {
                return info.schemesIterator();
            }
        }

        ActivityIntentResolver() {
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            boolean z = false;
            if (PackageManagerService.this.mCustPms == null || !PackageManagerService.this.mCustPms.isSkipMmsSendImageAction()) {
                if ((flags & 65536) != 0) {
                    z = true;
                }
                return super.queryIntent(intent, resolvedType, z, userId);
            }
            if ((flags & 65536) != 0) {
                z = true;
            }
            return PackageManagerService.this.mCustPms.filterResolveInfos(super.queryIntent(intent, resolvedType, z, userId), intent, resolvedType);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<PackageParser.Activity> packageActivities, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageActivities == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageActivities.size();
            ArrayList<PackageParser.ActivityIntentInfo[]> listCut = new ArrayList<>(N);
            for (int i = 0; i < N; i++) {
                ArrayList<PackageParser.ActivityIntentInfo> intentFilters = packageActivities.get(i).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    PackageParser.ActivityIntentInfo[] array = new PackageParser.ActivityIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        private PackageParser.Activity findMatchingActivity(List<PackageParser.Activity> activityList, ActivityInfo activityInfo) {
            Iterator<PackageParser.Activity> it = activityList.iterator();
            while (it.hasNext()) {
                PackageParser.Activity sysActivity = it.next();
                if (sysActivity.info.name.equals(activityInfo.name) || sysActivity.info.name.equals(activityInfo.targetActivity)) {
                    return sysActivity;
                }
                if (sysActivity.info.targetActivity != null && (sysActivity.info.targetActivity.equals(activityInfo.name) || sysActivity.info.targetActivity.equals(activityInfo.targetActivity))) {
                    return sysActivity;
                }
            }
            return null;
        }

        private <T> void getIntentListSubset(List<PackageParser.ActivityIntentInfo> intentList, IterGenerator<T> generator, Iterator<T> searchIterator) {
            while (searchIterator.hasNext() && intentList.size() != 0) {
                T searchAction = searchIterator.next();
                Iterator<PackageParser.ActivityIntentInfo> intentIter = intentList.iterator();
                while (intentIter.hasNext()) {
                    boolean selectionFound = false;
                    Iterator<T> intentSelectionIter = generator.generate(intentIter.next());
                    while (true) {
                        if (intentSelectionIter == null || !intentSelectionIter.hasNext()) {
                            break;
                        }
                        T intentSelection = intentSelectionIter.next();
                        if (intentSelection != null && intentSelection.equals(searchAction)) {
                            selectionFound = true;
                            break;
                        }
                    }
                    if (!selectionFound) {
                        intentIter.remove();
                    }
                }
            }
        }

        private boolean isProtectedAction(PackageParser.ActivityIntentInfo filter) {
            Iterator<String> actionsIter = filter.actionsIterator();
            while (actionsIter != null && actionsIter.hasNext()) {
                if (PackageManagerService.PROTECTED_ACTIONS.contains(actionsIter.next())) {
                    return true;
                }
            }
            return false;
        }

        private void adjustPriority(List<PackageParser.Activity> systemActivities, PackageParser.ActivityIntentInfo intent) {
            List<PackageParser.Activity> list = systemActivities;
            PackageParser.ActivityIntentInfo activityIntentInfo = intent;
            if (intent.getPriority() > 0) {
                ActivityInfo activityInfo = activityIntentInfo.activity.info;
                if (!((activityInfo.applicationInfo.privateFlags & 8) != 0)) {
                    if (PackageManagerService.DEBUG_FILTERS) {
                        Slog.i(PackageManagerService.TAG, "Non-privileged app; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                    }
                    activityIntentInfo.setPriority(0);
                } else if (list != null) {
                    PackageParser.Activity foundActivity = findMatchingActivity(list, activityInfo);
                    if (foundActivity == null) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            Slog.i(PackageManagerService.TAG, "New activity; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                        }
                        activityIntentInfo.setPriority(0);
                        return;
                    }
                    List<PackageParser.ActivityIntentInfo> intentListCopy = new ArrayList<>(foundActivity.intents);
                    ArrayList findFilters = findFilters(activityIntentInfo);
                    Iterator<String> actionsIterator = intent.actionsIterator();
                    if (actionsIterator != null) {
                        getIntentListSubset(intentListCopy, new ActionIterGenerator(), actionsIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                Slog.i(PackageManagerService.TAG, "Mismatched action; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> categoriesIterator = intent.categoriesIterator();
                    if (categoriesIterator != null) {
                        getIntentListSubset(intentListCopy, new CategoriesIterGenerator(), categoriesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                Slog.i(PackageManagerService.TAG, "Mismatched category; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<String> schemesIterator = intent.schemesIterator();
                    if (schemesIterator != null) {
                        getIntentListSubset(intentListCopy, new SchemesIterGenerator(), schemesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                Slog.i(PackageManagerService.TAG, "Mismatched scheme; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    Iterator<IntentFilter.AuthorityEntry> authoritiesIterator = intent.authoritiesIterator();
                    if (authoritiesIterator != null) {
                        getIntentListSubset(intentListCopy, new AuthoritiesIterGenerator(), authoritiesIterator);
                        if (intentListCopy.size() == 0) {
                            if (PackageManagerService.DEBUG_FILTERS) {
                                Slog.i(PackageManagerService.TAG, "Mismatched authority; cap priority to 0; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                            }
                            activityIntentInfo.setPriority(0);
                            return;
                        }
                    }
                    int cappedPriority = 0;
                    int i = intentListCopy.size() - 1;
                    while (true) {
                        int i2 = i;
                        if (i2 < 0) {
                            break;
                        }
                        cappedPriority = Math.max(cappedPriority, intentListCopy.get(i2).getPriority());
                        i = i2 - 1;
                    }
                    if (intent.getPriority() > cappedPriority) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            Slog.i(PackageManagerService.TAG, "Found matching filter(s); cap priority to " + cappedPriority + "; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                        }
                        activityIntentInfo.setPriority(cappedPriority);
                    }
                } else if (!isProtectedAction(activityIntentInfo)) {
                } else {
                    if (PackageManagerService.this.mDeferProtectedFilters) {
                        PackageManagerService.this.mProtectedFilters.add(activityIntentInfo);
                        if (PackageManagerService.DEBUG_FILTERS) {
                            Slog.i(PackageManagerService.TAG, "Protected action; save for later; package: " + applicationInfo.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                        }
                        return;
                    }
                    if (PackageManagerService.DEBUG_FILTERS && PackageManagerService.this.mSetupWizardPackage == null) {
                        Slog.i(PackageManagerService.TAG, "No setup wizard; All protected intents capped to priority 0");
                    }
                    if (activityIntentInfo.activity.info.packageName.equals(PackageManagerService.this.mSetupWizardPackage)) {
                        if (PackageManagerService.DEBUG_FILTERS) {
                            Slog.i(PackageManagerService.TAG, "Found setup wizard; allow priority " + intent.getPriority() + "; package: " + activityIntentInfo.activity.info.packageName + " activity: " + activityIntentInfo.activity.className + " priority: " + intent.getPriority());
                        }
                        return;
                    }
                    if (PackageManagerService.DEBUG_FILTERS) {
                        Slog.i(PackageManagerService.TAG, "Protected action; cap priority to 0; package: " + activityIntentInfo.activity.info.packageName + " activity: " + activityIntentInfo.activity.className + " origPrio: " + intent.getPriority());
                    }
                    activityIntentInfo.setPriority(0);
                }
            }
        }

        public final void addActivity(PackageParser.Activity a, String type) {
            this.mActivities.put(a.getComponentName(), a);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(type);
                sb.append(" ");
                sb.append(a.info.nonLocalizedLabel != null ? a.info.nonLocalizedLabel : a.info.name);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
            }
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                Log.v(PackageManagerService.TAG, "    Class=" + a.info.name);
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ActivityIntentInfo intent = (PackageParser.ActivityIntentInfo) a.intents.get(j);
                if ("activity".equals(type)) {
                    PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);
                    adjustPriority((ps == null || ps.pkg == null) ? null : ps.pkg.activities, intent);
                }
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Activity " + a.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeActivity(PackageParser.Activity a, String type) {
            Object obj;
            this.mActivities.remove(a.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(type);
                sb.append(" ");
                if (a.info.nonLocalizedLabel != null) {
                    obj = a.info.nonLocalizedLabel;
                } else {
                    obj = a.info.name;
                }
                sb.append(obj);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
                Log.v(PackageManagerService.TAG, "    Class=" + a.info.name);
            }
            int NI = a.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ActivityIntentInfo intent = (PackageParser.ActivityIntentInfo) a.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        /* access modifiers changed from: protected */
        public boolean allowFilterResult(PackageParser.ActivityIntentInfo filter, List<ResolveInfo> dest) {
            ActivityInfo filterAi = filter.activity.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ActivityInfo destAi = dest.get(i).activityInfo;
                if (destAi.name == filterAi.name && destAi.packageName == filterAi.packageName) {
                    return false;
                }
            }
            return true;
        }

        /* access modifiers changed from: protected */
        public PackageParser.ActivityIntentInfo[] newArray(int size) {
            return new PackageParser.ActivityIntentInfo[size];
        }

        /* access modifiers changed from: protected */
        public boolean isFilterStopped(PackageParser.ActivityIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            PackageParser.Package p = filter.activity.owner;
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (ps != null) {
                    if (((ps.pkgFlags & 1) != 0 && !HwServiceFactory.isCustedCouldStopped(p.packageName, true, ps.getStopped(userId))) || !ps.getStopped(userId)) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        /* access modifiers changed from: protected */
        public boolean isPackageForFilter(String packageName, PackageParser.ActivityIntentInfo info) {
            return packageName.equals(info.activity.owner.packageName);
        }

        /* access modifiers changed from: protected */
        public ResolveInfo newResult(PackageParser.ActivityIntentInfo info, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || !PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.activity.info, this.mFlags, userId)) {
                return null;
            }
            PackageParser.Activity activity = info.activity;
            PackageSetting ps = (PackageSetting) activity.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.mHwPMSEx.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ActivityInfo ai = PackageParser.generateActivityInfo(activity, this.mFlags, userState, userId);
            if (ai == null) {
                return null;
            }
            boolean matchInstantApp = false;
            boolean matchExplicitlyVisibleOnly = (this.mFlags & DumpState.DUMP_HANDLE) != 0;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            boolean componentVisible = matchVisibleToInstantApp && info.isVisibleToInstantApp() && (!matchExplicitlyVisibleOnly || info.isExplicitlyVisibleToInstantApp());
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                matchInstantApp = true;
            }
            if (matchVisibleToInstantApp && !componentVisible && !userState.instantApp) {
                return null;
            }
            if (!matchInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.activityInfo = ai;
            if ((this.mFlags & 64) != 0) {
                res.filter = info;
            }
            if (info != null && info.countActionFilters() > 0) {
                res.filter = info;
            }
            if (info != null) {
                res.handleAllWebDataURI = info.handleAllWebDataURI();
            }
            res.priority = info.getPriority();
            res.preferredOrder = activity.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            if (PackageManagerService.this.userNeedsBadging(userId)) {
                res.noResourceId = true;
            } else {
                res.icon = info.icon;
            }
            res.iconResourceId = info.icon;
            res.system = res.activityInfo.applicationInfo.isSystemApp();
            res.isInstantAppAvailable = userState.instantApp;
            return res;
        }

        /* access modifiers changed from: protected */
        public void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        /* access modifiers changed from: protected */
        public void dumpFilter(PrintWriter out, String prefix, PackageParser.ActivityIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.activity)));
            out.print(' ');
            filter.activity.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        /* access modifiers changed from: protected */
        public Object filterToLabel(PackageParser.ActivityIntentInfo filter) {
            return filter.activity;
        }

        /* access modifiers changed from: protected */
        public void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            PackageParser.Activity activity = (PackageParser.Activity) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(activity)));
            out.print(' ');
            activity.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    private interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    private final class ClearStorageConnection implements ServiceConnection {
        IMediaContainerService mContainerService;

        private ClearStorageConnection() {
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            synchronized (this) {
                this.mContainerService = IMediaContainerService.Stub.asInterface(Binder.allowBlocking(service));
                notifyAll();
            }
        }

        public void onServiceDisconnected(ComponentName name) {
            synchronized (this) {
                if (this.mContainerService == null) {
                    Slog.w(PackageManagerService.TAG, "onServiceDisconnected unknown reason");
                    notifyAll();
                }
            }
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    private static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        private CrossProfileDomainInfo() {
        }
    }

    class DefaultContainerConnection implements ServiceConnection {
        DefaultContainerConnection() {
        }

        public void onServiceConnected(ComponentName name, IBinder service) {
            PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(3, IMediaContainerService.Stub.asInterface(Binder.allowBlocking(service))));
        }

        public void onServiceDisconnected(ComponentName name) {
        }
    }

    class FileInstallArgs extends InstallArgs {
        /* access modifiers changed from: private */
        public File codeFile;
        private File resourceFile;
        final /* synthetic */ PackageManagerService this$0;

        /* JADX WARNING: Illegal instructions before constructor call */
        FileInstallArgs(PackageManagerService this$02, InstallParams params) {
            super(r0.origin, r0.move, r0.observer, r0.installFlags, r0.installerPackageName, r0.volumeUuid, params.getUser(), null, r0.packageAbiOverride, r0.grantedRuntimePermissions, r0.traceMethod, r0.traceCookie, r0.signingDetails, r0.installReason);
            InstallParams installParams = params;
            this.this$0 = this$02;
            if (isFwdLocked()) {
                throw new IllegalArgumentException("Forward locking only supported in ASEC");
            }
        }

        /* JADX INFO: super call moved to the top of the method (can break code semantics) */
        FileInstallArgs(PackageManagerService this$02, String codePath, String resourcePath, String[] instructionSets) {
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, 0, PackageParser.SigningDetails.UNKNOWN, 0);
            String str = resourcePath;
            this.this$0 = this$02;
            String str2 = codePath;
            File file = null;
            this.codeFile = str2 != null ? new File(str2) : null;
            String str3 = resourcePath;
            this.resourceFile = str3 != null ? new File(str3) : file;
        }

        /* access modifiers changed from: package-private */
        public int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            Trace.traceBegin(262144, "copyApk");
            try {
                return doCopyApk(imcs, temp);
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
            int ret;
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, this.origin.file + " already staged; skipping copy");
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = this.this$0.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret2 = imcs.copyPackage(this.origin.file.getAbsolutePath(), new IParcelFileDescriptorFactory.Stub() {
                    public ParcelFileDescriptor open(String name, int mode) throws RemoteException {
                        if (FileUtils.isValidExtFilename(name)) {
                            try {
                                File file = new File(FileInstallArgs.this.codeFile, name);
                                FileDescriptor fd = Os.open(file.getAbsolutePath(), OsConstants.O_RDWR | OsConstants.O_CREAT, 420);
                                Os.chmod(file.getAbsolutePath(), 420);
                                return new ParcelFileDescriptor(fd);
                            } catch (ErrnoException e) {
                                throw new RemoteException("Failed to open: " + e.getMessage());
                            }
                        } else {
                            throw new IllegalArgumentException("Invalid filename: " + name);
                        }
                    }
                });
                if (ret2 != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret2;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                NativeLibraryHelper.Handle handle = null;
                try {
                    handle = NativeLibraryHelper.Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, this.abiOverride);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = RequestStatus.SYS_ETIMEDOUT;
                } catch (Throwable th) {
                    IoUtils.closeQuietly(null);
                    throw th;
                }
                IoUtils.closeQuietly(handle);
                return ret;
            } catch (IOException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to create copy file: " + e2);
                return -4;
            }
        }

        /* access modifiers changed from: package-private */
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        public boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = this.this$0.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (!SELinux.restoreconRecursive(afterCodeFile)) {
                    Slog.w(PackageManagerService.TAG, "Failed to restorecon");
                    return false;
                }
                this.codeFile = afterCodeFile;
                this.resourceFile = afterCodeFile;
                try {
                    pkg.setCodePath(afterCodeFile.getCanonicalPath());
                    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                    pkg.setApplicationInfoCodePath(pkg.codePath);
                    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                    pkg.setApplicationInfoResourcePath(pkg.codePath);
                    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                    return true;
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Failed to get path: " + afterCodeFile, e);
                    return false;
                }
            } catch (ErrnoException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e2);
                return false;
            }
        }

        /* access modifiers changed from: package-private */
        public int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        public String getCodePath() {
            if (this.codeFile != null) {
                return this.codeFile.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        public String getResourcePath() {
            if (this.resourceFile != null) {
                return this.resourceFile.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp() {
            if (this.codeFile == null || !this.codeFile.exists()) {
                return false;
            }
            this.this$0.removeCodePathLI(this.codeFile);
            if (this.resourceFile != null && !FileUtils.contains(this.codeFile, this.resourceFile)) {
                this.resourceFile.delete();
            }
            return true;
        }

        /* access modifiers changed from: package-private */
        public void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            if (this.codeFile != null && this.codeFile.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParser.PackageParserException e) {
                }
            }
            cleanUp();
            this.this$0.removeDexFiles(allCodePaths, this.instructionSets);
        }

        /* access modifiers changed from: package-private */
        public boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    private abstract class HandlerParams {
        private static final int MAX_RETRIES = 4;
        private int mRetries = 0;
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        /* access modifiers changed from: package-private */
        public abstract void handleReturnCode();

        /* access modifiers changed from: package-private */
        public abstract void handleServiceError();

        /* access modifiers changed from: package-private */
        public abstract void handleStartCopy() throws RemoteException;

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceMethod(String traceMethod2) {
            this.traceMethod = traceMethod2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceCookie(int traceCookie2) {
            this.traceCookie = traceCookie2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public final boolean startCopy() {
            boolean res = false;
            try {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "startCopy " + this.mUser + ": " + this);
                }
                int i = this.mRetries + 1;
                this.mRetries = i;
                if (i > 4) {
                    Slog.w(PackageManagerService.TAG, "Failed to invoke remote methods on default container service. Giving up");
                    PackageManagerService.this.mHandler.sendEmptyMessage(11);
                    handleServiceError();
                    return false;
                }
                handleStartCopy();
                res = true;
                handleReturnCode();
                return res;
            } catch (RemoteException e) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Posting install MCS_RECONNECT");
                }
                PackageManagerService.this.mHandler.sendEmptyMessage(10);
                res = false;
            } catch (Exception e2) {
                Log.e(PackageManagerService.TAG, "Posting install MCS_GIVE_UP");
                PackageManagerService.this.mHandler.sendEmptyMessage(11);
            }
        }

        /* access modifiers changed from: package-private */
        public final void serviceError() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "serviceError");
            }
            handleServiceError();
            handleReturnCode();
        }
    }

    public class HwInnerPackageManagerService extends IHwPackageManager.Stub {
        PackageManagerService mPMS;

        HwInnerPackageManagerService(PackageManagerService pms) {
            this.mPMS = pms;
        }

        public boolean isPerfOptEnable(String packageName, int optType) {
            return PackageManagerService.mHwPMSEx.isPerfOptEnable(packageName, optType);
        }

        public int getAppUseNotchMode(String packageName) {
            return PackageManagerService.mHwPMSEx.getAppUseNotchMode(packageName);
        }

        public void setAppUseNotchMode(String packageName, int mode) {
            PackageManagerService.mHwPMSEx.setAppUseNotchMode(packageName, mode);
        }

        public void setAppCanUninstall(String packageName, boolean canUninstall) {
            PackageManagerService.mHwPMSEx.setAppCanUninstall(packageName, canUninstall);
        }

        public boolean setApplicationMaxAspectRatio(String packageName, float ar) {
            return PackageManagerService.mHwPMSEx.setApplicationMaxAspectRatio(packageName, ar);
        }

        public float getApplicationMaxAspectRatio(String packageName) {
            return PackageManagerService.mHwPMSEx.getApplicationMaxAspectRatio(packageName);
        }

        public boolean setApplicationAspectRatio(String packageName, String aspectName, float ar) {
            return PackageManagerService.mHwPMSEx.setApplicationAspectRatio(packageName, aspectName, ar);
        }

        public float getApplicationAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public List<String> getPreinstalledApkList() {
            return PackageManagerService.mHwPMSEx.getPreinstalledApkList();
        }

        public List<String> getHwPublicityAppList() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppList();
        }

        public ParcelFileDescriptor getHwPublicityAppParcelFileDescriptor() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppParcelFileDescriptor();
        }

        public int startBackupSession(IBackupSessionCallback callback) {
            return PackageManagerService.mHwPMSEx.getStartBackupSession(callback);
        }

        public int executeBackupTask(int sessionId, String taskCmd) {
            return PackageManagerService.mHwPMSEx.getExecuteBackupTask(sessionId, taskCmd);
        }

        public int finishBackupSession(int sessionId) {
            return PackageManagerService.mHwPMSEx.getFinishBackupSession(sessionId);
        }

        public String getResourcePackageNameByIcon(String pkgName, int icon, int userId) {
            return PackageManagerService.mHwPMSEx.getResourcePackageNameByIcon(pkgName, icon, userId);
        }

        public boolean scanInstallApk(String apkFile) {
            return PackageManagerService.mHwPMSEx.scanInstallApk(apkFile);
        }

        public List<String> getScanInstallList() {
            return PackageManagerService.mHwPMSEx.getScanInstallList();
        }

        public void setHdbKey(String key) {
            PackageManagerService.mHwPMSEx.setHdbKey(key);
        }

        public boolean pmInstallHwTheme(String themePath, boolean setwallpaper, int userId) {
            return PackageManagerService.mHwPMSEx.pmInstallHwTheme(themePath, setwallpaper, userId);
        }

        public boolean isMapleEnv() {
            return PackageManagerService.sIsMygote;
        }

        public boolean getMapleEnableFlag(String packageName) {
            if (PackageManagerService.sIsMygote) {
                return HwMaplePMServiceUtils.getMapleEnableFlag(packageName);
            }
            return false;
        }

        public void setMapleEnableFlag(String packageName, boolean flag) {
            if (PackageManagerService.sIsMygote) {
                HwMaplePMServiceUtils.setMapleEnableFlag(packageName, flag);
            }
        }

        public String readMspesFile(String fileName) {
            return PackageManagerService.mHwPMSEx.readMspesFile(fileName);
        }

        public boolean writeMspesFile(String fileName, String content) {
            return PackageManagerService.mHwPMSEx.writeMspesFile(fileName, content);
        }

        public String getMspesOEMConfig() {
            return PackageManagerService.mHwPMSEx.getMspesOEMConfig();
        }

        public int updateMspesOEMConfig(String src) {
            return PackageManagerService.mHwPMSEx.updateMspesOEMConfig(src);
        }
    }

    private static class IFVerificationParams {
        PackageParser.Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(PackageParser.Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.replacing = _replacing;
            this.verifierUid = _verifierUid;
        }
    }

    static abstract class InstallArgs {
        final String abiOverride;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        String packageName;
        int packageVersion;
        final PackageParser.SigningDetails signingDetails;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;

        /* access modifiers changed from: package-private */
        public abstract void cleanUpResourcesLI();

        /* access modifiers changed from: package-private */
        public abstract int copyApk(IMediaContainerService iMediaContainerService, boolean z) throws RemoteException;

        /* access modifiers changed from: package-private */
        public abstract boolean doPostDeleteLI(boolean z);

        /* access modifiers changed from: package-private */
        public abstract int doPostInstall(int i, int i2);

        /* access modifiers changed from: package-private */
        public abstract int doPreInstall(int i);

        /* access modifiers changed from: package-private */
        public abstract boolean doRename(int i, PackageParser.Package packageR, String str);

        /* access modifiers changed from: package-private */
        public abstract String getCodePath();

        /* access modifiers changed from: package-private */
        public abstract String getResourcePath();

        InstallArgs(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, UserHandle user2, String[] instructionSets2, String abiOverride2, String[] installGrantPermissions2, String traceMethod2, int traceCookie2, PackageParser.SigningDetails signingDetails2, int installReason2) {
            this.origin = origin2;
            this.move = move2;
            this.installFlags = installFlags2;
            this.observer = observer2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.user = user2;
            this.instructionSets = instructionSets2;
            this.abiOverride = abiOverride2;
            this.installGrantPermissions = installGrantPermissions2;
            this.traceMethod = traceMethod2;
            this.traceCookie = traceCookie2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
        }

        /* access modifiers changed from: package-private */
        public int doPreCopy() {
            return 1;
        }

        /* access modifiers changed from: package-private */
        public int doPostCopy(int uid) {
            return 1;
        }

        /* access modifiers changed from: protected */
        public boolean isFwdLocked() {
            return (this.installFlags & 1) != 0;
        }

        /* access modifiers changed from: protected */
        public boolean isExternalAsec() {
            return (this.installFlags & 8) != 0;
        }

        /* access modifiers changed from: protected */
        public boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.user;
        }
    }

    class InstallParams extends HandlerParams {
        final String[] grantedRuntimePermissions;
        int installFlags;
        final int installReason;
        final String installerPackageName;
        private InstallArgs mArgs;
        private int mRet;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final PackageParser.SigningDetails signingDetails;
        final VerificationInfo verificationInfo;
        final String volumeUuid;

        InstallParams(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, VerificationInfo verificationInfo2, UserHandle user, String packageAbiOverride2, String[] grantedPermissions, PackageParser.SigningDetails signingDetails2, int installReason2) {
            super(user);
            this.origin = origin2;
            this.move = move2;
            this.observer = observer2;
            this.installFlags = installFlags2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.verificationInfo = verificationInfo2;
            this.packageAbiOverride = packageAbiOverride2;
            this.grantedRuntimePermissions = grantedPermissions;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
        }

        public String toString() {
            return "InstallParams{" + Integer.toHexString(System.identityHashCode(this)) + " file=" + this.origin.file + "}";
        }

        /* JADX WARNING: Code restructure failed: missing block: B:65:0x00ab, code lost:
            if (r2 == false) goto L_0x00ae;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:66:0x00ad, code lost:
            return 2;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:68:0x00b0, code lost:
            return r14.recommendedInstallLocation;
         */
        private int installLocationPolicy(PackageInfoLite pkgLite) {
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            boolean downgradePermitted = false;
            boolean onSd = (this.installFlags & 8) != 0;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package installedPkg = PackageManagerService.this.mPackages.get(packageName);
                PackageParser.Package dataOwnerPkg = installedPkg;
                if (dataOwnerPkg == null) {
                    PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                    if (ps != null) {
                        dataOwnerPkg = ps.pkg;
                    }
                }
                if (dataOwnerPkg != null) {
                    boolean downgradeRequested = (this.installFlags & 128) != 0;
                    boolean packageDebuggable = (dataOwnerPkg.applicationInfo.flags & 2) != 0;
                    if (downgradeRequested && (Build.IS_DEBUGGABLE || packageDebuggable)) {
                        downgradePermitted = true;
                    }
                    if (!downgradePermitted) {
                        try {
                            PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                        } catch (PackageManagerException e) {
                            Slog.w(PackageManagerService.TAG, "Downgrade detected: " + e.getMessage());
                            return -7;
                        }
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    }
                    if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        if (!onSd) {
                            return 1;
                        }
                        Slog.w(PackageManagerService.TAG, "Cannot install update to system app on sdcard");
                        return -3;
                    } else if (onSd) {
                        return 2;
                    } else {
                        if (installLocation == 1) {
                            return 1;
                        }
                        if (installLocation != 2) {
                            if (PackageManagerService.isExternal(installedPkg)) {
                                return 2;
                            }
                            return 1;
                        }
                    }
                }
            }
        }

        public void handleStartCopy() throws RemoteException {
            int ret;
            int ret2;
            int ret3 = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                    this.installFlags &= -9;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onSd = (this.installFlags & 8) != 0;
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = null;
            if (onInt && onSd) {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing on both internal and external");
                ret3 = -19;
            } else if (!onSd || !ephemeral) {
                PackageInfoLite pkgLite2 = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                if (PackageManagerService.DEBUG_INSTANT && ephemeral) {
                    Slog.v(PackageManagerService.TAG, "pkgLite for install: " + pkgLite2);
                }
                if (this.origin.staged || pkgLite2.recommendedInstallLocation != -1) {
                    pkgLite = pkgLite2;
                } else {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, PackageManagerService.this.mContainerService.calculateInstalledSize(this.origin.resolvedPath, this.packageAbiOverride) + StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory()), 0, 0);
                        pkgLite = PackageManagerService.this.mContainerService.getMinimalPackageInfo(this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                        pkgLite = pkgLite2;
                    }
                    if (pkgLite.recommendedInstallLocation == -6) {
                        pkgLite.recommendedInstallLocation = -1;
                    }
                }
            } else {
                Slog.w(PackageManagerService.TAG, "Conflicting flags specified for installing ephemeral on external");
                ret3 = -19;
            }
            if (ret3 == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret3 = -19;
                } else if (loc == -4) {
                    ret3 = -1;
                } else if (loc == -1) {
                    ret3 = -4;
                } else if (loc == -2) {
                    ret3 = -2;
                } else if (loc == -6) {
                    ret3 = -3;
                } else if (loc == -5) {
                    ret3 = -20;
                } else {
                    int loc2 = installLocationPolicy(pkgLite);
                    if (loc2 == -7) {
                        ret3 = -25;
                    } else if (!onSd && !onInt) {
                        if (loc2 == 2) {
                            this.installFlags |= 8;
                            this.installFlags &= -17;
                        } else if (loc2 == 3) {
                            if (PackageManagerService.DEBUG_INSTANT) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -25;
                        } else {
                            this.installFlags |= 16;
                            this.installFlags &= -9;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            if (pkgLite != null) {
                args.packageName = pkgLite.packageName;
                args.packageVersion = pkgLite.versionCode;
            }
            this.mArgs = args;
            PackageManagerService.mHwPMSEx.verifyPackageSecurityPolicy(args.packageName, this.origin.file);
            if (ret == 1) {
                UserHandle verifierUser = getUser();
                if (verifierUser == UserHandle.ALL) {
                    verifierUser = UserHandle.SYSTEM;
                }
                int requiredUid = PackageManagerService.this.mRequiredVerifierPackage == null ? -1 : PackageManagerService.this.getPackageUid(PackageManagerService.this.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                int installerUid = this.verificationInfo == null ? -1 : this.verificationInfo.installerUid;
                if (this.origin.existing || requiredUid == -1 || !PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid)) {
                    int i = ret;
                    boolean z = onSd;
                    boolean z2 = onInt;
                    int i2 = installerUid;
                    int i3 = requiredUid;
                    ret = args.copyApk(PackageManagerService.this.mContainerService, true);
                } else {
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        Slog.d(PackageManagerService.TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
                    }
                    final int verificationId = PackageManagerService.this.mPendingVerificationToken = PackageManagerService.this.mPendingVerificationToken + 1;
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_LONG_VERSION_CODE", pkgLite.getLongVersionCode());
                    if (this.verificationInfo != null) {
                        if (this.verificationInfo.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState verificationState = new PackageVerificationState(requiredUid, args);
                    PackageManagerService.this.mPendingVerification.append(verificationId, verificationState);
                    List<ComponentName> sufficientVerifiers = PackageManagerService.this.matchVerifiers(pkgLite, receivers, verificationState);
                    DeviceIdleController.LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    if (sufficientVerifiers != null) {
                        int N = sufficientVerifiers.size();
                        if (N == 0) {
                            PackageInfoLite packageInfoLite = pkgLite;
                            int i4 = ret;
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret = -22;
                            boolean z3 = onSd;
                            if (ret == 1 || PackageManagerService.this.mRequiredVerifierPackage == null) {
                                int i5 = installerUid;
                                int i6 = requiredUid;
                            } else {
                                ComponentName requiredVerifierComponent = PackageManagerService.this.matchComponentForVerifier(PackageManagerService.this.mRequiredVerifierPackage, receivers);
                                boolean z4 = onInt;
                                Trace.asyncTraceBegin(262144, "verification", verificationId);
                                verification.setComponent(requiredVerifierComponent);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Context context = PackageManagerService.this.mContext;
                                List<ComponentName> list = sufficientVerifiers;
                                PackageVerificationState packageVerificationState = verificationState;
                                int i7 = verificationId;
                                List<ResolveInfo> list2 = receivers;
                                AnonymousClass1 r12 = new BroadcastReceiver() {
                                    public void onReceive(Context context, Intent intent) {
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                        msg.arg1 = verificationId;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                    }
                                };
                                Intent intent = verification;
                                int i8 = installerUid;
                                int i9 = requiredUid;
                                context.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", r12, null, 0, null, null);
                                this.mArgs = null;
                            }
                        } else {
                            ret2 = ret;
                            int i10 = 0;
                            while (true) {
                                int i11 = i10;
                                if (i11 >= N) {
                                    break;
                                }
                                ComponentName verifierComponent = sufficientVerifiers.get(i11);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                boolean onSd2 = onSd;
                                Intent sufficientIntent = new Intent(verification);
                                sufficientIntent.setComponent(verifierComponent);
                                ComponentName componentName = verifierComponent;
                                PackageManagerService.this.mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                                i10 = i11 + 1;
                                onSd = onSd2;
                            }
                        }
                    } else {
                        ret2 = ret;
                        boolean z5 = onSd;
                    }
                    ret = ret2;
                    if (ret == 1) {
                    }
                    int i52 = installerUid;
                    int i62 = requiredUid;
                }
            } else {
                int i12 = ret;
                boolean z6 = onSd;
                boolean z7 = onInt;
            }
            this.mRet = ret;
        }

        /* access modifiers changed from: package-private */
        public void handleReturnCode() {
            if (this.mArgs != null) {
                PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
            }
        }

        /* access modifiers changed from: package-private */
        public void handleServiceError() {
            this.mArgs = PackageManagerService.this.createInstallArgs(this);
            this.mRet = RequestStatus.SYS_ETIMEDOUT;
        }
    }

    static final class InstantAppIntentResolver extends IntentResolver<AuxiliaryResolveInfo.AuxiliaryFilter, AuxiliaryResolveInfo.AuxiliaryFilter> {
        final ArrayMap<String, Pair<Integer, InstantAppResolveInfo>> mOrderResult = new ArrayMap<>();

        InstantAppIntentResolver() {
        }

        /* access modifiers changed from: protected */
        public AuxiliaryResolveInfo.AuxiliaryFilter[] newArray(int size) {
            return new AuxiliaryResolveInfo.AuxiliaryFilter[size];
        }

        /* access modifiers changed from: protected */
        public boolean isPackageForFilter(String packageName, AuxiliaryResolveInfo.AuxiliaryFilter responseObj) {
            return true;
        }

        /* access modifiers changed from: protected */
        public AuxiliaryResolveInfo.AuxiliaryFilter newResult(AuxiliaryResolveInfo.AuxiliaryFilter responseObj, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            String packageName = responseObj.resolveInfo.getPackageName();
            Integer order = Integer.valueOf(responseObj.getOrder());
            Pair<Integer, InstantAppResolveInfo> lastOrderResult = this.mOrderResult.get(packageName);
            if (lastOrderResult != null && ((Integer) lastOrderResult.first).intValue() >= order.intValue()) {
                return null;
            }
            InstantAppResolveInfo res = responseObj.resolveInfo;
            if (order.intValue() > 0) {
                this.mOrderResult.put(packageName, new Pair(order, res));
            }
            return responseObj;
        }

        /* access modifiers changed from: protected */
        public void filterResults(List<AuxiliaryResolveInfo.AuxiliaryFilter> results) {
            if (this.mOrderResult.size() != 0) {
                int resultSize = results.size();
                int i = 0;
                while (i < resultSize) {
                    InstantAppResolveInfo info = results.get(i).resolveInfo;
                    String packageName = info.getPackageName();
                    Pair<Integer, InstantAppResolveInfo> savedInfo = this.mOrderResult.get(packageName);
                    if (savedInfo != null) {
                        if (savedInfo.second == info) {
                            this.mOrderResult.remove(packageName);
                            if (this.mOrderResult.size() == 0) {
                                break;
                            }
                        } else {
                            results.remove(i);
                            resultSize--;
                            i--;
                        }
                    }
                    i++;
                }
            }
        }
    }

    private interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<PackageParser.ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList<>();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = this.mCurrentIntentFilterVerifications.get(n).intValue();
                IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet<>();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(filters.get(m).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), PackageManagerService.this.getVerificationTimeout(), 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM);
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Sending IntentFilter verification broadcast");
            }
        }

        public void receiveVerificationResponse(int verificationId) {
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.i(PackageManagerService.TAG, "Received verification response " + verificationId + " for " + count + " filters, verified=" + verified);
            }
            for (int n = 0; n < count; n++) {
                PackageParser.ActivityIntentInfo filter = filters.get(n);
                filter.setVerified(verified);
                if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                    Slog.d(PackageManagerService.TAG, "IntentFilter " + filter.toString() + " verified with result:" + verified + " and hosts:" + ivs.getHostsString());
                }
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            String packageName = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(packageName);
            }
            if (ivi == null) {
                Slog.w(PackageManagerService.TAG, "IntentFilterVerificationInfo not found for verificationId:" + verificationId + " packageName:" + packageName);
                return;
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Updating IntentFilterVerificationInfo for package " + packageName + " verificationId:" + verificationId);
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    try {
                        ivi.setStatus(2);
                    } catch (Throwable th) {
                        throw th;
                    }
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    switch (PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId)) {
                        case 0:
                            if (verified) {
                                updatedStatus = 2;
                            } else {
                                updatedStatus = 1;
                            }
                            needUpdate = true;
                            break;
                        case 1:
                            if (verified) {
                                updatedStatus = 2;
                                needUpdate = true;
                                break;
                            }
                            break;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, PackageParser.ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Adding verification filter for " + packageName + ": " + filter);
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    private static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList<>();
        /* access modifiers changed from: private */
        public final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        public void handleMessage(Message msg) {
            SomeArgs args = (SomeArgs) msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback(this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            switch (what) {
                case 1:
                    callback.onCreated(args.argi1, (Bundle) args.arg2);
                    return;
                case 2:
                    callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
                    return;
                default:
                    return;
            }
        }

        /* access modifiers changed from: private */
        public void notifyCreated(int moveId, Bundle extras) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " created " + extras.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        /* access modifiers changed from: private */
        public void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        /* access modifiers changed from: private */
        public void notifyStatusChanged(int moveId, int status, long estMillis) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " status " + status);
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId2, String fromUuid2, String toUuid2, String packageName2, String dataAppName2, int appId2, String seinfo2, int targetSdkVersion2) {
            this.moveId = moveId2;
            this.fromUuid = fromUuid2;
            this.toUuid = toUuid2;
            this.packageName = packageName2;
            this.dataAppName = dataAppName2;
            this.appId = appId2;
            this.seinfo = seinfo2;
            this.targetSdkVersion = targetSdkVersion2;
        }
    }

    class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;
        final /* synthetic */ PackageManagerService this$0;

        /* JADX WARNING: Illegal instructions before constructor call */
        MoveInstallArgs(PackageManagerService this$02, InstallParams params) {
            super(r0.origin, r0.move, r0.observer, r0.installFlags, r0.installerPackageName, r0.volumeUuid, params.getUser(), null, r0.packageAbiOverride, r0.grantedRuntimePermissions, r0.traceMethod, r0.traceCookie, r0.signingDetails, r0.installReason);
            InstallParams installParams = params;
            this.this$0 = this$02;
        }

        /* access modifiers changed from: package-private */
        public int copyApk(IMediaContainerService imcs, boolean temp) {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Moving " + this.move.packageName + " from " + this.move.fromUuid + " to " + this.move.toUuid);
            }
            synchronized (this.this$0.mInstaller) {
                try {
                    this.this$0.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (Installer.InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return RequestStatus.SYS_ETIMEDOUT;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "codeFile after move is " + this.codeFile);
            }
            return 1;
        }

        /* access modifiers changed from: package-private */
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        public boolean doRename(int status, PackageParser.Package pkg, String oldCodePath) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        /* access modifiers changed from: package-private */
        public int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        public String getCodePath() {
            if (this.codeFile != null) {
                return this.codeFile.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        public String getResourcePath() {
            if (this.resourceFile != null) {
                return this.resourceFile.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile2 = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            Slog.d(PackageManagerService.TAG, "Cleaning up " + this.move.packageName + " on " + volumeUuid);
            int[] userIds = PackageManagerService.sUserManager.getUserIds();
            synchronized (this.this$0.mInstallLock) {
                for (int userId : userIds) {
                    try {
                        this.this$0.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                this.this$0.removeCodePathLI(codeFile2);
            }
            return true;
        }

        /* access modifiers changed from: package-private */
        public void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        /* access modifiers changed from: package-private */
        public boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    private static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList<>();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                handleOnPermissionsChanged(msg.arg1);
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            for (int i = 0; i < count; i++) {
                try {
                    this.mPermissionListeners.getBroadcastItem(i).onPermissionsChanged(uid);
                } catch (RemoteException e) {
                    Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                    throw th;
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    static class OriginInfo {
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file2) {
            return new OriginInfo(file2, false, false);
        }

        static OriginInfo fromExistingFile(File file2) {
            return new OriginInfo(file2, false, true);
        }

        static OriginInfo fromStagedFile(File file2) {
            return new OriginInfo(file2, true, false);
        }

        private OriginInfo(File file2, boolean staged2, boolean existing2) {
            this.file = file2;
            this.staged = staged2;
            this.existing = existing2;
            if (file2 != null) {
                this.resolvedPath = file2.getAbsolutePath();
                this.resolvedFile = file2;
                return;
            }
            this.resolvedPath = null;
            this.resolvedFile = null;
        }
    }

    private class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                Slog.d(PackageManagerService.TAG, "mFrozenPackages add package:" + this.mPackageName);
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((PackageParser.Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        /* access modifiers changed from: protected */
        public void finalize() throws Throwable {
            try {
                if (this.mCloseGuard != null) {
                    this.mCloseGuard.warnIfOpen();
                }
                close();
            } finally {
                super.finalize();
            }
        }

        public void close() {
            this.mCloseGuard.close();
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                        Slog.d(PackageManagerService.TAG, "mFrozenPackages remove package:" + this.mPackageName);
                    }
                    if (this.mChildren != null) {
                        for (PackageFreezer freezer : this.mChildren) {
                            freezer.close();
                        }
                    }
                }
            }
        }
    }

    class PackageHandler extends Handler {
        private boolean mBound = false;
        final ArrayList<HandlerParams> mPendingInstalls = new ArrayList<>();

        private boolean connectToService() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Log.i(PackageManagerService.TAG, "Trying to bind to DefaultContainerService");
            }
            Intent service = new Intent().setComponent(PackageManagerService.DEFAULT_CONTAINER_COMPONENT);
            Process.setThreadPriority(0);
            if (PackageManagerService.this.mContext.bindServiceAsUser(service, PackageManagerService.this.mDefContainerConn, 1, UserHandle.SYSTEM)) {
                Process.setThreadPriority(10);
                this.mBound = true;
                return true;
            }
            Process.setThreadPriority(10);
            return false;
        }

        private void disconnectService() {
            IMediaContainerService unused = PackageManagerService.this.mContainerService = null;
            this.mBound = false;
            Process.setThreadPriority(0);
            PackageManagerService.this.mContext.unbindService(PackageManagerService.this.mDefContainerConn);
            Process.setThreadPriority(10);
        }

        PackageHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* access modifiers changed from: package-private */
        /* JADX WARNING: Code restructure failed: missing block: B:272:0x076e, code lost:
            r4 = r5;
            r5 = r9;
            r28 = 0;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:273:0x0772, code lost:
            r6 = r28;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:274:0x0774, code lost:
            if (r6 >= r3) goto L_0x0784;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:275:0x0776, code lost:
            r1.this$0.sendPackageChangedBroadcast(r0[r6], true, r4[r6], r5[r6]);
            r28 = r6 + 1;
         */
        /* JADX WARNING: Code restructure failed: missing block: B:276:0x0784, code lost:
            android.os.Process.setThreadPriority(10);
         */
        public void doHandleMessage(Message msg) {
            int i;
            int ret;
            Message message = msg;
            boolean andCode = true;
            int i2 = 0;
            switch (message.what) {
                case 1:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        if (PackageManagerService.this.mPendingBroadcasts != null) {
                            int size = PackageManagerService.this.mPendingBroadcasts.size();
                            if (size > 0) {
                                String[] packages = new String[size];
                                ArrayList<String>[] components = new ArrayList[size];
                                int[] uids = new int[size];
                                int i3 = 0;
                                for (int n = 0; n < PackageManagerService.this.mPendingBroadcasts.userIdCount(); n++) {
                                    int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(n);
                                    Iterator<Map.Entry<String, ArrayList<String>>> it = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                                    while (it.hasNext() && i3 < size) {
                                        Map.Entry<String, ArrayList<String>> ent = it.next();
                                        packages[i3] = ent.getKey();
                                        components[i3] = ent.getValue();
                                        PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                        if (ps != null) {
                                            i = UserHandle.getUid(packageUserId, ps.appId);
                                        } else {
                                            i = -1;
                                        }
                                        uids[i3] = i;
                                        i3++;
                                    }
                                }
                                int size2 = i3;
                                PackageManagerService.this.mPendingBroadcasts.clear();
                                break;
                            } else {
                                return;
                            }
                        } else {
                            return;
                        }
                    }
                    break;
                case 3:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_bound");
                    }
                    if (message.obj != null) {
                        IMediaContainerService unused = PackageManagerService.this.mContainerService = (IMediaContainerService) message.obj;
                        Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                    }
                    if (PackageManagerService.this.mContainerService != null) {
                        if (this.mPendingInstalls.size() <= 0) {
                            Slog.w(PackageManagerService.TAG, "Empty queue");
                            break;
                        } else {
                            HandlerParams params = this.mPendingInstalls.get(0);
                            if (params != null) {
                                Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                                Trace.traceBegin(262144, "startCopy");
                                if (params.startCopy()) {
                                    if (this.mPendingInstalls.size() > 0) {
                                        this.mPendingInstalls.remove(0);
                                    }
                                    if (this.mPendingInstalls.size() != 0) {
                                        PackageManagerService.this.mHandler.sendEmptyMessage(3);
                                    } else if (this.mBound) {
                                        removeMessages(6);
                                        sendMessageDelayed(obtainMessage(6), 10000);
                                    }
                                }
                                Trace.traceEnd(262144);
                                break;
                            }
                        }
                    } else if (this.mBound) {
                        Slog.w(PackageManagerService.TAG, "Waiting to connect to media container service");
                        break;
                    } else {
                        Slog.e(PackageManagerService.TAG, "Cannot bind to media container service");
                        Iterator<HandlerParams> it2 = this.mPendingInstalls.iterator();
                        while (it2.hasNext()) {
                            HandlerParams params2 = it2.next();
                            params2.serviceError();
                            Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params2));
                            if (params2.traceMethod != null) {
                                Trace.asyncTraceEnd(262144, params2.traceMethod, params2.traceCookie);
                            }
                        }
                        this.mPendingInstalls.clear();
                        break;
                    }
                    break;
                case 5:
                    HandlerParams params3 = (HandlerParams) message.obj;
                    int idx = this.mPendingInstalls.size();
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "init_copy idx=" + idx + ": " + params3);
                    }
                    if (this.mBound) {
                        this.mPendingInstalls.add(idx, params3);
                        if (idx == 0) {
                            PackageManagerService.this.mHandler.sendEmptyMessage(3);
                            break;
                        }
                    } else {
                        Trace.asyncTraceBegin(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (connectToService()) {
                            this.mPendingInstalls.add(idx, params3);
                            break;
                        } else {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                            params3.serviceError();
                            Trace.asyncTraceEnd(262144, "bindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                            if (params3.traceMethod != null) {
                                Trace.asyncTraceEnd(262144, params3.traceMethod, params3.traceCookie);
                            }
                            return;
                        }
                    }
                    break;
                case 6:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_unbind");
                    }
                    if (this.mPendingInstalls.size() != 0 || PackageManagerService.this.mPendingVerification.size() != 0) {
                        if (this.mPendingInstalls.size() > 0) {
                            PackageManagerService.this.mHandler.sendEmptyMessage(3);
                            break;
                        }
                    } else if (this.mBound) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            Slog.i(PackageManagerService.TAG, "calling disconnectService()");
                        }
                        disconnectService();
                        break;
                    }
                    break;
                case 7:
                    Process.setThreadPriority(0);
                    String packageName = (String) message.obj;
                    int userId = message.arg1;
                    if (message.arg2 == 0) {
                        andCode = false;
                    }
                    synchronized (PackageManagerService.this.mPackages) {
                        if (userId == -1) {
                            try {
                                int[] users = PackageManagerService.sUserManager.getUserIds();
                                int length = users.length;
                                while (i2 < length) {
                                    PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(users[i2], packageName, andCode));
                                    i2++;
                                }
                            } catch (Throwable th) {
                                while (true) {
                                    throw th;
                                    break;
                                }
                            }
                        } else {
                            PackageManagerService.this.mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                        }
                    }
                    Process.setThreadPriority(10);
                    PackageManagerService.this.startCleaningPackages();
                    break;
                case 9:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Log.v(PackageManagerService.TAG, "Handling post-install for " + message.arg1);
                    }
                    PostInstallData data = PackageManagerService.this.mRunningInstalls.get(message.arg1);
                    boolean didRestore = message.arg2 != 0;
                    PackageManagerService.this.mRunningInstalls.delete(message.arg1);
                    if (data != null) {
                        InstallArgs args = data.args;
                        PackageInstalledInfo parentRes = data.res;
                        if (1 != parentRes.returnCode) {
                            PackageManagerService.this.uploadInstallErrRadar("{pkg:" + parentRes.name + "pkgName:" + args.packageName + ",Ver:" + args.packageVersion + ",ErrNum:" + parentRes.returnCode + ",Intaller:" + args.installerPackageName + ",Msg:" + parentRes.returnMsg + "}");
                        }
                        boolean grantPermissions = (args.installFlags & 256) != 0;
                        if (parentRes.pkg != null) {
                            PackageManagerService.this.addGrantedInstalledPkg(parentRes.pkg.packageName, grantPermissions);
                        }
                        boolean killApp = (args.installFlags & 4096) == 0;
                        boolean virtualPreload = (args.installFlags & 65536) != 0;
                        String[] grantedPermissions = args.installGrantPermissions;
                        PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, didRestore, args.installerPackageName, args.observer);
                        int childCount = parentRes.addedChildPackages != null ? parentRes.addedChildPackages.size() : 0;
                        while (i2 < childCount) {
                            PackageManagerService.this.handlePackagePostInstall(parentRes.addedChildPackages.valueAt(i2), grantPermissions, killApp, virtualPreload, grantedPermissions, false, args.installerPackageName, args.observer);
                            i2++;
                        }
                        if (!(parentRes.pkg == null || (PackageManagerService.isSystemApp(parentRes.pkg) && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0 && (parentRes.pkg.applicationInfo.hwFlags & 67108864) == 0))) {
                            PackageManagerService.this.parseInstalledPkgInfo(args, parentRes);
                        }
                        SmartShrinker.reclaim(Process.myPid(), 3);
                        if (args.traceMethod != null) {
                            Trace.asyncTraceEnd(262144, args.traceMethod, args.traceCookie);
                        }
                    } else {
                        Slog.e(PackageManagerService.TAG, "Bogus post-install token " + message.arg1);
                    }
                    Trace.asyncTraceEnd(262144, "postInstall", message.arg1);
                    break;
                case 10:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_reconnect");
                    }
                    if (this.mPendingInstalls.size() > 0) {
                        if (this.mBound) {
                            disconnectService();
                        }
                        if (!connectToService()) {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                            Iterator<HandlerParams> it3 = this.mPendingInstalls.iterator();
                            while (it3.hasNext()) {
                                HandlerParams params4 = it3.next();
                                params4.serviceError();
                                Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params4));
                            }
                            this.mPendingInstalls.clear();
                            break;
                        }
                    }
                    break;
                case 11:
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "mcs_giveup too many retries");
                    }
                    Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(this.mPendingInstalls.remove(0)));
                    break;
                case 13:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(13);
                        removeMessages(14);
                        PackageManagerService.this.mSettings.writeLPr();
                        PackageManagerService.this.mDirtyUsers.clear();
                    }
                    Process.setThreadPriority(10);
                    break;
                case 14:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(14);
                        Iterator it4 = PackageManagerService.this.mDirtyUsers.iterator();
                        while (it4.hasNext()) {
                            PackageManagerService.this.mSettings.writePackageRestrictionsLPr(((Integer) it4.next()).intValue());
                        }
                        PackageManagerService.this.mDirtyUsers.clear();
                    }
                    Process.setThreadPriority(10);
                    break;
                case 15:
                    int verificationId = message.arg1;
                    PackageVerificationState state = PackageManagerService.this.mPendingVerification.get(verificationId);
                    if (state != null) {
                        PackageVerificationResponse response = (PackageVerificationResponse) message.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(verificationId);
                            InstallArgs args2 = state.getInstallArgs();
                            Uri originUri = Uri.fromFile(args2.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                ret = RequestStatus.SYS_ETIMEDOUT;
                                PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                                try {
                                    ret = args2.copyApk(PackageManagerService.this.mContainerService, true);
                                } catch (RemoteException e) {
                                    Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                                }
                            } else {
                                ret = -22;
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId);
                            PackageManagerService.this.processPendingInstall(args2, ret);
                            PackageManagerService.this.mHandler.sendEmptyMessage(6);
                            break;
                        }
                    } else {
                        Slog.w(PackageManagerService.TAG, "Invalid verification token " + verificationId + " received");
                        break;
                    }
                    break;
                case 16:
                    int verificationId2 = message.arg1;
                    PackageVerificationState state2 = PackageManagerService.this.mPendingVerification.get(verificationId2);
                    if (state2 != null && !state2.timeoutExtended()) {
                        InstallArgs args3 = state2.getInstallArgs();
                        Uri originUri2 = Uri.fromFile(args3.origin.resolvedFile);
                        Slog.i(PackageManagerService.TAG, "Verification timed out for " + originUri2);
                        PackageManagerService.this.mPendingVerification.remove(verificationId2);
                        int ret2 = -22;
                        UserHandle user = args3.getUser();
                        if (PackageManagerService.this.getDefaultVerificationResponse(user) == 1) {
                            Slog.i(PackageManagerService.TAG, "Continuing with installation of " + originUri2);
                            state2.setVerifierResponse(Binder.getCallingUid(), 2);
                            PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, 1, user);
                            try {
                                ret2 = args3.copyApk(PackageManagerService.this.mContainerService, true);
                            } catch (RemoteException e2) {
                                Slog.e(PackageManagerService.TAG, "Could not contact the ContainerService");
                            }
                        } else {
                            PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, -1, user);
                        }
                        Trace.asyncTraceEnd(262144, "verification", verificationId2);
                        PackageManagerService.this.processPendingInstall(args3, ret2);
                        PackageManagerService.this.mHandler.sendEmptyMessage(6);
                        break;
                    }
                case 17:
                    IFVerificationParams params5 = (IFVerificationParams) message.obj;
                    PackageManagerService.this.verifyIntentFiltersIfNeeded(params5.userId, params5.verifierUid, params5.replacing, params5.pkg);
                    break;
                case 18:
                    int verificationId3 = message.arg1;
                    IntentFilterVerificationState state3 = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId3);
                    if (state3 != null) {
                        int userId2 = state3.getUserId();
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Processing IntentFilter verification with token:" + verificationId3 + " and userId:" + userId2);
                        }
                        IntentFilterVerificationResponse response2 = (IntentFilterVerificationResponse) message.obj;
                        state3.setVerifierResponse(response2.callerUid, response2.code);
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " and userId:" + userId2 + " is settings verifier response with response code:" + response2.code);
                        }
                        if (response2.code == -1 && PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Domains failing verification: " + response2.getFailedDomainsString());
                        }
                        if (!state3.isVerificationComplete()) {
                            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " was not said to be complete");
                                break;
                            }
                        } else {
                            PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(verificationId3);
                            break;
                        }
                    } else {
                        Slog.w(PackageManagerService.TAG, "Invalid IntentFilter verification token " + verificationId3 + " received");
                        break;
                    }
                    break;
                case 19:
                    Process.setThreadPriority(0);
                    synchronized (PackageManagerService.this.mPackages) {
                        removeMessages(19);
                        PackageManagerService.this.mSettings.writePackageListLPr(message.arg1);
                    }
                    Process.setThreadPriority(10);
                    break;
                case 20:
                    InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) message.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                    break;
                case 21:
                    if (!this.mBound) {
                        Trace.asyncTraceBegin(262144, "earlyBindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        if (!connectToService()) {
                            Slog.e(PackageManagerService.TAG, "Failed to bind to media container service");
                        }
                        Trace.asyncTraceEnd(262144, "earlyBindingMCS", System.identityHashCode(PackageManagerService.this.mHandler));
                        break;
                    }
                    break;
            }
        }
    }

    static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        PackageParser.Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParser.PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode2) {
            this.returnCode = returnCode2;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnCode = returnCode2;
            }
        }

        private void setReturnMessage(String returnMsg2) {
            this.returnMsg = returnMsg2;
            int childCount = this.addedChildPackages != null ? this.addedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnMsg = returnMsg2;
            }
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        private PackageManagerInternalImpl() {
        }

        public void updatePermissionFlagsTEMP(String permName, String packageName, int flagMask, int flagValues, int userId) {
            PackageManagerService.this.updatePermissionFlags(permName, packageName, flagMask, flagValues, userId);
        }

        public boolean isDataRestoreSafe(byte[] restoringFromSigHash, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasSha256Certificate(restoringFromSigHash, 1);
        }

        public boolean isDataRestoreSafe(Signature restoringFromSig, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasCertificate(restoringFromSig, 1);
        }

        public boolean hasSignatureCapability(int serverUid, int clientUid, @PackageParser.SigningDetails.CertCapabilities int capability) {
            PackageParser.SigningDetails serverSigningDetails = getSigningDetails(serverUid);
            PackageParser.SigningDetails clientSigningDetails = getSigningDetails(clientUid);
            return serverSigningDetails.checkCapability(clientSigningDetails, capability) || clientSigningDetails.hasAncestorOrSelf(serverSigningDetails);
        }

        private PackageParser.SigningDetails getSigningDetails(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null) {
                    return null;
                }
                PackageParser.SigningDetails signingDetails = p.mSigningDetails;
                return signingDetails;
            }
        }

        private PackageParser.SigningDetails getSigningDetails(int uid) {
            synchronized (PackageManagerService.this.mPackages) {
                Object obj = PackageManagerService.this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        PackageParser.SigningDetails signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
                        return signingDetails;
                    } else if (obj instanceof PackageSetting) {
                        PackageParser.SigningDetails signingDetails2 = ((PackageSetting) obj).signatures.mSigningDetails;
                        return signingDetails2;
                    }
                }
                PackageSetting ps = PackageParser.SigningDetails.UNKNOWN;
                return ps;
            }
        }

        public int getPermissionFlagsTEMP(String permName, String packageName, int userId) {
            return PackageManagerService.this.getPermissionFlags(permName, packageName, userId);
        }

        public boolean isInstantApp(String packageName, int userId) {
            return PackageManagerService.this.isInstantApp(packageName, userId);
        }

        public String getInstantAppPackageName(int uid) {
            return PackageManagerService.this.getInstantAppPackageName(uid);
        }

        public boolean filterAppAccess(PackageParser.Package pkg, int callingUid, int userId) {
            boolean access$7300;
            synchronized (PackageManagerService.this.mPackages) {
                access$7300 = PackageManagerService.this.filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, userId);
            }
            return access$7300;
        }

        public PackageParser.Package getPackage(String packageName) {
            PackageParser.Package packageR;
            synchronized (PackageManagerService.this.mPackages) {
                packageR = PackageManagerService.this.mPackages.get(PackageManagerService.this.resolveInternalPackageNameLPr(packageName, -1));
            }
            return packageR;
        }

        public PackageList getPackageList(PackageManagerInternal.PackageListObserver observer) {
            PackageList packageList;
            synchronized (PackageManagerService.this.mPackages) {
                int N = PackageManagerService.this.mPackages.size();
                ArrayList<String> list = new ArrayList<>(N);
                for (int i = 0; i < N; i++) {
                    list.add(PackageManagerService.this.mPackages.keyAt(i));
                }
                packageList = new PackageList(list, observer);
                if (observer != null) {
                    PackageManagerService.this.mPackageListObservers.add(packageList);
                }
            }
            return packageList;
        }

        public void removePackageListObserver(PackageManagerInternal.PackageListObserver observer) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mPackageListObservers.remove(observer);
            }
        }

        public PackageParser.Package getDisabledPackage(String packageName) {
            PackageParser.Package packageR;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(packageName);
                packageR = ps != null ? ps.pkg : null;
            }
            return packageR;
        }

        public String getKnownPackageName(int knownPackage, int userId) {
            switch (knownPackage) {
                case 0:
                    return PackageManagerService.PLATFORM_PACKAGE_NAME;
                case 1:
                    return PackageManagerService.this.mSetupWizardPackage;
                case 2:
                    return PackageManagerService.this.mRequiredInstallerPackage;
                case 3:
                    return PackageManagerService.this.mRequiredVerifierPackage;
                case 4:
                    return PackageManagerService.this.getDefaultBrowserPackageName(userId);
                case 5:
                    return PackageManagerService.this.mSystemTextClassifierPackage;
                default:
                    return null;
            }
        }

        public boolean isResolveActivityComponent(ComponentInfo component) {
            return PackageManagerService.this.mResolveActivity.packageName.equals(component.packageName) && PackageManagerService.this.mResolveActivity.name.equals(component.name);
        }

        public void setLocationPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProvider(provider);
        }

        public void setVoiceInteractionPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProvider(provider);
        }

        public void setSmsAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSmsAppPackagesProvider(provider);
        }

        public void setDialerAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setDialerAppPackagesProvider(provider);
        }

        public void setSimCallManagerPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSimCallManagerPackagesProvider(provider);
        }

        public void setUseOpenWifiAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setUseOpenWifiAppPackagesProvider(provider);
        }

        public void setSyncAdapterPackagesprovider(PackageManagerInternal.SyncAdapterPackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProvider(provider);
        }

        public void grantDefaultPermissionsToDefaultSmsApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSmsApp(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultDialerApp(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setDefaultDialerPackageNameLPw(packageName, userId);
            }
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultDialerApp(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultSimCallManager(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultSimCallManager(packageName, userId);
        }

        public void grantDefaultPermissionsToDefaultUseOpenWifiApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultUseOpenWifiApp(packageName, userId);
        }

        /* JADX WARNING: Code restructure failed: missing block: B:28:0x006a, code lost:
            return;
         */
        public void setKeepUninstalledPackages(List<String> packageList) {
            Preconditions.checkNotNull(packageList);
            List<String> removedFromList = null;
            synchronized (PackageManagerService.this.mPackages) {
                try {
                    if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                        int packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                        List<String> removedFromList2 = null;
                        int i = 0;
                        while (i < packagesCount) {
                            try {
                                String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i);
                                if (packageList == null || !packageList.contains(oldPackage)) {
                                    if (removedFromList2 == null) {
                                        removedFromList2 = new ArrayList<>();
                                    }
                                    removedFromList2.add(oldPackage);
                                }
                                i++;
                            } catch (Throwable th) {
                                th = th;
                                List<String> list = removedFromList2;
                                throw th;
                            }
                        }
                        removedFromList = removedFromList2;
                    }
                    List unused = PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                    if (removedFromList != null) {
                        int removedCount = removedFromList.size();
                        for (int i2 = 0; i2 < removedCount; i2++) {
                            PackageManagerService.this.deletePackageIfUnusedLPr(removedFromList.get(i2));
                        }
                    }
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            boolean isPermissionsReviewRequired;
            synchronized (PackageManagerService.this.mPackages) {
                isPermissionsReviewRequired = PackageManagerService.this.mPermissionManager.isPermissionsReviewRequired(PackageManagerService.this.mPackages.get(packageName), userId);
            }
            return isPermissionsReviewRequired;
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public Bundle getSuspendedPackageLauncherExtras(String packageName, int userId) {
            Bundle bundle;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                PersistableBundle launcherExtras = null;
                if (ps != null) {
                    launcherExtras = ps.readUserState(userId).suspendedLauncherExtras;
                }
                bundle = launcherExtras != null ? new Bundle(launcherExtras.deepCopy()) : null;
            }
            return bundle;
        }

        public boolean isPackageSuspended(String packageName, int userId) {
            boolean suspended;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                suspended = ps != null ? ps.getSuspended(userId) : false;
            }
            return suspended;
        }

        public String getSuspendingPackage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).suspendingPackage : null;
            }
            return str;
        }

        public String getSuspendedDialogMessage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).dialogMessage : null;
            }
            return str;
        }

        public int getPackageUid(String packageName, int flags, int userId) {
            return PackageManagerService.this.getPackageUid(packageName, flags, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, filterCallingUid, userId, false, true);
        }

        public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int callingUid, int userId) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, userId, callingUid, false);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public ComponentName getDefaultHomeActivity(int userId) {
            return PackageManagerService.this.getDefaultHomeActivity(userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
            ArraySet<Integer> usersWithPoOrDo = new ArraySet<>();
            if (deviceOwnerPackage != null) {
                usersWithPoOrDo.add(Integer.valueOf(deviceOwnerUserId));
            }
            int sz = profileOwnerPackages.size();
            for (int i = 0; i < sz; i++) {
                if (profileOwnerPackages.valueAt(i) != null) {
                    usersWithPoOrDo.add(Integer.valueOf(profileOwnerPackages.keyAt(i)));
                }
            }
            PackageManagerService.this.unsuspendForNonSystemSuspendingPackages(usersWithPoOrDo);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageStateProtected(String packageName, int userId) {
            return PackageManagerService.this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public void grantRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.grantRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public void revokeRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.revokeRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = PackageManagerService.this.mInstantAppInstallerActivity != null && PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
            }
            return z;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(PackageManagerInternal.ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                z = false;
                if (pkg != null && (pkg.applicationInfo.flags & 9) == 9) {
                    z = true;
                }
            }
            return z;
        }

        public boolean isLegacySystemApp(PackageParser.Package pkg) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                z = PackageManagerService.this.mPromoteSystemApps && ps.isSystem() && PackageManagerService.this.mExistingSystemPackages.contains(ps.name);
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            ArrayList<PackageInfo> overlayPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget != null) {
                        PackageInfo pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId);
                        if (pkg != null) {
                            overlayPackages.add(pkg);
                        }
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    try {
                        if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                            ArrayList<String> overlayPaths = null;
                            if (overlayPackageNames != null && overlayPackageNames.size() > 0) {
                                int N = overlayPackageNames.size();
                                overlayPaths = new ArrayList<>(N);
                                for (int i = 0; i < N; i++) {
                                    PackageParser.Package pkg = PackageManagerService.this.mPackages.get(overlayPackageNames.get(i));
                                    if (pkg == null) {
                                        Slog.e(PackageManagerService.TAG, "failed to find package " + packageName);
                                        return false;
                                    }
                                    overlayPaths.add(pkg.baseCodePath);
                                }
                            }
                            PackageManagerService.this.mSettings.mPackages.get(targetPackageName).setOverlayPaths(overlayPaths, userId);
                            return true;
                        }
                    } catch (Throwable th) {
                        throw th;
                    }
                }
                Slog.e(PackageManagerService.TAG, "failed to find package " + targetPackageName);
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
            return PackageManagerService.this.resolveContentProviderInternal(name, flags, userId);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public boolean isInMWPortraitWhiteList(String packageName) {
            return PackageManagerService.mHwPMSEx.isInMWPortraitWhiteList(packageName);
        }

        public int getUidTargetSdkVersion(int uid) {
            int access$8900;
            synchronized (PackageManagerService.this.mPackages) {
                access$8900 = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return access$8900;
        }

        public int getPackageTargetSdkVersion(String packageName) {
            int access$9000;
            synchronized (PackageManagerService.this.mPackages) {
                access$9000 = PackageManagerService.this.getPackageTargetSdkVersionLockedLPr(packageName);
            }
            return access$9000;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean canAccessComponent(int callingUid, ComponentName component, int userId) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = !PackageManagerService.this.filterAppAccessLPr(PackageManagerService.this.mSettings.mPackages.get(component.getPackageName()), callingUid, component, 0, userId);
            }
            return z;
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public float getUserMaxAspectRatio(String packageName) {
            return PackageManagerService.mHwPMSEx.getApplicationMaxAspectRatio(packageName);
        }

        public float getUserAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public void checkPackageStartable(String packageName, int userId) {
            PackageManagerService.this.checkPackageStartable(packageName, userId);
        }

        public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
            return PackageManagerService.this.getHwCertPermission(allowed, pkg, perm);
        }

        public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
            PackageManagerService.mHwPMSEx.installPackageAsUser(originPath, observer, installFlags, installerPackageName, userId);
        }
    }

    private class PackageManagerNative extends IPackageManagerNative.Stub {
        private PackageManagerNative() {
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
            }
            return "preload";
        }

        public long getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.getLongVersionCode();
                }
            } catch (Exception e) {
            }
            return 0;
        }
    }

    class PackageParserCallback implements PackageParser.Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            return PackageManagerService.this.hasSystemFeature(feature, 0);
        }

        /* access modifiers changed from: package-private */
        public final List<PackageParser.Package> getStaticOverlayPackages(Collection<PackageParser.Package> allPackages, String targetPackageName) {
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<PackageParser.Package> overlayPackages = null;
            for (PackageParser.Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mOverlayIsStatic) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList<>();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                Collections.sort(overlayPackages, new Comparator<PackageParser.Package>() {
                    public int compare(PackageParser.Package p1, PackageParser.Package p2) {
                        return p1.mOverlayPriority - p2.mOverlayPriority;
                    }
                });
            }
            return overlayPackages;
        }

        /* access modifiers changed from: package-private */
        public final String[] getStaticOverlayPaths(List<PackageParser.Package> overlayPackages, String targetPath) {
            String[] strArr = null;
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List<String> overlayPathList = null;
            for (PackageParser.Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList<>();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList<>();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (Installer.InstallerException e) {
                        Slog.e(PackageManagerService.TAG, "Failed to generate idmap for " + targetPath + " and " + overlayPackage.baseCodePath);
                    }
                }
            }
            if (overlayPathList != null) {
                strArr = (String[]) overlayPathList.toArray(new String[0]);
            }
            return strArr;
        }

        /* access modifiers changed from: package-private */
        public String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            List<PackageParser.Package> overlayPackages;
            String[] staticOverlayPaths;
            synchronized (PackageManagerService.this.mInstallLock) {
                synchronized (PackageManagerService.this.mPackages) {
                    overlayPackages = getStaticOverlayPackages(PackageManagerService.this.mPackages.values(), targetPackageName);
                }
                staticOverlayPaths = getStaticOverlayPaths(overlayPackages, targetPath);
            }
            return staticOverlayPaths;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, (String) null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        int[] instantUserIds = null;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender2) {
            this.packageSender = packageSender2;
        }

        /* access modifiers changed from: package-private */
        public void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.removedChildPackages.valueAt(i).sendPackageRemovedBroadcastInternal(killApp);
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                int childCount = this.removedChildPackages != null ? this.removedChildPackages.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    PackageRemovedInfo childInfo = this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageAppearedBroadcasts() {
            int packageCount = this.appearedChildPackages != null ? this.appearedChildPackages.size() : 0;
            for (int i = 0; i < packageCount; i++) {
                PackageInstalledInfo installedInfo = this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers, null);
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            Bundle bundle = extras;
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, bundle, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, bundle, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null, null);
            if (this.installerPackageName != null) {
                Bundle bundle2 = extras;
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, bundle2, 0, this.installerPackageName, null, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, bundle2, 0, this.installerPackageName, null, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                extras.putInt("android.intent.extra.UID", this.removedAppId >= 0 ? this.removedAppId : this.uid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", !killApp);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                if (this.removedPackage != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, null, null, this.broadcastUsers, this.instantUserIds);
                    if (this.installerPackageName != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, this.installerPackageName, null, this.broadcastUsers, this.instantUserIds);
                    }
                    if (this.dataRemoved && !this.isRemovedPackageSystemUpdate) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                        this.packageSender.notifyPackageRemoved(this.removedPackage);
                    }
                    if ((this.packageSender instanceof PackageManagerService) && !this.isUpdate) {
                        PackageManagerService packageManagerService = (PackageManagerService) this.packageSender;
                        PackageManagerService.mHwPMSEx.updateNochScreenWhite(this.removedPackage, "removed", 0);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                }
                if (this.packageSender instanceof PackageManagerService) {
                    PackageManagerService packageManagerService2 = (PackageManagerService) this.packageSender;
                    PackageManagerService.mHwPMSEx.deleteClonedProfileIfNeed(this.broadcastUsers);
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            this.instantUserIds = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (deletedPackageSetting.getInstantApp(userId)) {
                    this.instantUserIds = ArrayUtils.appendInt(this.instantUserIds, userId);
                } else {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    class ParallelPackageParserCallback extends PackageParserCallback {
        List<PackageParser.Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        /* access modifiers changed from: package-private */
        public void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayIsStatic) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        public synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr;
            if (this.mOverlayPackages == null) {
                strArr = null;
            } else {
                strArr = getStaticOverlayPaths(getStaticOverlayPackages(this.mOverlayPackages, targetPackageName), targetPath);
            }
            return strArr;
        }
    }

    static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray<>(2);

        public ArrayList<String> get(int userId, String packageName) {
            return getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += this.mUidMap.valueAt(i).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            ArrayMap<String, ArrayList<String>> map2 = new ArrayMap<>();
            this.mUidMap.put(userId, map2);
            return map2;
        }
    }

    static class PostInstallData {
        public InstallArgs args;
        public PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r) {
            this.args = _a;
            this.res = _r;
        }
    }

    private final class ProviderIntentResolver extends IntentResolver<PackageParser.ProviderIntentInfo, ResolveInfo> {
        private int mFlags;
        /* access modifiers changed from: private */
        public final ArrayMap<ComponentName, PackageParser.Provider> mProviders;

        private ProviderIntentResolver() {
            this.mProviders = new ArrayMap<>();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            return super.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<PackageParser.Provider> packageProviders, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageProviders == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageProviders.size();
            ArrayList<PackageParser.ProviderIntentInfo[]> listCut = new ArrayList<>(N);
            for (int i = 0; i < N; i++) {
                ArrayList<PackageParser.ProviderIntentInfo> intentFilters = packageProviders.get(i).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    PackageParser.ProviderIntentInfo[] array = new PackageParser.ProviderIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addProvider(PackageParser.Provider p) {
            if (this.mProviders.containsKey(p.getComponentName())) {
                Slog.w(PackageManagerService.TAG, "Provider " + p.getComponentName() + " already defined; ignoring");
                return;
            }
            this.mProviders.put(p.getComponentName(), p);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(p.info.nonLocalizedLabel != null ? p.info.nonLocalizedLabel : p.info.name);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
                Log.v(PackageManagerService.TAG, "    Class=" + p.info.name);
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ProviderIntentInfo intent = (PackageParser.ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Provider " + p.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeProvider(PackageParser.Provider p) {
            this.mProviders.remove(p.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(p.info.nonLocalizedLabel != null ? p.info.nonLocalizedLabel : p.info.name);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
                Log.v(PackageManagerService.TAG, "    Class=" + p.info.name);
            }
            int NI = p.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ProviderIntentInfo intent = (PackageParser.ProviderIntentInfo) p.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        /* access modifiers changed from: protected */
        public boolean allowFilterResult(PackageParser.ProviderIntentInfo filter, List<ResolveInfo> dest) {
            ProviderInfo filterPi = filter.provider.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ProviderInfo destPi = dest.get(i).providerInfo;
                if (destPi.name == filterPi.name && destPi.packageName == filterPi.packageName) {
                    return false;
                }
            }
            return true;
        }

        /* access modifiers changed from: protected */
        public PackageParser.ProviderIntentInfo[] newArray(int size) {
            return new PackageParser.ProviderIntentInfo[size];
        }

        /* access modifiers changed from: protected */
        public boolean isFilterStopped(PackageParser.ProviderIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            PackageParser.Package p = filter.provider.owner;
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (ps != null) {
                    if ((ps.pkgFlags & 1) != 0 || !ps.getStopped(userId)) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        /* access modifiers changed from: protected */
        public boolean isPackageForFilter(String packageName, PackageParser.ProviderIntentInfo info) {
            return packageName.equals(info.provider.owner.packageName);
        }

        /* access modifiers changed from: protected */
        public ResolveInfo newResult(PackageParser.ProviderIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            PackageParser.ProviderIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.provider.info, this.mFlags, userId)) {
                return null;
            }
            PackageParser.Provider provider = info.provider;
            PackageSetting ps = (PackageSetting) provider.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.mHwPMSEx.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            boolean isInstantApp = false;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                isInstantApp = true;
            }
            if (matchVisibleToInstantApp && !info.isVisibleToInstantApp() && !userState.instantApp) {
                return null;
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ProviderInfo pi = PackageParser.generateProviderInfo(provider, this.mFlags, userState, userId);
            if (pi == null) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.providerInfo = pi;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = info.getPriority();
            res.preferredOrder = provider.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            res.icon = info.icon;
            res.system = res.providerInfo.applicationInfo.isSystemApp();
            return res;
        }

        /* access modifiers changed from: protected */
        public void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        /* access modifiers changed from: protected */
        public void dumpFilter(PrintWriter out, String prefix, PackageParser.ProviderIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.provider)));
            out.print(' ');
            filter.provider.printComponentShortName(out);
            out.print(" filter ");
            out.println(Integer.toHexString(System.identityHashCode(filter)));
        }

        /* access modifiers changed from: protected */
        public Object filterToLabel(PackageParser.ProviderIntentInfo filter) {
            return filter.provider;
        }

        /* access modifiers changed from: protected */
        public void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            PackageParser.Provider provider = (PackageParser.Provider) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(provider)));
            out.print(' ');
            provider.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ScanFlags {
    }

    private static class ScanRequest {
        public final PackageSetting disabledPkgSetting;
        public final boolean isPlatformPackage;
        public final PackageParser.Package oldPkg;
        public final PackageSetting oldPkgSetting;
        public final PackageSetting originalPkgSetting;
        public final int parseFlags;
        public final PackageParser.Package pkg;
        public final PackageSetting pkgSetting;
        public final String realPkgName;
        public final int scanFlags;
        public final SharedUserSetting sharedUserSetting;
        public final UserHandle user;

        public ScanRequest(PackageParser.Package pkg2, SharedUserSetting sharedUserSetting2, PackageParser.Package oldPkg2, PackageSetting pkgSetting2, PackageSetting disabledPkgSetting2, PackageSetting originalPkgSetting2, String realPkgName2, int parseFlags2, int scanFlags2, boolean isPlatformPackage2, UserHandle user2) {
            this.pkg = pkg2;
            this.oldPkg = oldPkg2;
            this.pkgSetting = pkgSetting2;
            this.sharedUserSetting = sharedUserSetting2;
            this.oldPkgSetting = pkgSetting2 == null ? null : new PackageSetting(pkgSetting2);
            this.disabledPkgSetting = disabledPkgSetting2;
            this.originalPkgSetting = originalPkgSetting2;
            this.realPkgName = realPkgName2;
            this.parseFlags = parseFlags2;
            this.scanFlags = scanFlags2;
            this.isPlatformPackage = isPlatformPackage2;
            this.user = user2;
        }
    }

    private static class ScanResult {
        public final List<String> changedAbiCodePath;
        public final PackageSetting pkgSetting;
        public final boolean success;

        public ScanResult(boolean success2, PackageSetting pkgSetting2, List<String> changedAbiCodePath2) {
            this.success = success2;
            this.pkgSetting = pkgSetting2;
            this.changedAbiCodePath = changedAbiCodePath2;
        }
    }

    private final class ServiceIntentResolver extends IntentResolver<PackageParser.ServiceIntentInfo, ResolveInfo> {
        private int mFlags;
        /* access modifiers changed from: private */
        public final ArrayMap<ComponentName, PackageParser.Service> mServices;

        private ServiceIntentResolver() {
            this.mServices = new ArrayMap<>();
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) {
            this.mFlags = defaultOnly ? 65536 : 0;
            return super.queryIntent(intent, resolvedType, defaultOnly, userId);
        }

        public List<ResolveInfo> queryIntent(Intent intent, String resolvedType, int flags, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            this.mFlags = flags;
            return super.queryIntent(intent, resolvedType, (65536 & flags) != 0, userId);
        }

        public List<ResolveInfo> queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList<PackageParser.Service> packageServices, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId) || packageServices == null) {
                return null;
            }
            this.mFlags = flags;
            boolean defaultOnly = (65536 & flags) != 0;
            int N = packageServices.size();
            ArrayList<PackageParser.ServiceIntentInfo[]> listCut = new ArrayList<>(N);
            for (int i = 0; i < N; i++) {
                ArrayList<PackageParser.ServiceIntentInfo> intentFilters = packageServices.get(i).intents;
                if (intentFilters != null && intentFilters.size() > 0) {
                    PackageParser.ServiceIntentInfo[] array = new PackageParser.ServiceIntentInfo[intentFilters.size()];
                    intentFilters.toArray(array);
                    listCut.add(array);
                }
            }
            return super.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);
        }

        public final void addService(PackageParser.Service s) {
            this.mServices.put(s.getComponentName(), s);
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(s.info.nonLocalizedLabel != null ? s.info.nonLocalizedLabel : s.info.name);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
                Log.v(PackageManagerService.TAG, "    Class=" + s.info.name);
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ServiceIntentInfo intent = (PackageParser.ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                if (!intent.debugCheck()) {
                    Log.w(PackageManagerService.TAG, "==> For Service " + s.info.name);
                }
                addFilter(intent);
            }
        }

        public final void removeService(PackageParser.Service s) {
            this.mServices.remove(s.getComponentName());
            if (PackageManagerService.DEBUG_SHOW_INFO) {
                StringBuilder sb = new StringBuilder();
                sb.append("  ");
                sb.append(s.info.nonLocalizedLabel != null ? s.info.nonLocalizedLabel : s.info.name);
                sb.append(":");
                Log.v(PackageManagerService.TAG, sb.toString());
                Log.v(PackageManagerService.TAG, "    Class=" + s.info.name);
            }
            int NI = s.intents.size();
            for (int j = 0; j < NI; j++) {
                PackageParser.ServiceIntentInfo intent = (PackageParser.ServiceIntentInfo) s.intents.get(j);
                if (PackageManagerService.DEBUG_SHOW_INFO) {
                    Log.v(PackageManagerService.TAG, "    IntentFilter:");
                    intent.dump(new LogPrinter(2, PackageManagerService.TAG), "      ");
                }
                removeFilter(intent);
            }
        }

        /* access modifiers changed from: protected */
        public boolean allowFilterResult(PackageParser.ServiceIntentInfo filter, List<ResolveInfo> dest) {
            ServiceInfo filterSi = filter.service.info;
            for (int i = dest.size() - 1; i >= 0; i--) {
                ServiceInfo destAi = dest.get(i).serviceInfo;
                if (destAi.name == filterSi.name && destAi.packageName == filterSi.packageName) {
                    return false;
                }
            }
            return true;
        }

        /* access modifiers changed from: protected */
        public PackageParser.ServiceIntentInfo[] newArray(int size) {
            return new PackageParser.ServiceIntentInfo[size];
        }

        /* access modifiers changed from: protected */
        public boolean isFilterStopped(PackageParser.ServiceIntentInfo filter, int userId) {
            boolean z = true;
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return true;
            }
            PackageParser.Package p = filter.service.owner;
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (ps != null) {
                    if ((ps.pkgFlags & 1) != 0 || !ps.getStopped(userId)) {
                        z = false;
                    }
                    return z;
                }
            }
            return false;
        }

        /* access modifiers changed from: protected */
        public boolean isPackageForFilter(String packageName, PackageParser.ServiceIntentInfo info) {
            return packageName.equals(info.service.owner.packageName);
        }

        /* access modifiers changed from: protected */
        public ResolveInfo newResult(PackageParser.ServiceIntentInfo filter, int match, int userId) {
            if (!PackageManagerService.sUserManager.exists(userId)) {
                return null;
            }
            PackageParser.ServiceIntentInfo info = filter;
            if (!PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info.service.info, this.mFlags, userId)) {
                return null;
            }
            PackageParser.Service service = info.service;
            PackageSetting ps = (PackageSetting) service.owner.mExtras;
            if (ps == null) {
                return null;
            }
            if (PackageManagerService.this.mSafeMode && !PackageManagerService.mHwPMSEx.isSystemPathApp(ps)) {
                return null;
            }
            PackageUserState userState = ps.readUserState(userId);
            ServiceInfo si = PackageParser.generateServiceInfo(service, this.mFlags, userState, userId);
            if (si == null) {
                return null;
            }
            boolean isInstantApp = false;
            boolean matchVisibleToInstantApp = (this.mFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0;
            if ((this.mFlags & DumpState.DUMP_VOLUMES) != 0) {
                isInstantApp = true;
            }
            if (matchVisibleToInstantApp && !info.isVisibleToInstantApp() && !userState.instantApp) {
                return null;
            }
            if (!isInstantApp && userState.instantApp) {
                return null;
            }
            if (userState.instantApp && ps.isUpdateAvailable()) {
                return null;
            }
            ResolveInfo res = new ResolveInfo();
            res.serviceInfo = si;
            if ((this.mFlags & 64) != 0) {
                res.filter = filter;
            }
            res.priority = info.getPriority();
            res.preferredOrder = service.owner.mPreferredOrder;
            res.match = match;
            res.isDefault = info.hasDefault;
            res.labelRes = info.labelRes;
            res.nonLocalizedLabel = info.nonLocalizedLabel;
            res.icon = info.icon;
            res.system = res.serviceInfo.applicationInfo.isSystemApp();
            return res;
        }

        /* access modifiers changed from: protected */
        public void sortResults(List<ResolveInfo> results) {
            Collections.sort(results, PackageManagerService.mResolvePrioritySorter);
        }

        /* access modifiers changed from: protected */
        public void dumpFilter(PrintWriter out, String prefix, PackageParser.ServiceIntentInfo filter) {
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(filter.service)));
            out.print(' ');
            filter.service.printComponentShortName(out);
            out.print(" filter ");
            out.print(Integer.toHexString(System.identityHashCode(filter)));
            if (filter.service.info.permission != null) {
                out.print(" permission ");
                out.println(filter.service.info.permission);
                return;
            }
            out.println();
        }

        /* access modifiers changed from: protected */
        public Object filterToLabel(PackageParser.ServiceIntentInfo filter) {
            return filter.service;
        }

        /* access modifiers changed from: protected */
        public void dumpFilterLabel(PrintWriter out, String prefix, Object label, int count) {
            PackageParser.Service service = (PackageParser.Service) label;
            out.print(prefix);
            out.print(Integer.toHexString(System.identityHashCode(service)));
            out.print(' ');
            service.printComponentShortName(out);
            if (count > 1) {
                out.print(" (");
                out.print(count);
                out.print(" filters)");
            }
            out.println();
        }
    }

    public static final class SharedLibraryEntry {
        public final String apk;
        public final SharedLibraryInfo info;
        public final String path;

        SharedLibraryEntry(String _path, String _apk, String name, long version, int type, String declaringPackageName, long declaringPackageVersionCode) {
            this.path = _path;
            this.apk = _apk;
            SharedLibraryInfo sharedLibraryInfo = new SharedLibraryInfo(name, version, type, new VersionedPackage(declaringPackageName, declaringPackageVersionCode), null);
            this.info = sharedLibraryInfo;
        }
    }

    static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri2, Uri referrer2, int originatingUid2, int installerUid2) {
            this.originatingUri = originatingUri2;
            this.referrer = referrer2;
            this.originatingUid = originatingUid2;
            this.installerUid = installerUid2;
        }
    }

    static {
        boolean z = true;
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        sBrowserIntent.addFlags(512);
        PROTECTED_ACTIONS.add("android.intent.action.SEND");
        PROTECTED_ACTIONS.add("android.intent.action.SENDTO");
        PROTECTED_ACTIONS.add("android.intent.action.SEND_MULTIPLE");
        PROTECTED_ACTIONS.add("android.intent.action.VIEW");
        DISABLE_SPLIT_PKG.add("com.tencent.tmgp.cf");
        if (System.getenv("MAPLE_RUNTIME") == null) {
            z = false;
        }
        sIsMygote = z;
    }

    /* access modifiers changed from: private */
    public static boolean hasValidDomains(PackageParser.ActivityIntentInfo filter) {
        return filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"));
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x0331, code lost:
        r0 = th;
     */
    /* JADX WARNING: Incorrect type for immutable var: ssa=java.lang.String, code=com.android.server.pm.PackageSetting, for r37v0, types: [java.lang.String] */
    public void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, boolean launchedForRestore, PackageSetting ps, IPackageInstallObserver2 installObserver) {
        String str;
        PackageSetting ps2;
        String installerPackageName;
        int[] firstUserIds;
        int i;
        String packageName;
        String packageName2;
        int[] firstInstantUserIds;
        String installerPackageName2;
        PackageSetting ps3;
        int[] iArr;
        PackageInstalledInfo packageInstalledInfo = res;
        IPackageInstallObserver2 iPackageInstallObserver2 = installObserver;
        if (packageInstalledInfo.returnCode == 1) {
            if (packageInstalledInfo.removedInfo != null) {
                packageInstalledInfo.removedInfo.sendPackageRemovedBroadcasts(killApp);
            } else {
                boolean z = killApp;
            }
            if (grantPermissions) {
                this.mPermissionManager.grantRequestedRuntimePermissions(packageInstalledInfo.pkg, packageInstalledInfo.newUsers, grantedPermissions, Binder.getCallingUid(), this.mPermissionCallback);
            }
            boolean update = (packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.removedPackage == null) ? false : true;
            if (packageInstalledInfo.installerPackageName != null) {
                str = packageInstalledInfo.installerPackageName;
            } else if (packageInstalledInfo.removedInfo != null) {
                str = packageInstalledInfo.removedInfo.installerPackageName;
            } else {
                str = null;
            }
            String installerPackageName3 = str;
            if (packageInstalledInfo.pkg.parentPackage != null) {
                this.mPermissionManager.grantRuntimePermissionsGrantedToDisabledPackage(packageInstalledInfo.pkg, Binder.getCallingUid(), this.mPermissionCallback);
            }
            synchronized (this.mPackages) {
                try {
                    this.mInstantAppRegistry.onPackageInstalledLPw(packageInstalledInfo.pkg, packageInstalledInfo.newUsers);
                } finally {
                    th = th;
                    while (true) {
                    }
                }
            }
            String packageName3 = packageInstalledInfo.pkg.applicationInfo.packageName;
            int[] firstUserIds2 = EMPTY_INT_ARRAY;
            int[] firstInstantUserIds2 = EMPTY_INT_ARRAY;
            int[] updateUserIds = EMPTY_INT_ARRAY;
            int[] instantUserIds = EMPTY_INT_ARRAY;
            boolean allNewUsers = packageInstalledInfo.origUsers == null || packageInstalledInfo.origUsers.length == 0;
            PackageSetting ps4 = (PackageSetting) packageInstalledInfo.pkg.mExtras;
            int[] iArr2 = packageInstalledInfo.newUsers;
            int length = iArr2.length;
            int[] updateUserIds2 = updateUserIds;
            int[] firstUserIds3 = firstUserIds2;
            int i2 = 0;
            int[] iArr3 = instantUserIds;
            int[] firstInstantUserIds3 = firstInstantUserIds2;
            int[] instantUserIds2 = iArr3;
            while (i2 < length) {
                int newUser = iArr2[i2];
                boolean isInstantApp = ps.getInstantApp(newUser);
                if (allNewUsers) {
                    if (isInstantApp) {
                        firstInstantUserIds3 = ArrayUtils.appendInt(firstInstantUserIds3, newUser);
                    } else {
                        firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                    }
                    iArr = iArr2;
                } else {
                    boolean isNew = true;
                    iArr = iArr2;
                    int[] iArr4 = packageInstalledInfo.origUsers;
                    ps3 = ps;
                    int length2 = iArr4.length;
                    installerPackageName2 = installerPackageName3;
                    int i3 = 0;
                    while (true) {
                        if (i3 >= length2) {
                            break;
                        }
                        int i4 = length2;
                        if (iArr4[i3] == newUser) {
                            isNew = false;
                            break;
                        } else {
                            i3++;
                            length2 = i4;
                        }
                    }
                    if (isNew) {
                        if (isInstantApp) {
                            firstInstantUserIds3 = ArrayUtils.appendInt(firstInstantUserIds3, newUser);
                        } else {
                            firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                        }
                    } else if (isInstantApp) {
                        instantUserIds2 = ArrayUtils.appendInt(instantUserIds2, newUser);
                    } else {
                        updateUserIds2 = ArrayUtils.appendInt(updateUserIds2, newUser);
                    }
                }
                i2++;
                iArr2 = iArr;
                ps4 = ps3;
                installerPackageName3 = installerPackageName2;
            }
            String installerPackageName4 = installerPackageName3;
            setNeedClearDeviceForCTS(true, packageName3);
            try {
                mHwPMSEx.updatePackageBlackListInfo(packageName3);
            } catch (Exception e) {
                Slog.e(TAG, "update BlackList info failed");
            }
            if (packageInstalledInfo.pkg.staticSharedLibName == null) {
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(packageInstalledInfo.pkg.baseCodePath);
                mHwPMSEx.sendIncompatibleNotificationIfNeeded(packageName3);
                int[] instantUserIds3 = instantUserIds2;
                int[] firstUserIds4 = firstUserIds3;
                int[] firstInstantUserIds4 = firstInstantUserIds3;
                String packageName4 = packageName3;
                String installerPackageName5 = installerPackageName4;
                sendPackageAddedForNewUsers(packageName3, packageInstalledInfo.pkg.applicationInfo.isSystemApp() || virtualPreload, virtualPreload, UserHandle.getAppId(packageInstalledInfo.uid), firstUserIds4, firstInstantUserIds4);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", packageInstalledInfo.uid);
                if (update) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                Bundle extras2 = extras;
                int[] firstInstantUserIds5 = firstInstantUserIds4;
                firstUserIds = firstUserIds4;
                i = 0;
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName4, extras, 0, null, null, updateUserIds2, instantUserIds3);
                if (installerPackageName5 != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName4, extras2, 0, installerPackageName5, null, updateUserIds2, instantUserIds3);
                }
                String packageName5 = packageName4;
                mHwPMSEx.updateNochScreenWhite(packageName5, "add", packageInstalledInfo.pkg.applicationInfo.versionCode);
                boolean notifyVerifier = this.mRequiredVerifierPackage != null && !this.mRequiredVerifierPackage.equals(installerPackageName5);
                if (notifyVerifier) {
                    packageName2 = packageName5;
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName5, extras2, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds3);
                } else {
                    packageName2 = packageName5;
                }
                if (update) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras2, 0, null, null, updateUserIds2, instantUserIds3);
                    if (installerPackageName5 != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras2, 0, installerPackageName5, null, updateUserIds2, instantUserIds3);
                    }
                    if (notifyVerifier) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName2, extras2, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds3);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName2, null, updateUserIds2, instantUserIds3);
                    String str2 = ps;
                    firstInstantUserIds = firstInstantUserIds5;
                    packageName = packageName2;
                } else if (!launchedForRestore || isSystemApp(packageInstalledInfo.pkg)) {
                    String str3 = ps;
                    firstInstantUserIds = firstInstantUserIds5;
                    packageName = packageName2;
                } else {
                    if (DEBUG_BACKUP) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("Post-restore of ");
                        packageName = packageName2;
                        sb.append(packageName);
                        sb.append(" sending FIRST_LAUNCH in ");
                        sb.append(Arrays.toString(firstUserIds));
                        Slog.i(TAG, sb.toString());
                    } else {
                        packageName = packageName2;
                    }
                    firstInstantUserIds = firstInstantUserIds5;
                    sendFirstLaunchBroadcast(packageName, ps, firstUserIds, firstInstantUserIds);
                }
                if (packageInstalledInfo.pkg.isForwardLocked() || isExternal(packageInstalledInfo.pkg)) {
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + packageInstalledInfo.pkg + " is ASEC-hosted -> AVAILABLE");
                    }
                    int[] uidArray = {packageInstalledInfo.pkg.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList<>(1);
                    pkgList.add(packageName);
                    ArrayList<String> arrayList = pkgList;
                    int[] iArr5 = firstInstantUserIds;
                    sendResourcesChangedBroadcast(true, true, pkgList, uidArray, (IIntentReceiver) null);
                } else {
                    int[] iArr6 = firstInstantUserIds;
                }
            } else {
                String str4 = ps;
                int[] iArr7 = instantUserIds2;
                firstUserIds = firstUserIds3;
                int[] iArr8 = firstInstantUserIds3;
                packageName = packageName3;
                String str5 = installerPackageName4;
                i = 0;
            }
            if (firstUserIds != null && firstUserIds.length > 0) {
                synchronized (this.mPackages) {
                    int length3 = firstUserIds.length;
                    for (int i5 = i; i5 < length3; i5++) {
                        int userId = firstUserIds[i5];
                        if (packageIsBrowser(packageName, userId)) {
                            this.mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                        }
                        this.mSettings.applyPendingPermissionGrantsLPw(packageName, userId);
                    }
                }
            }
            if (allNewUsers && !update) {
                notifyPackageAdded(packageName);
            }
            EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            if (packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else {
                Runtime.getRuntime().gc();
                synchronized (this.mInstallLock) {
                    packageInstalledInfo.removedInfo.args.doPostDeleteLI(true);
                }
            }
            int length4 = firstUserIds.length;
            for (int i6 = i; i6 < length4; i6++) {
                int userId2 = firstUserIds[i6];
                PackageInfo info = getPackageInfo(packageName, i, userId2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, userId2);
                }
            }
        } else {
            String str6 = ps;
        }
        IPackageInstallObserver2 iPackageInstallObserver22 = installObserver;
        if (iPackageInstallObserver22 != null) {
            try {
                iPackageInstallObserver22.onPackageInstalled(packageInstalledInfo.name, packageInstalledInfo.returnCode, packageInstalledInfo.returnMsg, extrasForInstallResult(res));
            } catch (RemoteException e2) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
    }

    public void setNeedClearDeviceForCTS(boolean needvalue, String packageName) {
        if (packageName == null) {
            this.mNeedClearDeviceForCTS = false;
        } else if (packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEIVCEOWNER) || packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_DEVICEANDPROFILEOWNER) || packageName.equals(PACKAGE_NAME_BASICADMINRECEIVER_CTS_PACKAGEINSTALLER)) {
            this.mNeedClearDeviceForCTS = needvalue;
            Log.d(TAG, "setmNeedClearDeviceForCTS:" + this.mNeedClearDeviceForCTS);
        } else {
            this.mNeedClearDeviceForCTS = false;
        }
    }

    public boolean getNeedClearDeviceForCTS() {
        return this.mNeedClearDeviceForCTS;
    }

    /* access modifiers changed from: package-private */
    public Bundle extrasForInstallResult(PackageInstalledInfo res) {
        int i = res.returnCode;
        if (i != -112) {
            boolean z = true;
            if (i != 1) {
                return null;
            }
            Bundle extras = new Bundle();
            if (res.removedInfo == null || res.removedInfo.removedPackage == null) {
                z = false;
            }
            extras.putBoolean("android.intent.extra.REPLACING", z);
            return extras;
        }
        Bundle extras2 = new Bundle();
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
        return extras2;
    }

    /* access modifiers changed from: package-private */
    public void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, 10000);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, 10000);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(int userId) {
        int i = 0;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, 10000);
                }
                i++;
            } else {
                return;
            }
        }
    }

    /* JADX WARNING: type inference failed for: r2v0, types: [com.android.server.pm.PackageManagerService, java.lang.Object, android.os.IBinder] */
    /* JADX WARNING: type inference failed for: r3v1, types: [com.android.server.pm.PackageManagerService$PackageManagerNative, android.os.IBinder] */
    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        long startTime = SystemClock.uptimeMillis();
        PackageManagerServiceCompilerMapping.checkProperties();
        ? huaweiPackageManagerService = HwServiceFactory.getHuaweiPackageManagerService(context, installer, factoryTest, onlyCore);
        huaweiPackageManagerService.enableSystemUserPackages();
        ServiceManager.addService("package", huaweiPackageManagerService);
        Objects.requireNonNull(huaweiPackageManagerService);
        ServiceManager.addService("package_native", new PackageManagerNative());
        Slog.i(TAG, "PackageManagerService booting timestamp : " + (SystemClock.uptimeMillis() - startTime) + " ms");
        return huaweiPackageManagerService;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet<>();
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            Log.i(TAG, "Applications installed for system user: " + enableApps);
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                int i = 0;
                while (i < allAppsSize) {
                    try {
                        String pName = allAps.get(i);
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(pName);
                        if (pkgSetting != null) {
                            boolean install = enableApps.contains(pName);
                            if (pkgSetting.getInstalled(0) != install) {
                                StringBuilder sb = new StringBuilder();
                                sb.append(install ? "Installing " : "Uninstalling ");
                                sb.append(pName);
                                sb.append(" for system user");
                                Log.i(TAG, sb.toString());
                                pkgSetting.setInstalled(install, 0);
                            }
                        }
                        i++;
                    } finally {
                    }
                }
                scheduleWritePackageRestrictionsLocked(0);
            }
        }
    }

    private static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = 100000 + timeStart;
            long timeNow = timeStart;
            while (true) {
                if (SystemProperties.get("sys.cppreopt").equals("finished")) {
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            Slog.i(TAG, "cppreopts took " + (timeNow - timeStart) + " ms");
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x05f0, code lost:
        mHwPMSEx.loadCorrectUninstallDelapp();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x05f7, code lost:
        if (HWFLOW == false) goto L_0x05ff;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x05f9, code lost:
        r13.mStartTimer = android.os.SystemClock.uptimeMillis();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x05ff, code lost:
        mHwPMSEx.loadSysWhitelist();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0606, code lost:
        if (HWFLOW == false) goto L_0x063a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x0608, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("TimerCounter = ");
        r2 = r13.mTimerCounter + 1;
        r13.mTimerCounter = r2;
        r1.append(r2);
        r1.append(" **** loadSysWhitelist  ************ Time to elapsed: ");
        r35 = r5;
        r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
        r1.append(" ms");
        android.util.Slog.i(TAG, r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x063a, code lost:
        r35 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x063c, code lost:
        mHwPMSEx.readPersistentConfig();
        mHwPMSEx.initCertCompatSettings();
        mHwPMSEx.resetSharedUserSignaturesIfNeeded();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x064d, code lost:
        if (r13.mIsUpgrade == false) goto L_0x0657;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x0653, code lost:
        if (r7.sdkVersion > 22) goto L_0x0657;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0655, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0657, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x0658, code lost:
        r13.mPromoteSystemApps = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x065c, code lost:
        if (r13.mIsUpgrade == false) goto L_0x0666;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0662, code lost:
        if (r7.sdkVersion >= 24) goto L_0x0666;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x0664, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x0666, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x0667, code lost:
        r13.mIsPreNUpgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x066b, code lost:
        if (r13.mIsUpgrade == false) goto L_0x0675;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0671, code lost:
        if (r7.sdkVersion >= 25) goto L_0x0675;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0673, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0675, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x0676, code lost:
        r13.mIsPreNMR1Upgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x067a, code lost:
        if (r13.mIsUpgrade == false) goto L_0x0684;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x0680, code lost:
        if (r7.sdkVersion >= 28) goto L_0x0684;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x0682, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x0684, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x0685, code lost:
        r13.mIsPrePUpgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x0689, code lost:
        if (r13.mPromoteSystemApps == false) goto L_0x06b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x068b, code lost:
        r0 = r13.mSettings.mPackages.values().iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x069b, code lost:
        if (r0.hasNext() == false) goto L_0x06b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x069d, code lost:
        r1 = r0.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x06a7, code lost:
        if (isSystemApp(r1) == false) goto L_0x06b0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x06a9, code lost:
        r13.mExistingSystemPackages.add(r1.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x06b1, code lost:
        r13.mCacheDir = preparePackageParserCache(r13.mIsUpgrade);
        r0 = 528;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x06bd, code lost:
        if (r13.mIsUpgrade != false) goto L_0x06c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x06c1, code lost:
        if (r13.mFirstBoot == false) goto L_0x06c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x06c3, code lost:
        r0 = 528 | 8192;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x06c5, code lost:
        r5 = r0;
        mHwPMSEx.readPreInstallApkList();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x06cb, code lost:
        r1 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x06d3, code lost:
        r1 = huawei.cust.HwCfgFilePolicy.getCfgFileList("/overlay", 1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x06d7, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:?, code lost:
        android.util.Slog.e(TAG, r0.getMessage());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x027a, code lost:
        r13.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.log", LOG_UID, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
        r13.mSettings.addSharedUserLPw("com.nxp.uid.nfceeapi", SPI_UID, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.se", SE_UID, 1, 8);
        r13.mSettings.addSharedUserLPw("android.uid.hbs", HBS_UID, 1, 8);
        com.android.server.HwServiceFactory.getHwPackageServiceManager().addHwSharedUserLP(r13.mSettings);
        r9 = android.os.SystemProperties.get("debug.separate_processes");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x02dc, code lost:
        if (r9 == null) goto L_0x031b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x02e2, code lost:
        if (r9.length() <= 0) goto L_0x031b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x02ea, code lost:
        if ("*".equals(r9) == false) goto L_0x02f9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:0x02ec, code lost:
        r13.mDefParseFlags = 2;
        r13.mSeparateProcesses = null;
        android.util.Slog.w(TAG, "Running with debug.separate_processes: * (ALL)");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x02f9, code lost:
        r13.mDefParseFlags = 0;
        r13.mSeparateProcesses = r9.split(",");
        android.util.Slog.w(TAG, "Running with debug.separate_processes: " + r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x031b, code lost:
        r13.mDefParseFlags = 0;
        r13.mSeparateProcesses = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x0320, code lost:
        r13.mPackageDexOptimizer = new com.android.server.pm.PackageDexOptimizer(r15, r13.mInstallLock, r14, "*dexopt*");
        r1 = new com.android.server.pm.dex.DexManager(r13.mContext, r13, r13.mPackageDexOptimizer, r15, r13.mInstallLock, com.android.server.pm.dex.DexLogger.getListener(r13, r15, r13.mInstallLock));
        r13.mDexManager = r1;
        r13.mArtManagerService = new com.android.server.pm.dex.ArtManagerService(r13.mContext, r13, r15, r13.mInstallLock);
        r13.mMoveCallbacks = new com.android.server.pm.PackageManagerService.MoveCallbacks(com.android.server.FgThread.get().getLooper());
        r13.mOnPermissionChangeListeners = new com.android.server.pm.PackageManagerService.OnPermissionChangeListeners(com.android.server.FgThread.get().getLooper());
        getDefaultDisplayMetrics(r14, r13.mMetrics);
        android.os.Trace.traceBegin(262144, "get system config");
        r7 = com.android.server.SystemConfig.getInstance();
        r13.mAvailableFeatures = r7.getAvailableFeatures();
        android.os.Trace.traceEnd(262144);
        r13.mProtectedPackages = new com.android.server.pm.ProtectedPackages(r13.mContext);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x0397, code lost:
        if (HWFLOW == false) goto L_0x03c8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x0399, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("TimerCounter = ");
        r2 = r13.mTimerCounter + 1;
        r13.mTimerCounter = r2;
        r1.append(r2);
        r1.append(" **** Config Init  ************ Time to elapsed: ");
        r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
        r1.append(" ms");
        android.util.Slog.i(TAG, r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x03c8, code lost:
        r5 = r13.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x03ca, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:?, code lost:
        r6 = r13.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x03cd, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:?, code lost:
        r13.mHandlerThread = new com.android.server.ServiceThread(TAG, 10, true);
        r13.mHandlerThread.start();
        r13.mHandler = new com.android.server.pm.PackageManagerService.PackageHandler(r13, r13.mHandlerThread.getLooper());
        r13.mProcessLoggingHandler = new com.android.server.pm.ProcessLoggingHandler();
        com.android.server.Watchdog.getInstance().addThread(r13.mHandler, 600000);
        r13.mInstantAppRegistry = new com.android.server.pm.InstantAppRegistry(r13);
        r3 = r7.getSharedLibraries();
        r1 = r3.size();
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x0410, code lost:
        if (r0 >= r1) goto L_0x0456;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:490:0x1250, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:491:0x1251, code lost:
        r24 = r75;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:492:0x1254, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:493:0x1255, code lost:
        r16 = r5;
        r33 = r6;
        r17 = r7;
        r18 = r9;
        r24 = r75;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x0427, code lost:
        r31 = r1;
        r32 = r3;
        r16 = r5;
        r33 = r6;
        r17 = r7;
        r18 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:500:0x1263, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:501:0x1264, code lost:
        r16 = r5;
        r17 = r7;
        r18 = r9;
        r24 = r75;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:502:0x126c, code lost:
        monitor-exit(r16);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:503:0x126d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:504:0x126e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:?, code lost:
        addSharedLibraryLPw(r3.valueAt(r0), null, r3.keyAt(r0), -1, 0, PLATFORM_PACKAGE_NAME, 0);
        r0 = r0 + 1;
        r5 = r16;
        r7 = r17;
        r9 = r18;
        r1 = r31;
        r3 = r32;
        r6 = r33;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0456, code lost:
        r31 = r1;
        r32 = r3;
        r16 = r5;
        r33 = r6;
        r17 = r7;
        r18 = r9;
        com.android.server.pm.SELinuxMMAC.readInstallPolicy();
        mHwPMSEx.initHwCertificationManager();
        android.os.Trace.traceBegin(262144, "loadFallbacks");
        android.content.pm.FallbackCategoryProvider.loadFallbacks();
        android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x047a, code lost:
        if (HWFLOW == false) goto L_0x0482;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x047c, code lost:
        r13.mStartTimer = android.os.SystemClock.uptimeMillis();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x0482, code lost:
        android.os.Trace.traceBegin(262144, "read user settings");
        r13.mFirstBoot = !r13.mSettings.readLPw(sUserManager.getUsers(false));
        android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x049e, code lost:
        if (sIsMygote == false) goto L_0x04af;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x04a0, code lost:
        com.android.server.pm.HwMaplePMServiceUtils.init(r13.mHandlerThread.getLooper(), r13.mContext);
        com.android.server.pm.HwMaplePMServiceUtils.loadDisabledMaplePkgs();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x04af, code lost:
        com.android.server.pm.HwMaplePMServiceUtils.deleteDisabledMapleFile();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x04b2, code lost:
        r21 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x04b6, code lost:
        if (HWFLOW == false) goto L_0x04e7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x04b8, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("TimerCounter = ");
        r2 = r13.mTimerCounter + 1;
        r13.mTimerCounter = r2;
        r1.append(r2);
        r1.append(" **** mSettings.readLPw  ************ Time to elapsed: ");
        r1.append(android.os.SystemClock.uptimeMillis() - r13.mStartTimer);
        r1.append(" ms");
        android.util.Slog.i(TAG, r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x04ef, code lost:
        if (r13.mSettings.mDisabledSysPackages.size() <= 0) goto L_0x0534;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x04f1, code lost:
        r1 = r13.mSettings.mPackages.size() - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x04fb, code lost:
        if (r1 < 0) goto L_0x0534;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x04fd, code lost:
        r2 = r13.mSettings.mPackages.valueAt(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x050b, code lost:
        if (isExternal(r2) != false) goto L_0x0531;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x050f, code lost:
        if (r2.codePath == null) goto L_0x0519;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0517, code lost:
        if (r2.codePath.exists() != false) goto L_0x0531;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0521, code lost:
        if (r13.mSettings.getDisabledSystemPkgLPr(r2.name) == null) goto L_0x0531;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0523, code lost:
        r13.mSettings.mPackages.removeAt(r1);
        r13.mSettings.enableSystemPackageLPw(r2.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0531, code lost:
        r1 = r1 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0536, code lost:
        if (r13.mFirstBoot == 0) goto L_0x053b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x0538, code lost:
        requestCopyPreoptedFiles();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x053b, code lost:
        r0 = android.content.res.Resources.getSystem().getString(17039776);
        r0 = android.common.HwFrameworkFactory.getHuaweiResolverActivity(r13.mContext);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0551, code lost:
        if (android.text.TextUtils.isEmpty(r0) == false) goto L_0x0557;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0553, code lost:
        r0 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x0554, code lost:
        r22 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0557, code lost:
        r13.mCustomResolverComponentName = android.content.ComponentName.unflattenFromString(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x055e, code lost:
        r5 = android.os.SystemClock.uptimeMillis();
        android.util.EventLog.writeEvent(com.android.server.EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, r5);
        r27 = java.lang.System.getenv("BOOTCLASSPATH");
        r28 = java.lang.System.getenv("SYSTEMSERVERCLASSPATH");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x0578, code lost:
        if (r27 != null) goto L_0x0581;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x057a, code lost:
        android.util.Slog.w(TAG, "No BOOTCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x0581, code lost:
        if (r28 != null) goto L_0x058a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x0583, code lost:
        android.util.Slog.w(TAG, "No SYSTEMSERVERCLASSPATH found!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x058a, code lost:
        r8 = new java.io.File(android.os.Environment.getRootDirectory(), "framework");
        r7 = r13.mSettings.getInternalVersion();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x059c, code lost:
        if (r7 == null) goto L_0x05b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x05a6, code lost:
        if (android.os.Build.FINGERPRINT.equals(r7.fingerprint) == false) goto L_0x05b2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x05b0, code lost:
        if (android.os.Build.HWFINGERPRINT.equals(r7.hwFingerprint) != false) goto L_0x05b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x05b2, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x05b4, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x05b5, code lost:
        r13.mIsUpgrade = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x05ba, code lost:
        if (r13.mIsUpgrade == false) goto L_0x05f0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x05bc, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "FINGERPRINT Upgrading from " + r7.fingerprint + " to " + android.os.Build.FINGERPRINT + " and HWFINGERPRINT Upgrading from " + r7.hwFingerprint + " to " + android.os.Build.HWFINGERPRINT);
     */
    /* JADX WARNING: Removed duplicated region for block: B:190:0x083b A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:193:0x084a A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:194:0x087c A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:197:0x0882 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:200:0x0891 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:235:0x0973 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:272:0x0af3 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:273:0x0af8 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:276:0x0b13 A[ADDED_TO_REGION, Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:281:0x0b26 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:366:0x0e16 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:369:0x0e46 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:389:0x0f1a A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:406:0x0f99 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:407:0x0f9b A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:409:0x0f9e A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:412:0x0fda A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:414:0x0fe0 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:428:0x1028 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }, LOOP:12: B:426:0x1022->B:428:0x1028, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:431:0x103b A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:432:0x103d A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:435:0x1060 A[ADDED_TO_REGION, Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:452:0x10bb A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:453:0x10bc A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:466:0x1140 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:471:0x117e A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:474:0x119e A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:478:0x11d5 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    /* JADX WARNING: Removed duplicated region for block: B:481:0x11f5 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }, LOOP:14: B:480:0x11f3->B:481:0x11f5, LOOP_END] */
    /* JADX WARNING: Removed duplicated region for block: B:484:0x1232 A[Catch:{ PackageManagerException -> 0x0d66, all -> 0x1261 }] */
    public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        Object obj;
        ArrayMap<String, PackageParser.Package> arrayMap;
        boolean settingsDirty;
        File frameworkDir;
        Settings.VersionInfo ver;
        long startTime;
        int scanFlags;
        ArrayList<File> fileList;
        int scanFlags2;
        boolean z;
        File privilegedAppDir;
        int scanFlags3;
        File systemAppDir;
        File privilegedVendorAppDir;
        File vendorAppDir;
        File privilegedOdmAppDir;
        File privilegedOdmAppDir2;
        File odmAppDir;
        File vendorAppDir2;
        File odmAppDir2;
        File odmAppDir3;
        File oemAppDir;
        File oemAppDir2;
        int systemPackagesCount;
        List<String> possiblyDeletedUpdatedSystemApps;
        long j;
        Settings.VersionInfo ver2;
        boolean sdkUpdated;
        int storageFlags;
        Object obj2;
        Pair<ComponentName, String> instantAppResolverComponent;
        String str;
        int length;
        int i;
        int i2;
        int i3;
        File privilegedProductAppDir;
        List<String> possiblyDeletedUpdatedSystemApps2;
        int i4;
        int i5;
        long j2;
        File privilegedProductAppDir2;
        List<String> possiblyDeletedUpdatedSystemApps3;
        File odmAppDir4;
        File privilegedOdmAppDir3;
        File privilegedOdmAppDir4;
        File vendorAppDir3;
        int scanFlags4;
        File vendorAppDir4;
        File odmAppDir5;
        List<String> possiblyDeletedUpdatedSystemApps4;
        int rescanFlags;
        File oemAppDir3;
        File privilegedOdmAppDir5;
        int reparseFlags;
        int rescanFlags2;
        int reparseFlags2;
        File vendorAppDir5;
        File odmAppDir6;
        File oemAppDir4;
        List<String> possiblyDeletedUpdatedSystemApps5;
        File vendorAppDir6;
        File odmAppDir7;
        File oemAppDir5;
        int reparseFlags3;
        int reparseFlags4;
        int rescanFlags3;
        String msg;
        File productAppDir;
        File privilegedProductAppDir3;
        ArrayList arrayList;
        Iterator<PackageParser.Package> pkgIterator;
        Context context2 = context;
        Installer installer2 = installer;
        boolean z2 = onlyCore;
        mHwPMSEx = HwServiceExFactory.getHwPackageManagerServiceEx(this, context);
        HwPackageManagerServiceUtils.initHwPMSEx(mHwPMSEx);
        LockGuard.installLock((Object) this.mPackages, 3);
        Trace.traceBegin(262144, "create package manager");
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());
        Jlog.d(31, "JL_BOOT_PROGRESS_PMS_START");
        if (this.mSdkVersion <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }
        this.mContext = context2;
        this.mPermissionReviewRequired = context.getResources().getBoolean(17957000);
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        this.mFactoryTest = factoryTest;
        this.mOnlyCore = z2;
        this.mMetrics = new DisplayMetrics();
        this.mInstaller = installer2;
        synchronized (this.mInstallLock) {
            try {
                synchronized (this.mPackages) {
                    try {
                        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());
                        Slog.i(TAG, "UserManagerService");
                        HwServiceFactory.IHwUserManagerService service = HwServiceFactory.getHwUserManagerService();
                        if (service != null) {
                            sUserManager = service.getInstance(context2, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                        } else {
                            sUserManager = new UserManagerService(context2, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                        }
                    } catch (Throwable th) {
                        th = th;
                        boolean z3 = z2;
                        while (true) {
                            try {
                                throw th;
                            } catch (Throwable th2) {
                                th = th2;
                                throw th;
                            }
                        }
                    }
                    this.mPermissionManager = PermissionManagerService.create(context2, new DefaultPermissionGrantPolicy.DefaultPermissionGrantedCallback() {
                        public void onDefaultRuntimePermissionsGranted(int userId) {
                            synchronized (PackageManagerService.this.mPackages) {
                                PackageManagerService.this.mSettings.onDefaultRuntimePermissionsGrantedLPr(userId);
                            }
                        }
                    }, this.mPackages);
                    this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                    Slog.i(TAG, "mDefaultPermissionPolicy :" + this.mDefaultPermissionPolicy);
                    this.mSettings = new Settings(this.mPermissionManager.getPermissionSettings(), this.mPackages);
                }
            } catch (Throwable th3) {
                th = th3;
                boolean z4 = z2;
                throw th;
            }
        }
        i2 = i3 - 1;
        i4 = i5 + 1;
        scanFlags3 = scanFlags4;
        vendorAppDir2 = vendorAppDir3;
        possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps3;
        privilegedProductAppDir = privilegedProductAppDir2;
        oemAppDir2 = odmAppDir4;
        oemAppDir = privilegedOdmAppDir3;
        odmAppDir = privilegedOdmAppDir4;
        oemAppDir = odmAppDir3;
        scanDirTracedLI(odmAppDir3, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576, 0);
        File oemAppDir6 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir6;
        scanDirTracedLI(oemAppDir6, this.mDefParseFlags | 16, scanFlags3 | 131072 | 524288, 0);
        File privilegedProductAppDir4 = new File(Environment.getProductDirectory(), "priv-app");
        try {
            privilegedProductAppDir4 = privilegedProductAppDir4.getCanonicalFile();
        } catch (IOException e) {
        }
        File privilegedProductAppDir5 = privilegedProductAppDir4;
        File productAppDir2 = new File(Environment.getProductDirectory(), "app");
        try {
            productAppDir2 = productAppDir2.getCanonicalFile();
        } catch (IOException e2) {
        }
        File productAppDir3 = productAppDir2;
        List<String> arrayList2 = new ArrayList<>();
        ArrayList arrayList3 = new ArrayList();
        if (!this.mOnlyCore) {
            Iterator<PackageParser.Package> pkgIterator2 = this.mPackages.values().iterator();
            while (pkgIterator2.hasNext()) {
                PackageParser.Package pkg = pkgIterator2.next();
                if (pkg.isStub) {
                    arrayList3.add(pkg.packageName);
                }
            }
            Iterator<PackageSetting> psit = this.mSettings.mPackages.values().iterator();
            while (psit.hasNext()) {
                PackageSetting ps = psit.next();
                if ((ps.pkgFlags & 1) == 0) {
                    pkgIterator = pkgIterator2;
                    arrayList = arrayList3;
                    privilegedProductAppDir3 = privilegedProductAppDir5;
                    productAppDir = productAppDir3;
                } else {
                    pkgIterator = pkgIterator2;
                    getHwPMSEx().makeSetupDisabled(ps.name);
                    PackageParser.Package scannedPkg = this.mPackages.get(ps.name);
                    if (scannedPkg != null) {
                        arrayList = arrayList3;
                        if (this.mSettings.isDisabledSystemPackageLPr(ps.name)) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Expecting better updated system app for ");
                            sb.append(ps.name);
                            sb.append("; removing system app.  Last known codePath=");
                            sb.append(ps.codePathString);
                            sb.append(", versionCode=");
                            privilegedProductAppDir3 = privilegedProductAppDir5;
                            productAppDir = productAppDir3;
                            sb.append(ps.versionCode);
                            sb.append("; scanned versionCode=");
                            sb.append(scannedPkg.getLongVersionCode());
                            PackageManagerServiceUtils.logCriticalInfo(5, sb.toString());
                            removePackageLI(scannedPkg, true);
                            if (!getHwPMSEx().skipSetupEnable(ps.name)) {
                                this.mExpectingBetter.put(ps.name, ps.codePath);
                            }
                        } else {
                            privilegedProductAppDir3 = privilegedProductAppDir5;
                            productAppDir = productAppDir3;
                        }
                    } else {
                        arrayList = arrayList3;
                        privilegedProductAppDir3 = privilegedProductAppDir5;
                        productAppDir = productAppDir3;
                        if (!mHwPMSEx.isSystemAppGrantByMdm(ps.name)) {
                            if (!this.mSettings.isDisabledSystemPackageLPr(ps.name)) {
                                psit.remove();
                                settingsDirty = true;
                                PackageManagerServiceUtils.logCriticalInfo(5, "System package " + ps.name + " no longer exists; it's data will be wiped");
                                writeNetQinFlag(ps.name);
                            } else {
                                PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps.name);
                                if (disabledPs.codePath == null || !disabledPs.codePath.exists() || disabledPs.pkg == null) {
                                    arrayList2.add(ps.name);
                                }
                            }
                            pkgIterator2 = pkgIterator;
                            arrayList3 = arrayList;
                            privilegedProductAppDir5 = privilegedProductAppDir3;
                            productAppDir3 = productAppDir;
                        }
                    }
                }
                pkgIterator2 = pkgIterator;
                arrayList3 = arrayList;
                privilegedProductAppDir5 = privilegedProductAppDir3;
                productAppDir3 = productAppDir;
            }
        }
        ArrayList arrayList4 = arrayList3;
        File privilegedProductAppDir6 = privilegedProductAppDir5;
        File productAppDir4 = productAppDir3;
        deleteTempPackageFiles();
        int cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb2 = new StringBuilder();
        sb2.append("Finished scanning system apps. Time: ");
        sb2.append(systemScanTime);
        sb2.append(" ms, packageCount: ");
        sb2.append(systemPackagesCount);
        sb2.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
            possiblyDeletedUpdatedSystemApps = arrayList2;
            j = 0;
        } else {
            possiblyDeletedUpdatedSystemApps = arrayList2;
            j = systemScanTime / ((long) systemPackagesCount);
        }
        sb2.append(j);
        sb2.append(" , cached: ");
        sb2.append(cachedSystemApps);
        Slog.i(TAG, sb2.toString());
        if (!this.mIsUpgrade && systemPackagesCount > 0) {
            MetricsLogger.histogram(null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
        }
        if (!this.mOnlyCore) {
            int systemPackagesCount2 = systemPackagesCount;
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());
            boolean isPackageSettingsError = this.mSettings.isPackageSettingsError();
            long systemScanTime2 = systemScanTime;
            ArrayList arrayList5 = arrayList4;
            List<String> list = possiblyDeletedUpdatedSystemApps;
            File file = frameworkDir;
            privilegedProductAppDir = privilegedProductAppDir6;
            File productAppDir5 = productAppDir4;
            int systemPackagesCount3 = systemPackagesCount2;
            scanDirTracedLI(sAppInstallDir, 0, isPackageSettingsError ? scanFlags3 : scanFlags3 | 128, 0);
            scanDirTracedLI(sDrmAppPrivateInstallDir, this.mDefParseFlags | 4, isPackageSettingsError ? scanFlags3 : scanFlags3 | 128, 0);
            possiblyDeletedUpdatedSystemApps2 = list;
            for (String deletedAppName : possiblyDeletedUpdatedSystemApps2) {
                PackageParser.Package deletedPkg = this.mPackages.get(deletedAppName);
                this.mSettings.removeDisabledSystemPackageLPw(deletedAppName);
                if (deletedPkg == null) {
                    msg = "Updated system package " + deletedAppName + " no longer exists; removing its data";
                } else {
                    msg = "Updated system package + " + deletedAppName + " no longer exists; revoking system privileges";
                    PackageSetting deletedPs = this.mSettings.mPackages.get(deletedAppName);
                    deletedPkg.applicationInfo.flags &= -2;
                    deletedPs.pkgFlags &= -2;
                    if ((deletedPkg.applicationInfo.privateFlags & 8) != 0) {
                        deletedPkg.applicationInfo.privateFlags &= -9;
                        deletedPs.pkgPrivateFlags &= -9;
                    }
                }
                PackageManagerServiceUtils.logCriticalInfo(5, msg);
            }
            i4 = 0;
            while (true) {
                i5 = i4;
                if (i5 >= this.mExpectingBetter.size()) {
                    break;
                }
                String packageName = this.mExpectingBetter.keyAt(i5);
                if (!this.mPackages.containsKey(packageName)) {
                    File scanFile = this.mExpectingBetter.valueAt(i5);
                    PackageManagerServiceUtils.logCriticalInfo(5, "Expected better " + packageName + " but never showed up; reverting to system");
                    if (FileUtils.contains(privilegedAppDir, scanFile)) {
                        reparseFlags4 = this.mDefParseFlags | 16;
                        rescanFlags3 = scanFlags3 | 131072 | 262144;
                    } else if (FileUtils.contains(systemAppDir, scanFile)) {
                        reparseFlags4 = this.mDefParseFlags | 16;
                        rescanFlags3 = scanFlags3 | 131072;
                    } else {
                        if (FileUtils.contains(privilegedVendorAppDir, scanFile) == 0) {
                            privilegedOdmAppDir5 = odmAppDir;
                            if (FileUtils.contains(privilegedOdmAppDir5, scanFile)) {
                                possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                                vendorAppDir6 = vendorAppDir2;
                                odmAppDir7 = oemAppDir;
                                oemAppDir5 = oemAppDir2;
                            } else {
                                File vendorAppDir7 = vendorAppDir2;
                                if (!FileUtils.contains(vendorAppDir7, scanFile)) {
                                    possiblyDeletedUpdatedSystemApps4 = possiblyDeletedUpdatedSystemApps2;
                                    File odmAppDir8 = oemAppDir;
                                    if (FileUtils.contains(odmAppDir8, scanFile)) {
                                        vendorAppDir5 = vendorAppDir7;
                                        odmAppDir6 = odmAppDir8;
                                        oemAppDir4 = oemAppDir2;
                                    } else {
                                        odmAppDir5 = odmAppDir8;
                                        oemAppDir3 = oemAppDir2;
                                        if (FileUtils.contains(oemAppDir3, scanFile)) {
                                            reparseFlags3 = this.mDefParseFlags | 16;
                                            rescanFlags = scanFlags3 | 131072 | 524288;
                                        } else if (FileUtils.contains(privilegedProductAppDir, scanFile)) {
                                            reparseFlags3 = this.mDefParseFlags | 16;
                                            rescanFlags = scanFlags3 | 131072 | 2097152 | 262144;
                                        } else if (FileUtils.contains(productAppDir5, scanFile) != 0) {
                                            reparseFlags3 = this.mDefParseFlags | 16;
                                            rescanFlags = scanFlags3 | 131072 | 2097152;
                                        } else if (mHwPMSEx != null && mHwPMSEx.isSystemPreApp(scanFile)) {
                                            reparseFlags3 = this.mDefParseFlags | 16;
                                            rescanFlags = scanFlags3 | 131072;
                                        } else if (mHwPMSEx == null || !mHwPMSEx.isPrivilegedPreApp(scanFile)) {
                                            Slog.e(TAG, "Ignoring unexpected fallback path " + scanFile);
                                            privilegedOdmAppDir4 = privilegedOdmAppDir5;
                                            odmAppDir4 = oemAppDir3;
                                            privilegedProductAppDir2 = privilegedProductAppDir;
                                            possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps4;
                                            privilegedOdmAppDir3 = odmAppDir5;
                                            vendorAppDir3 = vendorAppDir7;
                                            scanFlags4 = scanFlags3;
                                        } else {
                                            reparseFlags3 = this.mDefParseFlags | 16;
                                            rescanFlags = scanFlags3 | 131072 | 262144;
                                        }
                                        vendorAppDir4 = vendorAppDir7;
                                        reparseFlags = reparseFlags4;
                                        vendorAppDir3 = vendorAppDir4;
                                        privilegedOdmAppDir4 = privilegedOdmAppDir5;
                                        int rescanFlags4 = rescanFlags;
                                        this.mSettings.enableSystemPackageLPw(packageName);
                                        settingsDirty = true;
                                        File file2 = scanFile;
                                        odmAppDir4 = oemAppDir3;
                                        String str2 = packageName;
                                        possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps4;
                                        privilegedOdmAppDir3 = odmAppDir5;
                                        privilegedProductAppDir2 = privilegedProductAppDir;
                                        scanFlags4 = scanFlags3;
                                        scanPackageTracedLI(scanFile, reparseFlags, rescanFlags4, 0, (UserHandle) null);
                                    }
                                } else {
                                    vendorAppDir5 = vendorAppDir7;
                                    possiblyDeletedUpdatedSystemApps4 = possiblyDeletedUpdatedSystemApps2;
                                    odmAppDir6 = oemAppDir;
                                    oemAppDir4 = oemAppDir2;
                                }
                                reparseFlags2 = this.mDefParseFlags | 16;
                                rescanFlags2 = scanFlags3 | 131072 | 1048576;
                                reparseFlags = reparseFlags2;
                                rescanFlags = rescanFlags2;
                                vendorAppDir3 = vendorAppDir4;
                                privilegedOdmAppDir4 = privilegedOdmAppDir5;
                                int rescanFlags42 = rescanFlags;
                                this.mSettings.enableSystemPackageLPw(packageName);
                                settingsDirty = true;
                                File file22 = scanFile;
                                odmAppDir4 = oemAppDir3;
                                String str22 = packageName;
                                possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps4;
                                privilegedOdmAppDir3 = odmAppDir5;
                                privilegedProductAppDir2 = privilegedProductAppDir;
                                scanFlags4 = scanFlags3;
                                scanPackageTracedLI(scanFile, reparseFlags, rescanFlags42, 0, (UserHandle) null);
                            }
                        } else {
                            possiblyDeletedUpdatedSystemApps5 = possiblyDeletedUpdatedSystemApps2;
                            vendorAppDir6 = vendorAppDir2;
                            privilegedOdmAppDir5 = odmAppDir;
                            odmAppDir7 = oemAppDir;
                            oemAppDir5 = oemAppDir2;
                        }
                        reparseFlags2 = this.mDefParseFlags | 16;
                        rescanFlags2 = scanFlags3 | 131072 | 1048576 | 262144;
                        reparseFlags = reparseFlags2;
                        rescanFlags = rescanFlags2;
                        vendorAppDir3 = vendorAppDir4;
                        privilegedOdmAppDir4 = privilegedOdmAppDir5;
                        int rescanFlags422 = rescanFlags;
                        this.mSettings.enableSystemPackageLPw(packageName);
                        settingsDirty = true;
                        File file222 = scanFile;
                        odmAppDir4 = oemAppDir3;
                        String str222 = packageName;
                        possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps4;
                        privilegedOdmAppDir3 = odmAppDir5;
                        privilegedProductAppDir2 = privilegedProductAppDir;
                        scanFlags4 = scanFlags3;
                        scanPackageTracedLI(scanFile, reparseFlags, rescanFlags422, 0, (UserHandle) null);
                    }
                    rescanFlags = rescanFlags3;
                    possiblyDeletedUpdatedSystemApps4 = possiblyDeletedUpdatedSystemApps2;
                    vendorAppDir4 = vendorAppDir2;
                    privilegedOdmAppDir5 = odmAppDir;
                    odmAppDir5 = oemAppDir;
                    oemAppDir3 = oemAppDir2;
                    reparseFlags = reparseFlags4;
                    vendorAppDir3 = vendorAppDir4;
                    privilegedOdmAppDir4 = privilegedOdmAppDir5;
                    int rescanFlags4222 = rescanFlags;
                    this.mSettings.enableSystemPackageLPw(packageName);
                    settingsDirty = true;
                    File file2222 = scanFile;
                    odmAppDir4 = oemAppDir3;
                    String str2222 = packageName;
                    possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps4;
                    privilegedOdmAppDir3 = odmAppDir5;
                    privilegedProductAppDir2 = privilegedProductAppDir;
                    scanFlags4 = scanFlags3;
                    scanPackageTracedLI(scanFile, reparseFlags, rescanFlags4222, 0, (UserHandle) null);
                } else {
                    privilegedProductAppDir2 = privilegedProductAppDir;
                    vendorAppDir3 = vendorAppDir2;
                    privilegedOdmAppDir4 = odmAppDir;
                    privilegedOdmAppDir3 = oemAppDir;
                    odmAppDir4 = oemAppDir2;
                    possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps2;
                    scanFlags4 = scanFlags3;
                }
                i4 = i5 + 1;
                scanFlags3 = scanFlags4;
                vendorAppDir2 = vendorAppDir3;
                possiblyDeletedUpdatedSystemApps2 = possiblyDeletedUpdatedSystemApps3;
                privilegedProductAppDir = privilegedProductAppDir2;
                oemAppDir2 = odmAppDir4;
                oemAppDir = privilegedOdmAppDir3;
                odmAppDir = privilegedOdmAppDir4;
            }
            File file3 = vendorAppDir2;
            File file4 = odmAppDir;
            File privilegedOdmAppDir6 = oemAppDir;
            File odmAppDir9 = oemAppDir2;
            List<String> list2 = possiblyDeletedUpdatedSystemApps2;
            int scanFlags5 = scanFlags3;
            ArrayList arrayList6 = arrayList5;
            decompressSystemApplications(arrayList6, scanFlags5);
            int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
            long dataScanTime = (SystemClock.uptimeMillis() - systemScanTime2) - startTime;
            int dataPackagesCount = this.mPackages.size() - systemPackagesCount3;
            StringBuilder sb3 = new StringBuilder();
            sb3.append("Finished scanning non-system apps. Time: ");
            sb3.append(dataScanTime);
            sb3.append(" ms, packageCount: ");
            sb3.append(dataPackagesCount);
            sb3.append(" , timePerPackage: ");
            if (dataPackagesCount == 0) {
                ArrayList arrayList7 = arrayList6;
                j2 = 0;
            } else {
                ArrayList arrayList8 = arrayList6;
                j2 = dataScanTime / ((long) dataPackagesCount);
            }
            sb3.append(j2);
            sb3.append(" , cached: ");
            sb3.append(cachedNonSystemApps);
            Slog.i(TAG, sb3.toString());
            if (this.mIsUpgrade && dataPackagesCount > 0) {
                MetricsLogger.histogram(null, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime) / dataPackagesCount);
            }
        } else {
            int i6 = systemPackagesCount;
            File file5 = frameworkDir;
            File file6 = vendorAppDir2;
            File file7 = odmAppDir;
            File privilegedOdmAppDir7 = oemAppDir;
            File odmAppDir10 = oemAppDir2;
            ArrayList arrayList9 = arrayList4;
            File file8 = privilegedProductAppDir6;
            File file9 = productAppDir4;
            List<String> list3 = possiblyDeletedUpdatedSystemApps;
            int i7 = scanFlags3;
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
            if (DEBUG_FILTERS && this.mSetupWizardPackage == null) {
                Slog.i(TAG, "No setup wizard; All protected intents capped to priority 0");
            }
            for (PackageParser.ActivityIntentInfo filter : this.mProtectedFilters) {
                if (!filter.activity.info.packageName.equals(this.mSetupWizardPackage)) {
                    if (DEBUG_FILTERS) {
                        Slog.i(TAG, "Protected action; cap priority to 0; package: " + filter.activity.info.packageName + " activity: " + filter.activity.className + " origPrio: " + filter.getPriority());
                    }
                    filter.setPriority(0);
                } else if (DEBUG_FILTERS) {
                    Slog.i(TAG, "Found setup wizard; allow priority " + filter.getPriority() + "; package: " + filter.activity.info.packageName + " activity: " + filter.activity.className + " priority: " + filter.getPriority());
                }
            }
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
            List<String> changedAbiCodePath = adjustCpuAbisForSharedUserLPw(setting.packages, null);
            if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                i2 = changedAbiCodePath.size() - 1;
                while (true) {
                    i3 = i2;
                    if (i3 >= 0) {
                        try {
                            this.mInstaller.rmdex(changedAbiCodePath.get(i3), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                        } catch (Installer.InstallerException e3) {
                        }
                        i2 = i3 - 1;
                    }
                }
                setting.fixSeInfoLocked();
            }
            setting.fixSeInfoLocked();
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver;
        sdkUpdated = ver2.sdkVersion != this.mSdkVersion;
        if (sdkUpdated) {
            this.tSdkVersion = ver2.sdkVersion;
            Slog.i(TAG, "Platform changed from " + ver2.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for internal storage");
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
            ver2.sdkVersion = this.mSdkVersion;
        }
        if (z && (this.mPromoteSystemApps || this.mFirstBoot)) {
            for (UserInfo user : sUserManager.getUsers(true)) {
                this.mSettings.applyDefaultPreferredAppsLPw(this, user.id);
                applyFactoryDefaultBrowserLPw(user.id);
                primeDomainVerificationsLPw(user.id);
            }
        } else if (!z && this.mIsUpgrade) {
            for (UserInfo user2 : sUserManager.getUsers(true)) {
                primeDomainVerificationsLPw(user2.id, 1);
            }
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
            storageFlags = 1;
        } else {
            storageFlags = 3;
        }
        int storageFlags2 = storageFlags;
        List<String> deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags2, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages, storageFlags2) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade && !z) {
            Slog.i(TAG, "Build fingerprint changed; clearing code caches");
            for (int i8 = 0; i8 < this.mSettings.mPackages.size(); i8++) {
                PackageSetting ps2 = this.mSettings.mPackages.valueAt(i8);
                if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps2.volumeUuid)) {
                    clearAppDataLIF(ps2.pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                }
            }
            ver2.fingerprint = Build.FINGERPRINT;
            ver2.hwFingerprint = Build.HWFINGERPRINT;
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!settingsDirty && !this.mIsUpgrade) {
            if (!this.mFirstBoot) {
                if (!this.mHandler.hasMessages(13)) {
                    this.mHandler.sendEmptyMessageDelayed(13, 5000);
                }
                Settings.VersionInfo versionInfo = ver2;
                mHwPMSEx.writeCertCompatPackages(true);
                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
                Jlog.d(32, "JL_BOOT_PROGRESS_PMS_READY");
                if (this.mOnlyCore) {
                    this.mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();
                    this.mRequiredInstallerPackage = getRequiredInstallerLPr();
                    this.mRequiredUninstallerPackage = getRequiredUninstallerLPr();
                    this.mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();
                    if (this.mIntentFilterVerifierComponent != null) {
                        this.mIntentFilterVerifier = new IntentVerifierProxy(this.mContext, this.mIntentFilterVerifierComponent);
                    } else {
                        this.mIntentFilterVerifier = null;
                    }
                    this.mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.services", -1);
                    this.mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.shared", -1);
                    obj2 = null;
                } else {
                    obj2 = null;
                    this.mRequiredVerifierPackage = null;
                    this.mRequiredInstallerPackage = null;
                    this.mRequiredUninstallerPackage = null;
                    this.mIntentFilterVerifierComponent = null;
                    this.mIntentFilterVerifier = null;
                    this.mServicesSystemSharedLibraryPackageName = null;
                    this.mSharedSystemSharedLibraryPackageName = null;
                }
                Object obj3 = obj2;
                this.mInstallerService = new PackageInstallerService(context, this);
                instantAppResolverComponent = getInstantAppResolverLPr();
                if (instantAppResolverComponent == null) {
                    if (DEBUG_INSTANT) {
                        Slog.d(TAG, "Set ephemeral resolver: " + instantAppResolverComponent);
                    }
                    this.mInstantAppResolverConnection = new InstantAppResolverConnection(this.mContext, (ComponentName) instantAppResolverComponent.first, (String) instantAppResolverComponent.second);
                    this.mInstantAppResolverSettingsComponent = getInstantAppResolverSettingsLPr((ComponentName) instantAppResolverComponent.first);
                    str = null;
                } else {
                    str = null;
                    this.mInstantAppResolverConnection = null;
                    this.mInstantAppResolverSettingsComponent = null;
                }
                updateInstantAppInstallerLocked(str);
                Map<Integer, List<PackageInfo>> userPackages = new HashMap<>();
                int[] currentUserIds = UserManagerService.getInstance().getUserIds();
                Slog.i(TAG, "begin getInstalledPackages");
                length = currentUserIds.length;
                i = 0;
                while (i < length) {
                    boolean sdkUpdated2 = sdkUpdated;
                    int userId = currentUserIds[i];
                    userPackages.put(Integer.valueOf(userId), getInstalledPackages(0, userId).getList());
                    i++;
                    sdkUpdated = sdkUpdated2;
                    deferPackages = deferPackages;
                    instantAppResolverComponent = instantAppResolverComponent;
                    Context context3 = context;
                }
                List<String> list4 = deferPackages;
                Pair<ComponentName, String> pair = instantAppResolverComponent;
                Slog.i(TAG, "end getInstalledPackages");
                this.mDexManager.load(userPackages);
                if (this.mIsUpgrade) {
                    MetricsLogger.histogram(null, "ota_package_manager_init_time", (int) (SystemClock.uptimeMillis() - startTime));
                }
                this.mInstaller.setWarnIfHeld(this.mPackages);
                Trace.traceEnd(262144);
                return;
            }
        }
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        Trace.traceBegin(262144, "write settings");
        this.mSettings.writeLPr();
        Trace.traceEnd(262144);
        if (HWFLOW) {
            StringBuilder sb4 = new StringBuilder();
            sb4.append("TimerCounter = ");
            int i9 = this.mTimerCounter + 1;
            this.mTimerCounter = i9;
            sb4.append(i9);
            sb4.append(" **** mSettings.writeLPr  ************ Time to elapsed: ");
            Settings.VersionInfo versionInfo2 = ver2;
            sb4.append(SystemClock.uptimeMillis() - this.mStartTimer);
            sb4.append(" ms");
            Slog.i(TAG, sb4.toString());
        }
        mHwPMSEx.writeCertCompatPackages(true);
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
        Jlog.d(32, "JL_BOOT_PROGRESS_PMS_READY");
        if (this.mOnlyCore) {
        }
        Object obj32 = obj2;
        this.mInstallerService = new PackageInstallerService(context, this);
        instantAppResolverComponent = getInstantAppResolverLPr();
        if (instantAppResolverComponent == null) {
        }
        updateInstantAppInstallerLocked(str);
        Map<Integer, List<PackageInfo>> userPackages2 = new HashMap<>();
        int[] currentUserIds2 = UserManagerService.getInstance().getUserIds();
        Slog.i(TAG, "begin getInstalledPackages");
        length = currentUserIds2.length;
        i = 0;
        while (i < length) {
        }
        List<String> list42 = deferPackages;
        Pair<ComponentName, String> pair2 = instantAppResolverComponent;
        Slog.i(TAG, "end getInstalledPackages");
        this.mDexManager.load(userPackages2);
        if (this.mIsUpgrade) {
        }
        this.mInstaller.setWarnIfHeld(this.mPackages);
        Trace.traceEnd(262144);
        return;
        File vendorAppDir8 = vendorAppDir;
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        mHwPMSEx.scanNonSystemPartitionDir(scanFlags3);
        if (HWFLOW) {
            StringBuilder sb5 = new StringBuilder();
            sb5.append("TimerCounter = ");
            int i10 = this.mTimerCounter + 1;
            this.mTimerCounter = i10;
            sb5.append(i10);
            sb5.append(" **** scanNonSystemPartitionDir  ************ Time to elapsed: ");
            vendorAppDir = vendorAppDir8;
            sb5.append(SystemClock.uptimeMillis() - this.mStartTimer);
            sb5.append(" ms");
            Slog.i(TAG, sb5.toString());
        } else {
            vendorAppDir = vendorAppDir8;
        }
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        mHwPMSEx.scanRemovableAppDir(scanFlags3);
        if (HWFLOW) {
            StringBuilder sb6 = new StringBuilder();
            sb6.append("TimerCounter = ");
            int i11 = this.mTimerCounter + 1;
            this.mTimerCounter = i11;
            sb6.append(i11);
            sb6.append(" **** scanRemovableAppDir  ************ Time to elapsed: ");
            sb6.append(SystemClock.uptimeMillis() - this.mStartTimer);
            sb6.append(" ms");
            Slog.i(TAG, sb6.toString());
        }
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        try {
            privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        } catch (IOException e4) {
            privilegedOdmAppDir2 = privilegedOdmAppDir;
        }
        try {
            odmAppDir = privilegedOdmAppDir2;
            vendorAppDir2 = vendorAppDir;
            scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576 | 262144, 0);
            odmAppDir2 = new File(Environment.getOdmDirectory(), "app");
            try {
                odmAppDir3 = odmAppDir2.getCanonicalFile();
            } catch (IOException e5) {
                odmAppDir3 = odmAppDir2;
            }
            oemAppDir = odmAppDir3;
            scanDirTracedLI(odmAppDir3, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576, 0);
            File oemAppDir62 = new File(Environment.getOemDirectory(), "app");
            oemAppDir2 = oemAppDir62;
            scanDirTracedLI(oemAppDir62, this.mDefParseFlags | 16, scanFlags3 | 131072 | 524288, 0);
            File privilegedProductAppDir42 = new File(Environment.getProductDirectory(), "priv-app");
            privilegedProductAppDir42 = privilegedProductAppDir42.getCanonicalFile();
            File privilegedProductAppDir52 = privilegedProductAppDir42;
            File productAppDir22 = new File(Environment.getProductDirectory(), "app");
            productAppDir22 = productAppDir22.getCanonicalFile();
            File productAppDir32 = productAppDir22;
            List<String> arrayList22 = new ArrayList<>();
            ArrayList arrayList32 = new ArrayList();
            if (!this.mOnlyCore) {
            }
            ArrayList arrayList42 = arrayList32;
            File privilegedProductAppDir62 = privilegedProductAppDir52;
            File productAppDir42 = productAppDir32;
            deleteTempPackageFiles();
            int cachedSystemApps2 = PackageParser.sCachedPackageReadCount.get();
            this.mSettings.pruneSharedUsersLPw();
            long systemScanTime3 = SystemClock.uptimeMillis() - startTime;
            systemPackagesCount = this.mPackages.size();
            StringBuilder sb22 = new StringBuilder();
            sb22.append("Finished scanning system apps. Time: ");
            sb22.append(systemScanTime3);
            sb22.append(" ms, packageCount: ");
            sb22.append(systemPackagesCount);
            sb22.append(" , timePerPackage: ");
            if (systemPackagesCount == 0) {
            }
            sb22.append(j);
            sb22.append(" , cached: ");
            sb22.append(cachedSystemApps2);
            Slog.i(TAG, sb22.toString());
            if (!this.mIsUpgrade) {
            }
            if (!this.mOnlyCore) {
            }
            this.mExpectingBetter.clear();
            this.mStorageManagerPackage = getStorageManagerPackageName();
            this.mSetupWizardPackage = getSetupWizardPackageName();
            if (this.mProtectedFilters.size() > 0) {
            }
            this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
            this.mDeferProtectedFilters = false;
            this.mProtectedFilters.clear();
            updateAllSharedLibrariesLPw(null);
            while (r1.hasNext()) {
            }
            this.mPackageUsage.read(this.mPackages);
            this.mCompilerStats.read();
            EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
            Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
            ver2 = ver;
            if (ver2.sdkVersion != this.mSdkVersion) {
            }
            if (sdkUpdated) {
            }
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            if (ver2 != null) {
            }
            if (z) {
            }
            while (r1.hasNext()) {
            }
            if (StorageManager.isFileEncryptedNativeOrEmulated()) {
            }
            int storageFlags22 = storageFlags;
            List<String> deferPackages2 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags22, true, true);
            this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages2, storageFlags22) {
                private final /* synthetic */ List f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
                }
            }, "prepareAppData");
            if (!this.mIsUpgrade) {
            }
            checkAndEnableWebview();
            checkDefaultBrowser();
            this.mExistingSystemPackages.clear();
            this.mPromoteSystemApps = false;
            ver2.databaseVersion = 3;
            if (!this.mFirstBoot) {
            }
        } catch (PackageManagerException e6) {
            PackageManagerException packageManagerException = e6;
            Slog.e(TAG, "Failed to parse original system package: " + e6.getMessage());
        } catch (Throwable th4) {
            th = th4;
            throw th;
        }
        ArrayList<File> fileList2 = fileList;
        if (fileList2 != null) {
            Iterator<File> it = fileList2.iterator();
            while (it.hasNext()) {
                scanDirTracedLI(it.next(), this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                scanFlags = scanFlags;
                fileList2 = fileList2;
            }
            scanFlags2 = scanFlags;
            ArrayList<File> arrayList10 = fileList2;
        } else {
            scanFlags2 = scanFlags;
            ArrayList<File> arrayList11 = fileList2;
            scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags2 | 131072 | 1048576, 0);
            scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags2 | 131072 | 2097152, 0);
        }
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        mHwPMSEx.getUninstallApk();
        if (HWFLOW) {
            StringBuilder sb7 = new StringBuilder();
            sb7.append("TimerCounter = ");
            int i12 = this.mTimerCounter + 1;
            this.mTimerCounter = i12;
            sb7.append(i12);
            sb7.append(" **** getUninstallApk  ************ Time to elapsed: ");
            sb7.append(SystemClock.uptimeMillis() - this.mStartTimer);
            sb7.append(" ms");
            Slog.i(TAG, sb7.toString());
        }
        this.mParallelPackageParserCallback.findStaticOverlayPackages();
        Settings.VersionInfo ver3 = ver;
        int scanFlags6 = scanFlags2;
        z = onlyCore;
        scanDirTracedLI(frameworkDir, this.mDefParseFlags | 16, scanFlags2 | 1 | 131072 | 262144, 0);
        Slog.i(TAG, "begin scan priv-app");
        privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
        scanFlags3 = scanFlags6;
        Settings.VersionInfo ver4 = ver3;
        scanDirTracedLI(privilegedAppDir, this.mDefParseFlags | 16, scanFlags6 | 131072 | 262144, 0);
        Slog.i(TAG, "end scan priv-app");
        Slog.i(TAG, "begin scan app");
        systemAppDir = new File(Environment.getRootDirectory(), "app");
        scanDirTracedLI(systemAppDir, this.mDefParseFlags | 16, scanFlags3 | 131072, 0);
        Slog.i(TAG, "end scan app");
        File privilegedVendorAppDir2 = new File(Environment.getVendorDirectory(), "priv-app");
        try {
            privilegedVendorAppDir2 = privilegedVendorAppDir2.getCanonicalFile();
        } catch (IOException e7) {
        }
        privilegedVendorAppDir = privilegedVendorAppDir2;
        File vendorAppDir9 = new File(Environment.getVendorDirectory(), "app");
        try {
            vendorAppDir9 = vendorAppDir9.getCanonicalFile();
        } catch (IOException e8) {
        }
        File vendorAppDir82 = vendorAppDir9;
        if (HWFLOW) {
        }
        mHwPMSEx.scanNonSystemPartitionDir(scanFlags3);
        if (HWFLOW) {
        }
        if (HWFLOW) {
        }
        mHwPMSEx.scanRemovableAppDir(scanFlags3);
        if (HWFLOW) {
        }
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        odmAppDir = privilegedOdmAppDir2;
        vendorAppDir2 = vendorAppDir;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576 | 262144, 0);
        odmAppDir2 = new File(Environment.getOdmDirectory(), "app");
        odmAppDir3 = odmAppDir2.getCanonicalFile();
        oemAppDir = odmAppDir3;
        scanDirTracedLI(odmAppDir3, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576, 0);
        File oemAppDir622 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir622;
        scanDirTracedLI(oemAppDir622, this.mDefParseFlags | 16, scanFlags3 | 131072 | 524288, 0);
        File privilegedProductAppDir422 = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir422 = privilegedProductAppDir422.getCanonicalFile();
        File privilegedProductAppDir522 = privilegedProductAppDir422;
        File productAppDir222 = new File(Environment.getProductDirectory(), "app");
        productAppDir222 = productAppDir222.getCanonicalFile();
        File productAppDir322 = productAppDir222;
        List<String> arrayList222 = new ArrayList<>();
        ArrayList arrayList322 = new ArrayList();
        if (!this.mOnlyCore) {
        }
        ArrayList arrayList422 = arrayList322;
        File privilegedProductAppDir622 = privilegedProductAppDir522;
        File productAppDir422 = productAppDir322;
        deleteTempPackageFiles();
        int cachedSystemApps22 = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime32 = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb222 = new StringBuilder();
        sb222.append("Finished scanning system apps. Time: ");
        sb222.append(systemScanTime32);
        sb222.append(" ms, packageCount: ");
        sb222.append(systemPackagesCount);
        sb222.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        sb222.append(j);
        sb222.append(" , cached: ");
        sb222.append(cachedSystemApps22);
        Slog.i(TAG, sb222.toString());
        if (!this.mIsUpgrade) {
        }
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver4;
        if (ver2.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        int storageFlags222 = storageFlags;
        List<String> deferPackages22 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags222, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages22, storageFlags222) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        odmAppDir = privilegedOdmAppDir2;
        vendorAppDir2 = vendorAppDir;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576 | 262144, 0);
        odmAppDir2 = new File(Environment.getOdmDirectory(), "app");
        odmAppDir3 = odmAppDir2.getCanonicalFile();
        oemAppDir = odmAppDir3;
        scanDirTracedLI(odmAppDir3, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576, 0);
        File oemAppDir6222 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir6222;
        scanDirTracedLI(oemAppDir6222, this.mDefParseFlags | 16, scanFlags3 | 131072 | 524288, 0);
        File privilegedProductAppDir4222 = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir4222 = privilegedProductAppDir4222.getCanonicalFile();
        File privilegedProductAppDir5222 = privilegedProductAppDir4222;
        File productAppDir2222 = new File(Environment.getProductDirectory(), "app");
        productAppDir2222 = productAppDir2222.getCanonicalFile();
        File productAppDir3222 = productAppDir2222;
        List<String> arrayList2222 = new ArrayList<>();
        ArrayList arrayList3222 = new ArrayList();
        if (!this.mOnlyCore) {
        }
        ArrayList arrayList4222 = arrayList3222;
        File privilegedProductAppDir6222 = privilegedProductAppDir5222;
        File productAppDir4222 = productAppDir3222;
        deleteTempPackageFiles();
        int cachedSystemApps222 = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime322 = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb2222 = new StringBuilder();
        sb2222.append("Finished scanning system apps. Time: ");
        sb2222.append(systemScanTime322);
        sb2222.append(" ms, packageCount: ");
        sb2222.append(systemPackagesCount);
        sb2222.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        sb2222.append(j);
        sb2222.append(" , cached: ");
        sb2222.append(cachedSystemApps222);
        Slog.i(TAG, sb2222.toString());
        if (!this.mIsUpgrade) {
        }
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver4;
        if (ver2.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        int storageFlags2222 = storageFlags;
        List<String> deferPackages222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags2222, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages222, storageFlags2222) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        File privilegedProductAppDir52222 = privilegedProductAppDir4222;
        File productAppDir22222 = new File(Environment.getProductDirectory(), "app");
        productAppDir22222 = productAppDir22222.getCanonicalFile();
        File productAppDir32222 = productAppDir22222;
        List<String> arrayList22222 = new ArrayList<>();
        ArrayList arrayList32222 = new ArrayList();
        if (!this.mOnlyCore) {
        }
        ArrayList arrayList42222 = arrayList32222;
        File privilegedProductAppDir62222 = privilegedProductAppDir52222;
        File productAppDir42222 = productAppDir32222;
        deleteTempPackageFiles();
        int cachedSystemApps2222 = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime3222 = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb22222 = new StringBuilder();
        sb22222.append("Finished scanning system apps. Time: ");
        sb22222.append(systemScanTime3222);
        sb22222.append(" ms, packageCount: ");
        sb22222.append(systemPackagesCount);
        sb22222.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        sb22222.append(j);
        sb22222.append(" , cached: ");
        sb22222.append(cachedSystemApps2222);
        Slog.i(TAG, sb22222.toString());
        if (!this.mIsUpgrade) {
        }
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver4;
        if (ver2.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        int storageFlags22222 = storageFlags;
        List<String> deferPackages2222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags22222, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages2222, storageFlags22222) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        privilegedVendorAppDir = privilegedVendorAppDir2;
        File vendorAppDir92 = new File(Environment.getVendorDirectory(), "app");
        vendorAppDir92 = vendorAppDir92.getCanonicalFile();
        File vendorAppDir822 = vendorAppDir92;
        if (HWFLOW) {
        }
        mHwPMSEx.scanNonSystemPartitionDir(scanFlags3);
        if (HWFLOW) {
        }
        if (HWFLOW) {
        }
        mHwPMSEx.scanRemovableAppDir(scanFlags3);
        if (HWFLOW) {
        }
        privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
        privilegedOdmAppDir2 = privilegedOdmAppDir.getCanonicalFile();
        odmAppDir = privilegedOdmAppDir2;
        vendorAppDir2 = vendorAppDir;
        scanDirTracedLI(privilegedOdmAppDir2, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576 | 262144, 0);
        odmAppDir2 = new File(Environment.getOdmDirectory(), "app");
        odmAppDir3 = odmAppDir2.getCanonicalFile();
        oemAppDir = odmAppDir3;
        scanDirTracedLI(odmAppDir3, this.mDefParseFlags | 16, scanFlags3 | 131072 | 1048576, 0);
        File oemAppDir62222 = new File(Environment.getOemDirectory(), "app");
        oemAppDir2 = oemAppDir62222;
        scanDirTracedLI(oemAppDir62222, this.mDefParseFlags | 16, scanFlags3 | 131072 | 524288, 0);
        File privilegedProductAppDir42222 = new File(Environment.getProductDirectory(), "priv-app");
        privilegedProductAppDir42222 = privilegedProductAppDir42222.getCanonicalFile();
        File privilegedProductAppDir522222 = privilegedProductAppDir42222;
        File productAppDir222222 = new File(Environment.getProductDirectory(), "app");
        productAppDir222222 = productAppDir222222.getCanonicalFile();
        File productAppDir322222 = productAppDir222222;
        List<String> arrayList222222 = new ArrayList<>();
        ArrayList arrayList322222 = new ArrayList();
        if (!this.mOnlyCore) {
        }
        ArrayList arrayList422222 = arrayList322222;
        File privilegedProductAppDir622222 = privilegedProductAppDir522222;
        File productAppDir422222 = productAppDir322222;
        deleteTempPackageFiles();
        int cachedSystemApps22222 = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime32222 = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb222222 = new StringBuilder();
        sb222222.append("Finished scanning system apps. Time: ");
        sb222222.append(systemScanTime32222);
        sb222222.append(" ms, packageCount: ");
        sb222222.append(systemPackagesCount);
        sb222222.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        sb222222.append(j);
        sb222222.append(" , cached: ");
        sb222222.append(cachedSystemApps22222);
        Slog.i(TAG, sb222222.toString());
        if (!this.mIsUpgrade) {
        }
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver4;
        if (ver2.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        int storageFlags222222 = storageFlags;
        List<String> deferPackages22222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags222222, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages22222, storageFlags222222) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
        File productAppDir3222222 = productAppDir222222;
        List<String> arrayList2222222 = new ArrayList<>();
        ArrayList arrayList3222222 = new ArrayList();
        if (!this.mOnlyCore) {
        }
        ArrayList arrayList4222222 = arrayList3222222;
        File privilegedProductAppDir6222222 = privilegedProductAppDir522222;
        File productAppDir4222222 = productAppDir3222222;
        deleteTempPackageFiles();
        int cachedSystemApps222222 = PackageParser.sCachedPackageReadCount.get();
        this.mSettings.pruneSharedUsersLPw();
        long systemScanTime322222 = SystemClock.uptimeMillis() - startTime;
        systemPackagesCount = this.mPackages.size();
        StringBuilder sb2222222 = new StringBuilder();
        sb2222222.append("Finished scanning system apps. Time: ");
        sb2222222.append(systemScanTime322222);
        sb2222222.append(" ms, packageCount: ");
        sb2222222.append(systemPackagesCount);
        sb2222222.append(" , timePerPackage: ");
        if (systemPackagesCount == 0) {
        }
        sb2222222.append(j);
        sb2222222.append(" , cached: ");
        sb2222222.append(cachedSystemApps222222);
        Slog.i(TAG, sb2222222.toString());
        if (!this.mIsUpgrade) {
        }
        if (!this.mOnlyCore) {
        }
        this.mExpectingBetter.clear();
        this.mStorageManagerPackage = getStorageManagerPackageName();
        this.mSetupWizardPackage = getSetupWizardPackageName();
        if (this.mProtectedFilters.size() > 0) {
        }
        this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
        this.mDeferProtectedFilters = false;
        this.mProtectedFilters.clear();
        updateAllSharedLibrariesLPw(null);
        while (r1.hasNext()) {
        }
        this.mPackageUsage.read(this.mPackages);
        this.mCompilerStats.read();
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
        Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
        ver2 = ver4;
        if (ver2.sdkVersion != this.mSdkVersion) {
        }
        if (sdkUpdated) {
        }
        this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
        if (ver2 != null) {
        }
        if (z) {
        }
        while (r1.hasNext()) {
        }
        if (StorageManager.isFileEncryptedNativeOrEmulated()) {
        }
        int storageFlags2222222 = storageFlags;
        List<String> deferPackages222222 = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags2222222, true, true);
        this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages222222, storageFlags2222222) {
            private final /* synthetic */ List f$1;
            private final /* synthetic */ int f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            public final void run() {
                PackageManagerService.lambda$new$0(PackageManagerService.this, this.f$1, this.f$2);
            }
        }, "prepareAppData");
        if (!this.mIsUpgrade) {
        }
        checkAndEnableWebview();
        checkDefaultBrowser();
        this.mExistingSystemPackages.clear();
        this.mPromoteSystemApps = false;
        ver2.databaseVersion = 3;
        if (!this.mFirstBoot) {
        }
    }

    public static /* synthetic */ void lambda$new$0(PackageManagerService packageManagerService, List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            packageManagerService.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages != null && !deferPackages.isEmpty()) {
            int count = 0;
            Iterator it = deferPackages.iterator();
            while (it.hasNext()) {
                String pkgName = (String) it.next();
                PackageParser.Package pkg = null;
                synchronized (packageManagerService.mPackages) {
                    PackageSetting ps = packageManagerService.mSettings.getPackageLPr(pkgName);
                    if (ps != null && ps.getInstalled(0)) {
                        pkg = ps.pkg;
                    }
                }
                if (pkg != null) {
                    synchronized (packageManagerService.mInstallLock) {
                        packageManagerService.prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                    }
                    count++;
                }
            }
            traceLog.traceEnd();
            Slog.i(TAG, "Deferred reconcileAppsData finished " + count + " packages");
        }
    }

    private void checkAndEnableWebview() {
        if (this.mIsUpgrade) {
            boolean isChina = "CN".equalsIgnoreCase(SystemProperties.get("ro.product.locale.region", BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
            try {
                int state = getApplicationEnabledSetting("com.google.android.webview", this.mContext.getUserId());
                boolean z = true;
                if (state != 1) {
                    z = false;
                }
                boolean isEnabled = z;
                Slog.i(TAG, "WebViewGoogle state=" + state + " version is china = " + isChina);
                if (!isEnabled && isChina) {
                    Slog.i(TAG, "current WebViewGoogle disable, enable it");
                    setApplicationEnabledSetting("com.google.android.webview", 1, 0, this.mContext.getUserId(), this.mContext.getOpPackageName());
                }
            } catch (Exception e) {
                Slog.w(TAG, "enable WebViewGoogle exception " + e.getMessage());
            }
        }
    }

    private void decompressSystemApplications(List<String> stubSystemApps, int scanFlags) {
        List<String> list = stubSystemApps;
        int i = stubSystemApps.size() - 1;
        while (true) {
            int i2 = i;
            if (i2 < 0) {
                break;
            }
            String pkgName = list.get(i2);
            if (this.mSettings.isDisabledSystemPackageLPr(pkgName)) {
                list.remove(i2);
            } else {
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg == null) {
                    list.remove(i2);
                } else {
                    PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        if (DEBUG_COMPRESSION != 0) {
                            Slog.i(TAG, "Uncompressing system stub; pkg: " + pkgName);
                        }
                        File scanFile = decompressPackage(pkg);
                        if (scanFile != null) {
                            try {
                                this.mSettings.disableSystemPackageLPw(pkgName, true);
                                removePackageLI(pkg, true);
                                scanPackageTracedLI(scanFile, 0, scanFlags, 0, (UserHandle) null);
                                ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                                list.remove(i2);
                            } catch (PackageManagerException e) {
                                Slog.e(TAG, "Failed to parse uncompressed system package: " + e.getMessage());
                            }
                        }
                    } else {
                        list.remove(i2);
                    }
                }
            }
            i = i2 - 1;
        }
        for (int i3 = stubSystemApps.size() - 1; i3 >= 0; i3 += -1) {
            this.mSettings.mPackages.get(list.get(i3)).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            PackageManagerServiceUtils.logCriticalInfo(6, "Stub disabled; pkg: " + pkgName);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x009e  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d7  */
    /* JADX WARNING: Removed duplicated region for block: B:38:0x00e5 A[RETURN] */
    private File decompressPackage(PackageParser.Package pkg) {
        int ret;
        int ret2;
        ErrnoException e;
        File[] compressedFiles = PackageManagerServiceUtils.getCompressedFiles(pkg.codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                Slog.i(TAG, "No files to decompress: " + pkg.baseCodePath);
            }
            return null;
        }
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), pkg.packageName);
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            int length = compressedFiles.length;
            ret = 1;
            int ret3 = 0;
            while (true) {
                if (ret3 >= length) {
                    break;
                }
                try {
                    File srcFile = compressedFiles[ret3];
                    String srcFileName = srcFile.getName();
                    ret = PackageManagerServiceUtils.decompressFile(srcFile, new File(dstCodePath, srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length())));
                    if (ret != 1) {
                        PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + pkg.packageName + ", file: " + dstFileName);
                        break;
                    }
                    ret3++;
                } catch (ErrnoException e2) {
                    e = e2;
                    PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + pkg.packageName + ", err: " + e.errno);
                    if (ret == 1) {
                    }
                    if (ret == 1) {
                    }
                }
            }
        } catch (ErrnoException e3) {
            ret = 1;
            e = e3;
            PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + pkg.packageName + ", err: " + e.errno);
            if (ret == 1) {
            }
            if (ret == 1) {
            }
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            AutoCloseable autoCloseable = null;
            try {
                autoCloseable = NativeLibraryHelper.Handle.create(dstCodePath);
                ret2 = NativeLibraryHelper.copyNativeBinariesWithOverride(autoCloseable, libraryRoot, null);
            } catch (IOException e4) {
                PackageManagerServiceUtils.logCriticalInfo(6, "Failed to extract native libraries; pkg: " + pkg.packageName);
                ret2 = RequestStatus.SYS_ETIMEDOUT;
            } catch (Throwable th) {
                IoUtils.closeQuietly(null);
                throw th;
            }
            IoUtils.closeQuietly(autoCloseable);
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (dstCodePath == null || !dstCodePath.exists()) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        if (this.mInstantAppInstallerActivity == null || this.mInstantAppInstallerActivity.getComponentName().getPackageName().equals(modifiedPackage)) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache(boolean isUpgrade) {
        Slog.i(TAG, "preparePackageParserCache, isUpgrade= " + isUpgrade);
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = FileUtils.createDir(Environment.getDataSystemDirectory(), "package_cache");
        if (cacheBaseDir == null) {
            return null;
        }
        if (isUpgrade) {
            FileUtils.deleteContents(cacheBaseDir);
        }
        File cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
        if (cacheDir == null) {
            Slog.wtf(TAG, "Cache directory cannot be created - wiping base dir " + cacheBaseDir);
            FileUtils.deleteContentsAndDir(cacheBaseDir);
            return null;
        }
        if (Build.IS_USERDEBUG && Build.VERSION.INCREMENTAL.startsWith("eng.")) {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir.lastModified() < new File(Environment.getRootDirectory(), "framework").lastModified()) {
                FileUtils.deleteContents(cacheBaseDir);
                cacheDir = FileUtils.createDir(cacheBaseDir, PACKAGE_PARSER_CACHE_VERSION);
            }
        }
        return cacheDir;
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isUpgrade() {
        return this.mIsUpgrade || SystemProperties.getBoolean("persist.pm.mock-upgrade", false);
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        throw new RuntimeException("There must be exactly one verifier; found " + matches);
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String str;
        synchronized (this.mPackages) {
            SharedLibraryEntry libraryEntry = getSharedLibraryEntryLPr(name, (long) version);
            if (libraryEntry != null) {
                str = libraryEntry.apk;
            } else {
                throw new IllegalStateException("Missing required shared library:" + name);
            }
        }
        return str;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one installer; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts("package", "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && (this.mResolveActivity.name == null || !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name))) {
            return resolveInfo.getComponentInfo().packageName;
        }
        throw new RuntimeException("There must be exactly one uninstaller; found " + resolveInfo);
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        int N = matches.size();
        ResolveInfo best = null;
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            ComponentName componentName = (ComponentName) instantAppResolver.first;
            return componentName;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        ResolveInfo info;
        String packageName;
        String[] packageArray = this.mContext.getResources().getStringArray(17236008);
        if (packageArray.length != 0 || Build.IS_DEBUGGABLE) {
            int callingUid = Binder.getCallingUid();
            int i = 0;
            List<ResolveInfo> resolvers = queryIntentServicesInternal(new Intent("android.intent.action.RESOLVE_INSTANT_APP_PACKAGE"), null, 786432 | (!Build.IS_DEBUGGABLE ? 1048576 : 0), 0, callingUid, false);
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            Set<String> possiblePackages = new ArraySet<>(Arrays.asList(packageArray));
            while (true) {
                int i2 = i;
                if (i2 < N) {
                    info = resolvers.get(i2);
                    if (info.serviceInfo != null) {
                        packageName = info.serviceInfo.packageName;
                        if (!possiblePackages.contains(packageName) && !Build.IS_DEBUGGABLE) {
                            if (DEBUG_INSTANT) {
                                Slog.d(TAG, "Ephemeral resolver not in allowed package list; pkg: " + packageName + ", info:" + info);
                            }
                        }
                    }
                    i = i2 + 1;
                } else {
                    if (DEBUG_INSTANT != 0) {
                        Slog.v(TAG, "Ephemeral resolver NOT found");
                    }
                    return null;
                }
            }
            if (DEBUG_INSTANT) {
                Slog.v(TAG, "Ephemeral resolver found; pkg: " + packageName + ", info:" + info);
            }
            return new Pair<>(new ComponentName(packageName, info.serviceInfo.name), "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE");
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    private ActivityInfo getInstantAppInstallerLPr() {
        String[] orderedActions;
        if (Build.IS_ENG) {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE_TEST", "android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        } else {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        }
        int resolveFlags = 786944 | (!Build.IS_ENG ? 1048576 : 0);
        Intent intent = new Intent();
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = null;
        for (String action : orderedActions) {
            intent.setAction(action);
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
            if (!matches.isEmpty()) {
                break;
            }
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Instant App installer not found with " + action);
            }
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            PackageSetting ps = this.mSettings.mPackages.get(iter.next().activityInfo.packageName);
            if (ps == null || (!ps.getPermissionsState().hasPermission("android.permission.INSTALL_PACKAGES", 0) && !Build.IS_ENG)) {
                iter.remove();
            }
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) matches.get(0).getComponentInfo();
        }
        throw new RuntimeException("There must be at most one ephemeral installer; found " + matches);
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName()), null, 786432, 0);
        if (matches.isEmpty()) {
            return null;
        }
        return matches.get(0).getComponentInfo().getComponentName();
    }

    private void primeDomainVerificationsLPw(int userId) {
        primeDomainVerificationsLPw(userId, 0);
    }

    private void primeDomainVerificationsLPw(int userId, int flag) {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Priming domain verifications in user " + userId);
        }
        Iterator<String> it = SystemConfig.getInstance().getLinkedApps().iterator();
        while (it.hasNext()) {
            String packageName = it.next();
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
            } else if (!pkg.isSystem()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
            } else {
                ArraySet<String> domains = null;
                Iterator it2 = pkg.activities.iterator();
                while (it2.hasNext()) {
                    Iterator it3 = ((PackageParser.Activity) it2.next()).intents.iterator();
                    while (it3.hasNext()) {
                        PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it3.next();
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet<>();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                if (domains == null || domains.size() <= 0) {
                    Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "      + " + packageName);
                    }
                    if (this.mIsUpgrade && flag == 1) {
                        PackageSetting ps = this.mSettings.mPackages.get(packageName);
                        if (ps != null && ps.getIntentFilterVerificationInfo() == null) {
                            ps.setIntentFilterVerificationInfo(new IntentFilterVerificationInfo(packageName, domains));
                            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                            Slog.w(TAG, "package " + packageName + " is a new application for hota upgrade, sysconfig app-link");
                        }
                    } else if (flag == 0) {
                        this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains).setStatus(0);
                        this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                    }
                }
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private void applyFactoryDefaultBrowserLPw(int userId) {
        String browserPkg = this.mContext.getResources().getString(17039920);
        if (!TextUtils.isEmpty(browserPkg)) {
            if (this.mSettings.mPackages.get(browserPkg) == null) {
                Slog.e(TAG, "Product default browser app does not exist: " + browserPkg);
                browserPkg = null;
            } else {
                this.mSettings.setDefaultBrowserPackageNameLPw(browserPkg, userId);
            }
        }
        if (browserPkg == null) {
            calculateDefaultBrowserLPw(userId);
        }
    }

    private void calculateDefaultBrowserLPw(int userId) {
        List<String> allBrowsers = resolveAllBrowserApps(userId);
        this.mSettings.setDefaultBrowserPackageNameLPw(allBrowsers.size() == 1 ? allBrowsers.get(0) : null, userId);
    }

    private List<String> resolveAllBrowserApps(int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int count = list.size();
        List<String> result = new ArrayList<>(count);
        for (int i = 0; i < count; i++) {
            ResolveInfo info = list.get(i);
            if (info.activityInfo != null && info.handleAllWebDataURI && (info.activityInfo.applicationInfo.flags & 1) != 0 && !result.contains(info.activityInfo.packageName)) {
                result.add(info.activityInfo.packageName);
            }
        }
        return result;
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo info = list.get(i);
            if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    private void checkDefaultBrowser() {
        int myUserId = UserHandle.myUserId();
        String packageName = getDefaultBrowserPackageName(myUserId);
        if (packageName != null && getPackageInfo(packageName, 0, myUserId) == null) {
            Slog.w(TAG, "Default browser no longer installed: " + packageName);
            synchronized (this.mPackages) {
                applyFactoryDefaultBrowserLPw(myUserId);
            }
        }
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!(e instanceof SecurityException) && !(e instanceof IllegalArgumentException)) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    static int[] appendInts(int[] cur, int[] add) {
        if (add == null) {
            return cur;
        }
        if (cur == null) {
            return add;
        }
        for (int appendInt : add) {
            cur = ArrayUtils.appendInt(cur, appendInt);
        }
        return cur;
    }

    /* access modifiers changed from: private */
    public boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") == 0) {
            ComponentName homeComponent = getDefaultHomeActivity(userId);
            if (homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid)) {
                return true;
            }
        }
        return false;
    }

    /* access modifiers changed from: private */
    public PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        PackageSetting packageSetting = ps;
        int i = flags;
        int i2 = userId;
        if (!sUserManager.exists(i2) || packageSetting == null) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(packageSetting, callingUid, i2)) {
            return null;
        }
        if ((i & 8192) != 0 && ps.isSystem()) {
            i |= DumpState.DUMP_CHANGES;
        }
        int flags2 = i;
        PackageUserState state = packageSetting.readUserState(i2);
        PackageParser.Package p = packageSetting.pkg;
        if (p != null) {
            PermissionsState permissionsState = ps.getPermissionsState();
            int i3 = callingUid;
            PermissionsState permissionsState2 = permissionsState;
            PackageParser.Package p2 = p;
            PackageUserState packageUserState = state;
            PackageInfo packageInfo = PackageParser.generatePackageInfo(p, (flags2 & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(i2), flags2, packageSetting.firstInstallTime, packageSetting.lastUpdateTime, (flags2 & 4096) == 0 || ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.emptySet() : permissionsState.getPermissions(i2), state, i2);
            if (packageInfo == null) {
                return null;
            }
            ApplicationInfo applicationInfo = packageInfo.applicationInfo;
            String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p2);
            applicationInfo.packageName = resolveExternalPackageNameLPr;
            packageInfo.packageName = resolveExternalPackageNameLPr;
            return packageInfo;
        }
        int i4 = callingUid;
        PackageUserState state2 = state;
        if ((flags2 & 8192) == 0 || !state2.isAvailable(flags2)) {
            return null;
        }
        PackageInfo pi = new PackageInfo();
        pi.packageName = packageSetting.name;
        pi.setLongVersionCode(packageSetting.versionCode);
        pi.sharedUserId = packageSetting.sharedUser != null ? packageSetting.sharedUser.name : null;
        pi.firstInstallTime = packageSetting.firstInstallTime;
        pi.lastUpdateTime = packageSetting.lastUpdateTime;
        ApplicationInfo ai = new ApplicationInfo();
        ai.packageName = packageSetting.name;
        ai.uid = UserHandle.getUid(i2, packageSetting.appId);
        ai.primaryCpuAbi = packageSetting.primaryCpuAbiString;
        ai.secondaryCpuAbi = packageSetting.secondaryCpuAbiString;
        ai.setVersionCode(packageSetting.versionCode);
        ai.flags = packageSetting.pkgFlags;
        ai.privateFlags = packageSetting.pkgPrivateFlags;
        pi.applicationInfo = PackageParser.generateApplicationInfo(ai, flags2, state2, i2);
        if (DEBUG_PACKAGE_INFO) {
            Log.v(TAG, "ps.pkg is n/a for [" + packageSetting.name + "]. Provides a minimum info.");
        }
        return pi;
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new SecurityException("Package " + packageName + " was not found!");
                } else if (ps.getInstalled(userId)) {
                    if (this.mSafeMode) {
                        if (!ps.isSystem()) {
                            throw new SecurityException("Package " + packageName + " not a system app!");
                        }
                    }
                    if (this.mFrozenPackages.contains(packageName)) {
                        throw new SecurityException("Package " + packageName + " is currently frozen!");
                    } else if (!userKeyUnlocked) {
                        if (!ps.pkg.applicationInfo.isEncryptionAware()) {
                            throw new SecurityException("Package " + packageName + " is not encryption aware!");
                        }
                    }
                } else {
                    throw new SecurityException("Package " + packageName + " was not installed for user " + userId + "!");
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isPackageAvailable(String packageName, int userId) {
        return mHwPMSEx.isPackageAvailable(packageName, userId);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0041, code lost:
        return false;
     */
    public boolean isPackageAvailableImpl(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                }
                if (ps != null) {
                    PackageUserState state = ps.readUserState(userId);
                    if (state != null) {
                        boolean isAvailable = PackageParser.isAvailable(state);
                        return isAvailable;
                    }
                }
            }
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        return getPackageInfoInternal(packageName, -1, mHwPMSEx.updateFlags(flags, userId), Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        if (versionedPackage == null) {
            return null;
        }
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getLongVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x00e1, code lost:
        return mHwPMSEx.handlePackageNotFound(r9, r12, r13);
     */
    public PackageInfo getPackageInfoInternal(String packageName, long versionCode, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, versionCode);
            boolean matchFactoryOnly = (2097152 & flags2) != 0;
            if (matchFactoryOnly) {
                PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(packageName2);
                if (ps != null) {
                    if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                        return null;
                    }
                    if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                        return null;
                    }
                    PackageInfo generatePackageInfo = generatePackageInfo(ps, flags2, userId);
                    return generatePackageInfo;
                }
            }
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                return null;
            }
            if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getPackageInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (ps2 != null && filterAppAccessLPr(ps2, filterCallingUid, userId)) {
                    return null;
                }
                PackageInfo generatePackageInfo2 = generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                return generatePackageInfo2;
            } else if (!matchFactoryOnly && (4202496 & flags2) != 0) {
                PackageSetting ps3 = this.mSettings.mPackages.get(packageName2);
                if (ps3 == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps3, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps3, filterCallingUid, userId)) {
                    return null;
                }
                PackageInfo generatePackageInfo3 = generatePackageInfo(ps3, flags2, userId);
                return generatePackageInfo3;
            }
        }
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (!isComponentVisibleToInstantApp(component, 1) && !isComponentVisibleToInstantApp(component, 3) && !isComponentVisibleToInstantApp(component, 4)) {
            return false;
        }
        return true;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        boolean z = true;
        boolean z2 = false;
        if (type == 1) {
            PackageParser.Activity activity = (PackageParser.Activity) this.mActivities.mActivities.get(component);
            if (activity == null) {
                return false;
            }
            boolean visibleToInstantApp = (1048576 & activity.info.flags) != 0;
            boolean explicitlyVisibleToInstantApp = (2097152 & activity.info.flags) == 0;
            if (!visibleToInstantApp || !explicitlyVisibleToInstantApp) {
                z = false;
            }
            return z;
        } else if (type == 2) {
            PackageParser.Activity activity2 = (PackageParser.Activity) this.mReceivers.mActivities.get(component);
            if (activity2 == null) {
                return false;
            }
            boolean visibleToInstantApp2 = (1048576 & activity2.info.flags) != 0;
            boolean explicitlyVisibleToInstantApp2 = (2097152 & activity2.info.flags) == 0;
            if (!visibleToInstantApp2 || explicitlyVisibleToInstantApp2) {
                z = false;
            }
            return z;
        } else if (type == 3) {
            PackageParser.Service service = (PackageParser.Service) this.mServices.mServices.get(component);
            if (!(service == null || (1048576 & service.info.flags) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 4) {
            PackageParser.Provider provider = (PackageParser.Provider) this.mProviders.mProviders.get(component);
            if (!(provider == null || (1048576 & provider.info.flags) == 0)) {
                z2 = true;
            }
            return z2;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    /* access modifiers changed from: private */
    public boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        }
        if (callerIsInstantApp) {
            if (isCallerSameApp(ps.name, callingUid)) {
                return false;
            }
            if (ps.getInstantApp(userId)) {
                return true;
            }
            if (component == null) {
                return !ps.pkg.visibleToInstantApps;
            }
            PackageParser.Instrumentation instrumentation = this.mInstrumentation.get(component);
            if (instrumentation == null || !isCallerSameApp(instrumentation.info.targetPackage, callingUid)) {
                return !isComponentVisibleToInstantApp(component, componentType);
            }
            return false;
        } else if (!ps.getInstantApp(userId) || isCallerSameApp(ps.name, callingUid) || canViewInstantApps(callingUid, userId)) {
            return false;
        } else {
            if (component != null) {
                return true;
            }
            return !this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId);
        }
    }

    /* access modifiers changed from: private */
    public boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        PackageSetting packageSetting = ps;
        if ((flags & 67108864) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId == 1000 || appId == 2000 || appId == 0) {
                int i = uid;
                return false;
            } else if (checkUidPermission("android.permission.INSTALL_PACKAGES", uid) == 0) {
                return false;
            }
        } else {
            int i2 = uid;
        }
        if (packageSetting == null || packageSetting.pkg == null || !packageSetting.pkg.applicationInfo.isStaticSharedLibrary()) {
            int i3 = userId;
            return false;
        }
        SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(packageSetting.pkg.staticSharedLibName, packageSetting.pkg.staticSharedLibVersion);
        if (libEntry == null) {
            return false;
        }
        String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
        if (uidPackageNames == null) {
            return true;
        }
        for (String uidPackageName : uidPackageNames) {
            if (packageSetting.name.equals(uidPackageName)) {
                return false;
            }
            PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
            if (uidPs != null) {
                int index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libEntry.info.getName());
                if (index >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libEntry.info.getLongVersion()) {
                    return false;
                }
            }
        }
        return true;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        boolean z;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    if (ps.getInstantApp(callingUserId) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            z = false;
                            translateName = z;
                        }
                    }
                    z = true;
                    translateName = z;
                }
                out[i] = translateName ? ps.realName : names[i];
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        String[] strArr = names;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return strArr;
        }
        String[] out = new String[strArr.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            boolean z = true;
            int i = strArr.length - 1;
            while (i >= 0) {
                String cur = this.mSettings.getRenamedPackageLPr(strArr[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = this.mSettings.mPackages.get(strArr[i]);
                    boolean z2 = false;
                    if (((ps == null || !ps.getInstantApp(callingUserId)) ? false : z) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            translateName = z2;
                        }
                    }
                    z2 = true;
                    translateName = z2;
                }
                out[i] = translateName ? cur : strArr[i];
                i--;
                z = true;
            }
        }
        return out;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x006d, code lost:
        return -1;
     */
    public int getPackageUid(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null || !p.isMatch(flags2)) {
                if ((4202496 & flags2) != 0) {
                    PackageSetting ps = this.mSettings.mPackages.get(packageName);
                    if (ps != null && ps.isMatch(flags2) && !filterAppAccessLPr(ps, callingUid, userId)) {
                        int uid = UserHandle.getUid(userId, ps.appId);
                        return uid;
                    }
                }
            } else if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                int uid2 = UserHandle.getUid(userId, p.applicationInfo.uid);
                return uid2;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x006f, code lost:
        return null;
     */
    public int[] getPackageGids(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null && p.isMatch(flags2)) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return null;
                }
                int[] computeGids = ps.getPermissionsState().computeGids(userId);
                return computeGids;
            } else if ((4202496 & flags2) != 0) {
                PackageSetting ps2 = this.mSettings.mPackages.get(packageName);
                if (ps2 != null && ps2.isMatch(flags2) && !filterAppAccessLPr(ps2, callingUid, userId)) {
                    int[] computeGids2 = ps2.getPermissionsState().computeGids(userId);
                    return computeGids2;
                }
            }
        }
    }

    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETPERMISSIONINFO);
        return this.mPermissionManager.getPermissionInfo(name, packageName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String groupName, int flags) {
        List<PermissionInfo> permissionList = this.mPermissionManager.getPermissionInfoByGroup(groupName, flags, getCallingUid());
        if (permissionList == null) {
            return null;
        }
        return new ParceledListSlice<>(permissionList);
    }

    public PermissionGroupInfo getPermissionGroupInfo(String groupName, int flags) {
        return this.mPermissionManager.getPermissionGroupInfo(groupName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        List<PermissionGroupInfo> permissionList = this.mPermissionManager.getAllPermissionGroups(flags, getCallingUid());
        return permissionList == null ? ParceledListSlice.emptyList() : new ParceledListSlice<>(permissionList);
    }

    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        return getApplicationInfoInternal(packageName, mHwPMSEx.updateFlags(flags, userId), Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x008c, code lost:
        return r1;
     */
    public ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForApplication(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, -1);
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getApplicationInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName2);
                if (ps == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                }
                ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags2, ps.readUserState(userId), userId);
                if (ai != null) {
                    ai.packageName = resolveExternalPackageNameLPr(p);
                }
            } else {
                if (!PLATFORM_PACKAGE_NAME.equals(packageName2)) {
                    if (!"system".equals(packageName2)) {
                        if ((4202496 & flags2) == 0) {
                            return null;
                        }
                        ApplicationInfo generateApplicationInfoFromSettingsLPw = generateApplicationInfoFromSettingsLPw(packageName2, flags2, filterCallingUid, userId);
                        return generateApplicationInfoFromSettingsLPw;
                    }
                }
                ApplicationInfo applicationInfo = this.mAndroidApplication;
                return applicationInfo;
            }
        }
    }

    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        if (UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            File dir = Environment.getDataPreloadsFileCacheDirectory();
            Slog.i(TAG, "Deleting preloaded file cache " + dir);
            FileUtils.deleteContents(dir);
            return;
        }
        throw new SecurityException("Only system or settings may call deletePreloadsFileCache");
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        PackageHandler packageHandler = this.mHandler;
        $$Lambda$PackageManagerService$Iz1l7RVtATr5Ybl_zHeYuCbGMvA r1 = new Runnable(volumeUuid, freeStorageSize, storageFlags, observer) {
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IPackageDataObserver f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.lambda$freeStorageAndNotify$1(PackageManagerService.this, this.f$1, this.f$2, this.f$3, this.f$4);
            }
        };
        packageHandler.post(r1);
    }

    public static /* synthetic */ void lambda$freeStorageAndNotify$1(PackageManagerService packageManagerService, String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            packageManagerService.freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        PackageHandler packageHandler = this.mHandler;
        $$Lambda$PackageManagerService$gqdNHYJiYM0w_nIH0nGMWWU8yzQ r1 = new Runnable(volumeUuid, freeStorageSize, storageFlags, pi) {
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IntentSender f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            public final void run() {
                PackageManagerService.lambda$freeStorage$2(PackageManagerService.this, this.f$1, this.f$2, this.f$3, this.f$4);
            }
        };
        packageHandler.post(r1);
    }

    public static /* synthetic */ void lambda$freeStorage$2(PackageManagerService packageManagerService, String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        int i = 0;
        boolean success = false;
        try {
            packageManagerService.freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            if (success) {
                i = 1;
            }
            try {
                pi.sendIntent(null, i, null, null, null);
            } catch (IntentSender.SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        long j;
        String str = volumeUuid;
        long j2 = bytes;
        int i = storageFlags;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(str);
        if (file.getUsableSpace() < j2) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, str);
                boolean aggressive = (i & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, i);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= j2) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= j2) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(str, j2, reservedBytes, 8192);
                } catch (Installer.InstallerException e) {
                }
                if (file.getUsableSpace() < j2) {
                    if (internalVolume && pruneUnusedStaticSharedLibraries(j2, Settings.Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", 7200000))) {
                        return;
                    }
                    if (!internalVolume || !this.mInstantAppRegistry.pruneInstalledInstantApps(j2, Settings.Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                        try {
                            StorageManager storageManager = storage;
                            j = 604800000;
                            try {
                                this.mInstaller.freeCache(str, j2, reservedBytes, 24576);
                            } catch (Installer.InstallerException e2) {
                            }
                        } catch (Installer.InstallerException e3) {
                            StorageManager storageManager2 = storage;
                            j = 604800000;
                        }
                        if (file.getUsableSpace() < j2) {
                            if (internalVolume && this.mInstantAppRegistry.pruneUninstalledInstantApps(j2, Settings.Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", j))) {
                                return;
                            }
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else {
                try {
                    this.mInstaller.freeCache(str, j2, 0, 0);
                } catch (Installer.InstallerException e4) {
                }
                if (file.getUsableSpace() >= j2) {
                    return;
                }
            }
            throw new IOException("Failed to free " + j2 + " on storage device at " + file);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00ce, code lost:
        if (r13 == null) goto L_0x0103;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00d0, code lost:
        r0 = r13.size();
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x00d5, code lost:
        r8 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00d6, code lost:
        if (r8 >= r0) goto L_0x0103;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x00d8, code lost:
        r9 = (android.content.pm.VersionedPackage) r13.get(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x00ef, code lost:
        if (deletePackageX(r9.getPackageName(), r9.getLongVersionCode(), 0, 2) != 1) goto L_0x00fc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x00f1, code lost:
        r3 = r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00f9, code lost:
        if (r3.getUsableSpace() < r23) goto L_0x00fe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00fb, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00fc, code lost:
        r3 = r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00fe, code lost:
        r1 = r8 + 1;
        r19 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x0103, code lost:
        r3 = r19;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0106, code lost:
        return false;
     */
    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        File volume;
        StorageManager storage;
        int libCount;
        int versionCount;
        File volume2;
        StorageManager storage2;
        StorageManager storage3 = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File volume3 = storage3.findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        long now = System.currentTimeMillis();
        synchronized (this.mPackages) {
            try {
                int[] userIds = sUserManager.getUserIds();
                int libCount2 = this.mSharedLibraries.size();
                ArrayList arrayList = null;
                int i = 0;
                while (i < libCount2) {
                    try {
                        LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.valueAt(i);
                        if (versionedLib != null) {
                            int versionCount2 = versionedLib.size();
                            int j = 0;
                            while (j < versionCount2) {
                                SharedLibraryInfo libInfo = versionedLib.valueAt(j).info;
                                if (libInfo.isStatic()) {
                                    VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                    int libCount3 = libCount2;
                                    LongSparseArray<SharedLibraryEntry> versionedLib2 = versionedLib;
                                    String internalPackageName = resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getLongVersionCode());
                                    PackageSetting ps = this.mSettings.getPackageLPr(internalPackageName);
                                    if (ps != null) {
                                        storage2 = storage3;
                                        volume2 = volume3;
                                        try {
                                            if (now - ps.lastUpdateTime < maxCachePeriod) {
                                                versionCount = versionCount2;
                                            } else {
                                                if (arrayList == null) {
                                                    arrayList = new ArrayList();
                                                }
                                                PackageSetting packageSetting = ps;
                                                versionCount = versionCount2;
                                                arrayList.add(new VersionedPackage(internalPackageName, declaringPackage.getLongVersionCode()));
                                            }
                                        } catch (Throwable th) {
                                            th = th;
                                            ArrayList arrayList2 = arrayList;
                                            File file = volume2;
                                            while (true) {
                                                try {
                                                    break;
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                }
                                            }
                                            throw th;
                                        }
                                    } else {
                                        versionCount = versionCount2;
                                        storage2 = storage3;
                                        volume2 = volume3;
                                    }
                                    j++;
                                    libCount2 = libCount3;
                                    versionedLib = versionedLib2;
                                    storage3 = storage2;
                                    volume3 = volume2;
                                    versionCount2 = versionCount;
                                }
                            }
                            libCount = libCount2;
                            storage = storage3;
                            volume = volume3;
                            i++;
                            libCount2 = libCount;
                            storage3 = storage;
                            volume3 = volume;
                        }
                        libCount = libCount2;
                        storage = storage3;
                        volume = volume3;
                        i++;
                        libCount2 = libCount;
                        storage3 = storage;
                        volume3 = volume;
                    } catch (Throwable th3) {
                        th = th3;
                        StorageManager storageManager = storage3;
                        File file2 = volume3;
                        ArrayList arrayList3 = arrayList;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                File volume4 = volume3;
                try {
                } catch (Throwable th4) {
                    th = th4;
                    File file3 = volume4;
                    ArrayList arrayList4 = arrayList;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            } catch (Throwable th5) {
                th = th5;
                StorageManager storageManager2 = storage3;
                File file4 = volume3;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    /* access modifiers changed from: package-private */
    public UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private ActivityManagerInternal getActivityManagerInternal() {
        if (this.mActivityManagerInternal == null) {
            this.mActivityManagerInternal = (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }
        return this.mActivityManagerInternal;
    }

    /* access modifiers changed from: private */
    public DeviceIdleController.LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (DeviceIdleController.LocalService) LocalServices.getService(DeviceIdleController.LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        int flags2;
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        boolean triaged = true;
        if ((flags & 15) != 0 && (269221888 & flags) == 0) {
            triaged = false;
        }
        if ((269492224 & flags) == 0) {
            triaged = false;
        }
        if ((flags & DumpState.DUMP_CHANGES) != 0) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, !isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId), "MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at " + Debug.getCallers(5));
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags2 = flags | DumpState.DUMP_CHANGES;
            return updateFlags(flags2, userId);
        }
        flags2 = flags;
        return updateFlags(flags2, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        if ((cookie instanceof Intent) && (((Intent) cookie).getFlags() & 256) != 0) {
            flags |= 268435456;
        }
        if ((269221888 & flags) == 0) {
        }
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        int flags2;
        if (this.mSafeMode) {
            flags |= 1048576;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= DumpState.DUMP_HANDLE;
            }
            flags2 = flags | DumpState.DUMP_SERVICE_PERMISSIONS | DumpState.DUMP_VOLUMES;
        } else {
            boolean allowMatchInstant = false;
            boolean wantMatchInstant = (flags & DumpState.DUMP_VOLUMES) != 0;
            if (wantInstantApps || (wantMatchInstant && canViewInstantApps(callingUid, userId))) {
                allowMatchInstant = true;
            }
            flags2 = flags & -50331649;
            if (!allowMatchInstant) {
                flags2 &= -8388609;
            }
        }
        return updateFlagsForComponent(flags2, userId, intent);
    }

    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return mHwPMSEx.getActivityInfo(component, flags, userId);
    }

    /* access modifiers changed from: private */
    public ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, component);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        }
        synchronized (this.mPackages) {
            PackageParser.Activity a = (PackageParser.Activity) this.mActivities.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getActivityInfo " + component + ": " + a);
            }
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                }
                ActivityInfo generateActivityInfo = PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
                return generateActivityInfo;
            } else if (!this.mResolveComponentName.equals(component)) {
                return null;
            } else {
                ActivityInfo generateActivityInfo2 = PackageParser.generateActivityInfo(this.mResolveActivity, flags2, new PackageUserState(), userId);
                return generateActivityInfo2;
            }
        }
    }

    private boolean isRecentsAccessingChildProfiles(int callingUid, int targetUserId) {
        if (!getActivityManagerInternal().isCallerRecents(callingUid)) {
            return false;
        }
        long token = Binder.clearCallingIdentity();
        try {
            int callingUserId = UserHandle.getUserId(callingUid);
            if (ActivityManager.getCurrentUser() != callingUserId) {
                return false;
            }
            boolean isSameProfileGroup = sUserManager.isSameProfileGroup(callingUserId, targetUserId);
            Binder.restoreCallingIdentity(token);
            return isSameProfileGroup;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        ComponentName componentName = component;
        synchronized (this.mPackages) {
            if (componentName == null) {
                try {
                    return false;
                } catch (Throwable th) {
                    throw th;
                }
            } else if (componentName.equals(this.mResolveComponentName)) {
                return true;
            } else {
                int callingUid = Binder.getCallingUid();
                int callingUserId = UserHandle.getUserId(callingUid);
                PackageParser.Activity a = (PackageParser.Activity) this.mActivities.mActivities.get(componentName);
                if (a == null) {
                    return false;
                }
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return false;
                }
                if (filterAppAccessLPr(ps, callingUid, componentName, 1, callingUserId)) {
                    return false;
                }
                for (int i = 0; i < a.intents.size(); i++) {
                    if (((PackageParser.ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                        return true;
                    }
                }
                return false;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0088, code lost:
        return null;
     */
    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            PackageParser.Activity a = (PackageParser.Activity) this.mReceivers.mActivities.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getReceiverInfo " + component + ": " + a);
            }
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                    return null;
                }
                ActivityInfo generateActivityInfo = PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
                return generateActivityInfo;
            }
        }
    }

    /* JADX INFO: finally extract failed */
    /* JADX WARNING: Removed duplicated region for block: B:19:0x0058  */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        boolean z;
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        SharedLibraryInfo libInfo;
        PackageManagerService packageManagerService = this;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(i, "userId must be >= 0");
        if (packageManagerService.getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int flags2 = packageManagerService.updateFlagsForPackage(flags, i, null);
        int i2 = 67108864;
        int i3 = 0;
        if (packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") == 0) {
            String str = packageName;
        } else if (!packageManagerService.canRequestPackageInstallsInternal(packageName, 67108864, i, false) && packageManagerService.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") != 0) {
            z = false;
            boolean canSeeStaticLibraries = z;
            synchronized (packageManagerService.mPackages) {
                int libCount = packageManagerService.mSharedLibraries.size();
                List<SharedLibraryInfo> result = null;
                int i4 = 0;
                while (true) {
                    int i5 = i4;
                    if (i5 < libCount) {
                        LongSparseArray<SharedLibraryEntry> versionedLib = packageManagerService.mSharedLibraries.valueAt(i5);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            int j = i3;
                            while (true) {
                                int j2 = j;
                                if (j2 >= versionCount) {
                                    continue;
                                    break;
                                }
                                SharedLibraryInfo libInfo2 = versionedLib.valueAt(j2).info;
                                if (!canSeeStaticLibraries) {
                                    libInfo = libInfo2;
                                    if (libInfo.isStatic()) {
                                        continue;
                                        break;
                                    }
                                } else {
                                    libInfo = libInfo2;
                                }
                                if ("com.huawei.androidx".equals(libInfo.getName())) {
                                    break;
                                }
                                long identity = Binder.clearCallingIdentity();
                                try {
                                    if (packageManagerService.getPackageInfoVersioned(libInfo.getDeclaringPackage(), flags2 | i2, i) == null) {
                                        Binder.restoreCallingIdentity(identity);
                                    } else {
                                        Binder.restoreCallingIdentity(identity);
                                        SharedLibraryInfo sharedLibraryInfo = new SharedLibraryInfo(libInfo.getName(), libInfo.getLongVersion(), libInfo.getType(), libInfo.getDeclaringPackage(), packageManagerService.getPackagesUsingSharedLibraryLPr(libInfo, flags2, i));
                                        if (result == null) {
                                            result = new ArrayList<>();
                                        }
                                        result.add(sharedLibraryInfo);
                                    }
                                    j = j2 + 1;
                                    packageManagerService = this;
                                    i2 = 67108864;
                                } catch (Throwable th) {
                                    Binder.restoreCallingIdentity(identity);
                                    throw th;
                                }
                            }
                        }
                        i4 = i5 + 1;
                        packageManagerService = this;
                        i2 = 67108864;
                        i3 = 0;
                    } else {
                        parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
                    }
                }
            }
            return parceledListSlice;
        }
        z = true;
        boolean canSeeStaticLibraries2 = z;
        synchronized (packageManagerService.mPackages) {
        }
        return parceledListSlice;
    }

    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = this.mSettings.mPackages.valueAt(i);
            if (ps != null && ps.getUserState().get(userId).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getLongVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList<>();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList<>();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0088, code lost:
        return null;
     */
    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            PackageParser.Service s = (PackageParser.Service) this.mServices.mServices.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getServiceInfo " + component + ": " + s);
            }
            if (s != null && this.mSettings.isEnabledAndMatchLPr(s.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                    return null;
                }
                ServiceInfo generateServiceInfo = PackageParser.generateServiceInfo(s, flags2, ps.readUserState(userId), userId);
                return generateServiceInfo;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0088, code lost:
        return null;
     */
    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            PackageParser.Provider p = (PackageParser.Provider) this.mProviders.mProviders.get(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getProviderInfo " + component + ": " + p);
            }
            if (p != null && this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                    return null;
                }
                ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(p, flags2, ps.readUserState(userId), userId);
                return generateProviderInfo;
            }
        }
    }

    public String[] getSystemSharedLibraryNames() {
        synchronized (this.mPackages) {
            int libCount = this.mSharedLibraries.size();
            Set<String> libs = null;
            for (int i = 0; i < libCount; i++) {
                LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.valueAt(i);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryEntry libEntry = versionedLib.valueAt(j);
                        if (!libEntry.info.isStatic()) {
                            if (libs == null) {
                                libs = new ArraySet<>();
                            }
                            libs.add(libEntry.info.getName());
                        } else {
                            PackageSetting ps = this.mSettings.getPackageLPr(libEntry.apk);
                            if (ps == null || filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), 67108864)) {
                                j++;
                            } else {
                                if (libs == null) {
                                    libs = new ArraySet<>();
                                }
                                libs.add(libEntry.info.getName());
                            }
                        }
                    }
                }
            }
            if (libs == null) {
                return null;
            }
            String[] libsArray = new String[libs.size()];
            libs.toArray(libsArray);
            return libsArray;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray<>();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap<>();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:26:0x004b, code lost:
        return r1;
     */
    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList<>(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (packageNames.isEmpty() == 0) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList<>(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice<>(res);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0024, code lost:
        return r1;
     */
    public boolean hasSystemFeature(String name, int version) {
        boolean z = false;
        if (mHwPMSEx != null && !mHwPMSEx.hasSystemFeatureDelegate(name, version)) {
            return false;
        }
        synchronized (this.mAvailableFeatures) {
            FeatureInfo feat = this.mAvailableFeatures.get(name);
            if (feat == null) {
                return false;
            }
            if (feat.version >= version) {
                z = true;
            }
        }
    }

    public int checkPermission(String permName, String pkgName, int userId) {
        if (mHwPMSEx.checkPermissionGranted(permName, userId)) {
            return 0;
        }
        return this.mPermissionManager.checkPermission(permName, pkgName, getCallingUid(), userId);
    }

    public int checkUidPermission(String permName, int uid) {
        PackageParser.Package pkg;
        int checkUidPermission;
        if (mHwPMSEx.checkUidPermissionGranted(permName, uid)) {
            return 0;
        }
        synchronized (this.mPackages) {
            String[] packageNames = getPackagesForUid(uid);
            if (packageNames == null || packageNames.length <= 0) {
                pkg = null;
            } else {
                pkg = this.mPackages.get(packageNames[0]);
            }
            checkUidPermission = this.mPermissionManager.checkUidPermission(permName, pkg, uid, getCallingUid());
        }
        return checkUidPermission;
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "isPermissionRevokedByPolicy for user " + userId);
        }
        boolean z = false;
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    private boolean addDynamicPermission(PermissionInfo info, final boolean async) {
        return this.mPermissionManager.addDynamicPermission(info, async, getCallingUid(), new PermissionManagerInternal.PermissionCallback() {
            public void onPermissionChanged() {
                if (!async) {
                    PackageManagerService.this.mSettings.writeLPr();
                } else {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }
        });
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, false);
        }
        return addDynamicPermission;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, true);
        }
        return addDynamicPermission;
    }

    public void removePermission(String permName) {
        this.mPermissionManager.removeDynamicPermission(permName, getCallingUid(), this.mPermissionCallback);
    }

    public void grantRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, false, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void revokeRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.revokeRuntimePermission(permName, packageName, false, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            for (int userId : UserManagerService.getInstance().getUserIds()) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    PackageParser.Package pkg = this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    public int getPermissionFlags(String permName, String packageName, int userId) {
        return this.mPermissionManager.getPermissionFlags(permName, packageName, getCallingUid(), userId);
    }

    public void updatePermissionFlags(String permName, String packageName, int flagMask, int flagValues, int userId) {
        this.mPermissionManager.updatePermissionFlags(permName, packageName, flagMask, flagValues, getCallingUid(), userId, this.mPermissionCallback);
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        synchronized (this.mPackages) {
            if (this.mPermissionManager.updatePermissionFlagsForAllApps(flagMask, flagValues, getCallingUid(), userId, this.mPackages.values(), this.mPermissionCallback)) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }

    /* JADX INFO: finally extract failed */
    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "canShowRequestPermissionRationale for user " + userId);
        }
        boolean z = false;
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            Binder.restoreCallingIdentity(identity);
            if ((flags & 22) != 0) {
                return false;
            }
            if ((flags & 1) != 0) {
                z = true;
            }
            return z;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
            throw th;
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                this.mOnPermissionChangeListeners.removeListenerLocked(listener);
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0031, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0034, code lost:
        return false;
     */
    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            }
            if (actionName == null || (!actionName.startsWith("android.net.netmon.lingerExpired") && !actionName.startsWith("com.android.server.sip.SipWakeupTimer") && !actionName.startsWith("com.android.internal.telephony.data-reconnect") && !actionName.startsWith("android.net.netmon.launchCaptivePortalApp"))) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:20:0x004d, code lost:
        return -4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x004f, code lost:
        return -4;
     */
    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            PackageParser.Package p1 = this.mPackages.get(pkg1);
            PackageParser.Package p2 = this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = (PackageSetting) p2.mExtras;
                    if (!filterAppAccessLPr((PackageSetting) p1.mExtras, callingUid, callingUserId)) {
                        if (!filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            int compareSignatures = PackageManagerServiceUtils.compareSignatures(p1.mSigningDetails.signatures, p2.mSigningDetails.signatures);
                            return compareSignatures;
                        }
                    }
                }
            }
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        Signature[] s1;
        Signature[] s2;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int uid12 = UserHandle.getAppId(uid1);
        int uid22 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid12);
            if (obj == null) {
                return -4;
            }
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s1 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
            } else if (!(obj instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return -4;
                }
                s1 = ps.signatures.mSigningDetails.signatures;
            }
            Object obj2 = this.mSettings.getUserIdLPr(uid22);
            if (obj2 == null) {
                return -4;
            }
            if (obj2 instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s2 = ((SharedUserSetting) obj2).signatures.mSigningDetails.signatures;
            } else if (!(obj2 instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps2 = (PackageSetting) obj2;
                if (filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                    return -4;
                }
                s2 = ps2.signatures.mSigningDetails.signatures;
            }
            int compareSignatures = PackageManagerServiceUtils.compareSignatures(s1, s2);
            return compareSignatures;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:23:0x003e, code lost:
        return false;
     */
    public boolean hasSigningCertificate(String packageName, byte[] certificate, int type) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                if (p.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                        return false;
                    }
                    switch (type) {
                        case 0:
                            boolean hasCertificate = p.mSigningDetails.hasCertificate(certificate);
                            return hasCertificate;
                        case 1:
                            boolean hasSha256Certificate = p.mSigningDetails.hasSha256Certificate(certificate);
                            return hasSha256Certificate;
                        default:
                            return false;
                    }
                }
            }
        }
    }

    public boolean hasUidSigningCertificate(int uid, byte[] certificate, int type) {
        PackageParser.SigningDetails signingDetails;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        int uid2 = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid2);
            if (obj == null) {
                return false;
            }
            if (obj instanceof SharedUserSetting) {
                if (getInstantAppPackageName(callingUid) != null) {
                    return false;
                }
                signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
            } else if (!(obj instanceof PackageSetting)) {
                return false;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return false;
                }
                signingDetails = ps.signatures.mSigningDetails;
            }
            switch (type) {
                case 0:
                    boolean hasCertificate = signingDetails.hasCertificate(certificate);
                    return hasCertificate;
                case 1:
                    boolean hasSha256Certificate = signingDetails.hasSha256Certificate(certificate);
                    return hasSha256Certificate;
                default:
                    return false;
            }
        }
    }

    /* access modifiers changed from: private */
    public void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private boolean isCompatSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 2;
    }

    private boolean isRecoverSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return getSettingsVersionForPackage(scannedPkg).databaseVersion < 3;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:32:0x0088, code lost:
        return r4;
     */
    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                ArrayList arrayList = new ArrayList(this.mPackages.keySet());
                return arrayList;
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList<>();
            if (instantAppPkgName != null) {
                for (PackageParser.Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (PackageParser.Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        result.add(pkg2.packageName);
                    }
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:40:0x00e8, code lost:
        return null;
     */
    public String[] getPackagesForUid(int uid) {
        SharedUserSetting sus;
        int callingUid = Binder.getCallingUid();
        int i = 0;
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        int uid2 = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid2);
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return null;
                }
                SharedUserSetting sus2 = (SharedUserSetting) obj;
                String[] res = new String[sus2.packages.size()];
                Iterator<PackageSetting> it = sus2.packages.iterator();
                while (it.hasNext()) {
                    PackageSetting ps = it.next();
                    if (this.mIsUpgrade) {
                        PackageSetting psNow = this.mSettings.mPackages.get(ps.name);
                        if (!(psNow == null || psNow.appId == ps.appId)) {
                            res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                            sus = sus2;
                            Slog.w(TAG, "getPackagesForUid " + uid2 + " warning, found package " + ps.name + " was user id " + ps.appId + ", but mismatch " + psNow.appId + " now!");
                            sus2 = sus;
                        }
                    }
                    sus = sus2;
                    if (ps.getInstalled(userId)) {
                        res[i] = ps.name;
                        i++;
                    } else {
                        res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                    }
                    sus2 = sus;
                }
                SharedUserSetting sharedUserSetting = sus2;
                return res;
            } else if ((obj instanceof PackageSetting) != 0) {
                PackageSetting ps2 = (PackageSetting) obj;
                if (ps2.getInstalled(userId) && !filterAppAccessLPr(ps2, callingUid, userId)) {
                    String[] strArr = {ps2.name};
                    return strArr;
                }
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                String str = sus.name + ":" + sus.userId;
                return str;
            } else if (!(obj instanceof PackageSetting)) {
                return null;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                String str2 = ps.name;
                return str2;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    names[i] = "shared:" + ((SharedUserSetting) obj).name;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid != null) {
                    int i = suid.userId;
                    return i;
                }
            } catch (PackageManagerException e) {
            } catch (Throwable th) {
                throw th;
            }
        }
        return -1;
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                int i = ((SharedUserSetting) obj).pkgFlags;
                return i;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                int i2 = ps.pkgFlags;
                return i2;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(uid));
            if (obj instanceof SharedUserSetting) {
                int i = ((SharedUserSetting) obj).pkgPrivateFlags;
                return i;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                int i2 = ps.pkgPrivateFlags;
                return i2;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:23:0x004a, code lost:
        return false;
     */
    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        int uid2 = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getUserIdLPr(uid2);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (it.next().isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                boolean isPrivileged = ((PackageSetting) obj).isPrivileged();
                return isPrivileged;
            }
        }
    }

    public String[] getAppOpPermissionPackages(String permName) {
        return this.mPermissionManager.getAppOpPermissionPackages(permName);
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        return resolveIntentInternal(intent, resolvedType, flags, userId, false, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    public ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
        try {
            Trace.traceBegin(262144, "resolveIntent");
            int i = userId;
            if (!sUserManager.exists(i)) {
                Trace.traceEnd(262144);
                return null;
            }
            int callingUid = Binder.getCallingUid();
            int flags2 = updateFlagsForResolve(flags, i, intent, filterCallingUid, resolveForStart);
            try {
                this.mPermissionManager.enforceCrossUserPermission(callingUid, i, false, false, "resolve intent");
                Trace.traceBegin(262144, "queryIntentActivities");
                List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags2, filterCallingUid, i, resolveForStart, true);
                Trace.traceEnd(262144);
                ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags2, query, userId);
                if (!(bestChoice == null || query == null || query.size() <= 1)) {
                    Slog.d(TAG, "resolve intent for uid:" + callingUid + ", matchs:" + query.size() + ", res:" + bestChoice);
                }
                Trace.traceEnd(262144);
                return bestChoice;
            } catch (Throwable th) {
                th = th;
                Trace.traceEnd(262144);
                throw th;
            }
        } catch (Throwable th2) {
            th = th2;
            int i2 = flags;
            Trace.traceEnd(262144);
            throw th;
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        ResolveInfo findPersistentPreferredActivityLP;
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            int callingUid = Binder.getCallingUid();
            Intent intent2 = updateIntentForResolve(intent);
            String resolvedType = intent2.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent2, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent2, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent2, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        Intent intent2 = intent;
        String str = resolvedType;
        int i = flags;
        IntentFilter intentFilter = filter;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                Log.v(TAG, "setLastChosenActivity intent=" + intent2 + " resolvedType=" + str + " flags=" + i + " filter=" + intentFilter + " match=" + match + " activity=" + activity);
                intentFilter.dump(new PrintStreamPrinter(System.out), "    ");
            } else {
                int i2 = match;
                ComponentName componentName = activity;
            }
            intent2.setComponent(null);
            findPreferredActivity(intent2, str, i, queryIntentActivitiesInternal(intent2, str, i, userId), 0, false, true, false, userId);
            addPreferredActivityInternal(intentFilter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            Log.v(TAG, "Querying last chosen activity for " + intent);
        }
        return findPreferredActivity(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean areWebInstantAppsDisabled() {
        return this.mWebInstantAppsDisabled;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00b9, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x00dc, code lost:
        return false;
     */
    private boolean isInstantAppResolutionAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        List<ResolveInfo> list = resolvedActivities;
        int i = userId;
        if (this.mInstantAppResolverConnection == null || this.mInstantAppInstallerActivity == null || intent.getComponent() != null || (intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!skipPackageCheck && intent.getPackage() != null) {
            return false;
        }
        if (!intent.isWebIntent()) {
            if (!(list == null || resolvedActivities.size() == 0) || (intent.getFlags() & 2048) == 0) {
                return false;
            }
        } else if (intent.getData() == null || TextUtils.isEmpty(intent.getData().getHost())) {
            return false;
        } else {
            if (areWebInstantAppsDisabled()) {
                return false;
            }
        }
        synchronized (this.mPackages) {
            int count = list == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = list.get(n);
                PackageSetting ps = this.mSettings.mPackages.get(info.activityInfo.packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI) {
                        int status = (int) (getDomainVerificationStatusLPr(ps, i) >> 32);
                        if (status == 2 || status == 4) {
                            if (DEBUG_INSTANT) {
                                Slog.v(TAG, "DENY instant app; pkg: " + packageName + ", status: " + status);
                            }
                        }
                    }
                    if (ps.getInstantApp(i)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app installed; pkg: " + packageName);
                        }
                    }
                }
            }
            return true;
        }
    }

    /* access modifiers changed from: private */
    public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        PackageHandler packageHandler = this.mHandler;
        InstantAppRequest instantAppRequest = new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false);
        this.mHandler.sendMessage(packageHandler.obtainMessage(20, instantAppRequest));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        List<ResolveInfo> list = query;
        int i = userId;
        if (list != null) {
            int N = query.size();
            if (N == 1) {
                return list.get(0);
            }
            if (N > 1) {
                boolean debug = (intent.getFlags() & 8) != 0;
                ResolveInfo r0 = list.get(0);
                ResolveInfo r1 = list.get(1);
                if (DEBUG_INTENT_MATCHING || debug) {
                    Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
                }
                if (r0.priority != r1.priority || r0.preferredOrder != r1.preferredOrder) {
                    ResolveInfo resolveInfo = r0;
                } else if (r0.isDefault != r1.isDefault) {
                    ResolveInfo resolveInfo2 = r1;
                    ResolveInfo resolveInfo3 = r0;
                } else {
                    ResolveInfo resolveInfo4 = r1;
                    ResolveInfo resolveInfo5 = r0;
                    ResolveInfo ri = findPreferredActivity(intent, resolvedType, flags, list, r0.priority, true, false, debug, i);
                    if (ri != null) {
                        return ri;
                    }
                    ResolveInfo resolveInfo6 = ri;
                    for (int i2 = 0; i2 < N; i2++) {
                        ResolveInfo ri2 = list.get(i2);
                        if (ri2.activityInfo == null) {
                            Slog.d(TAG, "chooseBestActivity activityInfo is Empty,ResolveInfo:" + ri2);
                        } else if (ri2.activityInfo.applicationInfo.isInstantApp()) {
                            if (((int) (getDomainVerificationStatusLPr(this.mSettings.mPackages.get(ri2.activityInfo.packageName), i) >> 32)) != 4) {
                                return ri2;
                            }
                        } else {
                            continue;
                        }
                    }
                    ResolveInfo ri3 = new ResolveInfo(this.mResolveInfo);
                    ri3.activityInfo = new ActivityInfo(ri3.activityInfo);
                    ri3.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                    String intentPackage = intent.getPackage();
                    if (!TextUtils.isEmpty(intentPackage) && allHavePackage(list, intentPackage)) {
                        ApplicationInfo appi = list.get(0).activityInfo.applicationInfo;
                        ri3.resolvePackageName = intentPackage;
                        if (userNeedsBadging(i)) {
                            ri3.noResourceId = true;
                        } else {
                            ri3.icon = appi.icon;
                        }
                        ri3.iconResourceId = appi.icon;
                        ri3.labelRes = appi.labelRes;
                    }
                    ri3.activityInfo.applicationInfo = new ApplicationInfo(ri3.activityInfo.applicationInfo);
                    if (i != 0) {
                        ri3.activityInfo.applicationInfo.uid = UserHandle.getUid(i, UserHandle.getAppId(ri3.activityInfo.applicationInfo.uid));
                    }
                    if (ri3.activityInfo.metaData == null) {
                        ri3.activityInfo.metaData = new Bundle();
                    }
                    ri3.activityInfo.metaData.putBoolean("android.dock_home", true);
                    return ri3;
                }
                return list.get(0);
            }
        }
        return null;
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || !packageName.equals(ai.packageName)) {
                return false;
            }
        }
        return true;
    }

    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List<PersistentPreferredActivity> pprefs;
        PackageManagerService packageManagerService = this;
        int i = flags;
        int i2 = userId;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = packageManagerService.mSettings.mPersistentPreferredActivities.get(i2);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        int i3 = 0;
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & i) != 0, i2);
        } else {
            Intent intent2 = intent;
            String str = resolvedType;
            pprefs = null;
        }
        if (pprefs != null && pprefs.size() > 0) {
            int M = pprefs.size();
            int i4 = 0;
            while (i4 < M) {
                PersistentPreferredActivity ppa = pprefs.get(i4);
                if (DEBUG_PREFERRED || debug) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Checking PersistentPreferredActivity ds=");
                    sb.append(ppa.countDataSchemes() > 0 ? ppa.getDataScheme(i3) : "<none>");
                    sb.append("\n  component=");
                    sb.append(ppa.mComponent);
                    Slog.v(TAG, sb.toString());
                    ppa.dump(new LogPrinter(2, TAG, 3), "  ");
                }
                ActivityInfo ai = packageManagerService.getActivityInfo(ppa.mComponent, i | 512, i2);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Found persistent preferred activity:");
                    if (ai != null) {
                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                    } else {
                        Slog.v(TAG, "  null");
                    }
                }
                if (ai != null) {
                    int j = 0;
                    while (j < N) {
                        ResolveInfo ri = query.get(j);
                        if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                            if (DEBUG_PREFERRED || debug) {
                                StringBuilder sb2 = new StringBuilder();
                                int i5 = j;
                                sb2.append("Returning persistent preferred activity: ");
                                sb2.append(ri.activityInfo.packageName);
                                sb2.append(SliceClientPermissions.SliceAuthority.DELIMITER);
                                sb2.append(ri.activityInfo.name);
                                Slog.v(TAG, sb2.toString());
                            } else {
                                int i6 = j;
                            }
                            return ri;
                        }
                        j++;
                        int i7 = flags;
                    }
                }
                List<ResolveInfo> list = query;
                i4++;
                packageManagerService = this;
                i = flags;
                i3 = 0;
            }
        }
        List<ResolveInfo> list2 = query;
        return null;
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x0255, code lost:
        if (r45 == false) goto L_0x028a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x0257, code lost:
        r2.removeFilter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x025d, code lost:
        if (DEBUG_PREFERRED == false) goto L_0x0280;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:139:0x025f, code lost:
        r32 = r0;
        r33 = r1;
        r1 = new java.lang.StringBuilder();
        r34 = r7;
        r1.append("Removing match ");
        r1.append(r6.mPref.mComponent);
        android.util.Slog.v(TAG, r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:13:0x003b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x0280, code lost:
        r34 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x0282, code lost:
        r30 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x0285, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x0286, code lost:
        r30 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x028a, code lost:
        r32 = r0;
        r33 = r1;
        r34 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0290, code lost:
        if (r44 == false) goto L_0x029c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:148:0x0298, code lost:
        if (r6.mPref.sameSet(r14) != false) goto L_0x029c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x029a, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x003c, code lost:
        r1 = r11;
        r2 = r12;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x029c, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02a1, code lost:
        if (r11.getAction() == null) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02ad, code lost:
        if (r11.getAction().equals("android.intent.action.VIEW") == false) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02b3, code lost:
        if (r11.getData() == null) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02bd, code lost:
        if (r11.getData().getScheme() == null) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x02cd, code lost:
        if (r11.getData().getScheme().equals("file") != false) goto L_0x02df;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x02dd, code lost:
        if (r11.getData().getScheme().equals("content") == false) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x02e3, code lost:
        if (r11.getType() == null) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x02ef, code lost:
        if (r11.getType().startsWith("audio/") == false) goto L_0x02f3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x02f1, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x02f3, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x02f4, code lost:
        if (r1 == false) goto L_0x0320;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x02f6, code lost:
        r9 = new java.lang.StringBuilder();
        r35 = r0;
        r9.append("preferred activity for ");
        r9.append(r11);
        r9.append(" type ");
        r9.append(r15);
        r9.append(", do not dropping preferred activity");
        android.util.Slog.i(TAG, r9.toString());
        r35 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x0320, code lost:
        r35 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0322, code lost:
        if (r35 == false) goto L_0x040c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x032a, code lost:
        if (r11.hasCategory("android.intent.category.HOME") == false) goto L_0x0338;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x0332, code lost:
        if ((r11.getFlags() & 512) != 0) goto L_0x0335;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0335, code lost:
        r36 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x033e, code lost:
        if (r6.mPref.isSuperset(r14) == false) goto L_0x0393;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0342, code lost:
        if (DEBUG_PREFERRED == false) goto L_0x0362;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x0344, code lost:
        android.util.Slog.i(TAG, "Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for " + r11 + " type " + r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x0362, code lost:
        r36 = r1;
        r22 = new com.android.server.pm.PreferredActivity(r6, r6.mPref.mMatch, r6.mPref.discardObsoleteComponents(r14), r6.mPref.mComponent, r6.mPref.mAlways);
        r2.removeFilter(r6);
        r2.addFilter(r22);
        r30 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x0393, code lost:
        r36 = r1;
        android.util.Slog.i(TAG, "Result set changed, dropping preferred activity for " + r11 + " type " + r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x03b5, code lost:
        if (r8.mIsDefaultGoogleCalendar == false) goto L_0x03ba;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x03b7, code lost:
        r8.mIsDefaultPreferredActivityChanged = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x03bc, code lost:
        if (DEBUG_PREFERRED == false) goto L_0x03d8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x03be, code lost:
        android.util.Slog.v(TAG, "Removing preferred activity since set changed " + r6.mPref.mComponent);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x03d8, code lost:
        r2.removeFilter(r6);
        r22 = new com.android.server.pm.PreferredActivity(r6, r6.mPref.mMatch, null, r6.mPref.mComponent, false);
        r2.addFilter(r22);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x03f9, code lost:
        if (1 == 0) goto L_0x0409;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x03fd, code lost:
        if (DEBUG_PREFERRED == false) goto L_0x0406;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x03ff, code lost:
        android.util.Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x0406, code lost:
        scheduleWritePackageRestrictionsLocked(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x040b, code lost:
        return null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x040c, code lost:
        r36 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x0412, code lost:
        if (DEBUG_PREFERRED != false) goto L_0x0416;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x0414, code lost:
        if (r46 == false) goto L_0x043c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:208:0x0416, code lost:
        android.util.Slog.v(TAG, "Returning preferred activity: " + r4.activityInfo.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r4.activityInfo.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x043e, code lost:
        if (r8.mIsDefaultGoogleCalendar == false) goto L_0x045b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x0444, code lost:
        if (r4.activityInfo.packageName == null) goto L_0x045b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x0450, code lost:
        if ("com.android.calendar".equals(r4.activityInfo.packageName) == false) goto L_0x045b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x0452, code lost:
        android.util.Log.i(TAG, "break huawei calendar, set default calendar is google calendar");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x045b, code lost:
        if (r30 == false) goto L_0x046b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x045f, code lost:
        if (DEBUG_PREFERRED == false) goto L_0x0468;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:220:0x0461, code lost:
        android.util.Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x0468, code lost:
        scheduleWritePackageRestrictionsLocked(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:223:0x046c, code lost:
        return r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:0x047e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Exception block dominator not found, dom blocks: [B:10:0x0039, B:95:0x0178] */
    /* JADX WARNING: Removed duplicated region for block: B:105:0x01b0 A[Catch:{ all -> 0x047e, all -> 0x003b }] */
    /* JADX WARNING: Removed duplicated region for block: B:122:0x0205 A[Catch:{ all -> 0x047e, all -> 0x003b }] */
    /* JADX WARNING: Removed duplicated region for block: B:125:0x022b A[Catch:{ all -> 0x047e, all -> 0x003b }] */
    /* JADX WARNING: Removed duplicated region for block: B:243:0x04b0 A[Catch:{ all -> 0x047e, all -> 0x003b }] */
    /* JADX WARNING: Removed duplicated region for block: B:260:0x00cf A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:56:0x00cc A[Catch:{ all -> 0x00d7 }] */
    /* JADX WARNING: Removed duplicated region for block: B:99:0x0186 A[Catch:{ all -> 0x047e, all -> 0x003b }] */
    public ResolveInfo findPreferredActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        List<PreferredActivity> prefs;
        boolean changed;
        PreferredActivity pa;
        int M;
        List<PreferredActivity> prefs2;
        int N;
        int match;
        StringBuilder sb;
        String str;
        boolean changed2;
        ResolveInfo pri;
        ResolveInfo pri2;
        StringBuilder sb2;
        String str2 = resolvedType;
        List<ResolveInfo> list = query;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return null;
        }
        int flags2 = updateFlagsForResolve(flags, i, intent, Binder.getCallingUid(), false);
        Intent intent2 = updateIntentForResolve(intent);
        synchronized (this.mPackages) {
            try {
                ResolveInfo pri3 = findPersistentPreferredActivityLP(intent2, str2, flags2, list, debug, i);
                if (pri3 != null) {
                    return pri3;
                }
                PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(i);
                if (DEBUG_PREFERRED || debug) {
                    Slog.v(TAG, "Looking for preferred activities...");
                }
                if (pir != null) {
                    prefs = pir.queryIntent(intent2, str2, (65536 & flags2) != 0, i);
                } else {
                    prefs = null;
                }
                if (prefs != null && prefs.size() > 0) {
                    boolean changed3 = false;
                    try {
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Figuring out best match...");
                        }
                        int N2 = query.size();
                        int match2 = 0;
                        int j = 0;
                        while (j < N2) {
                            try {
                                ResolveInfo ri = list.get(j);
                                if (!DEBUG_PREFERRED) {
                                    if (!debug) {
                                        pri = pri3;
                                        changed2 = changed3;
                                        pri2 = ri;
                                        if (pri2.match <= match2) {
                                            match2 = pri2.match;
                                        }
                                        j++;
                                        pri3 = pri;
                                        changed3 = changed2;
                                    }
                                }
                                sb2 = new StringBuilder();
                                pri = pri3;
                                try {
                                    sb2.append("Match for ");
                                    changed2 = changed3;
                                    pri2 = ri;
                                } catch (Throwable th) {
                                    th = th;
                                    List<PreferredActivity> list2 = prefs;
                                    changed = changed3;
                                    if (changed) {
                                    }
                                    throw th;
                                }
                            } catch (Throwable th2) {
                                th = th2;
                                ResolveInfo resolveInfo = pri3;
                                List<PreferredActivity> list3 = prefs;
                                changed = changed3;
                                if (changed) {
                                }
                                throw th;
                            }
                            try {
                                sb2.append(pri2.activityInfo);
                                sb2.append(": 0x");
                                sb2.append(Integer.toHexString(match2));
                                Slog.v(TAG, sb2.toString());
                                if (pri2.match <= match2) {
                                }
                                j++;
                                pri3 = pri;
                                changed3 = changed2;
                            } catch (Throwable th3) {
                                th = th3;
                                List<PreferredActivity> list4 = prefs;
                                changed = changed2;
                                if (changed) {
                                }
                                throw th;
                            }
                        }
                        boolean changed4 = changed3;
                        try {
                            if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match2));
                            }
                            int match3 = 268369920 & match2;
                            int M2 = prefs.size();
                            boolean changed5 = changed4;
                            int i2 = 0;
                            while (i2 < M2) {
                                try {
                                    pa = prefs.get(i2);
                                    M = M2;
                                    if (!DEBUG_PREFERRED) {
                                        if (!debug) {
                                            prefs2 = prefs;
                                            changed = changed5;
                                            if (pa.mPref.mMatch == match3) {
                                                if (!DEBUG_PREFERRED) {
                                                    if (debug) {
                                                    }
                                                }
                                                Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa.mPref.mMatch));
                                            } else if (!always || pa.mPref.mAlways) {
                                                ActivityInfo ai = getActivityInfo(pa.mPref.mComponent, flags2 | 512 | 524288 | 262144, i);
                                                if (!DEBUG_PREFERRED) {
                                                    if (!debug) {
                                                        match = match3;
                                                        if (ai != null) {
                                                            Slog.w(TAG, "Removing dangling preferred activity: " + pa.mPref.mComponent);
                                                            pir.removeFilter(pa);
                                                            changed = true;
                                                            N = N2;
                                                            i2++;
                                                            M2 = M;
                                                            prefs = prefs2;
                                                            changed5 = changed;
                                                            match3 = match;
                                                            N2 = N;
                                                        } else {
                                                            int j2 = 0;
                                                            while (true) {
                                                                if (j2 >= N2) {
                                                                    N = N2;
                                                                    break;
                                                                }
                                                                ResolveInfo ri2 = list.get(j2);
                                                                if (ri2.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                                                                    if (ri2.activityInfo.name.equals(ai.name)) {
                                                                        break;
                                                                    }
                                                                }
                                                                j2++;
                                                            }
                                                            i2++;
                                                            M2 = M;
                                                            prefs = prefs2;
                                                            changed5 = changed;
                                                            match3 = match;
                                                            N2 = N;
                                                        }
                                                    }
                                                }
                                                Slog.v(TAG, "Found preferred activity:");
                                                if (ai != null) {
                                                    match = match3;
                                                    ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                                } else {
                                                    match = match3;
                                                    Slog.v(TAG, "  null");
                                                }
                                                if (ai != null) {
                                                }
                                            } else if (DEBUG_PREFERRED || debug) {
                                                Slog.v(TAG, "Skipping mAlways=false entry");
                                            }
                                            match = match3;
                                            N = N2;
                                            i2++;
                                            M2 = M;
                                            prefs = prefs2;
                                            changed5 = changed;
                                            match3 = match;
                                            N2 = N;
                                        }
                                    }
                                    sb = new StringBuilder();
                                    prefs2 = prefs;
                                } catch (Throwable th4) {
                                    th = th4;
                                    List<PreferredActivity> list5 = prefs;
                                    changed = changed5;
                                    if (changed) {
                                    }
                                    throw th;
                                }
                                try {
                                    sb.append("Checking PreferredActivity ds=");
                                    if (pa.countDataSchemes() > 0) {
                                        try {
                                            str = pa.getDataScheme(0);
                                        } catch (Throwable th5) {
                                            th = th5;
                                            changed = changed5;
                                            if (changed) {
                                            }
                                            throw th;
                                        }
                                    } else {
                                        str = "<none>";
                                    }
                                    sb.append(str);
                                    sb.append("\n  component=");
                                    sb.append(pa.mPref.mComponent);
                                    Slog.v(TAG, sb.toString());
                                    changed = changed5;
                                    pa.dump(new LogPrinter(2, TAG, 3), "  ");
                                    if (pa.mPref.mMatch == match3) {
                                    }
                                    match = match3;
                                    N = N2;
                                    i2++;
                                    M2 = M;
                                    prefs = prefs2;
                                    changed5 = changed;
                                    match3 = match;
                                    N2 = N;
                                } catch (Throwable th6) {
                                    th = th6;
                                    changed = changed5;
                                    if (changed) {
                                        if (DEBUG_PREFERRED) {
                                            Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                        }
                                        scheduleWritePackageRestrictionsLocked(i);
                                    }
                                    throw th;
                                }
                            }
                            if (changed5) {
                                if (DEBUG_PREFERRED) {
                                    Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                }
                                scheduleWritePackageRestrictionsLocked(i);
                            }
                        } catch (Throwable th7) {
                            th = th7;
                            List<PreferredActivity> list6 = prefs;
                            changed = changed4;
                            if (changed) {
                            }
                            throw th;
                        }
                    } catch (Throwable th8) {
                        th = th8;
                        ResolveInfo resolveInfo2 = pri3;
                        List<PreferredActivity> list7 = prefs;
                        changed = false;
                        if (changed) {
                        }
                        throw th;
                    }
                }
                Intent intent3 = intent2;
                int i3 = flags2;
                return mHwPMSEx.hwFindPreferredActivity(intent2, str2, flags2, list, priority, always, removeMatches, debug, userId);
            } catch (Throwable th9) {
                th = th9;
                Intent intent4 = intent2;
                int i4 = flags2;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th10) {
                        th = th10;
                    }
                }
                throw th;
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        boolean z = false;
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (matches.get(i).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        int i2 = targetUserId;
        if (intent == null || !intent.hasWebURI()) {
            int i3 = sourceUserId;
            return false;
        }
        int callingUid = Binder.getCallingUid();
        int i4 = sourceUserId;
        UserInfo parent = getProfileParent(i4);
        synchronized (this.mPackages) {
            if (getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), i4, parent.id) != null) {
                z = true;
            }
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            return sUserManager.getProfileParent(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            return new ParceledListSlice<>(queryIntentActivitiesInternal(intent, resolvedType, flags, userId));
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0032, code lost:
        return r4;
     */
    public String getInstantAppPackageName(int callingUid) {
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            Object obj = this.mSettings.getUserIdLPr(UserHandle.getAppId(callingUid));
            String str = null;
            if (!(obj instanceof PackageSetting)) {
                return null;
            }
            PackageSetting ps = (PackageSetting) obj;
            if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                str = ps.pkg.packageName;
            }
        }
    }

    /* access modifiers changed from: protected */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* access modifiers changed from: protected */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        return mHwPMSEx.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, resolveForStart, allowDynamicSplits);
    }

    /* JADX WARNING: Removed duplicated region for block: B:68:0x00e6  */
    public List<ResolveInfo> queryIntentActivitiesInternalImpl(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        Intent intent2;
        ArrayMap<String, PackageParser.Package> arrayMap;
        int flags2;
        String instantAppPkgName;
        Intent intent3;
        int i;
        PackageManagerService packageManagerService;
        List<ResolveInfo> result;
        List<ResolveInfo> result2;
        Intent intent4;
        List<ResolveInfo> result3;
        boolean addInstant;
        List<ResolveInfo> result4;
        CrossProfileDomainInfo xpDomainInfo;
        ResolveInfo xpResolveInfo;
        Intent intent5;
        int i2;
        PackageManagerService packageManagerService2;
        boolean isTargetExplicitlyVisibleToInstantApp;
        String str = resolvedType;
        int i3 = filterCallingUid;
        int flags3 = userId;
        if (!sUserManager.exists(flags3)) {
            return Collections.emptyList();
        }
        String instantAppPkgName2 = getInstantAppPackageName(i3);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), flags3, false, false, "query intent activities");
        if (intent == null) {
            return Collections.emptyList();
        }
        String pkgName = intent.getPackage();
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent6 = intent.getSelector();
            comp = intent6.getComponent();
            intent2 = intent6;
        }
        ComponentName comp2 = comp;
        int flags4 = updateFlagsForResolve(flags, flags3, intent2, i3, resolveForStart, (comp2 == null && pkgName == null) ? false : true);
        if (comp2 != null) {
            ArrayList arrayList = new ArrayList(1);
            ActivityInfo ai = getActivityInfo(comp2, flags4, flags3);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags4) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags4) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags4) != 0;
                boolean isCallerInstantApp = instantAppPkgName2 != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName2);
                ComponentName componentName = comp2;
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    String str2 = pkgName;
                    if ((ai.flags & 2097152) == 0) {
                        isTargetExplicitlyVisibleToInstantApp = true;
                        if (!(isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp)))))) {
                            boolean z = isTargetSameInstantApp;
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            arrayList.add(ri);
                        }
                    }
                }
                isTargetExplicitlyVisibleToInstantApp = false;
                if (!(isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp)))))) {
                }
            } else {
                String str3 = pkgName;
                mHwPMSEx.handleActivityInfoNotFound(flags4, intent2, i3, arrayList);
            }
            ActivityInfo activityInfo = ai;
            ArrayList arrayList2 = arrayList;
            int i4 = flags4;
            return applyPostResolutionFilter(arrayList, instantAppPkgName2, allowDynamicSplits, i3, resolveForStart, flags3, intent2);
        }
        int flags5 = flags4;
        ComponentName componentName2 = comp2;
        String pkgName2 = pkgName;
        boolean sortResult = false;
        boolean addInstant2 = false;
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            if (pkgName2 == null) {
                String str4 = resolvedType;
                try {
                    List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent2, str4, flags3);
                    ResolveInfo xpResolveInfo2 = querySkipCurrentProfileIntents(matchingFilters, intent2, str4, flags5, flags3);
                    if (xpResolveInfo2 != null) {
                        try {
                            ArrayList arrayList3 = new ArrayList(1);
                            arrayList3.add(xpResolveInfo2);
                            List<ResolveInfo> filterIfNotSystemUser = filterIfNotSystemUser(arrayList3, flags3);
                            ArrayList arrayList4 = arrayList3;
                            String str5 = str4;
                            Intent intent7 = intent2;
                            arrayMap = arrayMap2;
                            try {
                                List<ResolveInfo> applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser, instantAppPkgName2, allowDynamicSplits, i3, resolveForStart, flags3, intent7);
                                return applyPostResolutionFilter;
                            } catch (Throwable th) {
                                th = th;
                                String str6 = instantAppPkgName2;
                                int i5 = flags3;
                                Intent intent8 = intent7;
                                String str7 = pkgName2;
                                int i6 = flags5;
                                throw th;
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            String str8 = str4;
                            arrayMap = arrayMap2;
                            String str9 = instantAppPkgName2;
                            int i7 = flags3;
                            int i8 = flags5;
                            Intent intent9 = intent2;
                            String str10 = pkgName2;
                            throw th;
                        }
                    } else {
                        String str11 = str4;
                        Intent intent10 = intent2;
                        arrayMap = arrayMap2;
                        String pkgName3 = pkgName2;
                        try {
                            intent4 = intent10;
                            try {
                                result3 = filterIfNotSystemUser(this.mActivities.queryIntent(intent4, str11, flags5, flags3), flags3);
                                addInstant = isInstantAppResolutionAllowed(intent4, result3, flags3, false);
                            } catch (Throwable th3) {
                                th = th3;
                                String str12 = instantAppPkgName2;
                                int i9 = flags3;
                                int i10 = flags5;
                                Intent intent11 = intent4;
                                throw th;
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            String str13 = instantAppPkgName2;
                            int i11 = flags3;
                            Intent intent12 = intent10;
                            int i12 = flags5;
                            String str14 = pkgName3;
                            throw th;
                        }
                        try {
                            boolean isVisibleToUser = false;
                            ResolveInfo resolveInfo = xpResolveInfo2;
                            List<ResolveInfo> result5 = result3;
                            ResolveInfo xpResolveInfo3 = queryCrossProfileIntents(matchingFilters, intent4, str11, flags5, flags3, hasNonNegativePriority(result3));
                            if (xpResolveInfo3 != null) {
                                try {
                                    if (isUserEnabled(xpResolveInfo3.targetUserId)) {
                                        if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo3), flags3).size() > 0) {
                                            isVisibleToUser = true;
                                        }
                                        if (isVisibleToUser) {
                                            result5.add(xpResolveInfo3);
                                            sortResult = true;
                                        }
                                    }
                                } catch (Throwable th5) {
                                    th = th5;
                                    String str15 = instantAppPkgName2;
                                    int i13 = flags3;
                                    int i14 = flags5;
                                    boolean z2 = addInstant;
                                    throw th;
                                }
                            }
                            boolean sortResult2 = sortResult;
                            try {
                                if (intent4.hasWebURI()) {
                                    UserInfo parent = getProfileParent(flags3);
                                    if (parent != null) {
                                        try {
                                            UserInfo userInfo = parent;
                                            xpResolveInfo = xpResolveInfo3;
                                            xpDomainInfo = getCrossProfileDomainPreferredLpr(intent4, str11, flags5, flags3, parent.id);
                                        } catch (Throwable th6) {
                                            th = th6;
                                            String str16 = instantAppPkgName2;
                                            int i15 = flags3;
                                            int i16 = flags5;
                                            boolean z3 = addInstant;
                                            boolean z4 = sortResult2;
                                            throw th;
                                        }
                                    } else {
                                        UserInfo userInfo2 = parent;
                                        xpResolveInfo = xpResolveInfo3;
                                        xpDomainInfo = null;
                                    }
                                    if (xpDomainInfo != null) {
                                        if (xpResolveInfo != null) {
                                            result5.remove(xpResolveInfo);
                                        }
                                        try {
                                            if (result5.size() != 0 || addInstant) {
                                                intent5 = intent4;
                                                instantAppPkgName = instantAppPkgName2;
                                                i2 = flags3;
                                                flags2 = flags5;
                                                packageManagerService2 = this;
                                            } else {
                                                result5.add(xpDomainInfo.resolveInfo);
                                                intent5 = intent4;
                                                i2 = flags3;
                                                int i17 = flags5;
                                                packageManagerService2 = this;
                                                try {
                                                    List<ResolveInfo> applyPostResolutionFilter2 = applyPostResolutionFilter(result5, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, i2, intent5);
                                                    return applyPostResolutionFilter2;
                                                } catch (Throwable th7) {
                                                    th = th7;
                                                    PackageManagerService packageManagerService3 = packageManagerService2;
                                                    int i18 = i2;
                                                    Intent intent13 = intent5;
                                                    throw th;
                                                }
                                            }
                                        } catch (Throwable th8) {
                                            th = th8;
                                            String str17 = instantAppPkgName2;
                                            int i19 = flags5;
                                            int i20 = flags3;
                                            boolean z5 = addInstant;
                                            boolean z6 = sortResult2;
                                            String str18 = pkgName3;
                                            Intent intent14 = intent4;
                                            throw th;
                                        }
                                    } else {
                                        intent5 = intent4;
                                        instantAppPkgName = instantAppPkgName2;
                                        i2 = flags3;
                                        flags2 = flags5;
                                        packageManagerService2 = this;
                                        try {
                                            if (result5.size() <= 1 && !addInstant) {
                                                List<ResolveInfo> applyPostResolutionFilter3 = packageManagerService2.applyPostResolutionFilter(result5, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, i2, intent5);
                                                return applyPostResolutionFilter3;
                                            }
                                        } catch (Throwable th9) {
                                            th = th9;
                                            PackageManagerService packageManagerService4 = packageManagerService2;
                                            int i21 = i2;
                                            Intent intent15 = intent5;
                                            boolean z7 = addInstant;
                                            boolean z8 = sortResult2;
                                            String str19 = pkgName3;
                                            throw th;
                                        }
                                    }
                                    packageManagerService = packageManagerService2;
                                    i = i2;
                                    intent3 = intent5;
                                    CrossProfileDomainInfo crossProfileDomainInfo = xpDomainInfo;
                                    try {
                                        result4 = packageManagerService2.filterCandidatesWithDomainPreferredActivitiesLPr(intent5, flags2, result5, xpDomainInfo, i);
                                        sortResult = true;
                                    } catch (Throwable th10) {
                                        th = th10;
                                        throw th;
                                    }
                                } else {
                                    instantAppPkgName = instantAppPkgName2;
                                    i = flags3;
                                    flags2 = flags5;
                                    intent3 = intent4;
                                    packageManagerService = this;
                                    result4 = result5;
                                    sortResult = sortResult2;
                                }
                                result = result4;
                                addInstant2 = addInstant;
                                String str20 = pkgName3;
                            } catch (Throwable th11) {
                                th = th11;
                                String str21 = instantAppPkgName2;
                                int i22 = flags3;
                                int i23 = flags5;
                                Intent intent16 = intent4;
                                boolean z9 = addInstant;
                                boolean z10 = sortResult2;
                                throw th;
                            }
                        } catch (Throwable th12) {
                            th = th12;
                            String str22 = instantAppPkgName2;
                            int i24 = flags3;
                            int i25 = flags5;
                            Intent intent17 = intent4;
                            boolean z11 = addInstant;
                            throw th;
                        }
                    }
                } catch (Throwable th13) {
                    th = th13;
                    arrayMap = arrayMap2;
                    String str23 = instantAppPkgName2;
                    int i26 = flags3;
                    int i27 = flags5;
                    Intent intent18 = intent2;
                    String str24 = pkgName2;
                    throw th;
                }
            } else {
                arrayMap = arrayMap2;
                instantAppPkgName = instantAppPkgName2;
                i = flags3;
                flags2 = flags5;
                packageManagerService = this;
                String pkgName4 = pkgName2;
                intent3 = intent2;
                try {
                } catch (Throwable th14) {
                    th = th14;
                    String str25 = pkgName4;
                    throw th;
                }
                try {
                    PackageParser.Package pkg = packageManagerService.mPackages.get(pkgName4);
                    List<ResolveInfo> result6 = null;
                    if (pkg != null) {
                        result6 = packageManagerService.filterIfNotSystemUser(packageManagerService.mActivities.queryIntentForPackage(intent3, resolvedType, flags2, pkg.activities, i), i);
                    }
                    if (result6 != null) {
                        if (result6.size() == 0) {
                        }
                        result = result6;
                    }
                    addInstant2 = packageManagerService.isInstantAppResolutionAllowed(intent3, null, i, true);
                    if (result6 == null) {
                        result = new ArrayList<>();
                    }
                    result = result6;
                } catch (Throwable th15) {
                    th = th15;
                    throw th;
                }
            }
            if (addInstant2) {
                result2 = packageManagerService.maybeAddInstantAppInstaller(result, intent3, resolvedType, flags2, i, resolveForStart);
            } else {
                result2 = result;
            }
            if (sortResult) {
                Collections.sort(result2, mResolvePrioritySorter);
            }
            return packageManagerService.applyPostResolutionFilter(result2, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, i, intent3);
        }
    }

    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        Intent intent2;
        String str;
        List<ResolveInfo> list = result;
        int i = userId;
        boolean alreadyResolvedLocally = (flags & DumpState.DUMP_VOLUMES) != 0;
        ResolveInfo localInstantApp = null;
        boolean blockResolution = false;
        if (!alreadyResolvedLocally) {
            intent2 = intent;
            str = resolvedType;
            List<ResolveInfo> instantApps = this.mActivities.queryIntent(intent2, str, 8388608 | flags | 64 | DumpState.DUMP_SERVICE_PERMISSIONS, i);
            int i2 = instantApps.size() - 1;
            while (true) {
                if (i2 < 0) {
                    break;
                }
                ResolveInfo info = instantApps.get(i2);
                PackageSetting ps = this.mSettings.mPackages.get(info.activityInfo.packageName);
                if (ps.getInstantApp(i)) {
                    boolean z = alreadyResolvedLocally;
                    if (((int) (getDomainVerificationStatusLPr(ps, i) >> 32)) == 3) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Instant app marked to never run; pkg: " + packageName);
                        }
                        blockResolution = true;
                    } else {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Found installed instant app; pkg: " + packageName);
                        }
                        localInstantApp = info;
                    }
                } else {
                    i2--;
                }
            }
        } else {
            intent2 = intent;
            str = resolvedType;
        }
        boolean z2 = alreadyResolvedLocally;
        ResolveInfo localInstantApp2 = localInstantApp;
        AuxiliaryResolveInfo auxiliaryResponse = null;
        if (!blockResolution) {
            if (localInstantApp2 == null) {
                Trace.traceBegin(262144, "resolveEphemeral");
                InstantAppRequest requestObject = new InstantAppRequest(null, intent2, str, null, i, null, resolveForStart);
                auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mInstantAppResolverConnection, requestObject);
                Trace.traceEnd(262144);
            } else {
                ApplicationInfo ai = localInstantApp2.activityInfo.applicationInfo;
                AuxiliaryResolveInfo auxiliaryResolveInfo = new AuxiliaryResolveInfo(null, ai.packageName, ai.longVersionCode, null);
                auxiliaryResponse = auxiliaryResolveInfo;
            }
        }
        if (intent.isWebIntent() && auxiliaryResponse == null) {
            return list;
        }
        PackageSetting ps2 = this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName);
        if (ps2 == null || ps2.getUserState().get(i) == null || !ps2.getUserState().get(i).isEnabled(this.mInstantAppInstallerActivity, 0)) {
            return list;
        }
        ResolveInfo ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
        ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps2.readUserState(i), i);
        ephemeralInstaller.match = 5799936;
        ephemeralInstaller.filter = new IntentFilter();
        if (intent.getAction() != null) {
            ephemeralInstaller.filter.addAction(intent.getAction());
        }
        if (!(intent.getData() == null || intent.getData().getPath() == null)) {
            ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
        }
        ephemeralInstaller.isInstantAppAvailable = true;
        ephemeralInstaller.isDefault = true;
        ephemeralInstaller.auxiliaryInfo = auxiliaryResponse;
        if (DEBUG_INSTANT) {
            Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
        }
        list.add(ephemeralInstaller);
        return list;
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        CrossProfileDomainInfo crossProfileDomainInfo;
        List<ResolveInfo> resultTargetUser;
        int i = sourceUserId;
        int i2 = parentUserId;
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", i)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser2 = this.mActivities.queryIntent(intent, resolvedType, flags, i2);
        if (resultTargetUser2 == null) {
            crossProfileDomainInfo = null;
        } else if (resultTargetUser2.isEmpty()) {
            List<ResolveInfo> list = resultTargetUser2;
            crossProfileDomainInfo = null;
        } else {
            CrossProfileDomainInfo result = null;
            int size = resultTargetUser2.size();
            int i3 = 0;
            while (i3 < size) {
                ResolveInfo riTargetUser = resultTargetUser2.get(i3);
                if (!riTargetUser.handleAllWebDataURI) {
                    PackageSetting ps = this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                    if (ps != null) {
                        int status = (int) (getDomainVerificationStatusLPr(ps, i2) >> 32);
                        if (result == null) {
                            resultTargetUser = resultTargetUser2;
                            CrossProfileDomainInfo result2 = new CrossProfileDomainInfo();
                            result2.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), i, i2);
                            result2.bestDomainVerificationStatus = status;
                            result = result2;
                        } else {
                            resultTargetUser = resultTargetUser2;
                            result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                        }
                        i3++;
                        resultTargetUser2 = resultTargetUser;
                        Intent intent2 = intent;
                    }
                }
                resultTargetUser = resultTargetUser2;
                i3++;
                resultTargetUser2 = resultTargetUser;
                Intent intent22 = intent;
            }
            if (result == null || result.bestDomainVerificationStatus != 3) {
                return result;
            }
            return null;
        }
        return crossProfileDomainInfo;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            return userInfo != null && userInfo.isEnabled();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((resolveInfos.get(i).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, boolean resolveForStart, int userId, Intent intent) {
        boolean z;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = resolveInfos;
        String str = ephemeralPkgName;
        int i = userId;
        boolean z2 = true;
        boolean blockInstant = intent.isWebIntent() && areWebInstantAppsDisabled();
        int i2 = resolveInfos.size() - 1;
        while (i2 >= 0) {
            ResolveInfo info = list.get(i2);
            if (info.isInstantAppAvailable && blockInstant) {
                list.remove(i2);
            } else if (!allowDynamicSplits || info.activityInfo == null || info.activityInfo.splitName == null || ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName)) {
                int i3 = filterCallingUid;
                z = z2;
                if (str != null && !str.equals(info.activityInfo.packageName) && ((!resolveForStart || !((intent.isWebIntent() || (intent.getFlags() & 2048) != 0) && intent.getPackage() == null && intent.getComponent() == null)) && (info.activityInfo.applicationInfo.isInstantApp() || (info.activityInfo.flags & 1048576) == 0))) {
                    list.remove(i2);
                }
                i2--;
                z2 = z;
                packageManagerService = this;
            } else if (packageManagerService.mInstantAppInstallerActivity == null) {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                }
                list.remove(i2);
            } else if (!blockInstant || !packageManagerService.isInstantApp(info.activityInfo.packageName, i)) {
                if (DEBUG_INSTALL) {
                    Slog.v(TAG, "Adding installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(packageManagerService.mInstantAppInstallerInfo);
                AuxiliaryResolveInfo auxiliaryResolveInfo = r12;
                AuxiliaryResolveInfo auxiliaryResolveInfo2 = new AuxiliaryResolveInfo(packageManagerService.findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, i), info.activityInfo.packageName, info.activityInfo.applicationInfo.longVersionCode, info.activityInfo.splitName);
                installerInfo.auxiliaryInfo = auxiliaryResolveInfo;
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                installerInfo.labelRes = info.resolveLabelResId();
                installerInfo.icon = info.resolveIconResId();
                z = true;
                installerInfo.isInstantAppAvailable = true;
                list.set(i2, installerInfo);
                i2--;
                z2 = z;
                packageManagerService = this;
            } else {
                list.remove(i2);
            }
            int i4 = filterCallingUid;
            z = z2;
            i2--;
            z2 = z;
            packageManagerService = this;
        }
        int i5 = filterCallingUid;
        return list;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR > 0) {
            for (int i = 0; i < NR; i++) {
                ResolveInfo info = result.get(i);
                if (info.activityInfo.splitName == null) {
                    return new ComponentName(packageName, info.activityInfo.name);
                }
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && resolveInfos.get(0).priority >= 0;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0265, code lost:
        if (DEBUG_PREFERRED != false) goto L_0x026b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x0269, code lost:
        if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x02ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x026b, code lost:
        android.util.Slog.v(TAG, "Filtered results with preferred activities. New candidates count: " + r8.size());
        r0 = r8.iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x028d, code lost:
        if (r0.hasNext() == false) goto L_0x02ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x028f, code lost:
        android.util.Slog.v(TAG, "  + " + r0.next().activityInfo);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x02ae, code lost:
        return r8;
     */
    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        int n;
        int numCandidates;
        int maxMatchPrio;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = candidates;
        CrossProfileDomainInfo crossProfileDomainInfo = xpDomainInfo;
        int i = userId;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            Slog.v(TAG, "Filtering results with preferred activities. Candidates count: " + candidates.size());
        }
        ArrayList<ResolveInfo> result = new ArrayList<>();
        ArrayList arrayList = new ArrayList();
        ArrayList arrayList2 = new ArrayList();
        ArrayList arrayList3 = new ArrayList();
        ArrayList arrayList4 = new ArrayList();
        ArrayList arrayList5 = new ArrayList();
        synchronized (packageManagerService.mPackages) {
            try {
                int count = candidates.size();
                int n2 = 0;
                while (n2 < count) {
                    ResolveInfo info = list.get(n2);
                    String packageName = info.activityInfo.packageName;
                    int count2 = count;
                    PackageSetting ps = packageManagerService.mSettings.mPackages.get(packageName);
                    if (ps != null) {
                        String str = packageName;
                        if (info.handleAllWebDataURI) {
                            arrayList5.add(info);
                        } else {
                            long packedStatus = packageManagerService.getDomainVerificationStatusLPr(ps, i);
                            PackageSetting packageSetting = ps;
                            int status = (int) (packedStatus >> 32);
                            int linkGeneration = (int) (packedStatus & -1);
                            if (status == 2) {
                                try {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        StringBuilder sb = new StringBuilder();
                                        sb.append("  + always: ");
                                        sb.append(info.activityInfo.packageName);
                                        sb.append(" : linkgen=");
                                        sb.append(linkGeneration);
                                        Slog.i(TAG, sb.toString());
                                    }
                                    info.preferredOrder = linkGeneration;
                                    arrayList.add(info);
                                } catch (Throwable th) {
                                    th = th;
                                    List<ResolveInfo> list2 = candidates;
                                    int i2 = userId;
                                    throw th;
                                }
                            } else if (status == 3) {
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    Slog.i(TAG, "  + never: " + info.activityInfo.packageName);
                                }
                                arrayList4.add(info);
                            } else if (status == 4) {
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    Slog.i(TAG, "  + always-ask: " + info.activityInfo.packageName);
                                }
                                arrayList3.add(info);
                            } else {
                                if (status != 0) {
                                    if (status == 1) {
                                    }
                                }
                                if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                    Slog.i(TAG, "  + ask: " + info.activityInfo.packageName);
                                }
                                arrayList2.add(info);
                            }
                        }
                    }
                    n2++;
                    count = count2;
                    packageManagerService = this;
                    list = candidates;
                    i = userId;
                }
                boolean includeBrowser = false;
                if (arrayList.size() > 0) {
                    result.addAll(arrayList);
                } else {
                    result.addAll(arrayList2);
                    if (!(crossProfileDomainInfo == null || crossProfileDomainInfo.bestDomainVerificationStatus == 3)) {
                        result.add(crossProfileDomainInfo.resolveInfo);
                    }
                    includeBrowser = true;
                }
                if (arrayList3.size() > 0) {
                    Iterator<ResolveInfo> it = result.iterator();
                    while (it.hasNext()) {
                        it.next().preferredOrder = 0;
                    }
                    n = 0;
                    result.addAll(arrayList3);
                    includeBrowser = true;
                } else {
                    n = 0;
                }
                if (includeBrowser) {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "   ...including browsers in candidate set");
                    }
                    if ((matchFlags & 131072) != 0) {
                        result.addAll(arrayList5);
                        boolean z = includeBrowser;
                        int i3 = userId;
                    } else {
                        try {
                            String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                            int numCandidates2 = arrayList5.size();
                            boolean z2 = includeBrowser;
                            int maxMatchPrio2 = 0;
                            ResolveInfo defaultBrowserMatch = null;
                            while (true) {
                                numCandidates = numCandidates2;
                                if (n >= numCandidates) {
                                    break;
                                }
                                int numCandidates3 = numCandidates;
                                ResolveInfo info2 = (ResolveInfo) arrayList5.get(n);
                                if (info2.priority > maxMatchPrio2) {
                                    maxMatchPrio2 = info2.priority;
                                }
                                if (info2.activityInfo.packageName.equals(defaultBrowserPackageName)) {
                                    if (defaultBrowserMatch != null) {
                                        maxMatchPrio = maxMatchPrio2;
                                        if (defaultBrowserMatch.priority < info2.priority) {
                                        }
                                    } else {
                                        maxMatchPrio = maxMatchPrio2;
                                    }
                                    if (debug) {
                                        Slog.v(TAG, "Considering default browser match " + info2);
                                    }
                                    defaultBrowserMatch = info2;
                                } else {
                                    maxMatchPrio = maxMatchPrio2;
                                }
                                n++;
                                numCandidates2 = numCandidates3;
                                maxMatchPrio2 = maxMatchPrio;
                                CrossProfileDomainInfo crossProfileDomainInfo2 = xpDomainInfo;
                            }
                            if (defaultBrowserMatch == null || defaultBrowserMatch.priority < maxMatchPrio2 || TextUtils.isEmpty(defaultBrowserPackageName)) {
                                result.addAll(arrayList5);
                            } else {
                                if (debug) {
                                    Slog.v(TAG, "Default browser match " + defaultBrowserMatch);
                                }
                                result.add(defaultBrowserMatch);
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    }
                    if (result.size() == 0) {
                        result.addAll(candidates);
                        result.removeAll(arrayList4);
                    } else {
                        List<ResolveInfo> list3 = candidates;
                    }
                } else {
                    List<ResolveInfo> list4 = candidates;
                    int i4 = userId;
                }
            } catch (Throwable th3) {
                th = th3;
                List<ResolveInfo> list5 = list;
                int i5 = i;
                throw th;
            }
        }
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        if (matchingFilters != null) {
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = matchingFilters.get(i);
                if ((filter.getFlags() & 2) != 0) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                }
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        List<CrossProfileIntentFilter> list = matchingFilters;
        if (list != null) {
            SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
            int size = matchingFilters.size();
            for (int i = 0; i < size; i++) {
                CrossProfileIntentFilter filter = list.get(i);
                int targetUserId = filter.getTargetUserId();
                boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
                boolean skipCurrentProfileIfNoMatchFound = (filter.getFlags() & 4) != 0;
                if (!skipCurrentProfile && !alreadyTriedUserIds.get(targetUserId) && (!skipCurrentProfileIfNoMatchFound || !matchInCurrentProfile)) {
                    ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                    if (resolveInfo != null) {
                        return resolveInfo;
                    }
                    alreadyTriedUserIds.put(targetUserId, true);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mActivities.queryIntent(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser != null && isUserEnabled(targetUserId)) {
            for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
                if ((resultTargetUser.get(i).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                    return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
                }
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        String className;
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                if (forwardingActivityInfo != null) {
                    forwardingActivityInfo.showUserIcon = targetUserId;
                } else {
                    Slog.i(TAG, "get forwarding Activity Info is null. sourceUserId:" + sourceUserId);
                }
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentActivityOptionsInternal(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        int specificsPos;
        ResolveInfo ri;
        ActivityInfo ai;
        ResolveInfo ri2;
        ComponentName comp;
        String str;
        PackageManagerService packageManagerService = this;
        Intent[] intentArr = specifics;
        Intent intent2 = intent;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int i2 = i;
        int flags2 = packageManagerService.updateFlagsForResolve(flags, i2, intent2, callingUid, false);
        packageManagerService.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent activity options");
        if (intent2 == null) {
            return Collections.emptyList();
        }
        String resultsAction = intent.getAction();
        List<ResolveInfo> results = packageManagerService.queryIntentActivitiesInternal(intent2, resolvedType, flags2 | 64, i);
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Query " + intent2 + ": " + results);
        }
        if (intentArr != null) {
            specificsPos = 0;
            int i3 = 0;
            while (i3 < intentArr.length) {
                Intent sintent = intentArr[i3];
                if (sintent != null) {
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i3 + ": " + sintent);
                    }
                    String action = sintent.getAction();
                    if (resultsAction != null && resultsAction.equals(action)) {
                        action = null;
                    }
                    ComponentName comp2 = sintent.getComponent();
                    if (comp2 == null) {
                        if (specificTypes != null) {
                            str = specificTypes[i3];
                        } else {
                            str = null;
                        }
                        ResolveInfo ri3 = packageManagerService.resolveIntent(sintent, str, flags2, i);
                        if (ri3 != null) {
                            ResolveInfo resolveInfo = packageManagerService.mResolveInfo;
                            ai = ri3.activityInfo;
                            ri = ri3;
                            comp2 = new ComponentName(ai.applicationInfo.packageName, ai.name);
                        }
                    } else {
                        ai = packageManagerService.getActivityInfo(comp2, flags2, i);
                        if (ai != null) {
                            ri = null;
                        }
                    }
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i3 + ": " + ai);
                    }
                    int N = results.size();
                    int j = specificsPos;
                    while (j < N) {
                        ResolveInfo sri = results.get(j);
                        if ((!sri.activityInfo.name.equals(comp2.getClassName()) || !sri.activityInfo.applicationInfo.packageName.equals(comp2.getPackageName())) && (action == null || !sri.filter.matchAction(action))) {
                            comp = comp2;
                        } else {
                            results.remove(j);
                            if (DEBUG_INTENT_MATCHING) {
                                StringBuilder sb = new StringBuilder();
                                comp = comp2;
                                sb.append("Removing duplicate item from ");
                                sb.append(j);
                                sb.append(" due to specific ");
                                sb.append(specificsPos);
                                Log.v(TAG, sb.toString());
                            } else {
                                comp = comp2;
                            }
                            if (ri == null) {
                                ri = sri;
                            }
                            j--;
                            N--;
                        }
                        j++;
                        comp2 = comp;
                        Intent intent3 = intent;
                    }
                    if (ri == null) {
                        ri2 = new ResolveInfo();
                        ri2.activityInfo = ai;
                    } else {
                        ri2 = ri;
                    }
                    results.add(specificsPos, ri2);
                    ri2.specificIndex = i3;
                    specificsPos++;
                }
                i3++;
                String str2 = resolvedType;
                packageManagerService = this;
                intentArr = specifics;
                Intent intent4 = intent;
            }
        } else {
            specificsPos = 0;
        }
        int N2 = results.size();
        for (int i4 = specificsPos; i4 < N2 - 1; i4++) {
            ResolveInfo rii = results.get(i4);
            if (rii.filter != null) {
                Iterator<String> it = rii.filter.actionsIterator();
                if (it != null) {
                    while (it.hasNext()) {
                        String action2 = it.next();
                        if (resultsAction == null || !resultsAction.equals(action2)) {
                            int j2 = i4 + 1;
                            while (j2 < N2) {
                                ResolveInfo rij = results.get(j2);
                                if (rij.filter != null && rij.filter.hasAction(action2)) {
                                    results.remove(j2);
                                    if (DEBUG_INTENT_MATCHING) {
                                        Log.v(TAG, "Removing duplicate item from " + j2 + " due to action " + action2 + " at " + i4);
                                    }
                                    j2--;
                                    N2--;
                                }
                                j2++;
                            }
                        }
                    }
                    if ((flags2 & 64) == 0) {
                        rii.filter = null;
                    }
                }
            }
        }
        if (caller != null) {
            int N3 = results.size();
            int i5 = 0;
            while (true) {
                if (i5 >= N3) {
                    break;
                }
                ActivityInfo ainfo = results.get(i5).activityInfo;
                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                    results.remove(i5);
                    break;
                }
                i5++;
            }
        }
        if ((flags2 & 64) == 0) {
            int N4 = results.size();
            int i6 = 0;
            while (true) {
                int i7 = i6;
                if (i7 >= N4) {
                    break;
                }
                results.get(i7).filter = null;
                i6 = i7 + 1;
            }
        }
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Result: " + results);
        }
        return results;
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false));
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Removed duplicated region for block: B:62:0x00cc  */
    public List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        Intent intent2;
        boolean isTargetExplicitlyVisibleToInstantApp;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int i2 = i;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, i2, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            ArrayList arrayList = new ArrayList(1);
            ActivityInfo ai = getReceiverInfo(comp2, flags2, i);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    ComponentName componentName = comp2;
                    if ((ai.flags & 2097152) == 0) {
                        isTargetExplicitlyVisibleToInstantApp = true;
                        if (!(isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp)))))) {
                            boolean z = isTargetInstantApp;
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            arrayList.add(ri);
                        }
                    }
                }
                isTargetExplicitlyVisibleToInstantApp = false;
                if (!(isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp)))))) {
                }
            }
            ActivityInfo activityInfo = ai;
            return applyPostResolutionFilter(arrayList, instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
        }
        synchronized (this.mPackages) {
            String pkgName = intent2.getPackage();
            if (pkgName == null) {
                List<ResolveInfo> applyPostResolutionFilter = applyPostResolutionFilter(this.mReceivers.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
                return applyPostResolutionFilter;
            }
            PackageParser.Package pkg = this.mPackages.get(pkgName);
            if (pkg != null) {
                PackageParser.Package packageR = pkg;
                List<ResolveInfo> applyPostResolutionFilter2 = applyPostResolutionFilter(this.mReceivers.queryIntentForPackage(intent2, resolvedType, flags2, pkg.receivers, i), instantAppPkgName, allowDynamicSplits, callingUid, false, i, intent2);
                return applyPostResolutionFilter2;
            }
            List<ResolveInfo> emptyList = Collections.emptyList();
            return emptyList;
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    public ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        List<ResolveInfo> query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false);
        if (query == null || query.size() < 1) {
            return null;
        }
        return query.get(0);
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentServicesInternal(intent, resolvedType, flags, userId, Binder.getCallingUid(), false));
    }

    /* access modifiers changed from: private */
    public List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        Intent intent2;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int i2 = i;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i2, false, false, "query intent receivers");
        int i3 = callingUid;
        String instantAppPkgName = getInstantAppPackageName(i3);
        int flags2 = updateFlagsForResolve(flags, i2, intent, i3, includeInstantApps);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ServiceInfo si = getServiceInfo(comp2, flags2, i);
            if (si != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (si.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (si.flags & 1048576) == 0;
                if (!(!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp)))) {
                    boolean z = isTargetHiddenFromInstantApp;
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    List<ResolveInfo> applyPostServiceResolutionFilter = applyPostServiceResolutionFilter(this.mServices.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName);
                    return applyPostServiceResolutionFilter;
                }
                String str = resolvedType;
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    PackageParser.Package packageR = pkg;
                    List<ResolveInfo> applyPostServiceResolutionFilter2 = applyPostServiceResolutionFilter(this.mServices.queryIntentForPackage(intent2, str, flags2, pkg.services, i), instantAppPkgName);
                    return applyPostServiceResolutionFilter2;
                }
                List<ResolveInfo> emptyList = Collections.emptyList();
                return emptyList;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (isEphemeralApp || (info.serviceInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.serviceInfo.splitName != null && !ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                AuxiliaryResolveInfo auxiliaryResolveInfo = new AuxiliaryResolveInfo(null, info.serviceInfo.packageName, info.serviceInfo.applicationInfo.longVersionCode, info.serviceInfo.splitName);
                installerInfo.auxiliaryInfo = auxiliaryResolveInfo;
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        Intent intent2;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, i, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp = intent.getComponent();
        if (comp != null || intent.getSelector() == null) {
            intent2 = intent;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        ComponentName comp2 = comp;
        if (comp2 != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ProviderInfo pi = getProviderInfo(comp2, flags2, i);
            if (pi != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp2.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (pi.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetHiddenFromInstantApp = (pi.flags & 1048576) == 0;
                if (!(!isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && isTargetHiddenFromInstantApp)))) {
                    boolean z = isTargetHiddenFromInstantApp;
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    list.add(ri);
                }
            }
            return list;
        }
        synchronized (this.mPackages) {
            try {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    List<ResolveInfo> applyPostContentProviderResolutionFilter = applyPostContentProviderResolutionFilter(this.mProviders.queryIntent(intent2, resolvedType, flags2, i), instantAppPkgName);
                    return applyPostContentProviderResolutionFilter;
                }
                String str = resolvedType;
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    PackageParser.Package packageR = pkg;
                    List<ResolveInfo> applyPostContentProviderResolutionFilter2 = applyPostContentProviderResolutionFilter(this.mProviders.queryIntentForPackage(intent2, str, flags2, pkg.providers, i), instantAppPkgName);
                    return applyPostContentProviderResolutionFilter2;
                }
                List<ResolveInfo> emptyList = Collections.emptyList();
                return emptyList;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (isEphemeralApp || (info.providerInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.providerInfo.splitName != null && !ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                AuxiliaryResolveInfo auxiliaryResolveInfo = new AuxiliaryResolveInfo(null, info.providerInfo.packageName, info.providerInfo.applicationInfo.longVersionCode, info.providerInfo.splitName);
                installerInfo.auxiliaryInfo = auxiliaryResolveInfo;
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public void onSystemServiceStartComplete() {
        synchronized (this.mPackages) {
            Slog.v(TAG, "onSystemServiceStartComplete() clear installed-packages cache");
            this.mCacheInstalledPackages = null;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:66:0x01de, code lost:
        android.util.Log.i(TAG, "getInstalledPackages cost " + (android.os.SystemClock.uptimeMillis() - r0) + " ms, flags: " + r13 + ", userId: " + r14 + ", callingUid: " + r8 + ", callingPid: " + r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x0219, code lost:
        return r4;
     */
    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        ArrayList<PackageInfo> list;
        int flags2 = mHwPMSEx.updateFlags(flags, userId);
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        int originFlag = flags2;
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDPACKAGES);
            if (getInstantAppPackageName(callingUid) != null) {
                ParceledListSlice<PackageInfo> emptyList = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList;
            } else if (!sUserManager.exists(userId)) {
                ParceledListSlice<PackageInfo> emptyList2 = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList2;
            } else {
                flags2 = updateFlagsForPackage(flags2, userId, null);
                boolean listUninstalled = (4202496 & flags2) != 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed packages");
                synchronized (this.mPackages) {
                    if (userId == 0) {
                        if (this.mCacheInstalledPackages != null) {
                            ParceledListSlice<PackageInfo> cache = (ParceledListSlice) this.mCacheInstalledPackages.get(Integer.valueOf(flags2));
                            if (cache != null) {
                                Slog.v(TAG, "getInstalledPackages() return cache, origin flags: " + originFlag);
                                Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                                return cache;
                            }
                        }
                    }
                    if (listUninstalled) {
                        list = new ArrayList<>(this.mSettings.mPackages.size());
                        for (PackageSetting ps : this.mSettings.mPackages.values()) {
                            if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                                if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                    PackageInfo pi = generatePackageInfo(ps, flags2, userId);
                                    if (pi != null) {
                                        list.add(pi);
                                    }
                                }
                            }
                        }
                    } else {
                        list = new ArrayList<>(this.mPackages.size());
                        for (PackageParser.Package p : this.mPackages.values()) {
                            PackageSetting ps2 = (PackageSetting) p.mExtras;
                            if (!filterSharedLibPackageLPr(ps2, callingUid, userId, flags2)) {
                                if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                    PackageInfo pi2 = generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                                    if (pi2 != null) {
                                        list.add(pi2);
                                    }
                                }
                            }
                        }
                    }
                    ParceledListSlice<PackageInfo> ret = new ParceledListSlice<>(list);
                    if (userId == 0 && this.mCacheInstalledPackages != null) {
                        this.mCacheInstalledPackages.put(Integer.valueOf(flags2), ret);
                        Slog.v(TAG, "getInstalledPackages() cache installed packages, origin flags: " + originFlag);
                    }
                }
            }
        } catch (Throwable th) {
            Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            throw th;
        }
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        PermissionsState permissionsState = ps.getPermissionsState();
        int numMatch = 0;
        for (int i = 0; i < permissions.length; i++) {
            if (permissionsState.hasPermission(permissions[i], userId)) {
                tmp[i] = true;
                numMatch++;
            } else {
                tmp[i] = false;
            }
        }
        if (numMatch != 0) {
            PackageInfo pi = generatePackageInfo(ps, flags, userId);
            if (pi != null) {
                if ((flags & 4096) == 0) {
                    if (numMatch == permissions.length) {
                        pi.requestedPermissions = permissions;
                    } else {
                        pi.requestedPermissions = new String[numMatch];
                        int numMatch2 = 0;
                        for (int i2 = 0; i2 < permissions.length; i2++) {
                            if (tmp[i2]) {
                                pi.requestedPermissions[numMatch2] = permissions[i2];
                                numMatch2++;
                            }
                        }
                    }
                }
                list.add(pi);
            }
        }
    }

    /* JADX WARNING: type inference failed for: r4v0 */
    /* JADX WARNING: type inference failed for: r4v1 */
    /* JADX WARNING: type inference failed for: r4v10 */
    /* JADX WARNING: Multi-variable type inference failed */
    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        String[] strArr = permissions;
        int i = userId;
        if (!sUserManager.exists(i)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, i, strArr);
        ? r4 = 1;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), i, true, false, "get packages holding permissions");
        boolean listUninstalled = (flags2 & 4202496) != 0;
        ArrayMap<String, PackageParser.Package> arrayMap3 = this.mPackages;
        synchronized (arrayMap3) {
            try {
                ArrayList<PackageInfo> list = new ArrayList<>();
                boolean[] tmpBools = new boolean[strArr.length];
                if (listUninstalled) {
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        addPackageHoldingPermissions(list, ps, strArr, tmpBools, flags2, i);
                    }
                } else {
                    for (PackageParser.Package pkg : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) pkg.mExtras;
                        if (ps2 != null) {
                            ArrayMap<String, PackageParser.Package> arrayMap4 = arrayMap3;
                            r4 = arrayMap4;
                            addPackageHoldingPermissions(list, ps2, strArr, tmpBools, flags2, i);
                            arrayMap2 = arrayMap4;
                        } else {
                            arrayMap2 = arrayMap3;
                        }
                        arrayMap3 = arrayMap2;
                    }
                }
                ArrayMap<String, PackageParser.Package> arrayMap5 = arrayMap3;
                ParceledListSlice<PackageInfo> parceledListSlice = new ParceledListSlice<>(list);
                return parceledListSlice;
            } catch (Throwable th) {
                th = th;
                arrayMap = r4;
                throw th;
            }
        }
    }

    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        ArrayList<ApplicationInfo> list;
        ParceledListSlice<ApplicationInfo> parceledListSlice;
        ApplicationInfo ai;
        int flags2 = mHwPMSEx.updateFlags(flags, userId);
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDAPPLICATIONS);
            if (getInstantAppPackageName(callingUid) != null) {
                ParceledListSlice<ApplicationInfo> emptyList = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList;
            } else if (!sUserManager.exists(userId)) {
                ParceledListSlice<ApplicationInfo> emptyList2 = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList2;
            } else {
                flags2 = updateFlagsForApplication(flags2, userId, null);
                boolean listUninstalled = (4202496 & flags2) != 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed application info");
                synchronized (this.mPackages) {
                    if (listUninstalled) {
                        list = new ArrayList<>(this.mSettings.mPackages.size());
                        for (PackageSetting ps : this.mSettings.mPackages.values()) {
                            int effectiveFlags = flags2;
                            if (ps.isSystem()) {
                                effectiveFlags |= DumpState.DUMP_CHANGES;
                            }
                            if (ps.pkg == null) {
                                ai = generateApplicationInfoFromSettingsLPw(ps.name, callingUid, effectiveFlags, userId);
                            } else if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                                if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                    ai = PackageParser.generateApplicationInfo(ps.pkg, effectiveFlags, ps.readUserState(userId), userId);
                                    if (ai != null) {
                                        ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
                                    }
                                }
                            }
                            if (ai != null) {
                                list.add(ai);
                            }
                        }
                    } else {
                        list = new ArrayList<>(this.mPackages.size());
                        for (PackageParser.Package p : this.mPackages.values()) {
                            if (p.mExtras != null) {
                                PackageSetting ps2 = (PackageSetting) p.mExtras;
                                if (!filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags2)) {
                                    if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                        ApplicationInfo ai2 = PackageParser.generateApplicationInfo(p, flags2, ps2.readUserState(userId), userId);
                                        if (ai2 != null) {
                                            ai2.packageName = resolveExternalPackageNameLPr(p);
                                            list.add(ai2);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    parceledListSlice = new ParceledListSlice<>(list);
                }
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return parceledListSlice;
            }
        } catch (Throwable th) {
            Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            throw th;
        }
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps == null) {
                return null;
            }
            ParceledListSlice<InstantAppInfo> parceledListSlice = new ParceledListSlice<>(instantApps);
            return parceledListSlice;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:21:0x0057, code lost:
        return r3;
     */
    public boolean isInstantApp(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            boolean returnAllowed = false;
            if (ps != null && !ps.getInstantApp(userId)) {
                return false;
            }
            if (ps != null && (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId) || this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId))) {
                returnAllowed = true;
            }
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        byte[] instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        boolean instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        PackageParser.Package pkg = this.mPackages.get(packageName);
        return pkg != null && UserHandle.getAppId(uid) == pkg.applicationInfo.uid;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        ArrayList<ApplicationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (PackageParser.Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    boolean matchesAware = false;
                    boolean matchesUnaware = (262144 & flags) != 0 && !p.applicationInfo.isDirectBootAware();
                    if ((524288 & flags) != 0 && p.applicationInfo.isDirectBootAware()) {
                        matchesAware = true;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && (matchesUnaware || matchesAware))) {
                        PackageSetting ps = this.mSettings.mPackages.get(p.packageName);
                        if (ps != null) {
                            ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                finalList.add(ai);
                            }
                        }
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        return resolveContentProviderInternal(name, flags, ((ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class)).handleUserForClone(name, userId));
    }

    /* access modifiers changed from: private */
    public ProviderInfo resolveContentProviderInternal(String name, int flags, int userId) {
        PackageSetting packageSetting;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, name);
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            PackageParser.Provider provider = this.mProvidersByAuthority.get(name);
            if (provider != null) {
                packageSetting = this.mSettings.mPackages.get(provider.owner.packageName);
            } else {
                packageSetting = null;
            }
            PackageSetting ps = packageSetting;
            if (ps == null) {
                return null;
            }
            if (!this.mSettings.isEnabledAndMatchLPr(provider.info, flags2, userId)) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, new ComponentName(provider.info.packageName, provider.info.name), 4, userId)) {
                return null;
            }
            ProviderInfo generateProviderInfo = PackageParser.generateProviderInfo(provider, flags2, ps.readUserState(userId), userId);
            return generateProviderInfo;
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                int userId = UserHandle.getCallingUserId();
                for (Map.Entry<String, PackageParser.Provider> entry : this.mProvidersByAuthority.entrySet()) {
                    PackageParser.Provider p = entry.getValue();
                    PackageSetting ps = this.mSettings.mPackages.get(p.owner.packageName);
                    if (ps != null && p.syncable && (!this.mSafeMode || (p.info.applicationInfo.flags & 1) != 0)) {
                        ProviderInfo info = PackageParser.generateProviderInfo(p, 0, ps.readUserState(userId), userId);
                        if (info != null) {
                            outNames.add(entry.getKey());
                            outInfo.add(info);
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:58:0x00e7, code lost:
        if (r14 == null) goto L_0x00f4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x00e9, code lost:
        java.util.Collections.sort(r14, mProviderInitOrderSorter);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x00f3, code lost:
        return new android.content.pm.ParceledListSlice<>(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x00f8, code lost:
        return android.content.pm.ParceledListSlice.emptyList();
     */
    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int i;
        Iterator<PackageParser.Provider> i2;
        ArrayList<ProviderInfo> finalList;
        String str = processName;
        String str2 = metaDataKey;
        int callingUid = Binder.getCallingUid();
        if (str != null) {
            i = UserHandle.getUserId(uid);
        } else {
            i = UserHandle.getCallingUserId();
        }
        int userId = i;
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForComponent(flags, userId, str);
        synchronized (this.mPackages) {
            Iterator<PackageParser.Provider> i3 = this.mProviders.mProviders.values().iterator();
            ArrayList<ProviderInfo> finalList2 = null;
            while (i3.hasNext()) {
                try {
                    PackageParser.Provider p = i3.next();
                    PackageSetting ps = this.mSettings.mPackages.get(p.owner.packageName);
                    if (!(ps == null || p.info.authority == null)) {
                        if (str != null) {
                            if (!p.info.processName.equals(str)) {
                                int i4 = uid;
                            } else if (UserHandle.isSameApp(p.info.applicationInfo.uid, uid)) {
                            }
                            i2 = i3;
                            i3 = i2;
                        } else {
                            int i5 = uid;
                        }
                        if (this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId)) {
                            if (str2 == null || (p.metaData != null && p.metaData.containsKey(str2))) {
                                i2 = i3;
                                PackageSetting ps2 = ps;
                                if (!filterAppAccessLPr(ps, callingUid, new ComponentName(p.info.packageName, p.info.name), 4, userId)) {
                                    if (finalList2 == null) {
                                        finalList = new ArrayList<>(3);
                                    } else {
                                        finalList = finalList2;
                                    }
                                    try {
                                        ProviderInfo info = PackageParser.generateProviderInfo(p, flags2, ps2.readUserState(userId), userId);
                                        if (info != null) {
                                            finalList.add(info);
                                        }
                                        finalList2 = finalList;
                                        i3 = i2;
                                    } catch (Throwable th) {
                                        th = th;
                                        throw th;
                                    }
                                }
                            } else {
                                i2 = i3;
                            }
                            i3 = i2;
                        }
                    }
                    i2 = i3;
                    i3 = i2;
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            }
        }
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (component == null) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            }
            InstrumentationInfo generateInstrumentationInfo = PackageParser.generateInstrumentationInfo(this.mInstrumentation.get(component), flags);
            return generateInstrumentationInfo;
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        ArrayList<InstrumentationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Instrumentation p : this.mInstrumentation.values()) {
                if (targetPackage == null || targetPackage.equals(p.info.targetPackage)) {
                    InstrumentationInfo ii = PackageParser.generateInstrumentationInfo(p, flags);
                    if (ii != null) {
                        finalList.add(ii);
                    }
                }
            }
        }
        return finalList;
    }

    private void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        Trace.traceBegin(262144, "scanDir [" + scanDir.getAbsolutePath() + "]");
        try {
            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        scanDirLI(dir, parseFlags, scanFlags, currentTime, 0);
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        if (HWFLOW) {
            this.mStartTimer = SystemClock.uptimeMillis();
        }
        File[] files = scanDir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, "No files in app dir " + scanDir);
            return;
        }
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + scanDir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags) + " hwFlags=0x" + Integer.toHexString(hwFlags));
        }
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x02a5, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x02a6, code lost:
        r15 = r23;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x00ae, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00af, code lost:
        r15 = r23;
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:100:0x023f A[Catch:{ Throwable -> 0x0298, all -> 0x0295 }] */
    /* JADX WARNING: Removed duplicated region for block: B:115:0x02a5 A[ExcHandler: Throwable (th java.lang.Throwable), Splitter:B:1:0x0018] */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x021f A[Catch:{ Throwable -> 0x0298, all -> 0x0295 }] */
    public void scanPackageFilesLI(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        Throwable th;
        boolean isPackage;
        ParallelPackageParser.ParseResult parseResult;
        int errorCode;
        boolean z;
        int errorCode2;
        File[] fileArr = files;
        int i = hwFlags;
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        ParallelPackageParser parallelPackageParser2 = parallelPackageParser;
        try {
            int length = fileArr.length;
            int fileCount = 0;
            int fileCount2 = 0;
            while (true) {
                isPackage = true;
                if (fileCount2 >= length) {
                    break;
                }
                File file = fileArr[fileCount2];
                if ((!PackageParser.isApkFile(file) && !file.isDirectory()) || PackageInstallerService.isStageName(file.getName())) {
                    isPackage = false;
                }
                if (isPackage) {
                    if (!mHwPMSEx.isUninstallApk(file.getPath() + ".apk")) {
                        HwCustEmergDataManager emergDataManager = HwCustEmergDataManager.getDefault();
                        if (emergDataManager != null && !emergDataManager.isEmergencyState() && emergDataManager.getEmergencyPkgName().contains(file.getName())) {
                            Log.i(TAG, "dont scan EmergencyData.apk");
                        } else if ((134217728 & i) == 0) {
                            try {
                                parallelPackageParser2.submit(file, parseFlags);
                                fileCount++;
                                fileCount2++;
                            } catch (Throwable th2) {
                                th = th2;
                                th = null;
                                $closeResource(th, parallelPackageParser2);
                                throw th;
                            }
                        } else if (DEBUG_PACKAGE_SCANNING) {
                            Slog.w(TAG, "Ignore illegal APK: " + file.getAbsolutePath());
                        }
                    }
                }
                int i2 = parseFlags;
                fileCount2++;
            }
            int i3 = parseFlags;
            int fileCount3 = fileCount;
            while (fileCount3 > 0) {
                ParallelPackageParser.ParseResult parseResult2 = parallelPackageParser2.take();
                PackageParser.PackageParserException packageParserException = parseResult2.throwable;
                if (packageParserException == null) {
                    if (parseResult2.pkg.applicationInfo.isStaticSharedLibrary()) {
                        renameStaticSharedLibraryPackage(parseResult2.pkg);
                    }
                    if (true == isPackage) {
                        int fixedScanFlags = scanFlags;
                        try {
                            if (!parseResult2.pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
                                try {
                                    if (locationIsProduct(parseResult2.pkg.codePath)) {
                                        fixedScanFlags |= 2097152;
                                    } else if (locationIsVendor(parseResult2.pkg.codePath)) {
                                        fixedScanFlags |= 1048576;
                                    }
                                } catch (PackageManagerException e) {
                                    e = e;
                                    PackageParser.PackageParserException packageParserException2 = packageParserException;
                                    parseResult = parseResult2;
                                    errorCode = e.error;
                                    Slog.w(TAG, "Failed to scan " + parseResult.scanFile + ": " + e.getMessage());
                                    HwPackageManagerServiceUtils.reportException(HwPackageManagerServiceUtils.EVENT_APK_LOST_EXCEPTION, "Failed to scan " + parseResult.scanFile + ": " + e.getMessage());
                                    if ((scanFlags & 131072) == 0) {
                                    }
                                    fileCount3--;
                                    isPackage = z;
                                }
                            }
                            parseResult2.pkg.applicationInfo.hwFlags = i;
                            int currHwFlags = i;
                            if (mHwPMSEx.isPreRemovableApp(parseResult2.pkg.codePath) && (currHwFlags & DumpState.DUMP_HANDLE) == 0) {
                                currHwFlags |= DumpState.DUMP_HANDLE;
                                parseResult2.pkg.applicationInfo.hwFlags = currHwFlags;
                            }
                            errorCode2 = 1;
                            Throwable th3 = packageParserException;
                            parseResult = parseResult2;
                            try {
                                scanPackageChildLI(parseResult2.pkg, i3, fixedScanFlags, currentTime, null, currHwFlags);
                            } catch (PackageManagerException e2) {
                                e = e2;
                            }
                        } catch (PackageManagerException e3) {
                            e = e3;
                            Throwable th4 = packageParserException;
                            parseResult = parseResult2;
                            errorCode = e.error;
                            Slog.w(TAG, "Failed to scan " + parseResult.scanFile + ": " + e.getMessage());
                            if (parseResult.scanFile != null && parseResult.scanFile.toString().startsWith("/data/app")) {
                                HwPackageManagerServiceUtils.reportException(HwPackageManagerServiceUtils.EVENT_APK_LOST_EXCEPTION, "Failed to scan " + parseResult.scanFile + ": " + e.getMessage());
                            }
                            if ((scanFlags & 131072) == 0) {
                            }
                            fileCount3--;
                            isPackage = z;
                        }
                    } else {
                        errorCode2 = 1;
                        Throwable th5 = packageParserException;
                        parseResult = parseResult2;
                    }
                    errorCode = errorCode2;
                } else {
                    PackageParser.PackageParserException e4 = packageParserException;
                    parseResult = parseResult2;
                    if (e4 instanceof PackageParser.PackageParserException) {
                        errorCode = e4.error;
                        Slog.w(TAG, "Failed to parse " + parseResult.scanFile + ": " + e4.getMessage());
                        if (parseResult.scanFile != null && parseResult.scanFile.toString().startsWith("/data/app")) {
                            HwPackageManagerServiceUtils.reportException(HwPackageManagerServiceUtils.EVENT_APK_LOST_EXCEPTION, "Failed to parse " + parseResult.scanFile + ": " + e.getMessage());
                        }
                    } else {
                        if (parseResult.scanFile != null && parseResult.scanFile.toString().startsWith("/data/app")) {
                            HwPackageManagerServiceUtils.reportException(HwPackageManagerServiceUtils.EVENT_APK_LOST_EXCEPTION, "Unexpected exception occurred while parsing " + parseResult.scanFile + ": " + e4.getMessage());
                        }
                        throw new IllegalStateException("Unexpected exception occurred while parsing " + parseResult.scanFile, e4);
                    }
                }
                if ((scanFlags & 131072) == 0) {
                    z = true;
                    if (errorCode != 1) {
                        PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                        removeCodePathLI(parseResult.scanFile);
                    }
                } else {
                    z = true;
                }
                fileCount3--;
                isPackage = z;
            }
            $closeResource(null, parallelPackageParser2);
        } catch (Throwable th6) {
            th = th6;
            int i4 = parseFlags;
            th = null;
            $closeResource(th, parallelPackageParser2);
            throw th;
        }
    }

    private static /* synthetic */ void $closeResource(Throwable x0, AutoCloseable x1) {
        if (x0 != null) {
            try {
                x1.close();
            } catch (Throwable th) {
                x0.addSuppressed(th);
            }
        } else {
            x1.close();
        }
    }

    public static void reportSettingsProblem(int priority, String msg) {
        PackageManagerServiceUtils.logCriticalInfo(priority, msg);
    }

    private void collectCertificatesLI(PackageSetting ps, PackageParser.Package pkg, boolean forceCollect, boolean skipVerify) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : PackageManagerServiceUtils.getLastModifiedTime(pkg);
        if (ps == null || forceCollect || !ps.codePathString.equals(pkg.codePath) || ps.timeStamp != lastModifiedTime || isCompatSignatureUpdateNeeded(pkg) || isRecoverSignatureUpdateNeeded(pkg)) {
            StringBuilder sb = new StringBuilder();
            sb.append(pkg.codePath);
            sb.append(" changed; collecting certs");
            sb.append(forceCollect ? " (forced)" : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
            Slog.i(TAG, sb.toString());
        } else if (ps.signatures.mSigningDetails.signatures == null || ps.signatures.mSigningDetails.signatures.length == 0 || ps.signatures.mSigningDetails.signatureSchemeVersion == 0) {
            Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.,skipVerify=" + skipVerify);
        } else {
            pkg.mSigningDetails = new PackageParser.SigningDetails(ps.signatures.mSigningDetails);
            return;
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, skipVerify);
            Trace.traceEnd(262144);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    private void maybeClearProfilesForUpgradesLI(PackageSetting originalPkgSetting, PackageParser.Package currentPkg) {
        if (originalPkgSetting != null && isUpgrade() && originalPkgSetting.versionCode != ((long) currentPkg.mVersionCode)) {
            clearAppProfilesLIF(currentPkg, -1);
            if (DEBUG_INSTALL) {
                Slog.d(TAG, originalPkgSetting.name + " clear profile due to version change " + originalPkgSetting.versionCode + " != " + currentPkg.mVersionCode);
            }
        }
    }

    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageTracedLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage [" + scanFile.toString() + "]");
        try {
            return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* access modifiers changed from: protected */
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        File file = scanFile;
        int hwFlags2 = hwFlags;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx.isUninstallApk(scanFile.getPath() + ".apk")) {
            return null;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Parsing: " + file);
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        pp.setCacheDir(this.mCacheDir);
        if ((134217728 & hwFlags2) != 0) {
            if (DEBUG_PACKAGE_SCANNING) {
                Slog.w(TAG, "Ignore illegal APK: " + scanFile.getAbsolutePath());
            }
            return null;
        }
        Trace.traceBegin(262144, "parsePackage");
        int i = parseFlags;
        try {
            PackageParser.Package pkg = pp.parsePackage(file, i, true, hwFlags2);
            int currHwFlags = pkg.applicationInfo.hwFlags;
            if (mHwPMSEx.isPreRemovableApp(pkg.codePath) && (currHwFlags & DumpState.DUMP_HANDLE) == 0) {
                hwFlags2 |= DumpState.DUMP_HANDLE;
                pkg.applicationInfo.hwFlags = currHwFlags | DumpState.DUMP_HANDLE;
            }
            int hwFlags3 = hwFlags2;
            Trace.traceEnd(262144);
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                renameStaticSharedLibraryPackage(pkg);
            }
            int fixedScanFlags = scanFlags;
            if (!pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
                if (locationIsProduct(pkg.codePath)) {
                    fixedScanFlags |= 2097152;
                } else if (locationIsVendor(pkg.codePath)) {
                    fixedScanFlags |= 1048576;
                }
            }
            return scanPackageChildLI(pkg, i, fixedScanFlags, currentTime, user, hwFlags3);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable pkg2) {
            Trace.traceEnd(262144);
            throw pkg2;
        }
    }

    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        PackageParser.Package packageR = pkg;
        int i = scanFlags;
        int i2 = hwFlags;
        if (packageR != null && mHwPMSEx.isInMspesForbidInstallPackageList(packageR.packageName)) {
            return null;
        }
        if (packageR != null && mHwPMSEx.isInMultiWinWhiteList(packageR.packageName)) {
            pkg.forceResizeableAllActivity();
        }
        if (packageR != null && DISABLE_SPLIT_PKG.contains(packageR.packageName)) {
            pkg.clearResizeableAllActivity();
        }
        if ((i & 1024) != 0) {
            i &= -1025;
        } else if (packageR.childPackages != null && packageR.childPackages.size() > 0) {
            i |= 1024;
        }
        int scanFlags2 = i;
        boolean isNewInstall = (1073741824 & i2) != 0 && !this.mPackages.containsKey(packageR.packageName);
        PackageParser.Package scannedPkg = addForInitLI(packageR, parseFlags, scanFlags2, currentTime, user, i2);
        int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
        for (int i3 = 0; i3 < childCount; i3++) {
            addForInitLI((PackageParser.Package) packageR.childPackages.get(i3), parseFlags, scanFlags2, currentTime, user, i2);
        }
        if ((scanFlags2 & 1024) != 0) {
            return scanPackageChildLI(packageR, parseFlags, scanFlags2, currentTime, user, i2);
        }
        if (!(!this.mCotaFlag || this.mTempPkgList == null || scannedPkg == null)) {
            this.mTempPkgList.add(packageR);
        }
        mHwPMSEx.doPostScanInstall(packageR, user, isNewInstall, i2);
        return scannedPkg;
    }

    private boolean canSkipFullPackageVerification(PackageParser.Package pkg) {
        if (!canSkipFullApkVerification(pkg.baseCodePath)) {
            return false;
        }
        if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            for (String canSkipFullApkVerification : pkg.splitCodePaths) {
                if (!canSkipFullApkVerification(canSkipFullApkVerification)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean canSkipFullApkVerification(String apkPath) {
        try {
            byte[] rootHashObserved = VerityUtils.generateFsverityRootHash(apkPath);
            if (rootHashObserved == null) {
                return false;
            }
            synchronized (this.mInstallLock) {
                this.mInstaller.assertFsverityRootHashMatches(apkPath, rootHashObserved);
            }
            return true;
        } catch (Installer.InstallerException | IOException | DigestException | NoSuchAlgorithmException e) {
            Slog.w(TAG, "Error in fsverity check. Fallback to full apk verification.", e);
            return false;
        }
    }

    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return addForInitLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX INFO: finally extract failed */
    /* JADX WARNING: Code restructure failed: missing block: B:100:0x01ec, code lost:
        r7 = (java.lang.String) r13.childPackageNames.get(r11);
        r16 = false;
        r17 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x01f8, code lost:
        r30 = r3;
        r3 = r17;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x01fe, code lost:
        if (r3 >= r2) goto L_0x0220;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x0200, code lost:
        r31 = r2;
        r32 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0212, code lost:
        if (((android.content.pm.PackageParser.Package) r9.childPackages.get(r3)).packageName.equals(r7) == false) goto L_0x0217;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x0214, code lost:
        r16 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x0217, code lost:
        r17 = r3 + 1;
        r3 = r30;
        r2 = r31;
        r5 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x0220, code lost:
        r31 = r2;
        r32 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x0224, code lost:
        if (r16 != false) goto L_0x022b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x0226, code lost:
        r10.mSettings.removeDisabledSystemPackageLPw(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x022b, code lost:
        r11 = r11 + 1;
        r3 = r30;
        r2 = r31;
        r5 = r32;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x0235, code lost:
        r31 = r2;
        r30 = r3;
        r32 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0246, code lost:
        if (r9 != r10.mPlatformPackage) goto L_0x024b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x0248, code lost:
        r21 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x024b, code lost:
        r21 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x024d, code lost:
        r5 = r12;
        r7 = r13;
        r29 = r14;
        r3 = r15;
        r11 = new com.android.server.pm.PackageManagerService.ScanRequest(r9, r6, null, r7, null, null, null, r8, r39, r21, r42);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:?, code lost:
        r11 = mHwPMSEx.adjustScanFlagForApk(r9, r39);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:?, code lost:
        applyPolicy(r9, r8, r11, r10.mPlatformPackage, r1);
        scanPackageOnlyLI(r11, r10.mFactoryTest, -1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x0275, code lost:
        r7 = r13;
        r3 = r15;
        r11 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x027a, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x027b, code lost:
        r12 = r0;
        r13 = r7;
        r14 = r26;
        r15 = r25;
        r7 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0282, code lost:
        if (r15 == false) goto L_0x0290;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x028c, code lost:
        if (r7.codePathString.equals(r9.codePath) != false) goto L_0x0290;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x028e, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x0290, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x0291, code lost:
        r16 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x0293, code lost:
        if (r15 == false) goto L_0x02a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x029d, code lost:
        if (r37.getLongVersionCode() <= r7.versionCode) goto L_0x02a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x029f, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x02a1, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x02a2, code lost:
        r17 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x02a6, code lost:
        if (r10.mIsUpgrade == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02a8, code lost:
        if (r23 == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x02aa, code lost:
        if (r14 == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x02b4, code lost:
        if (mHwPMSEx.isInValidApkPatchFile(r7.codePath, r8) == false) goto L_0x02b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x02b6, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02b8, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x02b9, code lost:
        r18 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02bb, code lost:
        if (r23 == false) goto L_0x02c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x02bd, code lost:
        if (r14 == false) goto L_0x02c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x02bf, code lost:
        if (r16 == false) goto L_0x02c3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x02c1, code lost:
        if (r17 != false) goto L_0x02c5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:148:0x02c3, code lost:
        if (r18 == false) goto L_0x02c7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x02c5, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02c7, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x02c8, code lost:
        r19 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02cb, code lost:
        if (r19 == false) goto L_0x033e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02cd, code lost:
        r2 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02cf, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:?, code lost:
        r10.mPackages.remove(r7.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x02d7, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02d8, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package updated; name: " + r7.name + "; " + r7.versionCode + " --> " + r37.getLongVersionCode() + "; " + r7.codePathString + " --> " + r9.codePath);
        createInstallArgsForExisting(packageFlagsToInstallFlags(r7), r7.codePathString, r7.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r7)).cleanUpResourcesLI();
        r4 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x032e, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:?, code lost:
        r10.mSettings.enableSystemPackageLPw(r7.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x0336, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x033e, code lost:
        if (r23 == false) goto L_0x039e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0340, code lost:
        if (r14 == false) goto L_0x039e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x0342, code lost:
        if (r19 != false) goto L_0x039e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x0344, code lost:
        mHwPMSEx.addUpdatedRemoveableAppFlag(r9.codePath, r9.packageName);
        r2 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x034f, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0358, code lost:
        if (r10.mPackages.containsKey(r9.packageName) != false) goto L_0x0361;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x035a, code lost:
        r10.mPackages.put(r9.packageName, r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0361, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x039a, code lost:
        throw new com.android.server.pm.PackageManagerException(5, "Package " + r9.packageName + " at " + r9.codePath + " ignored: updated version " + r7.versionCode + " better than this " + r37.getLongVersionCode());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x039e, code lost:
        if (r14 == false) goto L_0x03b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x03a8, code lost:
        if (mHwPMSEx.needAddUpdatedRemoveableAppFlag(r9.packageName) == false) goto L_0x03b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x03aa, code lost:
        r1 = (r1 & -33554433) | 67108864;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x03b1, code lost:
        r6 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x03b4, code lost:
        if (r10.mIsUpgrade == false) goto L_0x044f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x03b6, code lost:
        if (r15 == false) goto L_0x044f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x03ba, code lost:
        if (r10.mCustPms == null) goto L_0x044f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x03c5, code lost:
        if (r10.mCustPms.isListedApp(r9.packageName) != -1) goto L_0x03cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x03c7, code lost:
        r33 = r12;
        r12 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x03cc, code lost:
        r5 = createInstallArgsForExisting(packageFlagsToInstallFlags(r7), r7.codePathString, r7.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r7));
        r1 = r10.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x03de, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:?, code lost:
        r5.cleanUpResourcesLI();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x03e2, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x03e3, code lost:
        r22 = r5;
        r33 = r12;
        r12 = r6;
        removePackageDataLIF(r7, null, new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r10), r10.mCustPms.isListedApp(r9.packageName), true);
        r10.mSettings.removeDisabledSystemPackageLPw(r9.packageName);
        r10.mSettings.removePackageLPw(r9.packageName);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "package " + r9.packageName + " no longer needed; Don't install & wipe its data");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:205:0x0444, code lost:
        throw new com.android.server.pm.PackageManagerException(-5, "abort installing old version " + r9.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x0445, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x0446, code lost:
        r22 = r5;
        r33 = r12;
        r12 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x044c, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:0x044d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x044f, code lost:
        r33 = r12;
        r12 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:0x0452, code lost:
        r6 = com.android.server.pm.PackageManagerServiceUtils.isApkVerificationForced(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x0458, code lost:
        if ((r8 & 16) != 0) goto L_0x046f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x045d, code lost:
        if ((33554432 & r12) != 0) goto L_0x046f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:217:0x045f, code lost:
        if (r6 == false) goto L_0x0467;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x0465, code lost:
        if (canSkipFullPackageVerification(r37) != false) goto L_0x046f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x0469, code lost:
        if (r10.mIsPrePUpgrade == false) goto L_0x046c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:222:0x046c, code lost:
        r27 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:223:0x046f, code lost:
        r27 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:224:0x0471, code lost:
        r5 = r27;
        collectCertificatesLI(r7, r9, r6, r5);
        mHwPMSEx.checkIllegalSysApk(r9, r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:225:0x047c, code lost:
        if (r7 == null) goto L_0x049b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:227:0x0486, code lost:
        if (r7.codePathString.equals(r9.codePath) == false) goto L_0x049b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:229:0x0497, code lost:
        if (r7.timeStamp != new java.io.File(r9.codePath).lastModified()) goto L_0x049b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:230:0x0499, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:231:0x049b, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:232:0x049c, code lost:
        r4 = r0;
        mHwPMSEx.checkHwCertification(r9, r4);
        mHwPMSEx.replaceSignatureIfNeeded(r7, r9, true, r4);
        maybeClearProfilesForUpgradesLI(r7, r9);
        r20 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:233:0x04ad, code lost:
        if (r23 == false) goto L_0x0616;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:234:0x04af, code lost:
        if (r14 != false) goto L_0x0616;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:235:0x04b1, code lost:
        if (r15 == false) goto L_0x0616;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:237:0x04b7, code lost:
        if (r7.isSystem() != false) goto L_0x0616;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:239:0x04c4, code lost:
        if (r9.mSigningDetails.checkCapability(r7.signatures.mSigningDetails, 1) != false) goto L_0x055b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:241:0x04d2, code lost:
        if (r7.signatures.mSigningDetails.checkCapability(r9.mSigningDetails, 8) != false) goto L_0x055b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:242:0x04d4, code lost:
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, "System package signature mismatch; name: " + r7.name);
        r2 = freezePackage(r9.packageName, "scanPackageInternalLI");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:245:0x04f6, code lost:
        r34 = r2;
        r0 = true;
        r21 = r4;
        r22 = r5;
        r24 = r6;
        r35 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:247:?, code lost:
        deletePackageLIF(r9.packageName, null, true, null, 0, null, false, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:248:0x0522, code lost:
        r1 = r34;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:249:0x0524, code lost:
        if (r1 == null) goto L_0x052a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:250:0x0526, code lost:
        $closeResource(null, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:251:0x052a, code lost:
        r9 = r37;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:252:0x0531, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:253:0x0532, code lost:
        r1 = r34;
        r2 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:254:0x0536, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:255:0x0537, code lost:
        r1 = r34;
        r6 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:256:0x053b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:257:0x053c, code lost:
        r1 = r2;
        r21 = r4;
        r22 = r5;
        r24 = r6;
        r35 = r7;
        r2 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:258:0x0547, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:259:0x0548, code lost:
        r1 = r2;
        r21 = r4;
        r22 = r5;
        r24 = r6;
        r35 = r7;
        r6 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:261:?, code lost:
        throw r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:262:0x0553, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:263:0x0554, code lost:
        r2 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:264:0x0555, code lost:
        if (r1 != null) goto L_0x0557;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:265:0x0557, code lost:
        $closeResource(r2, r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:266:0x055a, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:267:0x055b, code lost:
        r0 = true;
        r21 = r4;
        r22 = r5;
        r24 = r6;
        r35 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:268:0x0564, code lost:
        if (r17 == false) goto L_0x05c7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:269:0x0566, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("System package enabled; name: ");
        r2 = r35;
        r1.append(r2.name);
        r1.append("; ");
        r1.append(r2.versionCode);
        r1.append(" --> ");
        r1.append(r37.getLongVersionCode());
        r1.append("; ");
        r1.append(r2.codePathString);
        r1.append(" --> ");
        r9 = r37;
        r1.append(r9.codePath);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(5, r1.toString());
        r1 = createInstallArgsForExisting(packageFlagsToInstallFlags(r2), r2.codePathString, r2.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r2));
        r3 = r10.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:270:0x05be, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:272:?, code lost:
        r1.cleanUpResourcesLI();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:273:0x05c2, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:278:0x05c7, code lost:
        r9 = r37;
        r2 = r35;
        r20 = true;
        mHwPMSEx.addUpdatedRemoveableAppFlag(r9.codePath, r2.name);
        com.android.server.pm.PackageManagerServiceUtils.logCriticalInfo(4, "System package disabled; name: " + r2.name + "; old: " + r2.codePathString + " @ " + r2.versionCode + "; new: " + r9.codePath + " @ " + r9.codePath);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:279:0x0616, code lost:
        r21 = r4;
        r22 = r5;
        r24 = r6;
        r2 = r7;
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:280:0x061e, code lost:
        r25 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:281:0x0620, code lost:
        r1 = scanPackageNewLI(r9, r38, r11 | 2, r40, r42, r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:282:0x062f, code lost:
        if (r20 == false) goto L_0x0640;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:283:0x0631, code lost:
        r2 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:284:0x0633, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:286:?, code lost:
        r10.mSettings.disableSystemPackageLPw(r9.packageName, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:287:0x063b, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:292:0x0640, code lost:
        mHwPMSEx.addPreinstalledPkgToList(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:293:0x0645, code lost:
        return r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:294:0x0646, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:295:0x0647, code lost:
        r12 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:296:0x0649, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:297:0x064a, code lost:
        r12 = r39;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:299:?, code lost:
        monitor-exit(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:300:0x064d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:301:0x064e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:305:0x0652, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00da, code lost:
        r9.setApplicationVolumeUuid(r9.volumeUuid);
        r9.setApplicationInfoCodePath(r9.codePath);
        r9.setApplicationInfoBaseCodePath(r9.baseCodePath);
        r9.setApplicationInfoSplitCodePaths(r9.splitCodePaths);
        r9.setApplicationInfoResourcePath(r9.codePath);
        r9.setApplicationInfoBaseResourcePath(r9.baseCodePath);
        r9.setApplicationInfoSplitResourcePaths(r9.splitCodePaths);
        r4 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00ff, code lost:
        monitor-enter(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:?, code lost:
        r0 = r10.mSettings.getRenamedPackageLPr(r9.mRealPackage);
        r3 = getRealPackageName(r9, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x010c, code lost:
        if (r3 == null) goto L_0x0111;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x010e, code lost:
        ensurePackageRenamed(r9, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0111, code lost:
        r5 = getOriginalPackageLocked(r9, r0);
        r24 = r10.mSettings.getPackageLPr(r9.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x011f, code lost:
        if (r5 != null) goto L_0x0124;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0121, code lost:
        r11 = r24;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x0124, code lost:
        r11 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x0125, code lost:
        r15 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x0126, code lost:
        if (r15 == null) goto L_0x012a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0128, code lost:
        r11 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x012a, code lost:
        r11 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x012b, code lost:
        r25 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x012d, code lost:
        if (r25 == false) goto L_0x0132;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x012f, code lost:
        r11 = r15.name;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0132, code lost:
        r11 = r9.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0134, code lost:
        r14 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0135, code lost:
        if (r23 == false) goto L_0x015c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x0137, code lost:
        if (r25 != false) goto L_0x015c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x013f, code lost:
        if (r10.mSettings.getDisabledSystemPkgLPr(r14) == null) goto L_0x015c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x0141, code lost:
        r10.mSettings.removeDisabledSystemPackageLPw(r14);
        android.util.Slog.w(TAG, r14 + " updated but found that the pkg is not already exists, remove updated info!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x015c, code lost:
        r13 = r10.mSettings.getDisabledSystemPkgLPr(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0163, code lost:
        if (r13 == null) goto L_0x0167;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0165, code lost:
        r11 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0167, code lost:
        r11 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0168, code lost:
        r26 = r11;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x016c, code lost:
        if (DEBUG_INSTALL == false) goto L_0x0187;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x016e, code lost:
        if (r26 == false) goto L_0x0187;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0170, code lost:
        android.util.Slog.d(TAG, "updatedPkg = " + r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0189, code lost:
        if (r9.mSharedUserId == null) goto L_0x0194;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x018b, code lost:
        r6 = r10.mSettings.getSharedUserLPw(r9.mSharedUserId, 0, 0, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0194, code lost:
        r6 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0197, code lost:
        if (DEBUG_PACKAGE_SCANNING == false) goto L_0x01cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x019c, code lost:
        if ((Integer.MIN_VALUE & r8) == 0) goto L_0x01cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x019e, code lost:
        if (r6 == null) goto L_0x01cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01a0, code lost:
        android.util.Log.d(TAG, "Shared UserID " + r9.mSharedUserId + " (uid=" + r6.userId + "): packages=" + r6.packages);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01cc, code lost:
        if (r23 == false) goto L_0x0275;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01ce, code lost:
        if (r26 == false) goto L_0x0275;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01d2, code lost:
        if (r9.childPackages == null) goto L_0x01db;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01d4, code lost:
        r2 = r9.childPackages.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01db, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01de, code lost:
        if (r13.childPackageNames == null) goto L_0x01e7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x01e0, code lost:
        r11 = r13.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01e7, code lost:
        r11 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01e8, code lost:
        r12 = r11;
        r11 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01ea, code lost:
        if (r11 >= r12) goto L_0x0235;
     */
    /* JADX WARNING: Removed duplicated region for block: B:265:0x0557  */
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        PackageParser.Package packageR = pkg;
        int i = parseFlags;
        int hwFlags2 = hwFlags;
        boolean scanSystemPartition = mHwPMSEx.isSystemAppGrantByMdm(packageR.packageName) ? true : (i & 16) != 0;
        synchronized (this.mPackages) {
            if ((1073741824 & hwFlags2) == 0) {
                try {
                    PackageSetting psTemp = this.mSettings.getPackageLPr(packageR.packageName);
                    if (!mHwPMSEx.needInstallRemovablePreApk(packageR, hwFlags2)) {
                        mHwPMSEx.addUnisntallDataToCache(packageR.packageName, packageR.codePath);
                        if (psTemp == null || !psTemp.isAnyInstalled(sUserManager.getUserIds()) || (this.mSettings.getDisabledSystemPkgLPr(packageR.packageName) == null && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/"))) {
                            Slog.d(TAG, "scan return here for package:" + packageR.packageName);
                            return null;
                        }
                    } else if (psTemp != null && psTemp.codePath != null && !psTemp.codePathString.equals(packageR.codePath) && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/") && !scanSystemPartition && ((long) packageR.mVersionCode) <= psTemp.versionCode) {
                        Slog.d(TAG, "scan return here for ota nosys package:" + packageR.packageName);
                        mHwPMSEx.recordUninstalledDelapp(packageR.packageName, packageR.codePath.toString());
                        return null;
                    }
                } catch (Throwable th) {
                    th = th;
                    int i2 = scanFlags;
                    while (true) {
                        throw th;
                    }
                }
            }
        }
    }

    private static void renameStaticSharedLibraryPackage(PackageParser.Package pkg) {
        pkg.setPackageName(pkg.packageName + STATIC_SHARED_LIB_DELIMITER + pkg.staticSharedLibVersion);
    }

    private static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    private void verifyValidVerifierInstall(String installerPackageName, String pkgName, int userId, int appId) throws PackageManagerException {
        if (pkgName.equals("com.android.vending") && ((TextUtils.isEmpty(installerPackageName) || (!installerPackageName.equals("com.android.packageinstaller") && !installerPackageName.equals("com.huawei.appmarket"))) && pkgName.equals("com.android.vending") && ((TextUtils.isEmpty(installerPackageName) || !installerPackageName.equals("com.android.vending")) && checkPermission("android.permission.INSTALL_PACKAGES", installerPackageName, userId) != -1 && appId != 0 && appId != 2000 && appId != 1000))) {
            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Invalid installer for " + "com.android.vending" + "!");
        }
    }

    private static final void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        boolean dexOptDialogShown;
        enforceSystemOrRoot("Only the system can request fstrim");
        HwThemeManager.applyDefaultHwTheme(false, this.mContext, 0);
        HwThemeManager.linkDataSkinDirAsUser(0);
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                long interval = Settings.Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        Slog.w(TAG, "No disk maintenance in " + timeSinceLast + "; running immediately");
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039583), true);
                        } catch (RemoteException e) {
                        }
                    }
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        List<PackageParser.Package> pkgs;
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isUpgrade();
        boolean causeFirstBoot = isFirstBoot() || this.mIsPreNUpgrade;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (!isBoPD) {
            if (causeUpgrade || causeFirstBoot || causePrunedCache) {
                synchronized (this.mPackages) {
                    pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
                }
                boolean showDialog = this.mIsPreNUpgrade;
                if (SystemProperties.getBoolean("ro.config.show_dex2oatDialog", true)) {
                    showDialog = this.mIsUpgrade;
                }
                long startTime = System.nanoTime();
                int[] stats = performDexOptUpgrade(pkgs, showDialog, causeFirstBoot ? 0 : 1, false);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
                MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime));
            }
        }
    }

    private static String getPrebuildProfilePath(PackageParser.Package pkg) {
        return pkg.baseCodePath + ".prof";
    }

    /* access modifiers changed from: package-private */
    public boolean isUseProfileForDexopt(PackageParser.Package pkg) {
        if ((!isFirstBoot() && !isUpgrade()) || !isSystemApp(pkg)) {
            return false;
        }
        File profileFile = new File(getPrebuildProfilePath(pkg));
        if (profileFile.exists()) {
            try {
                if (this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                    return false;
                }
                Log.e(TAG, "Installer failed to copy system profile!");
                return false;
            } catch (Exception e) {
                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                return false;
            }
        } else {
            PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (disabledPs == null || !disabledPs.pkg.isStub) {
                return false;
            }
            File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
            if (!profileFile2.exists()) {
                return false;
            }
            try {
                if (this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName(null))) {
                    return true;
                }
                Log.e(TAG, "Failed to copy system profile for stub package!");
                return false;
            } catch (Exception e2) {
                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + " ", e2);
                return false;
            }
        }
    }

    private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, int compilationReason, boolean bootComplete) {
        int numberOfPackagesToDexopt;
        if (sIsMygote) {
            MplDexOptAdaptor.getInstance().getDexOptNeededCachePrepare(pkgs, compilationReason, bootComplete, this.mDexManager, this, 0);
        }
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed = 0;
        int numberOfPackagesToDexopt2 = pkgs.size();
        boolean isChina = "CN".equalsIgnoreCase(SystemProperties.get("ro.product.locale.region", BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS));
        connectBootAnimation();
        Iterator<PackageParser.Package> it = pkgs.iterator();
        while (true) {
            int i = 1;
            if (it.hasNext()) {
                PackageParser.Package pkg = it.next();
                int numberOfPackagesVisited2 = numberOfPackagesVisited + 1;
                boolean useProfileForDexopt = sIsMygote != 0 ? false : isUseProfileForDexopt(pkg);
                if (!PackageDexOptimizer.canOptimizePackage(pkg)) {
                    numberOfPackagesSkipped++;
                    numberOfPackagesVisited = numberOfPackagesVisited2;
                } else {
                    if (!showDialog || this.mIBootAnmation == null) {
                        numberOfPackagesToDexopt = numberOfPackagesToDexopt2;
                    } else {
                        int inputData = 0;
                        if (numberOfPackagesVisited2 != 1) {
                            inputData = 0 | DumpState.DUMP_HANDLE;
                        }
                        int data = (100 * numberOfPackagesVisited2) / numberOfPackagesToDexopt2;
                        if (data != 0) {
                            i = data;
                        }
                        try {
                            this.mIBootAnmation.notifyProcessing((isChina ? 0 : 256) | inputData | (i << 16));
                            numberOfPackagesToDexopt = numberOfPackagesToDexopt2;
                        } catch (RemoteException e) {
                            StringBuilder sb = new StringBuilder();
                            numberOfPackagesToDexopt = numberOfPackagesToDexopt2;
                            sb.append("show boot dexoat process error,");
                            sb.append(e.getMessage());
                            Slog.w(TAG, sb.toString());
                        }
                    }
                    int pkgCompilationReason = compilationReason;
                    if (useProfileForDexopt) {
                        pkgCompilationReason = 3;
                    }
                    int dexoptFlags = bootComplete ? 4 : 0;
                    if (compilationReason == 0) {
                        dexoptFlags |= 1024;
                    }
                    int primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
                    switch (primaryDexOptStaus) {
                        case -1:
                            numberOfPackagesFailed++;
                            break;
                        case 0:
                            numberOfPackagesSkipped++;
                            break;
                        case 1:
                            numberOfPackagesOptimized++;
                            break;
                        default:
                            int i2 = pkgCompilationReason;
                            Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                            break;
                    }
                    numberOfPackagesVisited = numberOfPackagesVisited2;
                    numberOfPackagesToDexopt2 = numberOfPackagesToDexopt;
                }
            } else {
                this.mHandler.postDelayed(new Runnable() {
                    public void run() {
                        if (PackageManagerService.this.mIBootAnmation != null) {
                            try {
                                PackageManagerService.this.mIBootAnmation.notifyProcessing(DumpState.DUMP_SERVICE_PERMISSIONS);
                            } catch (RemoteException e) {
                                Slog.w(PackageManagerService.TAG, "finish boot dexoat process error," + e.getMessage());
                            }
                        }
                        PackageManagerService.this.mIBootAnmation = null;
                    }
                }, 1000);
                if (sIsMygote) {
                    MplDexOptAdaptor.getInstance().getDexOptNeededCacheClear();
                }
                return new int[]{numberOfPackagesOptimized, numberOfPackagesSkipped, numberOfPackagesFailed};
            }
        }
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    /* access modifiers changed from: private */
    @GuardedBy("mPackages")
    public void notifyPackageUseLocked(String packageName, int reason) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Loading a package that does not exist for the calling user. package=" + loadingPackageName + ", user=" + userId);
            return;
        }
        this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        DexManager.RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Registering a dex module for a package that does not exist for the calling user. package=" + packageName + ", user=" + userId);
            result = new DexManager.RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new Runnable(callback, dexModulePath, result) {
                private final /* synthetic */ IDexModuleRegisterCallback f$0;
                private final /* synthetic */ String f$1;
                private final /* synthetic */ DexManager.RegisterDexModuleResult f$2;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void run() {
                    PackageManagerService.lambda$registerDexModule$3(this.f$0, this.f$1, this.f$2);
                }
            });
        }
    }

    static /* synthetic */ void lambda$registerDexModule$3(IDexModuleRegisterCallback callback, String dexModulePath, DexManager.RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to callback after module registration " + dexModulePath, e);
        }
    }

    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        if (mHwPMSEx.isApkDexOpt(targetCompilerFilter)) {
            return mHwPMSEx.hwPerformDexOptMode(packageName, checkProfiles, targetCompilerFilter, force, bootComplete, splitName);
        }
        int i = 0;
        int i2 = (force ? 2 : 0) | checkProfiles;
        if (bootComplete) {
            i = 4;
        }
        DexoptOptions dexoptOptions = new DexoptOptions(packageName, -1, targetCompilerFilter, splitName, (int) (i | i2));
        return performDexOpt(dexoptOptions);
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    /* access modifiers changed from: package-private */
    public boolean performDexOpt(DexoptOptions options) {
        boolean z = false;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            z = true;
        }
        return z;
    }

    /* access modifiers changed from: package-private */
    public int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        Trace.traceBegin(262144, "dexopt");
        try {
            return performDexOptInternal(options);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int performDexOptInternal(DexoptOptions options) {
        int performDexOptInternalWithDependenciesLI;
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
            long callingId = Binder.clearCallingIdentity();
            try {
                synchronized (this.mInstallLock) {
                    performDexOptInternalWithDependenciesLI = performDexOptInternalWithDependenciesLI(p, options);
                }
                Binder.restoreCallingIdentity(callingId);
                return performDexOptInternalWithDependenciesLI;
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
                throw th;
            }
        }
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
        PackageDexOptimizer packageDexOptimizer;
        if (options.isForce()) {
            packageDexOptimizer = new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            packageDexOptimizer = this.mPackageDexOptimizer;
        }
        PackageDexOptimizer pdo = packageDexOptimizer;
        Collection<PackageParser.Package> deps = findSharedNonSystemLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions dexoptOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            DexoptOptions libraryOptions = dexoptOptions;
            for (PackageParser.Package depPackage : deps) {
                pdo.performDexOpt(depPackage, null, instructionSets, getOrCreateCompilerPackageStats(depPackage), this.mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
            }
        }
        return pdo.performDexOpt(p, p.usesLibraryFiles, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    /* access modifiers changed from: package-private */
    public DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob(List<String> packageNames) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext, packageNames);
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> findSharedNonSystemLibraries(PackageParser.Package p) {
        if (p.usesLibraries == null && p.usesOptionalLibraries == null && p.usesStaticLibraries == null) {
            return Collections.emptyList();
        }
        ArrayList<PackageParser.Package> retValue = new ArrayList<>();
        findSharedNonSystemLibrariesRecursive(p, retValue, new HashSet<>());
        retValue.remove(p);
        return retValue;
    }

    private void findSharedNonSystemLibrariesRecursive(PackageParser.Package p, ArrayList<PackageParser.Package> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(p.packageName)) {
            collectedNames.add(p.packageName);
            collected.add(p);
            if (p.usesLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesLibraries, null, collected, collectedNames);
            }
            if (p.usesOptionalLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesOptionalLibraries, null, collected, collectedNames);
            }
            if (p.usesStaticLibraries != null) {
                findSharedNonSystemLibrariesRecursive(p.usesStaticLibraries, p.usesStaticLibrariesVersions, collected, collectedNames);
            }
        }
    }

    private void findSharedNonSystemLibrariesRecursive(ArrayList<String> libs, long[] versions, ArrayList<PackageParser.Package> collected, Set<String> collectedNames) {
        int libNameCount = libs.size();
        for (int i = 0; i < libNameCount; i++) {
            PackageParser.Package libPkg = findSharedNonSystemLibrary(libs.get(i), (versions == null || versions.length != libNameCount) ? -1 : versions[i]);
            if (libPkg != null) {
                findSharedNonSystemLibrariesRecursive(libPkg, collected, collectedNames);
            }
        }
    }

    private PackageParser.Package findSharedNonSystemLibrary(String name, long version) {
        synchronized (this.mPackages) {
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(name, version);
            if (libEntry == null) {
                return null;
            }
            PackageParser.Package packageR = this.mPackages.get(libEntry.apk);
            return packageR;
        }
    }

    private SharedLibraryEntry getSharedLibraryEntryLPr(String name, long version) {
        LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return null;
        }
        return versionedLib.get(version);
    }

    private SharedLibraryEntry getLatestSharedLibraVersionLPr(PackageParser.Package pkg) {
        LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        long previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            long libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return versionedLib.get(previousLibVersion);
        }
        return null;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
        synchronized (this.mPackages) {
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
                Iterator<Integer> it = this.mDirtyUsers.iterator();
                while (it.hasNext()) {
                    this.mSettings.writePackageRestrictionsLPr(it.next().intValue());
                }
                this.mDirtyUsers.clear();
            }
        }
    }

    public void dumpProfiles(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                this.mArtManagerService.dumpProfiles(pkg);
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res != 1) {
                throw new IllegalStateException("Failed to dexopt: " + res);
            }
        }
    }

    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, PackageParser.Package newPkg) {
        if ((oldPkg.pkgFlags & 1) == 0) {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package not in system partition");
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package still exists");
            return false;
        }
    }

    /* access modifiers changed from: package-private */
    public void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
            }
        } else {
            codePath.delete();
        }
    }

    private int[] resolveUserIds(int userId) {
        if (userId == -1) {
            return sUserManager.getUserIds();
        }
        return new int[]{userId};
    }

    /* access modifiers changed from: private */
    public void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
        clearAppProfilesLIF(pkg, -1);
    }

    private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        for (int realUserId : resolveUserIds(userId)) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(PackageParser.Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppProfilesLeafLIF((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void destroyAppProfilesLeafLIF(PackageParser.Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        this.mArtManagerService.clearAppProfiles(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mArtManagerService.clearAppProfiles((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void setInstallAndUpdateTime(PackageParser.Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                ps2.firstInstallTime = firstInstallTime;
                ps2.lastUpdateTime = lastUpdateTime;
            }
        }
    }

    private void addSharedLibraryLPr(Set<String> usesLibraryFiles, SharedLibraryEntry file, PackageParser.Package changingLib) {
        if (file.path != null) {
            usesLibraryFiles.add(file.path);
            return;
        }
        PackageParser.Package p = this.mPackages.get(file.apk);
        if (changingLib != null && changingLib.packageName.equals(file.apk) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    private void updateSharedLibrariesLPr(PackageParser.Package pkg, PackageParser.Package changingLib) throws PackageManagerException {
        if (pkg != null) {
            Set<String> usesLibraryFiles = null;
            if (pkg.usesLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesLibraries, null, null, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, null);
            }
            if (pkg.usesStaticLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, changingLib, true, pkg.applicationInfo.targetSdkVersion, usesLibraryFiles);
            }
            if (pkg.usesOptionalLibraries != null) {
                usesLibraryFiles = addSharedLibrariesLPw(pkg.usesOptionalLibraries, null, null, pkg.packageName, changingLib, false, pkg.applicationInfo.targetSdkVersion, usesLibraryFiles);
            }
            if (!ArrayUtils.isEmpty(usesLibraryFiles)) {
                pkg.usesLibraryFiles = (String[]) usesLibraryFiles.toArray(new String[usesLibraryFiles.size()]);
            } else {
                pkg.usesLibraryFiles = null;
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:57:0x01c0  */
    private Set<String> addSharedLibrariesLPw(List<String> requestedLibraries, long[] requiredVersions, String[][] requiredCertDigests, String packageName, PackageParser.Package changingLib, boolean required, int targetSdk, Set<String> outUsedLibraries) throws PackageManagerException {
        long libVersion;
        int libCount;
        String[] strArr;
        String str = packageName;
        PackageParser.Package packageR = changingLib;
        int libCount2 = requestedLibraries.size();
        Set<String> outUsedLibraries2 = outUsedLibraries;
        int i = 0;
        while (i < libCount2) {
            String libName = requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(libName, libVersion);
            if (libEntry != null) {
                libCount = libCount2;
                if (!(requiredVersions == null || requiredCertDigests == null)) {
                    if (libEntry.info.getLongVersion() == requiredVersions[i]) {
                        PackageParser.Package libPkg = this.mPackages.get(libEntry.apk);
                        if (packageR != null && packageR.packageName.equals(libEntry.apk) && (libPkg == null || libPkg.packageName.equals(packageR.packageName))) {
                            libPkg = packageR;
                        }
                        if (libPkg != null) {
                            String[] expectedCertDigests = requiredCertDigests[i];
                            if (expectedCertDigests.length > 1) {
                                if (targetSdk >= 27) {
                                    strArr = PackageUtils.computeSignaturesSha256Digests(libPkg.mSigningDetails.signatures);
                                } else {
                                    strArr = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSigningDetails.signatures[0]});
                                }
                                String[] libCertDigests = strArr;
                                if (expectedCertDigests.length == libCertDigests.length) {
                                    Arrays.sort(libCertDigests);
                                    Arrays.sort(expectedCertDigests);
                                    int certCount = libCertDigests.length;
                                    int j = 0;
                                    while (j < certCount) {
                                        int certCount2 = certCount;
                                        String[] libCertDigests2 = libCertDigests;
                                        if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                                            j++;
                                            certCount = certCount2;
                                            libCertDigests = libCertDigests2;
                                        } else {
                                            throw new PackageManagerException(-9, "Package " + str + " requires differently signed static shared library; failing!");
                                        }
                                    }
                                } else {
                                    String[] strArr2 = libCertDigests;
                                    throw new PackageManagerException(-9, "Package " + str + " requires differently signed static shared library; failing!");
                                }
                            } else {
                                if (!libPkg.mSigningDetails.hasSha256Certificate(ByteStringUtils.fromHexToByteArray(expectedCertDigests[0]))) {
                                    throw new PackageManagerException(-9, "Package " + str + " requires differently signed static shared library; failing!");
                                }
                                if (outUsedLibraries2 == null) {
                                    outUsedLibraries2 = new LinkedHashSet<>();
                                }
                                addSharedLibraryLPr(outUsedLibraries2, libEntry, packageR);
                            }
                        } else {
                            throw new PackageManagerException(-9, "Package " + str + " requires unavailable static shared library; failing!");
                        }
                    } else {
                        throw new PackageManagerException(-9, "Package " + str + " requires unavailable static shared library " + libName + " version " + libEntry.info.getLongVersion() + "; failing!");
                    }
                }
                if (outUsedLibraries2 == null) {
                }
                addSharedLibraryLPr(outUsedLibraries2, libEntry, packageR);
            } else if (required) {
                throw new PackageManagerException(-9, "Package " + str + " requires unavailable shared library " + libName + "; failing!");
            } else if (DEBUG_SHARED_LIBRARIES) {
                StringBuilder sb = new StringBuilder();
                libCount = libCount2;
                sb.append("Package ");
                sb.append(str);
                sb.append(" desires unavailable shared library ");
                sb.append(libName);
                sb.append("; ignoring!");
                Slog.i(TAG, sb.toString());
            } else {
                libCount = libCount2;
            }
            i++;
            libCount2 = libCount;
        }
        return outUsedLibraries2;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null || which == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (which.get(j).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    /* access modifiers changed from: protected */
    public ArrayList<PackageParser.Package> updateAllSharedLibrariesLPw(PackageParser.Package changingPkg) {
        ArrayList<PackageParser.Package> res = null;
        for (PackageParser.Package pkg : this.mPackages.values()) {
            if (changingPkg == null || hasString(pkg.usesLibraries, changingPkg.libraryNames) || hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) || ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName)) {
                if (res == null) {
                    res = new ArrayList<>();
                }
                res.add(pkg);
                try {
                    updateSharedLibrariesLPr(pkg, changingPkg);
                } catch (PackageManagerException e) {
                    if (!pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                        deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                    }
                    Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
                }
            } else if (!"com.huawei.androidx".equals(changingPkg.manifestPackageName)) {
                return null;
            }
        }
        return res;
    }

    /* JADX INFO: finally extract failed */
    private PackageParser.Package scanPackageTracedLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        PackageParser.Package packageR = pkg;
        int i = scanFlags;
        Trace.traceBegin(262144, "scanPackage");
        if ((i & 1024) != 0) {
            i &= -1025;
        } else if (packageR.childPackages != null && packageR.childPackages.size() > 0) {
            i |= 1024;
        }
        int scanFlags2 = i;
        try {
            PackageParser.Package scannedPkg = scanPackageNewLI(packageR, parseFlags, scanFlags2, currentTime, user);
            int i2 = 0;
            int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
            while (true) {
                int i3 = i2;
                if (i3 >= childCount) {
                    break;
                }
                scanPackageNewLI((PackageParser.Package) packageR.childPackages.get(i3), parseFlags, scanFlags2, currentTime, user);
                i2 = i3 + 1;
            }
            Trace.traceEnd(262144);
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageTracedLI(packageR, parseFlags, scanFlags2, currentTime, user);
            }
            return scannedPkg;
        } catch (Throwable scannedPkg2) {
            Trace.traceEnd(262144);
            throw scannedPkg2;
        }
    }

    private int adjustScanFlags(int scanFlags, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user, PackageParser.Package pkg) {
        if (disabledPkgSetting != null) {
            scanFlags |= 131072;
            if ((disabledPkgSetting.pkgPrivateFlags & 8) != 0) {
                scanFlags |= 262144;
            }
            if ((131072 & disabledPkgSetting.pkgPrivateFlags) != 0) {
                scanFlags |= 524288;
            }
            if ((disabledPkgSetting.pkgPrivateFlags & 262144) != 0) {
                scanFlags |= 1048576;
            }
            if ((disabledPkgSetting.pkgPrivateFlags & 524288) != 0) {
                scanFlags |= 2097152;
            }
        }
        if (pkgSetting != null) {
            int userId = user == null ? 0 : user.getIdentifier();
            if (pkgSetting.getInstantApp(userId)) {
                scanFlags |= 16384;
            }
            if (pkgSetting.getVirtulalPreload(userId)) {
                scanFlags |= 65536;
            }
        }
        boolean skipVendorPrivilegeScan = (1048576 & scanFlags) != 0 && SystemProperties.getInt("ro.vndk.version", 28) < 28;
        if ((scanFlags & 262144) == 0 && !pkg.isPrivileged() && pkg.mSharedUserId != null && !skipVendorPrivilegeScan) {
            SharedUserSetting sharedUserSetting = null;
            try {
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                synchronized (this.mPackages) {
                    if (PackageManagerServiceUtils.compareSignatures(this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME).signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) != 0) {
                        scanFlags |= 262144;
                    }
                }
            }
        }
        return scanFlags;
    }

    @GuardedBy("mInstallLock")
    private PackageParser.Package scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageNewLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0259, code lost:
        return r3;
     */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x021f A[Catch:{ all -> 0x025a, all -> 0x02a3 }] */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x0247 A[Catch:{ all -> 0x025a, all -> 0x02a3 }] */
    /* JADX WARNING: Removed duplicated region for block: B:50:0x0116 A[SYNTHETIC, Splitter:B:50:0x0116] */
    /* JADX WARNING: Removed duplicated region for block: B:62:0x0161  */
    /* JADX WARNING: Removed duplicated region for block: B:75:0x0193  */
    /* JADX WARNING: Removed duplicated region for block: B:89:0x01dc  */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x01e4 A[Catch:{ all -> 0x025f }] */
    /* JADX WARNING: Removed duplicated region for block: B:94:0x01e6 A[Catch:{ all -> 0x025f }] */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x01ec  */
    /* JADX WARNING: Removed duplicated region for block: B:98:0x01ef  */
    @GuardedBy("mInstallLock")
    private PackageParser.Package scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        int hwFlags2;
        PackageParser.Package packageR;
        String renamedPkgName;
        PackageSetting disabledPkgSettingCheck;
        ScanRequest scanRequest;
        ScanResult result;
        PackageParser.Package packageR2 = pkg;
        int i = parseFlags;
        int i2 = hwFlags;
        PackageSetting disabledPkgSettingCheck2 = this.mSettings.getDisabledSystemPkgLPr(packageR2.packageName);
        if (!(disabledPkgSettingCheck2 == null || disabledPkgSettingCheck2.codePath == null || disabledPkgSettingCheck2.codePath.exists())) {
            Slog.i(TAG, "sysPackagesPath " + disabledPkgSettingCheck2.codePathString + ", has removed, remove its FLAG_SYSTEM & removeDisabledSystemPackageLPw");
            ApplicationInfo applicationInfo = packageR2.applicationInfo;
            applicationInfo.flags = applicationInfo.flags & -2;
            ApplicationInfo applicationInfo2 = packageR2.applicationInfo;
            applicationInfo2.flags = applicationInfo2.flags & -129;
            this.mSettings.removeDisabledSystemPackageLPw(packageR2.packageName);
        }
        String renamedPkgName2 = this.mSettings.getRenamedPackageLPr(packageR2.mRealPackage);
        String realPkgName = getRealPackageName(packageR2, renamedPkgName2);
        if (realPkgName != null) {
            ensurePackageRenamed(packageR2, renamedPkgName2);
        }
        PackageSetting originalPkgSetting = getOriginalPackageLocked(packageR2, renamedPkgName2);
        PackageSetting pkgSetting = this.mSettings.getPackageLPr(packageR2.packageName);
        PackageSetting disabledPkgSetting = this.mSettings.getDisabledSystemPkgLPr(packageR2.packageName);
        if (this.mTransferedPackages.contains(packageR2.packageName)) {
            Slog.w(TAG, "Package " + packageR2.packageName + " was transferred to another, but its .apk remains");
        }
        int scanFlags2 = adjustScanFlags(scanFlags, pkgSetting, disabledPkgSetting, user, packageR2);
        if (disabledPkgSetting != null) {
            mHwPMSEx.resolvePersistentFlagForPackage(disabledPkgSetting.pkgFlags, packageR2);
        }
        int scanFlags3 = mHwPMSEx.adjustScanFlagForApk(packageR2, scanFlags2);
        synchronized (this.mPackages) {
            try {
                applyPolicy(packageR2, i, scanFlags3, this.mPlatformPackage, i2);
                assertPackageIsValid(packageR2, i, scanFlags3);
                if (sIsMygote) {
                    try {
                        String type = HwMaplePMServiceUtils.getMapleAppType(pkg);
                        if (type != null && type.equals("m")) {
                            int hwFlags3 = i2 | DumpState.DUMP_SERVICE_PERMISSIONS;
                            try {
                                ApplicationInfo applicationInfo3 = packageR2.applicationInfo;
                                applicationInfo3.hwFlags = 16777216 | applicationInfo3.hwFlags;
                                hwFlags2 = hwFlags3;
                                SharedUserSetting sharedUserSetting = null;
                                if (packageR2.mSharedUserId != null) {
                                }
                                SharedUserSetting sharedUserSetting2 = sharedUserSetting;
                                if (!isSystemApp(pkg)) {
                                }
                                if (!isSystemApp(pkg)) {
                                }
                                if (pkgSetting == null) {
                                }
                                scanRequest = scanRequest;
                                String str = renamedPkgName;
                                PackageSetting packageSetting = disabledPkgSettingCheck;
                                packageR = packageR2;
                                scanRequest = new ScanRequest(packageR2, sharedUserSetting2, pkgSetting == null ? null : pkgSetting.pkg, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags3, packageR2 == this.mPlatformPackage, user);
                                result = scanPackageOnlyLI(scanRequest, this.mFactoryTest, currentTime, hwFlags2);
                                if (result.success) {
                                }
                                PackageSetting psMygote = this.mSettings.mPackages.get(packageR.packageName);
                                int hwFlags4 = hwFlags2 | DumpState.DUMP_VOLUMES;
                                ApplicationInfo applicationInfo4 = packageR.applicationInfo;
                                applicationInfo4.hwFlags = 8388608 | applicationInfo4.hwFlags;
                                if (sIsMygote) {
                                }
                                destroyAppDataLIF(packageR, -1, 3);
                                destroyAppProfilesLIF(packageR, -1);
                            } catch (Throwable th) {
                                th = th;
                                int i3 = hwFlags3;
                                PackageParser.Package packageR3 = packageR2;
                                long j = currentTime;
                                throw th;
                            }
                        } else if (type != null) {
                            if (type.equals("z")) {
                                hwFlags2 = i2 | DumpState.DUMP_VOLUMES;
                                try {
                                    packageR2.applicationInfo.hwFlags |= DumpState.DUMP_VOLUMES;
                                    SharedUserSetting sharedUserSetting3 = null;
                                    if (packageR2.mSharedUserId != null) {
                                        sharedUserSetting3 = this.mSettings.getSharedUserLPw(packageR2.mSharedUserId, 0, 0, true);
                                        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & i) != 0) {
                                            Log.d(TAG, "Shared UserID " + packageR2.mSharedUserId + " (uid=" + sharedUserSetting3.userId + "): packages=" + sharedUserSetting3.packages);
                                        }
                                    }
                                    SharedUserSetting sharedUserSetting22 = sharedUserSetting3;
                                    try {
                                        if (!isSystemApp(pkg)) {
                                            try {
                                                if (HwDeviceManager.disallowOp(7, packageR2.packageName)) {
                                                    UiThread.getHandler().post(new Runnable() {
                                                        public void run() {
                                                            if (PackageManagerService.this.mContext != null) {
                                                                Toast toast = Toast.makeText(PackageManagerService.this.mContext, PackageManagerService.this.mContext.getString(33686139), 0);
                                                                toast.getWindowParams().privateFlags |= 16;
                                                                toast.show();
                                                            }
                                                        }
                                                    });
                                                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is not in the installpackage_whitelist");
                                                }
                                            } catch (Throwable th2) {
                                                th = th2;
                                                PackageSetting packageSetting2 = disabledPkgSetting;
                                                PackageSetting packageSetting3 = pkgSetting;
                                                String str2 = renamedPkgName2;
                                                PackageSetting packageSetting4 = disabledPkgSettingCheck2;
                                                packageR = packageR2;
                                                long j2 = currentTime;
                                                destroyAppDataLIF(packageR, -1, 3);
                                                destroyAppProfilesLIF(packageR, -1);
                                                throw th;
                                            }
                                        }
                                        if (!isSystemApp(pkg)) {
                                            try {
                                                if (!HwDeviceManager.disallowOp(19, packageR2.packageName)) {
                                                    renamedPkgName = renamedPkgName2;
                                                    disabledPkgSettingCheck = disabledPkgSettingCheck2;
                                                } else {
                                                    final String pkgName = getCallingAppName(this.mContext, packageR2);
                                                    try {
                                                        new Handler().postDelayed(new Runnable() {
                                                            public void run() {
                                                                Toast.makeText(PackageManagerService.this.mContext, PackageManagerService.this.mContext.getResources().getString(33685933, new Object[]{pkgName}), 0).show();
                                                            }
                                                        }, 500);
                                                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is in the installpackage_blacklist");
                                                    } catch (Throwable th3) {
                                                        th = th3;
                                                        PackageSetting packageSetting5 = disabledPkgSetting;
                                                        PackageSetting packageSetting6 = pkgSetting;
                                                        packageR = packageR2;
                                                        PackageSetting packageSetting7 = disabledPkgSettingCheck2;
                                                        String str3 = renamedPkgName2;
                                                        long j22 = currentTime;
                                                        if (0 == 0 && (scanFlags3 & 64) != 0) {
                                                            destroyAppDataLIF(packageR, -1, 3);
                                                            destroyAppProfilesLIF(packageR, -1);
                                                        }
                                                        throw th;
                                                    }
                                                }
                                            } catch (Throwable th4) {
                                                th = th4;
                                                PackageSetting packageSetting8 = disabledPkgSetting;
                                                PackageSetting packageSetting9 = pkgSetting;
                                                String str4 = renamedPkgName2;
                                                PackageSetting packageSetting10 = disabledPkgSettingCheck2;
                                                packageR = packageR2;
                                                long j3 = currentTime;
                                                destroyAppDataLIF(packageR, -1, 3);
                                                destroyAppProfilesLIF(packageR, -1);
                                                throw th;
                                            }
                                        } else {
                                            renamedPkgName = renamedPkgName2;
                                            disabledPkgSettingCheck = disabledPkgSettingCheck2;
                                        }
                                        try {
                                            scanRequest = scanRequest;
                                            String str5 = renamedPkgName;
                                            PackageSetting packageSetting11 = disabledPkgSettingCheck;
                                            packageR = packageR2;
                                        } catch (Throwable th5) {
                                            th = th5;
                                            PackageSetting packageSetting12 = disabledPkgSetting;
                                            PackageSetting packageSetting13 = pkgSetting;
                                            packageR = packageR2;
                                            PackageSetting packageSetting14 = disabledPkgSettingCheck;
                                            String str6 = renamedPkgName;
                                            long j4 = currentTime;
                                            destroyAppDataLIF(packageR, -1, 3);
                                            destroyAppProfilesLIF(packageR, -1);
                                            throw th;
                                        }
                                        try {
                                            scanRequest = new ScanRequest(packageR2, sharedUserSetting22, pkgSetting == null ? null : pkgSetting.pkg, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags3, packageR2 == this.mPlatformPackage, user);
                                            try {
                                                result = scanPackageOnlyLI(scanRequest, this.mFactoryTest, currentTime, hwFlags2);
                                                if (result.success) {
                                                    commitScanResultsLocked(scanRequest, result, hwFlags2);
                                                }
                                                PackageSetting psMygote2 = this.mSettings.mPackages.get(packageR.packageName);
                                                if (sIsMygote && HwMaplePMServiceUtils.isWebviewBothApp(psMygote2)) {
                                                    int hwFlags42 = hwFlags2 | DumpState.DUMP_VOLUMES;
                                                    ApplicationInfo applicationInfo42 = packageR.applicationInfo;
                                                    applicationInfo42.hwFlags = 8388608 | applicationInfo42.hwFlags;
                                                }
                                                if (sIsMygote) {
                                                    HwMaplePMServiceUtils.verifyMd5(pkg);
                                                }
                                                if (1 == 0 && (scanFlags3 & 64) != 0) {
                                                    destroyAppDataLIF(packageR, -1, 3);
                                                    destroyAppProfilesLIF(packageR, -1);
                                                }
                                            } catch (Throwable th6) {
                                                th = th6;
                                                throw th;
                                            }
                                        } catch (Throwable th7) {
                                            th = th7;
                                            long j222 = currentTime;
                                            destroyAppDataLIF(packageR, -1, 3);
                                            destroyAppProfilesLIF(packageR, -1);
                                            throw th;
                                        }
                                    } catch (Throwable th8) {
                                        th = th8;
                                        PackageSetting packageSetting15 = disabledPkgSetting;
                                        PackageSetting packageSetting16 = pkgSetting;
                                        String str7 = renamedPkgName2;
                                        PackageSetting packageSetting17 = disabledPkgSettingCheck2;
                                        packageR = packageR2;
                                        long j5 = currentTime;
                                        destroyAppDataLIF(packageR, -1, 3);
                                        destroyAppProfilesLIF(packageR, -1);
                                        throw th;
                                    }
                                } catch (Throwable th9) {
                                    th = th9;
                                }
                            }
                        }
                    } catch (Throwable th10) {
                        th = th10;
                        int i4 = i2;
                        PackageParser.Package packageR32 = packageR2;
                        long j6 = currentTime;
                        throw th;
                    }
                }
                hwFlags2 = i2;
                SharedUserSetting sharedUserSetting32 = null;
                try {
                    if (packageR2.mSharedUserId != null) {
                    }
                    SharedUserSetting sharedUserSetting222 = sharedUserSetting32;
                    if (!isSystemApp(pkg)) {
                    }
                    if (!isSystemApp(pkg)) {
                    }
                    if (pkgSetting == null) {
                    }
                    scanRequest = scanRequest;
                    String str52 = renamedPkgName;
                    PackageSetting packageSetting112 = disabledPkgSettingCheck;
                    packageR = packageR2;
                    scanRequest = new ScanRequest(packageR2, sharedUserSetting222, pkgSetting == null ? null : pkgSetting.pkg, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags3, packageR2 == this.mPlatformPackage, user);
                    result = scanPackageOnlyLI(scanRequest, this.mFactoryTest, currentTime, hwFlags2);
                    if (result.success) {
                    }
                    PackageSetting psMygote22 = this.mSettings.mPackages.get(packageR.packageName);
                    int hwFlags422 = hwFlags2 | DumpState.DUMP_VOLUMES;
                    ApplicationInfo applicationInfo422 = packageR.applicationInfo;
                    applicationInfo422.hwFlags = 8388608 | applicationInfo422.hwFlags;
                    if (sIsMygote) {
                    }
                    destroyAppDataLIF(packageR, -1, 3);
                    destroyAppProfilesLIF(packageR, -1);
                } catch (Throwable th11) {
                    th = th11;
                    PackageSetting packageSetting18 = disabledPkgSetting;
                    PackageSetting packageSetting19 = pkgSetting;
                    String str8 = renamedPkgName2;
                    PackageSetting packageSetting20 = disabledPkgSettingCheck2;
                    PackageParser.Package packageR4 = packageR2;
                    long j7 = currentTime;
                    throw th;
                }
            } catch (Throwable th12) {
                th = th12;
                PackageSetting packageSetting21 = disabledPkgSetting;
                PackageSetting packageSetting22 = pkgSetting;
                String str9 = renamedPkgName2;
                PackageSetting packageSetting23 = disabledPkgSettingCheck2;
                PackageParser.Package packageR5 = packageR2;
                long j8 = currentTime;
                int i5 = i2;
                throw th;
            }
        }
    }

    @GuardedBy("mPackages")
    private void commitScanResultsLocked(ScanRequest request, ScanResult result) throws PackageManagerException {
        commitScanResultsLocked(request, result, 0);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x0233, code lost:
        throw new com.android.server.pm.PackageManagerException(-104, "Signature mismatch for shared user: " + r3.sharedUser);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x0234, code lost:
        r7.sharedUser.signatures.mSigningDetails = r11.mSigningDetails;
        r7.sharedUser.signaturesChanged = java.lang.Boolean.TRUE;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x0242, code lost:
        reportSettingsProblem(5, "System package " + r11.packageName + " signature changed; retaining data.");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x0345, code lost:
        r28 = r2;
        r9 = r3;
        r21 = r5;
        r22 = r6;
        r23 = r7;
        r17 = r19;
        r19 = r25;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x0352, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01ad, code lost:
        r25 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01b8, code lost:
        throw new com.android.server.pm.PackageManagerException(-104, "Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x01b9, code lost:
        r0 = e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01ba, code lost:
        r25 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x01c0, code lost:
        r1 = mHwPMSEx.isSystemSignatureUpdated(r3.signatures.mSigningDetails.signatures, r11.mSigningDetails.signatures);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x01d0, code lost:
        if (r1 != false) goto L_0x01d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01d2, code lost:
        r9 = new java.lang.StringBuilder();
        r26 = r6;
        r9.append("CertCompat: ");
        r9.append(r11.packageName);
        r9.append(" system signature update; retaining data.");
        android.util.Slog.i(TAG, r9.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01f2, code lost:
        r26 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01f4, code lost:
        r3.signatures.mSigningDetails = r11.mSigningDetails;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x01fc, code lost:
        if (r7.sharedUser != null) goto L_0x01fe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01fe, code lost:
        if (r1 != false) goto L_0x0234;
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:109:0x0271  */
    /* JADX WARNING: Removed duplicated region for block: B:123:0x02cd  */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x02ea  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x030c  */
    /* JADX WARNING: Removed duplicated region for block: B:150:0x0345  */
    /* JADX WARNING: Removed duplicated region for block: B:155:0x02e6 A[EDGE_INSN: B:155:0x02e6->B:128:0x02e6 ?: BREAK  , SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:40:0x00e1  */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x00fa  */
    /* JADX WARNING: Removed duplicated region for block: B:54:0x0152 A[SYNTHETIC, Splitter:B:54:0x0152] */
    /* JADX WARNING: Removed duplicated region for block: B:81:0x01ac A[ExcHandler: IllegalArgumentException (e java.lang.IllegalArgumentException), Splitter:B:54:0x0152] */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x01c0  */
    @GuardedBy("mPackages")
    private void commitScanResultsLocked(ScanRequest request, ScanResult result, int hwFlags) throws PackageManagerException {
        String realPkgName;
        PackageSetting signatureCheckPs;
        KeySetManagerService ksms;
        KeySetManagerService ksms2;
        int i;
        int i2;
        int i3;
        PackageSetting pkgSetting;
        ScanRequest scanRequest = request;
        ScanResult scanResult = result;
        PackageParser.Package pkg = scanRequest.pkg;
        PackageParser.Package oldPkg = scanRequest.oldPkg;
        int parseFlags = scanRequest.parseFlags;
        int scanFlags = scanRequest.scanFlags;
        PackageSetting oldPkgSetting = scanRequest.oldPkgSetting;
        PackageSetting originalPkgSetting = scanRequest.originalPkgSetting;
        PackageSetting disabledPkgSetting = scanRequest.disabledPkgSetting;
        UserHandle user = scanRequest.user;
        String realPkgName2 = scanRequest.realPkgName;
        PackageSetting pkgSetting2 = scanResult.pkgSetting;
        List<String> changedAbiCodePath = scanResult.changedAbiCodePath;
        boolean z = false;
        if (scanResult.pkgSetting != scanRequest.pkgSetting) {
            if (originalPkgSetting != null) {
                this.mSettings.addRenamedPackageLPw(pkg.packageName, originalPkgSetting.name);
            }
            this.mSettings.addUserToSettingLPw(pkgSetting2);
            if (originalPkgSetting != null && (scanFlags & 1024) == 0) {
                this.mTransferedPackages.add(originalPkgSetting.name);
            }
        }
        pkg.applicationInfo.uid = pkgSetting2.appId;
        this.mSettings.writeUserRestrictionsLPw(pkgSetting2, oldPkgSetting);
        if ((scanFlags & 1024) == 0 && realPkgName2 != null) {
            this.mTransferedPackages.add(pkg.packageName);
        }
        if ((hwFlags & 1073741824) != 0) {
            realPkgName = realPkgName2;
            PackageSetting packageSetting = originalPkgSetting;
        } else if ((scanFlags & 16) == 0 && (parseFlags & 16) == 0) {
            realPkgName = realPkgName2;
            PackageSetting packageSetting2 = originalPkgSetting;
        } else {
            String deletedSysAppName = this.mSettings.getDisabledSystemPackageName(pkg.codePath);
            if (deletedSysAppName == null || deletedSysAppName.equals(pkg.packageName)) {
                realPkgName = realPkgName2;
                PackageSetting packageSetting3 = originalPkgSetting;
                PackageSetting signatureCheckPs2 = pkgSetting2;
                if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                    if (libraryEntry != null) {
                        signatureCheckPs2 = this.mSettings.getPackageLPr(libraryEntry.apk);
                    }
                }
                signatureCheckPs = signatureCheckPs2;
                ksms = this.mSettings.mKeySetManagerService;
                if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                    try {
                        boolean compareCompat = isCompatSignatureUpdateNeeded(pkg);
                        boolean compareRecover = isRecoverSignatureUpdateNeeded(pkg);
                        if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, disabledPkgSetting, pkg.mSigningDetails, compareCompat, compareRecover)) {
                            boolean z2 = compareRecover;
                            synchronized (this.mPackages) {
                                ksms.removeAppKeySetDataLPw(pkg.packageName);
                            }
                        }
                        pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                        if (signatureCheckPs.sharedUser != null) {
                            if (pkg.mSigningDetails.hasAncestor(signatureCheckPs.sharedUser.signatures.mSigningDetails)) {
                                signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                            }
                            if (signatureCheckPs.sharedUser.signaturesChanged == null) {
                                signatureCheckPs.sharedUser.signaturesChanged = Boolean.FALSE;
                            }
                        }
                    } catch (PackageManagerException e) {
                        e = e;
                        ksms2 = ksms;
                        if ((parseFlags & 16) == 0) {
                        }
                    } catch (IllegalArgumentException e2) {
                    }
                } else if (ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                    pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                } else if ((parseFlags & 16) != 0) {
                    pkgSetting2.signatures.mSigningDetails = pkg.mSigningDetails;
                    reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                } else {
                    throw new PackageManagerException(-7, "Package " + pkg.packageName + " upgrade keys do not match the previously installed version");
                }
                ksms2 = ksms;
                PackageSetting disabledPkgSetting2 = disabledPkgSetting;
                if ((scanFlags & 1024) == 0 && pkg.mAdoptPermissions != null) {
                    i3 = pkg.mAdoptPermissions.size() - 1;
                    while (i3 >= 0) {
                        String origName = (String) pkg.mAdoptPermissions.get(i3);
                        PackageSetting orig = this.mSettings.getPackageLPr(origName);
                        if (orig == null || !verifyPackageUpdateLPr(orig, pkg)) {
                            pkgSetting = pkgSetting2;
                        } else {
                            StringBuilder sb = new StringBuilder();
                            pkgSetting = pkgSetting2;
                            sb.append("Adopting permissions from ");
                            sb.append(origName);
                            sb.append(" to ");
                            sb.append(pkg.packageName);
                            Slog.i(TAG, sb.toString());
                            this.mSettings.mPermissions.transferPermissions(origName, pkg.packageName);
                        }
                        i3--;
                        pkgSetting2 = pkgSetting;
                    }
                }
                PackageSetting pkgSetting3 = pkgSetting2;
                if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                    i = changedAbiCodePath.size() - 1;
                    while (true) {
                        i2 = i;
                        if (i2 < 0) {
                            break;
                        }
                        try {
                            this.mInstaller.rmdex(changedAbiCodePath.get(i2), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                        } catch (Installer.InstallerException e3) {
                        }
                        i = i2 - 1;
                    }
                }
                if ((scanFlags & 1024) != 0) {
                    if (oldPkgSetting != null) {
                        synchronized (this.mPackages) {
                            this.mSettings.mPackages.put(oldPkgSetting.name, oldPkgSetting);
                        }
                    }
                    List<String> list = changedAbiCodePath;
                    UserHandle userHandle = user;
                    PackageSetting packageSetting4 = signatureCheckPs;
                    String str = realPkgName;
                    KeySetManagerService keySetManagerService = ksms2;
                    PackageSetting packageSetting5 = disabledPkgSetting2;
                    PackageSetting packageSetting6 = pkgSetting3;
                    return;
                }
                int userId = user == null ? 0 : user.getIdentifier();
                if ((Integer.MIN_VALUE & parseFlags) != 0) {
                    z = true;
                }
                PackageSetting pkgSetting4 = pkgSetting3;
                String str2 = realPkgName;
                KeySetManagerService keySetManagerService2 = ksms2;
                UserHandle userHandle2 = user;
                List<String> list2 = changedAbiCodePath;
                PackageSetting packageSetting7 = disabledPkgSetting2;
                PackageSetting pkgSetting5 = pkgSetting4;
                PackageSetting packageSetting8 = signatureCheckPs;
                commitPackageSettings(pkg, oldPkg, pkgSetting4, user, scanFlags, z);
                if (pkgSetting5.getInstantApp(userId)) {
                    this.mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting5.appId);
                    return;
                }
                return;
            }
            if (this.mCustPms != null) {
                realPkgName = realPkgName2;
                if (this.mCustPms.isListedApp(deletedSysAppName) != -1) {
                    PackageSetting packageSetting9 = originalPkgSetting;
                    PackageSetting signatureCheckPs22 = pkgSetting2;
                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                    }
                    signatureCheckPs = signatureCheckPs22;
                    ksms = this.mSettings.mKeySetManagerService;
                    if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                    }
                    ksms2 = ksms;
                    PackageSetting disabledPkgSetting22 = disabledPkgSetting;
                    i3 = pkg.mAdoptPermissions.size() - 1;
                    while (i3 >= 0) {
                    }
                    PackageSetting pkgSetting32 = pkgSetting2;
                    i = changedAbiCodePath.size() - 1;
                    while (true) {
                        i2 = i;
                        if (i2 < 0) {
                        }
                        i = i2 - 1;
                    }
                    if ((scanFlags & 1024) != 0) {
                    }
                }
            } else {
                realPkgName = realPkgName2;
            }
            StringBuilder sb2 = new StringBuilder();
            PackageSetting packageSetting10 = originalPkgSetting;
            sb2.append("deletedSysAppName ");
            sb2.append(deletedSysAppName);
            sb2.append(", IN ");
            sb2.append(pkg.codePath);
            sb2.append(", REMOVED");
            Log.i(TAG, sb2.toString());
            this.mSettings.removeDisabledSystemPackageLPw(deletedSysAppName);
            PackageSetting signatureCheckPs222 = pkgSetting2;
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
            }
            signatureCheckPs = signatureCheckPs222;
            ksms = this.mSettings.mKeySetManagerService;
            if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
            }
            ksms2 = ksms;
            PackageSetting disabledPkgSetting222 = disabledPkgSetting;
            i3 = pkg.mAdoptPermissions.size() - 1;
            while (i3 >= 0) {
            }
            PackageSetting pkgSetting322 = pkgSetting2;
            i = changedAbiCodePath.size() - 1;
            while (true) {
                i2 = i;
                if (i2 < 0) {
                }
                i = i2 - 1;
            }
            if ((scanFlags & 1024) != 0) {
            }
        }
        updateSharedLibrariesLPr(pkg, null);
        PackageSetting signatureCheckPs2222 = pkgSetting2;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
        }
        signatureCheckPs = signatureCheckPs2222;
        ksms = this.mSettings.mKeySetManagerService;
        if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
        }
        ksms2 = ksms;
        PackageSetting disabledPkgSetting2222 = disabledPkgSetting;
        i3 = pkg.mAdoptPermissions.size() - 1;
        while (i3 >= 0) {
        }
        PackageSetting pkgSetting3222 = pkgSetting2;
        i = changedAbiCodePath.size() - 1;
        while (true) {
            i2 = i;
            if (i2 < 0) {
            }
            i = i2 - 1;
        }
        if ((scanFlags & 1024) != 0) {
        }
    }

    private static String getRealPackageName(PackageParser.Package pkg, String renamedPkgName) {
        if (isPackageRenamed(pkg, renamedPkgName)) {
            return pkg.mRealPackage;
        }
        return null;
    }

    private static boolean isPackageRenamed(PackageParser.Package pkg, String renamedPkgName) {
        return pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPkgName);
    }

    @GuardedBy("mPackages")
    private PackageSetting getOriginalPackageLocked(PackageParser.Package pkg, String renamedPkgName) {
        if (!isPackageRenamed(pkg, renamedPkgName)) {
            return null;
        }
        for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
            PackageSetting originalPs = this.mSettings.getPackageLPr((String) pkg.mOriginalPackages.get(i));
            if (originalPs != null && verifyPackageUpdateLPr(originalPs, pkg)) {
                if (originalPs.sharedUser != null) {
                    if (!originalPs.sharedUser.name.equals(pkg.mSharedUserId)) {
                        Slog.w(TAG, "Unable to migrate data from " + originalPs.name + " to " + pkg.packageName + ": old uid " + originalPs.sharedUser.name + " differs from " + pkg.mSharedUserId);
                    }
                } else if (DEBUG_UPGRADE) {
                    Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + originalPs.name);
                }
                return originalPs;
            }
        }
        return null;
    }

    private static void ensurePackageRenamed(PackageParser.Package pkg, String renamedPackageName) {
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPackageName) && !pkg.packageName.equals(renamedPackageName)) {
            pkg.setPackageName(renamedPackageName);
        }
    }

    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime) throws PackageManagerException {
        return scanPackageOnlyLI(request, isUnderFactoryTest, currentTime, 0);
    }

    /* JADX WARNING: Removed duplicated region for block: B:122:0x0313  */
    /* JADX WARNING: Removed duplicated region for block: B:128:0x0333  */
    /* JADX WARNING: Removed duplicated region for block: B:154:0x03c3  */
    /* JADX WARNING: Removed duplicated region for block: B:157:0x03d8  */
    /* JADX WARNING: Removed duplicated region for block: B:163:0x03ee  */
    /* JADX WARNING: Removed duplicated region for block: B:180:0x0438  */
    /* JADX WARNING: Removed duplicated region for block: B:183:0x044a  */
    /* JADX WARNING: Removed duplicated region for block: B:29:0x00c8  */
    /* JADX WARNING: Removed duplicated region for block: B:31:0x00d7  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d9  */
    /* JADX WARNING: Removed duplicated region for block: B:35:0x00de  */
    /* JADX WARNING: Removed duplicated region for block: B:49:0x0170  */
    /* JADX WARNING: Removed duplicated region for block: B:55:0x01ea  */
    /* JADX WARNING: Removed duplicated region for block: B:56:0x01ec  */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x01f2  */
    /* JADX WARNING: Removed duplicated region for block: B:67:0x0208  */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x020c  */
    /* JADX WARNING: Removed duplicated region for block: B:77:0x022c  */
    /* JADX WARNING: Removed duplicated region for block: B:78:0x0236  */
    /* JADX WARNING: Removed duplicated region for block: B:81:0x024b  */
    /* JADX WARNING: Removed duplicated region for block: B:82:0x024d  */
    /* JADX WARNING: Removed duplicated region for block: B:85:0x026c  */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x027c  */
    @GuardedBy("mInstallLock")
    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime, int hwFlags) throws PackageManagerException {
        String primaryCpuAbiFromSettings;
        String secondaryCpuAbiFromSettings;
        String secondaryCpuAbiFromSettings2;
        String[] usesStaticLibraries;
        boolean createNewPackage;
        int scanFlags;
        boolean needToDeriveAbi;
        SharedUserSetting sharedUserSetting;
        UserHandle user;
        String secondaryCpuAbiFromSettings3;
        String primaryCpuAbiFromSettings2;
        PackageSetting disabledPkgSetting;
        int parseFlags;
        boolean isPlatformPackage;
        PackageSetting originalPkgSetting;
        int scanFlags2;
        long j;
        String volumeUuid;
        ScanRequest scanRequest = request;
        long j2 = currentTime;
        PackageParser.Package pkg = scanRequest.pkg;
        PackageSetting pkgSetting = scanRequest.pkgSetting;
        PackageSetting disabledPkgSetting2 = scanRequest.disabledPkgSetting;
        PackageSetting originalPkgSetting2 = scanRequest.originalPkgSetting;
        int parseFlags2 = scanRequest.parseFlags;
        int scanFlags3 = scanRequest.scanFlags;
        String realPkgName = scanRequest.realPkgName;
        SharedUserSetting sharedUserSetting2 = scanRequest.sharedUserSetting;
        UserHandle user2 = scanRequest.user;
        boolean isPlatformPackage2 = scanRequest.isPlatformPackage;
        List<String> changedAbiCodePath = null;
        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags2) != 0) {
            Log.d(TAG, "Scanning package " + pkg.packageName);
        }
        DexManager.maybeLogUnexpectedPackageDetails(pkg);
        new File(pkg.codePath);
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
        boolean needToDeriveAbi2 = (scanFlags3 & 8192) != 0;
        if (!needToDeriveAbi2) {
            if (pkgSetting != null) {
                String str = pkgSetting.primaryCpuAbiString;
                primaryCpuAbiFromSettings = pkgSetting.secondaryCpuAbiString;
                secondaryCpuAbiFromSettings = str;
                if (pkgSetting != null || pkgSetting.sharedUser == sharedUserSetting2) {
                    secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
                } else {
                    StringBuilder sb = new StringBuilder();
                    secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
                    sb.append("Package ");
                    sb.append(pkg.packageName);
                    sb.append(" shared user changed from ");
                    sb.append(pkgSetting.sharedUser != null ? pkgSetting.sharedUser.name : "<nothing>");
                    sb.append(" to ");
                    sb.append(sharedUserSetting2 != null ? sharedUserSetting2.name : "<nothing>");
                    sb.append("; replacing with new");
                    reportSettingsProblem(5, sb.toString());
                    pkgSetting = null;
                }
                usesStaticLibraries = null;
                if (pkg.usesStaticLibraries != null) {
                    usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
                    pkg.usesStaticLibraries.toArray(usesStaticLibraries);
                }
                createNewPackage = pkgSetting != null;
                if (!createNewPackage) {
                    primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
                    secondaryCpuAbiFromSettings3 = secondaryCpuAbiFromSettings2;
                    isPlatformPackage = isPlatformPackage2;
                    user = user2;
                    sharedUserSetting = sharedUserSetting2;
                    String str2 = realPkgName;
                    needToDeriveAbi = needToDeriveAbi2;
                    parseFlags = parseFlags2;
                    scanFlags = scanFlags3;
                    originalPkgSetting = originalPkgSetting2;
                    disabledPkgSetting = disabledPkgSetting2;
                    destCodeFile = destCodeFile;
                    pkgSetting = Settings.createNewSetting(pkg.packageName, originalPkgSetting2, disabledPkgSetting2, realPkgName, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, (long) pkg.mVersionCode, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, true, (scanFlags3 & 16384) != 0, (65536 & scanFlags3) != 0, pkg.parentPackage != null ? pkg.parentPackage.packageName : null, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
                } else {
                    needToDeriveAbi = needToDeriveAbi2;
                    primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
                    user = user2;
                    sharedUserSetting = sharedUserSetting2;
                    String str3 = realPkgName;
                    scanFlags = scanFlags3;
                    parseFlags = parseFlags2;
                    originalPkgSetting = originalPkgSetting2;
                    disabledPkgSetting = disabledPkgSetting2;
                    secondaryCpuAbiFromSettings3 = secondaryCpuAbiFromSettings2;
                    isPlatformPackage = isPlatformPackage2;
                    Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
                }
                if (createNewPackage && originalPkgSetting != null) {
                    pkg.setPackageName(originalPkgSetting.name);
                    reportSettingsProblem(5, "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name);
                }
                UserHandle user3 = user;
                int userId = user3 != null ? 0 : user3.getIdentifier();
                if (createNewPackage) {
                    scanFlags2 = scanFlags;
                    setInstantAppForUser(pkgSetting, userId, (scanFlags2 & 16384) != 0, (32768 & scanFlags2) != 0);
                } else {
                    scanFlags2 = scanFlags;
                }
                if (disabledPkgSetting != null) {
                    pkg.applicationInfo.flags |= 128;
                    HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
                }
                SharedUserSetting sharedUserSetting3 = sharedUserSetting;
                int targetSdkVersion = (sharedUserSetting3 != null || sharedUserSetting3.packages.size() == 0) ? pkg.applicationInfo.targetSdkVersion : sharedUserSetting3.seInfoTargetSdkVersion;
                boolean isPrivileged = sharedUserSetting3 == null ? sharedUserSetting3.isPrivileged() | pkg.isPrivileged() : pkg.isPrivileged();
                pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, isPrivileged, pkg.applicationInfo.targetSandboxVersion, targetSdkVersion);
                pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId != -1 ? 0 : userId));
                pkg.mExtras = pkgSetting;
                pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
                if (!isPlatformPackage) {
                    pkg.applicationInfo.initForUser(0);
                }
                String cpuAbiOverride = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
                if ((scanFlags2 & 4) == 0) {
                    String str4 = secondaryCpuAbiFromSettings3;
                    if ((scanFlags2 & 256) != 0) {
                        PackageSetting packageSetting = originalPkgSetting;
                        pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
                        pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
                    }
                    setNativeLibraryPaths(pkg, sAppLib32InstallDir);
                } else if (needToDeriveAbi) {
                    Trace.traceBegin(262144, "derivePackageAbi");
                    derivePackageAbi(pkg, cpuAbiOverride, (pkg.isLibrary() ^ true) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
                    Trace.traceEnd(262144);
                    if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                        setBundledAppAbisAndRoots(pkg, pkgSetting);
                        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
                    }
                    PackageSetting packageSetting2 = originalPkgSetting;
                    String str5 = primaryCpuAbiFromSettings2;
                    String str6 = secondaryCpuAbiFromSettings3;
                } else {
                    if (primaryCpuAbiFromSettings2 != null || ((!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath))) {
                        pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings2;
                        pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings3;
                    } else {
                        derivePackageAbi(pkg, cpuAbiOverride, !pkg.isLibrary() && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
                        if (pkg.applicationInfo.primaryCpuAbi == null) {
                            setBundledAppAbisAndRoots(pkg, pkgSetting);
                        }
                    }
                    setNativeLibraryPaths(pkg, sAppLib32InstallDir);
                    PackageSetting packageSetting3 = originalPkgSetting;
                }
                if (isPlatformPackage) {
                    pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
                }
                if ((scanFlags2 & 1) == 0 || (scanFlags2 & 4) == 0 || cpuAbiOverride != null || pkg.packageName == null) {
                } else {
                    StringBuilder sb2 = new StringBuilder();
                    String[] strArr = usesStaticLibraries;
                    sb2.append("Ignoring persisted ABI override ");
                    sb2.append(cpuAbiOverride);
                    sb2.append(" for package ");
                    sb2.append(pkg.packageName);
                    Slog.w(TAG, sb2.toString());
                }
                pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
                pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
                pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
                pkg.cpuAbiOverride = cpuAbiOverride;
                pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
                if ((scanFlags2 & 16) == 0 && pkgSetting.sharedUser != null) {
                    changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
                }
                List<String> changedAbiCodePath2 = changedAbiCodePath;
                if (isUnderFactoryTest && pkg.requestedPermissions.contains("android.permission.FACTORY_TEST")) {
                    pkg.applicationInfo.flags |= 16;
                }
                if (isSystemApp(pkg)) {
                    pkgSetting.isOrphaned = true;
                }
                UserHandle userHandle = user3;
                long scanFileTime = PackageManagerServiceUtils.getLastModifiedTime(pkg);
                SharedUserSetting sharedUserSetting4 = sharedUserSetting3;
                int i = targetSdkVersion;
                j = currentTime;
                if (j == 0) {
                    boolean z = isPrivileged;
                    File file = destCodeFile;
                    if (pkgSetting.firstInstallTime == 0) {
                        pkgSetting.lastUpdateTime = j;
                        pkgSetting.firstInstallTime = j;
                    } else if ((scanFlags2 & 8) != 0) {
                        pkgSetting.lastUpdateTime = j;
                    }
                } else {
                    File file2 = destCodeFile;
                    if (pkgSetting.firstInstallTime == 0) {
                        pkgSetting.lastUpdateTime = scanFileTime;
                        pkgSetting.firstInstallTime = scanFileTime;
                    } else if ((parseFlags & 16) != 0) {
                        if (scanFileTime != pkgSetting.timeStamp) {
                            pkgSetting.lastUpdateTime = scanFileTime;
                        }
                        if (sIsMygote && HwMaplePMServiceUtils.verifyMd5(pkg) && !HwMaplePMServiceUtils.getMapleEnableFlag(pkg.packageName)) {
                            HwMaplePMServiceUtils.setMapleEnableFlag(pkg.packageName, true);
                        }
                    }
                }
                pkgSetting.setTimeStamp(scanFileTime);
                pkgSetting.pkg = pkg;
                pkgSetting.pkgFlags = pkg.applicationInfo.flags;
                long j3 = scanFileTime;
                if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
                    pkgSetting.versionCode = pkg.getLongVersionCode();
                }
                volumeUuid = pkg.applicationInfo.volumeUuid;
                if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
                    StringBuilder sb3 = new StringBuilder();
                    sb3.append("Update");
                    sb3.append(pkgSetting.isSystem() ? " system" : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                    sb3.append(" package ");
                    sb3.append(pkg.packageName);
                    sb3.append(" volume from ");
                    sb3.append(pkgSetting.volumeUuid);
                    sb3.append(" to ");
                    sb3.append(volumeUuid);
                    Slog.i(TAG, sb3.toString());
                    pkgSetting.volumeUuid = volumeUuid;
                }
                return new ScanResult(true, pkgSetting, changedAbiCodePath2);
            }
            needToDeriveAbi2 = true;
        }
        secondaryCpuAbiFromSettings = null;
        primaryCpuAbiFromSettings = null;
        if (pkgSetting != null) {
        }
        secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
        usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
        }
        createNewPackage = pkgSetting != null;
        if (!createNewPackage) {
        }
        pkg.setPackageName(originalPkgSetting.name);
        reportSettingsProblem(5, "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name);
        UserHandle user32 = user;
        if (user32 != null) {
        }
        if (createNewPackage) {
        }
        if (disabledPkgSetting != null) {
        }
        SharedUserSetting sharedUserSetting32 = sharedUserSetting;
        if (sharedUserSetting32 != null) {
        }
        if (sharedUserSetting32 == null) {
        }
        pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, isPrivileged, pkg.applicationInfo.targetSandboxVersion, targetSdkVersion);
        pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId != -1 ? 0 : userId));
        pkg.mExtras = pkgSetting;
        pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
        if (!isPlatformPackage) {
        }
        String cpuAbiOverride2 = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
        if ((scanFlags2 & 4) == 0) {
        }
        if (isPlatformPackage) {
        }
        if ((scanFlags2 & 1) == 0) {
        }
        pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
        pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        pkgSetting.cpuAbiOverrideString = cpuAbiOverride2;
        pkg.cpuAbiOverride = cpuAbiOverride2;
        pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
        changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
        List<String> changedAbiCodePath22 = changedAbiCodePath;
        pkg.applicationInfo.flags |= 16;
        if (isSystemApp(pkg)) {
        }
        UserHandle userHandle2 = user32;
        long scanFileTime2 = PackageManagerServiceUtils.getLastModifiedTime(pkg);
        SharedUserSetting sharedUserSetting42 = sharedUserSetting32;
        int i2 = targetSdkVersion;
        j = currentTime;
        if (j == 0) {
        }
        pkgSetting.setTimeStamp(scanFileTime2);
        pkgSetting.pkg = pkg;
        pkgSetting.pkgFlags = pkg.applicationInfo.flags;
        long j32 = scanFileTime2;
        if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
        }
        volumeUuid = pkg.applicationInfo.volumeUuid;
        if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
        }
        return new ScanResult(true, pkgSetting, changedAbiCodePath22);
    }

    private static boolean apkHasCode(String fileName) {
        StrictJarFile jarFile = null;
        boolean z = false;
        try {
            StrictJarFile jarFile2 = new StrictJarFile(fileName, false, false);
            if (jarFile2.findEntry("classes.dex") != null) {
                z = true;
            }
            try {
                jarFile2.close();
            } catch (IOException e) {
            }
            return z;
        } catch (IOException e2) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e3) {
                }
            }
            return false;
        } catch (Throwable th) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e4) {
                }
            }
            throw th;
        }
    }

    private static void assertCodePolicy(PackageParser.Package pkg) throws PackageManagerException {
        if (((pkg.applicationInfo.flags & 4) != 0) && !apkHasCode(pkg.baseCodePath)) {
            throw new PackageManagerException(-2, "Package " + pkg.baseCodePath + " code is missing");
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            int i = 0;
            while (i < pkg.splitCodePaths.length) {
                if (!((pkg.splitFlags[i] & 4) != 0) || apkHasCode(pkg.splitCodePaths[i])) {
                    i++;
                } else {
                    throw new PackageManagerException(-2, "Package " + pkg.splitCodePaths[i] + " code is missing");
                }
            }
        }
    }

    private static void applyPolicy(PackageParser.Package pkg, int parseFlags, int scanFlags, PackageParser.Package platformPkg, int hwFlags) {
        if ((scanFlags & 131072) != 0) {
            pkg.applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                Iterator it = pkg.services.iterator();
                while (it.hasNext()) {
                    PackageParser.Service s = (PackageParser.Service) it.next();
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                Iterator it2 = pkg.providers.iterator();
                while (it2.hasNext()) {
                    PackageParser.Provider p = (PackageParser.Provider) it2.next();
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                Iterator it3 = pkg.activities.iterator();
                while (it3.hasNext()) {
                    PackageParser.Activity a = (PackageParser.Activity) it3.next();
                    ActivityInfo activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                Iterator it4 = pkg.receivers.iterator();
                while (it4.hasNext()) {
                    PackageParser.Activity r = (PackageParser.Activity) it4.next();
                    ActivityInfo activityInfo2 = r.info;
                    r.info.directBootAware = true;
                    activityInfo2.encryptionAware = true;
                }
            }
            if (PackageManagerServiceUtils.compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            pkg.applicationInfo.flags &= -9;
            pkg.applicationInfo.privateFlags &= -33;
            pkg.applicationInfo.privateFlags &= -65;
            if (pkg.permissionGroups != null && pkg.permissionGroups.size() > 0) {
                for (int i = pkg.permissionGroups.size() - 1; i >= 0; i--) {
                    ((PackageParser.PermissionGroup) pkg.permissionGroups.get(i)).info.priority = 0;
                }
            }
        }
        if ((scanFlags & 262144) == 0) {
            pkg.protectedBroadcasts = null;
            if (pkg.receivers != null) {
                for (int i2 = pkg.receivers.size() - 1; i2 >= 0; i2--) {
                    PackageParser.Activity receiver = (PackageParser.Activity) pkg.receivers.get(i2);
                    if ((receiver.info.flags & 1073741824) != 0) {
                        receiver.info.exported = false;
                    }
                }
            }
            if (pkg.services != null) {
                for (int i3 = pkg.services.size() - 1; i3 >= 0; i3--) {
                    PackageParser.Service service = (PackageParser.Service) pkg.services.get(i3);
                    if ((service.info.flags & 1073741824) != 0) {
                        service.info.exported = false;
                    }
                }
            }
            if (pkg.providers != null) {
                int i4 = pkg.providers.size() - 1;
                while (true) {
                    int i5 = i4;
                    if (i5 < 0) {
                        break;
                    }
                    PackageParser.Provider provider = (PackageParser.Provider) pkg.providers.get(i5);
                    if ((provider.info.flags & 1073741824) != 0) {
                        provider.info.exported = false;
                    }
                    i4 = i5 - 1;
                }
            }
        }
        if ((scanFlags & 262144) != 0) {
            pkg.applicationInfo.privateFlags |= 8;
        }
        HwPackageManagerServiceUtils.addFlagsForRemovablePreApk(pkg, hwFlags);
        HwPackageManagerServiceUtils.addFlagsForUpdatedRemovablePreApk(pkg, hwFlags);
        if ((scanFlags & 524288) != 0) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 131072 | applicationInfo.privateFlags;
        }
        if ((scanFlags & 1048576) != 0) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 262144 | applicationInfo2.privateFlags;
        }
        if ((2097152 & scanFlags) != 0) {
            ApplicationInfo applicationInfo3 = pkg.applicationInfo;
            applicationInfo3.privateFlags = 524288 | applicationInfo3.privateFlags;
        }
        if (PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (platformPkg != null && PackageManagerServiceUtils.compareSignatures(platformPkg.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
            ApplicationInfo applicationInfo4 = pkg.applicationInfo;
            applicationInfo4.privateFlags = 1048576 | applicationInfo4.privateFlags;
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
    }

    private static <T> T assertNotNull(T object, String message) throws PackageManagerException {
        if (object != null) {
            return object;
        }
        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, message);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags) throws PackageManagerException {
        assertPackageIsValid(pkg, parseFlags, scanFlags, 0);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags, int hwFlags) throws PackageManagerException {
        PackageParser.Package packageR = pkg;
        int i = scanFlags;
        if ((parseFlags & 64) != 0) {
            assertCodePolicy(pkg);
        }
        if (packageR.applicationInfo.getCodePath() == null || packageR.applicationInfo.getResourcePath() == null) {
            throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
        }
        this.mSettings.mKeySetManagerService.assertScannedPackageValid(packageR);
        synchronized (this.mPackages) {
            if (packageR.packageName.equals(PLATFORM_PACKAGE_NAME)) {
                if (this.mAndroidApplication != null) {
                    Slog.w(TAG, "*************************************************");
                    Slog.w(TAG, "Core android package being redefined.  Skipping.");
                    Slog.w(TAG, " codePath=" + packageR.codePath);
                    Slog.w(TAG, "*************************************************");
                    throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
                }
            }
            if ((hwFlags & 1073741824) == 0) {
                if (this.mPackages.containsKey(packageR.packageName)) {
                    throw new PackageManagerException(-5, "Application package " + packageR.packageName + " already installed.  Skipping duplicate.");
                }
            }
            if (packageR.applicationInfo.isStaticSharedLibrary()) {
                if (this.mPackages.containsKey(packageR.manifestPackageName)) {
                    throw new PackageManagerException("Duplicate static shared lib provider package");
                } else if (packageR.applicationInfo.targetSdkVersion < 26) {
                    throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                } else if ((i & 16384) != 0) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                } else if (!ArrayUtils.isEmpty(packageR.mOriginalPackages)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                } else if (!ArrayUtils.isEmpty(packageR.childPackages)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                } else if (!ArrayUtils.isEmpty(packageR.libraryNames)) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                } else if (packageR.mSharedUserId != null) {
                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                } else if (!packageR.activities.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare activities");
                } else if (!packageR.services.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare services");
                } else if (!packageR.providers.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare content providers");
                } else if (!packageR.receivers.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                } else if (!packageR.permissionGroups.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare permission groups");
                } else if (!packageR.permissions.isEmpty()) {
                    throw new PackageManagerException("Static shared libs cannot declare permissions");
                } else if (packageR.protectedBroadcasts != null) {
                    throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                } else if (packageR.mOverlayTarget == null) {
                    long minVersionCode = Long.MIN_VALUE;
                    long maxVersionCode = JobStatus.NO_LATEST_RUNTIME;
                    LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(packageR.staticSharedLibName);
                    if (versionedLib != null) {
                        int versionCount = versionedLib.size();
                        long maxVersionCode2 = Long.MAX_VALUE;
                        long minVersionCode2 = Long.MIN_VALUE;
                        int i2 = 0;
                        while (true) {
                            if (i2 >= versionCount) {
                                maxVersionCode = maxVersionCode2;
                                minVersionCode = minVersionCode2;
                                break;
                            }
                            SharedLibraryInfo libInfo = versionedLib.valueAt(i2).info;
                            long libVersionCode = libInfo.getDeclaringPackage().getLongVersionCode();
                            if (libInfo.getLongVersion() >= packageR.staticSharedLibVersion) {
                                long minVersionCode3 = minVersionCode2;
                                if (libInfo.getLongVersion() <= packageR.staticSharedLibVersion) {
                                    minVersionCode = libVersionCode;
                                    maxVersionCode = libVersionCode;
                                    break;
                                }
                                maxVersionCode2 = Math.min(maxVersionCode2, libVersionCode - 1);
                                minVersionCode2 = minVersionCode3;
                            } else {
                                minVersionCode2 = Math.max(minVersionCode2, libVersionCode + 1);
                            }
                            i2++;
                        }
                    }
                    if (pkg.getLongVersionCode() < minVersionCode || pkg.getLongVersionCode() > maxVersionCode) {
                        throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                    }
                } else {
                    throw new PackageManagerException("Static shared libs cannot be overlay targets");
                }
            }
            if (packageR.childPackages != null && !packageR.childPackages.isEmpty()) {
                if ((262144 & i) != 0) {
                    int childCount = packageR.childPackages.size();
                    int i3 = 0;
                    while (i3 < childCount) {
                        if (!this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(packageR.packageName, ((PackageParser.Package) packageR.childPackages.get(i3)).packageName)) {
                            i3++;
                        } else {
                            throw new PackageManagerException("Can't override child of another disabled app. Ignoring package " + packageR.packageName);
                        }
                    }
                } else {
                    throw new PackageManagerException("Only privileged apps can add child packages. Ignoring package " + packageR.packageName);
                }
            }
            if ((i & 128) != 0) {
                if (!this.mExpectingBetter.containsKey(packageR.packageName)) {
                    if (!mHwPMSEx.isSystemAppGrantByMdm(packageR)) {
                        PackageSetting known = this.mSettings.getPackageLPr(packageR.packageName);
                        if (known != null) {
                            if (DEBUG_PACKAGE_SCANNING) {
                                Log.d(TAG, "Examining " + packageR.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                            }
                            if (!packageR.applicationInfo.getCodePath().equals(known.codePathString) || !packageR.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                                throw new PackageManagerException(-23, "Application package " + packageR.packageName + " found at " + packageR.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                            }
                        } else {
                            throw new PackageManagerException(-19, "Application package " + packageR.packageName + " not found; ignoring.");
                        }
                    }
                }
                PackageManagerServiceUtils.logCriticalInfo(5, "Relax SCAN_REQUIRE_KNOWN requirement for package " + packageR.packageName);
            }
            if ((i & 4) != 0) {
                int N = packageR.providers.size();
                for (int i4 = 0; i4 < N; i4++) {
                    PackageParser.Provider p = (PackageParser.Provider) packageR.providers.get(i4);
                    if (p.info.authority != null) {
                        String[] names = p.info.authority.split(";");
                        for (int j = 0; j < names.length; j++) {
                            if (this.mProvidersByAuthority.containsKey(names[j])) {
                                PackageParser.Provider other = this.mProvidersByAuthority.get(names[j]);
                                String otherPackageName = (other == null || other.getComponentName() == null) ? "?" : other.getComponentName().getPackageName();
                                throw new PackageManagerException(-13, "Can't install because provider name " + names[j] + " (in package " + packageR.applicationInfo.packageName + ") is already used by " + otherPackageName);
                            }
                        }
                        continue;
                    }
                }
            }
            if (pkg.isPrivileged() == 0 && packageR.mSharedUserId != null) {
                SharedUserSetting sharedUserSetting = null;
                try {
                    sharedUserSetting = this.mSettings.getSharedUserLPw(packageR.mSharedUserId, 0, 0, false);
                } catch (PackageManagerException e) {
                }
                if (sharedUserSetting != null) {
                    if (sharedUserSetting.isPrivileged()) {
                        PackageSetting platformPkgSetting = this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME);
                        if (platformPkgSetting.signatures.mSigningDetails != PackageParser.SigningDetails.UNKNOWN) {
                            if (PackageManagerServiceUtils.compareSignatures(platformPkgSetting.signatures.mSigningDetails.signatures, packageR.mSigningDetails.signatures) != 0) {
                                throw new PackageManagerException("Apps that share a user with a privileged app must themselves be marked as privileged. " + packageR.packageName + " shares privileged user " + packageR.mSharedUserId + ".");
                            }
                        }
                    }
                }
            }
            if (packageR.mOverlayTarget != null) {
                if ((131072 & i) != 0) {
                    if ((parseFlags & 16) == 0) {
                        PackageSetting previousPkg = (PackageSetting) assertNotNull(this.mSettings.getPackageLPr(packageR.packageName), "previous package state not present");
                        PackageParser.Package ppkg = previousPkg.pkg;
                        if (ppkg == null) {
                            try {
                                ppkg = new PackageParser().parsePackage(previousPkg.codePath, parseFlags | 16);
                            } catch (PackageParser.PackageParserException e2) {
                                Slog.w(TAG, "failed to parse " + previousPkg.codePath, e2);
                            }
                        }
                        if (ppkg != null) {
                            if (ppkg.mOverlayIsStatic) {
                                throw new PackageManagerException("Overlay " + packageR.packageName + " is static and cannot be upgraded.");
                            }
                        }
                        if (packageR.mOverlayIsStatic) {
                            throw new PackageManagerException("Overlay " + packageR.packageName + " cannot be upgraded into a static overlay.");
                        }
                    }
                } else if (!packageR.mOverlayIsStatic) {
                    PackageSetting platformPkgSetting2 = this.mSettings.getPackageLPr(PLATFORM_PACKAGE_NAME);
                    if (platformPkgSetting2.signatures.mSigningDetails != PackageParser.SigningDetails.UNKNOWN) {
                        if (PackageManagerServiceUtils.compareSignatures(platformPkgSetting2.signatures.mSigningDetails.signatures, packageR.mSigningDetails.signatures) != 0) {
                            throw new PackageManagerException("Overlay " + packageR.packageName + " must be signed with the platform certificate.");
                        }
                    }
                } else {
                    throw new PackageManagerException("Overlay " + packageR.packageName + " is static but not pre-installed.");
                }
            }
        }
    }

    private boolean addSharedLibraryLPw(String path, String apk, String name, long version, int type, String declaringPackageName, long declaringVersionCode) {
        int i;
        String str;
        String str2 = name;
        long j = version;
        LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(str2);
        if (versionedLib == null) {
            versionedLib = new LongSparseArray<>();
            this.mSharedLibraries.put(str2, versionedLib);
            i = type;
            if (i == 2) {
                str = declaringPackageName;
                this.mStaticLibsByDeclaringPackage.put(str, versionedLib);
            } else {
                str = declaringPackageName;
            }
        } else {
            i = type;
            str = declaringPackageName;
            if (versionedLib.indexOfKey(j) >= 0) {
                return false;
            }
        }
        LongSparseArray<SharedLibraryEntry> versionedLib2 = versionedLib;
        SharedLibraryEntry libEntry = new SharedLibraryEntry(path, apk, str2, j, i, str, declaringVersionCode);
        versionedLib2.put(j, libEntry);
        return true;
    }

    private boolean removeSharedLibraryLPw(String name, long version) {
        LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            return false;
        }
        int libIdx = versionedLib.indexOfKey(version);
        if (libIdx < 0) {
            return false;
        }
        SharedLibraryEntry libEntry = versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() <= 0) {
            this.mSharedLibraries.remove(name);
            if (libEntry.info.getType() == 2) {
                this.mStaticLibsByDeclaringPackage.remove(libEntry.info.getDeclaringPackage().getPackageName());
            }
        }
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:270:0x0705, code lost:
        android.os.Trace.traceEnd(262144);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:271:0x070b, code lost:
        return;
     */
    /* JADX WARNING: Removed duplicated region for block: B:134:0x02fd A[Catch:{ all -> 0x03e4 }] */
    /* JADX WARNING: Removed duplicated region for block: B:156:0x0387 A[Catch:{ all -> 0x06b2, all -> 0x0374, all -> 0x045b }] */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x022a  */
    /* JADX WARNING: Removed duplicated region for block: B:99:0x0254 A[SYNTHETIC, Splitter:B:99:0x0254] */
    private void commitPackageSettings(PackageParser.Package pkg, PackageParser.Package oldPkg, PackageSetting pkgSetting, UserHandle user, int scanFlags, boolean chatty) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayList<PackageParser.Package> clientLibPkgs;
        PackageParser.Package packageR;
        Iterator<PackageCleanItem> iter;
        ArrayList<PackageParser.Package> clientLibPkgs2;
        boolean z;
        PackageParser.Provider p;
        PackageParser.Package packageR2;
        Iterator<PackageCleanItem> iter2;
        boolean hasStaticSharedLibs;
        int i;
        boolean hasStaticSharedLibs2;
        PackageParser.Package packageR3 = pkg;
        PackageParser.Package packageR4 = oldPkg;
        PackageSetting packageSetting = pkgSetting;
        int i2 = scanFlags;
        boolean z2 = chatty;
        PackageParser.Package packageR5 = packageR3.packageName;
        if (this.mCustomResolverComponentName != null && this.mCustomResolverComponentName.getPackageName().equals(packageR3.packageName)) {
            getHwPMSEx().setUpCustomResolverActivity(packageR3);
        }
        if (packageR3.packageName.equals(PLATFORM_PACKAGE_NAME)) {
            synchronized (this.mPackages) {
                if ((i2 & 1024) == 0) {
                    try {
                        this.mPlatformPackage = packageR3;
                        packageR3.mVersionCode = this.mSdkVersion;
                        packageR3.mVersionCodeMajor = 0;
                        this.mAndroidApplication = packageR3.applicationInfo;
                        if (!this.mResolverReplaced) {
                            this.mResolveActivity.applicationInfo = this.mAndroidApplication;
                            this.mResolveActivity.name = ResolverActivity.class.getName();
                            this.mResolveActivity.packageName = this.mAndroidApplication.packageName;
                            this.mResolveActivity.processName = "system:ui";
                            this.mResolveActivity.launchMode = 0;
                            this.mResolveActivity.documentLaunchMode = 3;
                            this.mResolveActivity.flags = 32;
                            this.mResolveActivity.theme = 16974374;
                            this.mResolveActivity.exported = true;
                            this.mResolveActivity.enabled = true;
                            this.mResolveActivity.resizeMode = 2;
                            this.mResolveActivity.configChanges = 3504;
                            this.mResolveInfo.activityInfo = this.mResolveActivity;
                            this.mResolveInfo.priority = 0;
                            this.mResolveInfo.preferredOrder = 0;
                            this.mResolveInfo.match = 0;
                            this.mResolveComponentName = new ComponentName(this.mAndroidApplication.packageName, this.mResolveActivity.name);
                        }
                    } catch (Throwable th) {
                        throw th;
                    }
                }
            }
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            boolean hasStaticSharedLibs3 = false;
            try {
                if (packageR3.staticSharedLibName != null) {
                    try {
                        ArrayMap<String, PackageParser.Package> arrayMap3 = arrayMap2;
                        try {
                            arrayMap = arrayMap3;
                            packageR4 = packageR5;
                            if (addSharedLibraryLPw(null, packageR3.packageName, packageR3.staticSharedLibName, packageR3.staticSharedLibVersion, 2, packageR3.manifestPackageName, pkg.getLongVersionCode())) {
                                hasStaticSharedLibs3 = true;
                                updateAllSharedLibrariesLPw(pkg);
                            } else {
                                Slog.w(TAG, "Package " + packageR3.packageName + " library " + packageR3.staticSharedLibName + " already exists; skipping");
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            PackageParser.Package packageR6 = packageR4;
                            PackageParser.Package packageR7 = oldPkg;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        arrayMap = arrayMap2;
                        PackageParser.Package packageR8 = packageR5;
                        PackageParser.Package packageR9 = oldPkg;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                } else {
                    arrayMap = arrayMap2;
                    packageR4 = packageR5;
                }
                if (!hasStaticSharedLibs3) {
                    boolean z3 = true;
                    if ((packageR3.applicationInfo.flags & 1) != 0 && packageR3.libraryNames != null) {
                        int i3 = 0;
                        while (true) {
                            int i4 = i3;
                            if (i4 >= packageR3.libraryNames.size()) {
                                break;
                            }
                            String name = (String) packageR3.libraryNames.get(i4);
                            boolean allowed = false;
                            if (pkg.isUpdatedSystemApp()) {
                                PackageSetting sysPs = this.mSettings.getDisabledSystemPkgLPr(packageR3.packageName);
                                if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                                    int j = 0;
                                    while (true) {
                                        if (j >= sysPs.pkg.libraryNames.size()) {
                                            break;
                                        } else if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                                            allowed = true;
                                            break;
                                        } else {
                                            j++;
                                        }
                                    }
                                }
                            } else {
                                allowed = true;
                            }
                            if (allowed) {
                                hasStaticSharedLibs = hasStaticSharedLibs3;
                                hasStaticSharedLibs2 = z3;
                                i = i4;
                                if (!addSharedLibraryLPw(null, packageR3.packageName, name, -1, 1, packageR3.packageName, pkg.getLongVersionCode())) {
                                    Slog.w(TAG, "Package " + packageR3.packageName + " library " + name + " already exists; skipping");
                                }
                            } else {
                                hasStaticSharedLibs = hasStaticSharedLibs3;
                                hasStaticSharedLibs2 = z3;
                                i = i4;
                                Slog.w(TAG, "Package " + packageR3.packageName + " declares lib " + name + " that is not declared on system image; skipping");
                            }
                            i3 = i + 1;
                            z3 = hasStaticSharedLibs2;
                            hasStaticSharedLibs3 = hasStaticSharedLibs;
                        }
                        boolean hasStaticSharedLibs4 = z3;
                        if ((i2 & 16) == 0) {
                            clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                            if ((i2 & 16) == 0 && (i2 & 2048) == 0 && (i2 & 4096) == 0) {
                                checkPackageFrozen(packageR4);
                            }
                            if (clientLibPkgs != null) {
                                for (int i5 = 0; i5 < clientLibPkgs.size(); i5++) {
                                    PackageParser.Package clientPkg = clientLibPkgs.get(i5);
                                    killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
                                }
                            }
                            Trace.traceBegin(262144, "updateSettings");
                            synchronized (this.mPackages) {
                                try {
                                    this.mSettings.insertPackageSettingLPw(packageSetting, packageR3);
                                    mHwPMSEx.updateCertCompatPackage(packageR3, packageSetting);
                                    this.mPackages.put(packageR3.applicationInfo.packageName, packageR3);
                                    Iterator<PackageCleanItem> iter3 = this.mSettings.mPackagesToBeCleaned.iterator();
                                    while (iter3.hasNext()) {
                                        try {
                                            if (packageR4.equals(iter3.next().packageName)) {
                                                iter3.remove();
                                            }
                                        } catch (Throwable th4) {
                                            th = th4;
                                            ArrayList<PackageParser.Package> arrayList = clientLibPkgs;
                                            PackageParser.Package packageR10 = packageR4;
                                            PackageParser.Package packageR11 = oldPkg;
                                            throw th;
                                        }
                                    }
                                    this.mSettings.mKeySetManagerService.addScannedPackageLPw(packageR3);
                                    int N = packageR3.providers.size();
                                    StringBuilder r = null;
                                    int i6 = 0;
                                    while (i6 < N) {
                                        try {
                                            PackageParser.Provider p2 = (PackageParser.Provider) packageR3.providers.get(i6);
                                            p2.info.processName = fixProcessName(packageR3.applicationInfo.processName, p2.info.processName);
                                            this.mProviders.addProvider(p2);
                                            p2.syncable = p2.info.isSyncable;
                                            if (p2.info.authority != null) {
                                                String[] names = p2.info.authority.split(";");
                                                p2.info.authority = null;
                                                PackageParser.Provider p3 = p2;
                                                int j2 = 0;
                                                while (j2 < names.length) {
                                                    if (j2 == 1) {
                                                        if (p3.syncable) {
                                                            p3 = new PackageParser.Provider(p3);
                                                            p3.syncable = false;
                                                            ArrayList<PackageParser.Package> clientLibPkgs3 = clientLibPkgs;
                                                            if (this.mProvidersByAuthority.containsKey(names[j2])) {
                                                                this.mProvidersByAuthority.put(names[j2], p3);
                                                                if (p3.info.authority == null) {
                                                                    try {
                                                                        p3.info.authority = names[j2];
                                                                        iter2 = iter3;
                                                                    } catch (Throwable th5) {
                                                                        th = th5;
                                                                        PackageParser.Package packageR102 = packageR4;
                                                                        PackageParser.Package packageR112 = oldPkg;
                                                                        throw th;
                                                                    }
                                                                } else {
                                                                    ProviderInfo providerInfo = p3.info;
                                                                    StringBuilder sb = new StringBuilder();
                                                                    iter2 = iter3;
                                                                    sb.append(p3.info.authority);
                                                                    sb.append(";");
                                                                    sb.append(names[j2]);
                                                                    providerInfo.authority = sb.toString();
                                                                }
                                                                if (DEBUG_PACKAGE_SCANNING) {
                                                                    PackageParser.Package packageR12 = packageR4;
                                                                    if (chatty) {
                                                                        try {
                                                                            StringBuilder sb2 = new StringBuilder();
                                                                            packageR2 = packageR12;
                                                                            sb2.append("Registered content provider: ");
                                                                            sb2.append(names[j2]);
                                                                            sb2.append(", className = ");
                                                                            sb2.append(p3.info.name);
                                                                            sb2.append(", isSyncable = ");
                                                                            sb2.append(p3.info.isSyncable);
                                                                            Log.d(TAG, sb2.toString());
                                                                            p = p3;
                                                                        } catch (Throwable th6) {
                                                                            th = th6;
                                                                            PackageParser.Package packageR1122 = oldPkg;
                                                                            throw th;
                                                                        }
                                                                    } else {
                                                                        packageR2 = packageR12;
                                                                        p = p3;
                                                                    }
                                                                } else {
                                                                    packageR2 = packageR4;
                                                                    boolean z4 = chatty;
                                                                    p = p3;
                                                                }
                                                            } else {
                                                                iter2 = iter3;
                                                                packageR2 = packageR4;
                                                                boolean z5 = chatty;
                                                                PackageParser.Provider other = this.mProvidersByAuthority.get(names[j2]);
                                                                StringBuilder sb3 = new StringBuilder();
                                                                p = p3;
                                                                sb3.append("Skipping provider name ");
                                                                sb3.append(names[j2]);
                                                                sb3.append(" (in package ");
                                                                sb3.append(packageR3.applicationInfo.packageName);
                                                                sb3.append("): name already used by ");
                                                                sb3.append((other == null || other.getComponentName() == null) ? "?" : other.getComponentName().getPackageName());
                                                                Slog.w(TAG, sb3.toString());
                                                            }
                                                            j2++;
                                                            clientLibPkgs = clientLibPkgs3;
                                                            iter3 = iter2;
                                                            packageR4 = packageR2;
                                                            p3 = p;
                                                        }
                                                    }
                                                    ArrayList<PackageParser.Package> clientLibPkgs32 = clientLibPkgs;
                                                    try {
                                                        if (this.mProvidersByAuthority.containsKey(names[j2])) {
                                                        }
                                                        j2++;
                                                        clientLibPkgs = clientLibPkgs32;
                                                        iter3 = iter2;
                                                        packageR4 = packageR2;
                                                        p3 = p;
                                                    } catch (Throwable th7) {
                                                        th = th7;
                                                        PackageParser.Package packageR13 = packageR4;
                                                        boolean z6 = chatty;
                                                        PackageParser.Package packageR14 = oldPkg;
                                                        throw th;
                                                    }
                                                }
                                                clientLibPkgs2 = clientLibPkgs;
                                                iter = iter3;
                                                packageR = packageR4;
                                                z = chatty;
                                                p2 = p3;
                                            } else {
                                                clientLibPkgs2 = clientLibPkgs;
                                                iter = iter3;
                                                packageR = packageR4;
                                                z = chatty;
                                            }
                                            if (z) {
                                                if (r == null) {
                                                    r = new StringBuilder(256);
                                                } else {
                                                    r.append(' ');
                                                }
                                                r.append(p2.info.name);
                                            }
                                            i6++;
                                            clientLibPkgs = clientLibPkgs2;
                                            iter3 = iter;
                                            packageR4 = packageR;
                                        } catch (Throwable th8) {
                                            th = th8;
                                            ArrayList<PackageParser.Package> arrayList2 = clientLibPkgs;
                                            PackageParser.Package packageR15 = packageR4;
                                            boolean z7 = chatty;
                                            PackageParser.Package packageR16 = oldPkg;
                                            throw th;
                                        }
                                    }
                                    ArrayList<PackageParser.Package> arrayList3 = clientLibPkgs;
                                    Iterator<PackageCleanItem> it = iter3;
                                    PackageParser.Package packageR17 = packageR4;
                                    boolean z8 = chatty;
                                    if (r != null && DEBUG_PACKAGE_SCANNING) {
                                        Log.d(TAG, "  Providers: " + r);
                                    }
                                    int N2 = packageR3.services.size();
                                    StringBuilder r2 = null;
                                    for (int i7 = 0; i7 < N2; i7++) {
                                        PackageParser.Service s = (PackageParser.Service) packageR3.services.get(i7);
                                        s.info.processName = fixProcessName(packageR3.applicationInfo.processName, s.info.processName);
                                        this.mServices.addService(s);
                                        if (z8) {
                                            if (r2 == null) {
                                                r2 = new StringBuilder(256);
                                            } else {
                                                r2.append(' ');
                                            }
                                            r2.append(s.info.name);
                                        }
                                    }
                                    if (r2 != null && DEBUG_PACKAGE_SCANNING) {
                                        Log.d(TAG, "  Services: " + r2);
                                    }
                                    int N3 = packageR3.receivers.size();
                                    StringBuilder r3 = null;
                                    for (int i8 = 0; i8 < N3; i8++) {
                                        PackageParser.Activity a = (PackageParser.Activity) packageR3.receivers.get(i8);
                                        a.info.processName = fixProcessName(packageR3.applicationInfo.processName, a.info.processName);
                                        this.mReceivers.addActivity(a, HwBroadcastRadarUtil.KEY_RECEIVER);
                                        if (z8) {
                                            if (r3 == null) {
                                                r3 = new StringBuilder(256);
                                            } else {
                                                r3.append(' ');
                                            }
                                            r3.append(a.info.name);
                                        }
                                    }
                                    if (r3 != null && DEBUG_PACKAGE_SCANNING) {
                                        Log.d(TAG, "  Receivers: " + r3);
                                    }
                                    int N4 = packageR3.activities.size();
                                    StringBuilder r4 = null;
                                    for (int i9 = 0; i9 < N4; i9++) {
                                        PackageParser.Activity a2 = (PackageParser.Activity) packageR3.activities.get(i9);
                                        a2.info.processName = fixProcessName(packageR3.applicationInfo.processName, a2.info.processName);
                                        this.mActivities.addActivity(a2, "activity");
                                        if (z8) {
                                            if (r4 == null) {
                                                r4 = new StringBuilder(256);
                                            } else {
                                                r4.append(' ');
                                            }
                                            r4.append(a2.info.name);
                                        }
                                    }
                                    if (r4 != null && DEBUG_PACKAGE_SCANNING) {
                                        Log.d(TAG, "  Activities: " + r4);
                                    }
                                    if ((i2 & 16384) != 0) {
                                        Slog.w(TAG, "Permission groups from package " + packageR3.packageName + " ignored: instant apps cannot define new permission groups.");
                                    } else {
                                        this.mPermissionManager.addAllPermissionGroups(packageR3, z8);
                                    }
                                    if ((i2 & 16384) != 0) {
                                        Slog.w(TAG, "Permissions from package " + packageR3.packageName + " ignored: instant apps cannot define new permissions.");
                                    } else {
                                        this.mPermissionManager.addAllPermissions(packageR3, z8);
                                    }
                                    int N5 = packageR3.instrumentation.size();
                                    StringBuilder r5 = null;
                                    for (int i10 = 0; i10 < N5; i10++) {
                                        PackageParser.Instrumentation a3 = (PackageParser.Instrumentation) packageR3.instrumentation.get(i10);
                                        a3.info.packageName = packageR3.applicationInfo.packageName;
                                        a3.info.sourceDir = packageR3.applicationInfo.sourceDir;
                                        a3.info.publicSourceDir = packageR3.applicationInfo.publicSourceDir;
                                        a3.info.splitNames = packageR3.splitNames;
                                        a3.info.splitSourceDirs = packageR3.applicationInfo.splitSourceDirs;
                                        a3.info.splitPublicSourceDirs = packageR3.applicationInfo.splitPublicSourceDirs;
                                        a3.info.splitDependencies = packageR3.applicationInfo.splitDependencies;
                                        a3.info.dataDir = packageR3.applicationInfo.dataDir;
                                        a3.info.deviceProtectedDataDir = packageR3.applicationInfo.deviceProtectedDataDir;
                                        a3.info.credentialProtectedDataDir = packageR3.applicationInfo.credentialProtectedDataDir;
                                        a3.info.primaryCpuAbi = packageR3.applicationInfo.primaryCpuAbi;
                                        a3.info.secondaryCpuAbi = packageR3.applicationInfo.secondaryCpuAbi;
                                        a3.info.nativeLibraryDir = packageR3.applicationInfo.nativeLibraryDir;
                                        a3.info.secondaryNativeLibraryDir = packageR3.applicationInfo.secondaryNativeLibraryDir;
                                        this.mInstrumentation.put(a3.getComponentName(), a3);
                                        if (z8) {
                                            if (r5 == null) {
                                                r5 = new StringBuilder(256);
                                            } else {
                                                r5.append(' ');
                                            }
                                            r5.append(a3.info.name);
                                        }
                                    }
                                    if (r5 != null && DEBUG_PACKAGE_SCANNING) {
                                        Log.d(TAG, "  Instrumentation: " + r5);
                                    }
                                    if (packageR3.protectedBroadcasts != null) {
                                        int N6 = packageR3.protectedBroadcasts.size();
                                        synchronized (this.mProtectedBroadcasts) {
                                            for (int i11 = 0; i11 < N6; i11++) {
                                                this.mProtectedBroadcasts.add((String) packageR3.protectedBroadcasts.get(i11));
                                            }
                                        }
                                    }
                                    if ("com.huawei.remoteassistant".equals(packageR3.packageName) && checkSignatures(PLATFORM_PACKAGE_NAME, "com.huawei.remoteassistant") == 0) {
                                        Slog.i(TAG, "ddMarketFlagsForApp when scanning for " + packageR3.packageName);
                                        ApplicationInfo applicationInfo = packageR3.applicationInfo;
                                        applicationInfo.hwFlags = applicationInfo.hwFlags | 536870912;
                                    }
                                    PackageParser.Package packageR18 = oldPkg;
                                    if (packageR18 != null) {
                                        try {
                                            AsyncTask.execute(new Runnable(packageR3, packageR18, new ArrayList<>(this.mPackages.keySet())) {
                                                private final /* synthetic */ PackageParser.Package f$1;
                                                private final /* synthetic */ PackageParser.Package f$2;
                                                private final /* synthetic */ ArrayList f$3;

                                                {
                                                    this.f$1 = r2;
                                                    this.f$2 = r3;
                                                    this.f$3 = r4;
                                                }

                                                public final void run() {
                                                    PackageManagerService.this.mPermissionManager.revokeRuntimePermissionsIfGroupChanged(this.f$1, this.f$2, this.f$3, PackageManagerService.this.mPermissionCallback);
                                                }
                                            });
                                        } catch (Throwable th9) {
                                            th = th9;
                                            throw th;
                                        }
                                    }
                                } catch (Throwable th10) {
                                    th = th10;
                                    ArrayList<PackageParser.Package> arrayList4 = clientLibPkgs;
                                    PackageParser.Package packageR19 = packageR4;
                                    PackageParser.Package packageR162 = oldPkg;
                                    throw th;
                                }
                            }
                        }
                    }
                }
                clientLibPkgs = null;
                try {
                    checkPackageFrozen(packageR4);
                    if (clientLibPkgs != null) {
                    }
                    Trace.traceBegin(262144, "updateSettings");
                    synchronized (this.mPackages) {
                    }
                } catch (Throwable th11) {
                    th = th11;
                    ArrayList<PackageParser.Package> arrayList5 = clientLibPkgs;
                    PackageParser.Package packageR20 = packageR4;
                    PackageParser.Package packageR21 = oldPkg;
                    ArrayList<PackageParser.Package> arrayList6 = arrayList5;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            } catch (Throwable th12) {
                th = th12;
                arrayMap = arrayMap2;
                PackageParser.Package packageR22 = packageR5;
                PackageParser.Package packageR23 = packageR4;
                while (true) {
                    break;
                }
                throw th;
            }
        }
    }

    private static void derivePackageAbi(PackageParser.Package pkg, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
        int copyRet;
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        if (pkg.isForwardLocked() || pkg.applicationInfo.isExternalAsec() || (isSystemApp(pkg) && !pkg.isUpdatedSystemApp())) {
            extractLibs = false;
        }
        String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        NativeLibraryHelper.Handle handle = null;
        try {
            handle = NativeLibraryHelper.Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (HwMaplePMServiceUtils.isNeedToCopyMapleSO(pkg)) {
                NativeLibraryHelper.copyNativeMapleBinaries(handle, new File(nativeLibraryRoot.getParent(), "maple"));
            }
            if (isMultiArch(pkg.applicationInfo)) {
                if (pkg.cpuAbiOverride != null && !INSTALL_PACKAGE_SUFFIX.equals(pkg.cpuAbiOverride)) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 >= 0 && pkg.isLibrary()) {
                    if (extractLibs) {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                    }
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                    if (extractLibs) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                if (abi64 >= 0) {
                    if (extractLibs) {
                        if (pkg.isLibrary()) {
                            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                        }
                    }
                    pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                }
                if (abi32 >= 0) {
                    String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                    if (abi64 < 0) {
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else if (pkg.use32bitAbi) {
                        pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                        pkg.applicationInfo.primaryCpuAbi = abi;
                    } else {
                        pkg.applicationInfo.secondaryCpuAbi = abi;
                    }
                }
                Flog.i(203, "derivePackageAbi for MultiArch : " + pkg + ", path " + nativeLibraryRootStr + ", need extractLibs " + extractLibs + ", abi32 " + abi32 + ", abi64 " + abi64);
            } else {
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0) {
                    if (copyRet != -114) {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Error unpackaging native libs for app, errorCode=" + copyRet);
                    }
                }
                if (copyRet >= 0) {
                    if (!pkg.isLibrary()) {
                        pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                    } else {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library with native libs must be multiarch");
                    }
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
        } catch (IOException ioe) {
            Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(null);
            throw th;
        }
        IoUtils.closeQuietly(handle);
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
    }

    private static List<String> adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage) {
        String adjustedAbi;
        List<String> changedAbiCodePath = null;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if ((scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) && ps.primaryCpuAbiString != null) {
                String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Instruction set mismatch, ");
                    sb.append(requirer == null ? "[caller]" : requirer);
                    sb.append(" requires ");
                    sb.append(requiredInstructionSet);
                    sb.append(" whereas ");
                    sb.append(ps);
                    sb.append(" requires ");
                    sb.append(instructionSet);
                    Slog.w(TAG, sb.toString());
                }
                if (requiredInstructionSet == null) {
                    requiredInstructionSet = instructionSet;
                    requirer = ps;
                }
            }
        }
        if (requiredInstructionSet != null) {
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (scannedPackage != null) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if ((scannedPackage == null || !scannedPackage.packageName.equals(ps2.name)) && ps2.primaryCpuAbiString == null) {
                    if (SystemProperties.get("persist.sys.shareduid_abi_check", PACKAGE_PARSER_CACHE_VERSION).equals("0")) {
                        ps2.primaryCpuAbiString = adjustedAbi;
                    }
                    if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi))) {
                        if (SystemProperties.get("persist.sys.shareduid_abi_check", PACKAGE_PARSER_CACHE_VERSION).equals("0")) {
                            ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                        }
                        if (changedAbiCodePath == null) {
                            changedAbiCodePath = new ArrayList<>();
                        }
                        changedAbiCodePath.add(ps2.codePathString);
                    }
                }
            }
        }
        return changedAbiCodePath;
    }

    /* access modifiers changed from: package-private */
    public void setUpCustomResolverActivity(PackageParser.Package pkg) {
        Slog.w(TAG, "setUpCustomResolverActivity");
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            Slog.i(TAG, "Replacing default ResolverActivity with custom activity: " + this.mResolveComponentName);
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Set ephemeral installer activity: " + installerActivity.getComponentName());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        this.mInstantAppInstallerActivity.flags |= 288;
        this.mInstantAppInstallerActivity.exported = true;
        this.mInstantAppInstallerActivity.enabled = true;
        this.mInstantAppInstallerInfo.activityInfo = this.mInstantAppInstallerActivity;
        this.mInstantAppInstallerInfo.priority = 1;
        this.mInstantAppInstallerInfo.preferredOrder = 1;
        this.mInstantAppInstallerInfo.isDefault = true;
        this.mInstantAppInstallerInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else if (FileUtils.contains(Environment.getProductDirectory(), codePath)) {
            codeRoot = Environment.getProductDirectory();
        } else {
            try {
                File f = codePath.getCanonicalFile();
                File parent = f.getParentFile();
                while (true) {
                    File parentFile = parent.getParentFile();
                    File tmp = parentFile;
                    if (parentFile == null) {
                        break;
                    }
                    f = parent;
                    parent = tmp;
                }
                File codeRoot2 = f;
                Slog.w(TAG, "Unrecognized code path " + codePath + " - using " + codeRoot2);
                codeRoot = codeRoot2;
            } catch (IOException e) {
                Slog.w(TAG, "Can't canonicalize code path " + codePath);
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    protected static void setNativeLibraryPaths(PackageParser.Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        boolean bundledApp = info.isSystemApp() && !info.isUpdatedSystemApp();
        boolean asecApp = info.isForwardLocked() || info.isExternalAsec();
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{is64Bit ? "lib64" : "lib", apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{is64Bit ? "lib" : "lib64", apkName}).getAbsolutePath();
                }
            } else if (asecApp) {
                info.nativeLibraryRootDir = new File(codeFile.getParentFile(), "lib").getAbsolutePath();
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
            return;
        }
        info.nativeLibraryRootDir = new File(codeFile, "lib").getAbsolutePath();
        info.nativeLibraryRootRequiresIsa = true;
        info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
        if (info.secondaryCpuAbi != null) {
            info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
        }
    }

    private static void setBundledAppAbisAndRoots(PackageParser.Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
        boolean has64BitLibs;
        boolean has64BitLibs2;
        boolean has64BitLibs3;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs2 = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has64BitLibs = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
                has64BitLibs3 = false;
            } else {
                has64BitLibs3 = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
                has64BitLibs2 = has64BitLibs3;
                has64BitLibs = false;
            } else {
                has64BitLibs2 = has64BitLibs3;
                has64BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs2 && !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has64BitLibs && !has64BitLibs2) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (!has64BitLibs || !has64BitLibs2) {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    }

    /* access modifiers changed from: private */
    public void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    /* access modifiers changed from: private */
    public void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(PackageParser.Package pkg, boolean chatty) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps, chatty);
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                removePackageLI(ps2, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removePackageLI(PackageSetting ps, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + ps.name);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(ps.name);
            PackageParser.Package pkg = ps.pkg;
            if (pkg != null) {
                cleanPackageDataStructuresLILPw(pkg, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        int N = pkg.providers.size();
        StringBuilder r = null;
        for (int i = 0; i < N; i++) {
            PackageParser.Provider p = (PackageParser.Provider) pkg.providers.get(i);
            this.mProviders.removeProvider(p);
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                for (int j = 0; j < names.length; j++) {
                    if (this.mProvidersByAuthority.get(names[j]) == p) {
                        this.mProvidersByAuthority.remove(names[j]);
                        if (DEBUG_REMOVE && chatty) {
                            Log.d(TAG, "Unregistered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    }
                }
                if (DEBUG_REMOVE != 0 && chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(p.info.name);
                }
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Providers: " + r);
        }
        int N2 = pkg.services.size();
        StringBuilder r2 = null;
        for (int i2 = 0; i2 < N2; i2++) {
            PackageParser.Service s = (PackageParser.Service) pkg.services.get(i2);
            this.mServices.removeService(s);
            if (chatty) {
                if (r2 == null) {
                    r2 = new StringBuilder(256);
                } else {
                    r2.append(' ');
                }
                r2.append(s.info.name);
            }
        }
        if (r2 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Services: " + r2);
        }
        int N3 = pkg.receivers.size();
        StringBuilder r3 = null;
        for (int i3 = 0; i3 < N3; i3++) {
            PackageParser.Activity a = (PackageParser.Activity) pkg.receivers.get(i3);
            this.mReceivers.removeActivity(a, HwBroadcastRadarUtil.KEY_RECEIVER);
            if (DEBUG_REMOVE && chatty) {
                if (r3 == null) {
                    r3 = new StringBuilder(256);
                } else {
                    r3.append(' ');
                }
                r3.append(a.info.name);
            }
        }
        if (r3 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Receivers: " + r3);
        }
        int N4 = pkg.activities.size();
        StringBuilder r4 = null;
        for (int i4 = 0; i4 < N4; i4++) {
            PackageParser.Activity a2 = (PackageParser.Activity) pkg.activities.get(i4);
            this.mActivities.removeActivity(a2, "activity");
            if (DEBUG_REMOVE && chatty) {
                if (r4 == null) {
                    r4 = new StringBuilder(256);
                } else {
                    r4.append(' ');
                }
                r4.append(a2.info.name);
            }
        }
        if (r4 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Activities: " + r4);
        }
        this.mPermissionManager.removeAllPermissions(pkg, chatty);
        int N5 = pkg.instrumentation.size();
        StringBuilder r5 = null;
        for (int i5 = 0; i5 < N5; i5++) {
            PackageParser.Instrumentation a3 = (PackageParser.Instrumentation) pkg.instrumentation.get(i5);
            this.mInstrumentation.remove(a3.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r5 == null) {
                    r5 = new StringBuilder(256);
                } else {
                    r5.append(' ');
                }
                r5.append(a3.info.name);
            }
        }
        if (r5 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Instrumentation: " + r5);
        }
        StringBuilder r6 = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            for (int i6 = 0; i6 < pkg.libraryNames.size(); i6++) {
                String name = (String) pkg.libraryNames.get(i6);
                if (removeSharedLibraryLPw(name, 0) && DEBUG_REMOVE && chatty) {
                    if (r6 == null) {
                        r6 = new StringBuilder(256);
                    } else {
                        r6.append(' ');
                    }
                    r6.append(name);
                }
            }
        }
        StringBuilder r7 = null;
        if (pkg.staticSharedLibName != null && removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
            if (r7 == null) {
                r7 = new StringBuilder(256);
            } else {
                r7.append(' ');
            }
            r7.append(pkg.staticSharedLibName);
        }
        if (r7 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Libraries: " + r7);
        }
    }

    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        mHwPMSEx.preSendPackageBroadcast(action, pkg, extras, flags, targetPkg, finishedReceiver, userIds, instantUserIds);
        PackageHandler packageHandler = this.mHandler;
        final int[] iArr = userIds;
        final String str = action;
        final String str2 = pkg;
        final Bundle bundle = extras;
        final int i = flags;
        final String str3 = targetPkg;
        final IIntentReceiver iIntentReceiver = finishedReceiver;
        final int[] iArr2 = instantUserIds;
        AnonymousClass10 r1 = new Runnable() {
            public void run() {
                int[] resolvedUserIds;
                try {
                    IActivityManager am = ActivityManager.getService();
                    if (am != null) {
                        if (iArr == null) {
                            resolvedUserIds = am.getRunningUserIds();
                        } else {
                            resolvedUserIds = iArr;
                        }
                        PackageManagerService.this.doSendBroadcast(am, str, str2, bundle, i, str3, iIntentReceiver, resolvedUserIds, false);
                        if (!(iArr2 == null || iArr2 == PackageManagerService.EMPTY_INT_ARRAY)) {
                            PackageManagerService.this.doSendBroadcast(am, str, str2, bundle, i, str3, iIntentReceiver, iArr2, true);
                        }
                    }
                } catch (RemoteException e) {
                }
            }
        };
        packageHandler.post(r1);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0019, code lost:
        if (r0 < 0) goto L_0x0023;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x001b, code lost:
        r1[r0].onPackageAdded(r4);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0023, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x0016, code lost:
        r0 = r1.length - 1;
     */
    public void notifyPackageAdded(String packageName) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray();
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0019, code lost:
        if (r0 < 0) goto L_0x0023;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x001b, code lost:
        r1[r0].onPackageRemoved(r4);
        r0 = r0 - 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0023, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:9:0x0016, code lost:
        r0 = r1.length - 1;
     */
    public void notifyPackageRemoved(String packageName) {
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                PackageManagerInternal.PackageListObserver[] observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray();
            }
        }
    }

    /* access modifiers changed from: private */
    public void doSendBroadcast(IActivityManager am, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, boolean isInstantApp) throws RemoteException {
        String str = pkg;
        Bundle bundle = extras;
        String str2 = targetPkg;
        for (int id : userIds) {
            Intent intent = new Intent(action, str != null ? Uri.fromParts("package", str, null) : null);
            String[] requiredPermissions = isInstantApp ? INSTANT_APP_BROADCAST_PERMISSION : null;
            if (bundle != null) {
                intent.putExtras(bundle);
            }
            if (str2 != null) {
                intent.setPackage(str2);
            }
            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
            if (uid > 0 && UserHandle.getUserId(uid) != id) {
                uid = UserHandle.getUid(id, UserHandle.getAppId(uid));
                intent.putExtra("android.intent.extra.UID", uid);
            }
            intent.putExtra("android.intent.extra.user_handle", id);
            intent.addFlags(67108864 | flags);
            if (DEBUG_BROADCASTS) {
                RuntimeException here = new RuntimeException("here");
                here.fillInStackTrace();
                Slog.d(TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + " " + intent.getExtras(), here);
            }
            Intent intent2 = intent;
            am.broadcastIntent(null, intent, null, finishedReceiver, 0, null, null, requiredPermissions, -1, null, finishedReceiver != null, false, id);
        }
    }

    private boolean isExternalMediaAvailable() {
        return this.mMediaMounted || Environment.isExternalStorageEmulated();
    }

    public PackageCleanItem nextPackageToClean(PackageCleanItem lastPackage) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || !isExternalMediaAvailable()) {
            return null;
        }
        synchronized (this.mPackages) {
            ArrayList<PackageCleanItem> pkgs = this.mSettings.mPackagesToBeCleaned;
            if (lastPackage != null) {
                pkgs.remove(lastPackage);
            }
            if (pkgs.size() <= 0) {
                return null;
            }
            PackageCleanItem packageCleanItem = pkgs.get(0);
            return packageCleanItem;
        }
    }

    /* access modifiers changed from: package-private */
    public void schedulePackageCleaning(String packageName, int userId, boolean andCode) {
        Message msg = this.mHandler.obtainMessage(7, userId, andCode, packageName);
        if (this.mSystemReady) {
            msg.sendToTarget();
            return;
        }
        if (this.mPostSystemReadyMessages == null) {
            this.mPostSystemReadyMessages = new ArrayList<>();
        }
        this.mPostSystemReadyMessages.add(msg);
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0017, code lost:
        r0 = new android.content.Intent("android.content.pm.CLEAN_EXTERNAL_STORAGE");
        r0.setComponent(DEFAULT_CONTAINER_COMPONENT);
        r1 = android.app.ActivityManager.getService();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0027, code lost:
        if (r1 == null) goto L_0x006a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:13:0x0029, code lost:
        r2 = -1;
        r3 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x002c, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x002f, code lost:
        if (r10.mDefaultContainerWhitelisted != false) goto L_0x0048;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0031, code lost:
        r10.mDefaultContainerWhitelisted = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0047, code lost:
        r2 = android.os.UserHandle.getUid(0, r10.mSettings.mPackages.get(DEFAULT_CONTAINER_PACKAGE).appId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0048, code lost:
        r9 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x004a, code lost:
        if (r9 <= 0) goto L_0x0052;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:?, code lost:
        r1.backgroundWhitelistUid(r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x0052, code lost:
        r1.startService(null, r0, null, false, r10.mContext.getOpPackageName(), 0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0064, code lost:
        r4 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x0065, code lost:
        r2 = r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0067, code lost:
        r4 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:?, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:0x0069, code lost:
        throw r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x006a, code lost:
        return;
     */
    public void startCleaningPackages() {
        if (isExternalMediaAvailable()) {
            synchronized (this.mPackages) {
                if (this.mSettings.mPackagesToBeCleaned.isEmpty()) {
                }
            }
        }
    }

    private int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(UserHandle.getUserId(installerUid));
        if (ownerPackage != null && ownerPackage.equals(installerPackageName)) {
            return 1;
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    /* access modifiers changed from: package-private */
    public void earlyBindToDefContainer() {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(21));
    }

    /* access modifiers changed from: package-private */
    public void installStage(String packageName, File stagedDir, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, PackageParser.SigningDetails signingDetails) {
        PackageInstaller.SessionParams sessionParams2 = sessionParams;
        int i = installerUid;
        UserHandle user2 = mHwPMSEx.getHwUserHandle(user);
        if (!DEBUG_INSTANT || (sessionParams2.installFlags & 2048) == 0) {
            String str = packageName;
        } else {
            Slog.d(TAG, "Ephemeral install of " + packageName);
        }
        VerificationInfo verificationInfo = new VerificationInfo(sessionParams2.originatingUri, sessionParams2.referrerUri, sessionParams2.originatingUid, i);
        OriginInfo origin = OriginInfo.fromStagedFile(stagedDir);
        Message msg = this.mHandler.obtainMessage(5);
        String str2 = installerPackageName;
        int installReason = fixUpInstallReason(str2, i, sessionParams2.installReason);
        int i2 = sessionParams2.installFlags;
        String str3 = sessionParams2.volumeUuid;
        String str4 = sessionParams2.abiOverride;
        String str5 = str4;
        InstallParams params = new InstallParams(origin, null, observer, i2, str2, str3, verificationInfo, user2, str5, sessionParams2.grantedRuntimePermissions, signingDetails, installReason);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        Message msg2 = msg;
        msg2.obj = params;
        Trace.asyncTraceBegin(262144, "installStage", System.identityHashCode(msg2.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg2.obj));
        this.mHandler.sendMessage(msg2);
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        boolean isInstantApp = pkgSetting.getInstantApp(userId);
        sendPackageAddedForNewUsers(packageName, isSystem, false, pkgSetting.appId, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
        PackageInstaller.SessionInfo info = new PackageInstaller.SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
    }

    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds) {
        int[] iArr = userIds;
        if (!ArrayUtils.isEmpty(userIds) || !ArrayUtils.isEmpty(instantUserIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(ArrayUtils.isEmpty(userIds) ? instantUserIds[0] : iArr[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, iArr, instantUserIds);
            if (!sendBootCompleted || ArrayUtils.isEmpty(userIds)) {
                String str = packageName;
                boolean z = includeStopped;
            } else {
                this.mHandler.post(new Runnable(iArr, packageName, includeStopped) {
                    private final /* synthetic */ int[] f$1;
                    private final /* synthetic */ String f$2;
                    private final /* synthetic */ boolean f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    public final void run() {
                        PackageManagerService.lambda$sendPackageAddedForNewUsers$5(PackageManagerService.this, this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
    }

    public static /* synthetic */ void lambda$sendPackageAddedForNewUsers$5(PackageManagerService packageManagerService, int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            packageManagerService.sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        int i;
        String str = packageName;
        int i2 = userId;
        if (this.mUserManagerInternal.isUserRunning(i2)) {
            IActivityManager am = ActivityManager.getService();
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(str);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = {"android.permission.RECEIVE_BOOT_COMPLETED"};
                try {
                    am.broadcastIntent(null, lockedBcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, userId);
                    i = userId;
                } catch (RemoteException e) {
                    e = e;
                    int i3 = userId;
                    throw e.rethrowFromSystemServer();
                }
                try {
                    if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(i)) {
                        Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(str);
                        if (includeStopped) {
                            bcIntent.addFlags(32);
                        }
                        am.broadcastIntent(null, bcIntent, null, null, 0, null, null, requiredPermissions, -1, null, false, false, i);
                    }
                } catch (RemoteException e2) {
                    e = e2;
                    throw e.rethrowFromSystemServer();
                }
            } catch (RemoteException e3) {
                e = e3;
                int i4 = i2;
                throw e.rethrowFromSystemServer();
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:62:0x0123, code lost:
        r6 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0125, code lost:
        if (r4 == false) goto L_0x012f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:?, code lost:
        sendPackageAddedForUser(r13, r6, r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x012a, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x012e, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x012f, code lost:
        if (r5 == false) goto L_0x0144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:?, code lost:
        killApplication(r13, android.os.UserHandle.getUid(r15, r6.appId), "hiding pkg");
        sendApplicationHiddenForUser(r13, r6, r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x013f, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0143, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0144, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0149, code lost:
        return false;
     */
    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
        if (hidden && isPackageDeviceAdmin(packageName, userId)) {
            Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
            return false;
        } else if (!hidden || !HwPackageManagerServiceUtils.isInAntiFillingWhiteList(packageName, hasSystemFeature("android.software.home_screen", 0))) {
            long callingId = Binder.clearCallingIdentity();
            boolean sendAdded = false;
            boolean sendRemoved = false;
            try {
                synchronized (this.mPackages) {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting == null) {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                        Slog.w(TAG, "Cannot hide package: android");
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    } else {
                        PackageParser.Package pkg = this.mPackages.get(packageName);
                        if (pkg == null || pkg.staticSharedLibName == null) {
                            if (hidden) {
                                if (!UserHandle.isSameApp(callingUid, pkgSetting.appId) && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                                    Slog.w(TAG, "Not hiding protected package: " + packageName);
                                    Binder.restoreCallingIdentity(callingId);
                                    return false;
                                }
                            }
                            if (pkgSetting.getHidden(userId) != hidden) {
                                pkgSetting.setHidden(hidden, userId);
                                this.mSettings.writePackageRestrictionsLPr(userId);
                                if (hidden) {
                                    sendRemoved = true;
                                } else {
                                    sendAdded = true;
                                }
                            }
                        } else {
                            Slog.w(TAG, "Cannot hide package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        }
                    }
                }
            } catch (Throwable th) {
                Binder.restoreCallingIdentity(callingId);
                throw th;
            }
        } else {
            Slog.w(TAG, "Not hiding package " + packageName + ": limited by anti-filling");
            return false;
        }
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int userId, boolean suspended, PersistableBundle launcherExtras) {
        String str;
        if (pkgList.length > 0) {
            Bundle extras = new Bundle(1);
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (launcherExtras != null) {
                extras.putBundle("android.intent.extra.LAUNCHER_EXTRAS", new Bundle(launcherExtras.deepCopy()));
            }
            if (suspended) {
                str = "android.intent.action.PACKAGES_SUSPENDED";
            } else {
                str = "android.intent.action.PACKAGES_UNSUSPENDED";
            }
            sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId}, null);
        }
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, false, "getApplicationHidden for user " + userId);
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                } else if (filterAppAccessLPr(ps, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                } else {
                    boolean hidden = ps.getHidden(userId);
                    Binder.restoreCallingIdentity(callingId);
                    return hidden;
                }
            }
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
    }

    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason) {
        mHwPMSEx.preInstallExistingPackageAsUser(packageName, userId, installFlags, installReason);
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x00bf, code lost:
        r7 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00c0, code lost:
        if (r5 == false) goto L_0x00e7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x00c4, code lost:
        if (r7.pkg == null) goto L_0x00d3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x00c6, code lost:
        r13 = r1.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x00c8, code lost:
        monitor-enter(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:?, code lost:
        prepareAppDataAfterInstallLIF(r7.pkg);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x00ce, code lost:
        monitor-exit(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x00d3, code lost:
        sendPackageAddedForUser(r2, r7, r9);
        r13 = r1.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x00d8, code lost:
        monitor-enter(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:?, code lost:
        updateSequenceNumberLP(r7, new int[]{r9});
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x00e2, code lost:
        monitor-exit(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x00e7, code lost:
        android.os.Binder.restoreCallingIdentity(r3);
        r0 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x00ed, code lost:
        return 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x00f3, code lost:
        r0 = th;
     */
    public int installExistingPackageAsUserInternal(String packageName, int userId, int installFlags, int installReason) {
        String str = packageName;
        int i = userId;
        int i2 = installFlags;
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i, true, true, "installExistingPackage for user " + i);
        if (isUserRestricted(i, "no_install_apps")) {
            return -111;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean installed = false;
        boolean instantApp = (i2 & 2048) != 0;
        boolean fullApp = (i2 & 16384) != 0;
        try {
            synchronized (this.mPackages) {
                try {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(str);
                    if (pkgSetting == null) {
                        Binder.restoreCallingIdentity(callingId);
                        return -3;
                    }
                    if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                        int[] userIds = sUserManager.getUserIds();
                        int length = userIds.length;
                        boolean installAllowed = false;
                        int i3 = 0;
                        while (true) {
                            if (i3 >= length) {
                                break;
                            }
                            installAllowed = !pkgSetting.getInstantApp(userIds[i3]);
                            if (installAllowed) {
                                break;
                            }
                            i3++;
                        }
                        if (!installAllowed) {
                            Binder.restoreCallingIdentity(callingId);
                            return -3;
                        }
                    }
                    if (!pkgSetting.getInstalled(i)) {
                        pkgSetting.setInstalled(true, i);
                        pkgSetting.setHidden(false, i);
                        try {
                            pkgSetting.setInstallReason(installReason, i);
                            this.mSettings.writePackageRestrictionsLPr(i);
                            this.mSettings.writeKernelMappingLPr(pkgSetting);
                            installed = true;
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } else {
                        int i4 = installReason;
                        if (fullApp && pkgSetting.getInstantApp(i)) {
                            installed = true;
                        }
                    }
                    setInstantAppForUser(pkgSetting, i, instantApp, fullApp);
                } catch (Throwable th2) {
                    th = th2;
                    int i5 = installReason;
                    throw th;
                }
            }
        } catch (Throwable th3) {
            th = th3;
            int i6 = installReason;
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
    }

    static void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (instantApp || fullApp) {
            if (userId == -1) {
                for (int currentUserId : sUserManager.getUserIds()) {
                    if (instantApp && !pkgSetting.getInstantApp(currentUserId)) {
                        pkgSetting.setInstantApp(true, currentUserId);
                    } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                        pkgSetting.setInstantApp(false, currentUserId);
                    }
                }
            } else if (instantApp && !pkgSetting.getInstantApp(userId)) {
                pkgSetting.setInstantApp(true, userId);
            } else if (fullApp && pkgSetting.getInstantApp(userId)) {
                pkgSetting.setInstantApp(false, userId);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        Log.w(TAG, "User is restricted: " + restrictionKey);
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01c5, code lost:
        r0 = th;
     */
    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, PersistableBundle appExtras, PersistableBundle launcherExtras, String dialogMessage, String callingPackage, int userId) {
        long callingId;
        ArrayMap<String, PackageParser.Package> arrayMap;
        long callingId2;
        String packageName;
        String[] strArr = packageNames;
        boolean z = suspended;
        String str = callingPackage;
        int i = userId;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "setPackagesSuspendedAsUser");
        int callingUid = Binder.getCallingUid();
        int i2 = 0;
        if (callingUid != 0 && callingUid != 1000 && getPackageUid(str, 0, i) != callingUid) {
            throw new SecurityException("Calling package " + str + " in user " + i + " does not belong to calling uid " + callingUid);
        } else if (!PLATFORM_PACKAGE_NAME.equals(str) && this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(i) != null) {
            throw new UnsupportedOperationException("Cannot suspend/unsuspend packages. User " + i + " has an active DO or PO");
        } else if (ArrayUtils.isEmpty(packageNames)) {
            return strArr;
        } else {
            List<String> changedPackagesList = new ArrayList<>(strArr.length);
            List<String> unactionedPackages = new ArrayList<>(strArr.length);
            long callingId3 = Binder.clearCallingIdentity();
            try {
                ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
                synchronized (arrayMap2) {
                    while (i2 < strArr.length) {
                        try {
                            try {
                                String packageName2 = strArr[i2];
                                if (str != null) {
                                    try {
                                        if (str.equals(packageName2)) {
                                            StringBuilder sb = new StringBuilder();
                                            sb.append("Calling package: ");
                                            sb.append(str);
                                            sb.append(" trying to ");
                                            sb.append(z ? BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS : "un");
                                            sb.append("suspend itself. Ignoring");
                                            Slog.w(TAG, sb.toString());
                                            unactionedPackages.add(packageName2);
                                            arrayMap = arrayMap2;
                                            callingId2 = callingId3;
                                            i2++;
                                            callingId3 = callingId2;
                                            arrayMap2 = arrayMap;
                                            strArr = packageNames;
                                            z = suspended;
                                            str = callingPackage;
                                        }
                                    } catch (Throwable th) {
                                        th = th;
                                        PersistableBundle persistableBundle = launcherExtras;
                                        arrayMap = arrayMap2;
                                        callingId = callingId3;
                                        boolean z2 = z;
                                        PersistableBundle persistableBundle2 = appExtras;
                                        while (true) {
                                            try {
                                                break;
                                            } catch (Throwable th2) {
                                                th = th2;
                                            }
                                        }
                                        throw th;
                                    }
                                }
                                PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName2);
                                if (pkgSetting == null) {
                                    PackageSetting packageSetting = pkgSetting;
                                    packageName = packageName2;
                                    arrayMap = arrayMap2;
                                    callingId2 = callingId3;
                                } else if (filterAppAccessLPr(pkgSetting, callingUid, i)) {
                                    PackageSetting packageSetting2 = pkgSetting;
                                    packageName = packageName2;
                                    arrayMap = arrayMap2;
                                    callingId2 = callingId3;
                                } else {
                                    if (z) {
                                        if (!canSuspendPackageForUserLocked(packageName2, i)) {
                                            unactionedPackages.add(packageName2);
                                            arrayMap = arrayMap2;
                                            callingId2 = callingId3;
                                            i2++;
                                            callingId3 = callingId2;
                                            arrayMap2 = arrayMap;
                                            strArr = packageNames;
                                            z = suspended;
                                            str = callingPackage;
                                        }
                                    }
                                    boolean z3 = z;
                                    PackageSetting packageSetting3 = pkgSetting;
                                    String packageName3 = packageName2;
                                    arrayMap = arrayMap2;
                                    callingId2 = callingId3;
                                    try {
                                        pkgSetting.setSuspended(z3, str, dialogMessage, appExtras, launcherExtras, i);
                                        changedPackagesList.add(packageName3);
                                        i2++;
                                        callingId3 = callingId2;
                                        arrayMap2 = arrayMap;
                                        strArr = packageNames;
                                        z = suspended;
                                        str = callingPackage;
                                    } catch (Throwable th3) {
                                        th = th3;
                                        PersistableBundle persistableBundle3 = appExtras;
                                        PersistableBundle persistableBundle4 = launcherExtras;
                                        callingId = callingId2;
                                        boolean z4 = suspended;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                }
                                Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping suspending/un-suspending.");
                                unactionedPackages.add(packageName);
                                i2++;
                                callingId3 = callingId2;
                                arrayMap2 = arrayMap;
                                strArr = packageNames;
                                z = suspended;
                                str = callingPackage;
                            } catch (Throwable th4) {
                                th = th4;
                                arrayMap = arrayMap2;
                                PersistableBundle persistableBundle5 = appExtras;
                                PersistableBundle persistableBundle6 = launcherExtras;
                                callingId = callingId3;
                                boolean z5 = suspended;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } catch (Throwable th5) {
                            th = th5;
                            PersistableBundle persistableBundle7 = launcherExtras;
                            arrayMap = arrayMap2;
                            callingId = callingId3;
                            boolean z6 = z;
                            PersistableBundle persistableBundle8 = appExtras;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    }
                    arrayMap = arrayMap2;
                    long callingId4 = callingId3;
                    try {
                        Binder.restoreCallingIdentity(callingId4);
                        if (!changedPackagesList.isEmpty()) {
                            String[] changedPackages = (String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]);
                            long j = callingId4;
                            boolean z7 = suspended;
                            sendPackagesSuspendedForUser(changedPackages, i, z7, launcherExtras);
                            sendMyPackageSuspendedOrUnsuspended(changedPackages, z7, appExtras, i);
                            synchronized (this.mPackages) {
                                scheduleWritePackageRestrictionsLocked(i);
                            }
                        } else {
                            PersistableBundle persistableBundle9 = appExtras;
                            PersistableBundle persistableBundle10 = launcherExtras;
                            long j2 = callingId4;
                            boolean z8 = suspended;
                        }
                        return (String[]) unactionedPackages.toArray(new String[unactionedPackages.size()]);
                    } catch (Throwable th6) {
                        th = th6;
                        PersistableBundle persistableBundle11 = appExtras;
                        PersistableBundle persistableBundle12 = launcherExtras;
                        callingId = callingId4;
                        boolean z9 = suspended;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th7) {
                th = th7;
                PersistableBundle persistableBundle13 = appExtras;
                PersistableBundle persistableBundle14 = launcherExtras;
                callingId = callingId3;
                boolean z10 = z;
                Binder.restoreCallingIdentity(callingId);
                throw th;
            }
        }
    }

    public PersistableBundle getSuspendedPackageAppExtras(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getPackageUid(packageName, 0, userId) == callingUid) {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown target package: " + packageName);
                }
                PackageUserState packageUserState = ps.readUserState(userId);
                if (!packageUserState.suspended) {
                    return null;
                }
                PersistableBundle persistableBundle = packageUserState.suspendedAppExtras;
                return persistableBundle;
            }
        }
        throw new SecurityException("Calling package " + packageName + " does not belong to calling uid " + callingUid);
    }

    private void sendMyPackageSuspendedOrUnsuspended(String[] affectedPackages, boolean suspended, PersistableBundle appExtras, int userId) {
        String action;
        Bundle intentExtras = new Bundle();
        if (suspended) {
            action = "android.intent.action.MY_PACKAGE_SUSPENDED";
            if (appExtras != null) {
                intentExtras.putBundle("android.intent.extra.SUSPENDED_PACKAGE_EXTRAS", new Bundle(appExtras.deepCopy()));
            }
        } else {
            action = "android.intent.action.MY_PACKAGE_UNSUSPENDED";
        }
        final String action2 = action;
        PackageHandler packageHandler = this.mHandler;
        final boolean z = suspended;
        final int i = userId;
        final String[] strArr = affectedPackages;
        final Bundle bundle = intentExtras;
        AnonymousClass11 r1 = new Runnable() {
            public void run() {
                try {
                    IActivityManager am = ActivityManager.getService();
                    if (am == null) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("IActivityManager null. Cannot send MY_PACKAGE_ ");
                        sb.append(z ? BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS : "UN");
                        sb.append("SUSPENDED broadcasts");
                        Slog.wtf(PackageManagerService.TAG, sb.toString());
                        return;
                    }
                    int[] targetUserIds = {i};
                    for (String packageName : strArr) {
                        PackageManagerService.this.doSendBroadcast(am, action2, null, bundle, DumpState.DUMP_SERVICE_PERMISSIONS, packageName, null, targetUserIds, false);
                    }
                } catch (RemoteException e) {
                }
            }
        };
        packageHandler.post(r1);
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        PermissionManagerInternal permissionManagerInternal = this.mPermissionManager;
        permissionManagerInternal.enforceCrossUserPermission(callingUid, userId, true, false, "isPackageSuspendedForUser for user " + userId);
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new IllegalArgumentException("Unknown target package: " + packageName);
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForSuspendingPackage(String packageName, int affectedUser) {
        for (int userId : affectedUser == -1 ? sUserManager.getUserIds() : new int[]{affectedUser}) {
            Objects.requireNonNull(packageName);
            unsuspendForSuspendingPackages(new Predicate(packageName) {
                private final /* synthetic */ String f$0;

                {
                    this.f$0 = r1;
                }

                public final boolean test(Object obj) {
                    return this.f$0.equals((String) obj);
                }
            }, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForNonSystemSuspendingPackages(ArraySet<Integer> userIds) {
        int sz = userIds.size();
        for (int i = 0; i < sz; i++) {
            unsuspendForSuspendingPackages($$Lambda$PackageManagerService$bnLYyNywBZdr_a6WGQKRTv8z0S4.INSTANCE, userIds.valueAt(i).intValue());
        }
    }

    static /* synthetic */ boolean lambda$unsuspendForNonSystemSuspendingPackages$6(String suspendingPackage) {
        return !PLATFORM_PACKAGE_NAME.equals(suspendingPackage);
    }

    private void unsuspendForSuspendingPackages(Predicate<String> packagePredicate, int userId) {
        List<String> affectedPackages = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageSetting ps : this.mSettings.mPackages.values()) {
                PackageUserState pus = ps.readUserState(userId);
                if (pus.suspended && packagePredicate.test(pus.suspendingPackage)) {
                    ps.setSuspended(false, null, null, null, null, userId);
                    affectedPackages.add(ps.name);
                }
            }
        }
        if (!affectedPackages.isEmpty()) {
            String[] packageArray = (String[]) affectedPackages.toArray(new String[affectedPackages.size()]);
            sendMyPackageSuspendedOrUnsuspended(packageArray, false, null, userId);
            sendPackagesSuspendedForUser(packageArray, userId, false, null);
            this.mSettings.writePackageRestrictionsLPr(userId);
        }
    }

    @GuardedBy("mPackages")
    private boolean canSuspendPackageForUserLocked(String packageName, int userId) {
        if (isPackageDeviceAdmin(packageName, userId)) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": has an active device admin");
            return false;
        } else if (packageName.equals(getActiveLauncherPackageName(userId))) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": contains the active launcher");
            return false;
        } else if (packageName.equals(this.mRequiredInstallerPackage)) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package installation");
            return false;
        } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package uninstallation");
            return false;
        } else if (packageName.equals(this.mRequiredVerifierPackage)) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package verification");
            return false;
        } else if (packageName.equals(getDefaultDialerPackageName(userId))) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": is the default dialer");
            return false;
        } else if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": protected package");
            return false;
        } else {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg != null && pkg.applicationInfo.isStaticSharedLibrary()) {
                Slog.w(TAG, "Cannot suspend package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                return false;
            } else if (!PLATFORM_PACKAGE_NAME.equals(packageName)) {
                return true;
            } else {
                Slog.w(TAG, "Cannot suspend package: " + packageName);
                return false;
            }
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        if (resolveInfo == null) {
            return null;
        }
        return resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        String defaultDialerPackageNameLPw;
        synchronized (this.mPackages) {
            defaultDialerPackageNameLPw = this.mSettings.getDefaultDialerPackageNameLPw(userId);
        }
        return defaultDialerPackageNameLPw;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT) {
            millisecondsToDelay = AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && !state.timeoutExtended()) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    /* access modifiers changed from: private */
    public void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    /* access modifiers changed from: private */
    public ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        int i = 0;
        while (true) {
            if (i >= NR) {
                break;
            }
            ResolveInfo info = receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
            i++;
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    /* access modifiers changed from: private */
    public List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        List<ComponentName> sufficientVerifiers = new ArrayList<>(N + 1);
        for (VerifierInfo verifierInfo : pkgInfo.verifiers) {
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (comp != null) {
                int verifierUid = getUidForVerifier(verifierInfo);
                if (verifierUid != -1) {
                    if (DEBUG_VERIFY) {
                        Slog.d(TAG, "Added sufficient verifier " + verifierInfo.packageName + " with the correct signature");
                    }
                    sufficientVerifiers.add(comp);
                    verificationState.addSufficientVerifier(verifierUid);
                }
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            }
            if (pkg.mSigningDetails.signatures.length != 1) {
                Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " has more than one signature; ignoring");
                return -1;
            }
            try {
                if (!Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSigningDetails.signatures[0].getPublicKey().getEncoded())) {
                    Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " does not have the expected public key; ignoring");
                    return -1;
                }
                int i = pkg.applicationInfo.uid;
                return i;
            } catch (CertificateException e) {
                return -1;
            }
        }
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            Slog.v(TAG, "BM finishing package install for " + token);
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch));
    }

    /* access modifiers changed from: private */
    public long getVerificationTimeout() {
        return Settings.Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", 10000);
    }

    /* access modifiers changed from: private */
    public int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    /* access modifiers changed from: private */
    public boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        boolean z = false;
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || this.mInstantAppInstallerActivity == null || !this.mInstantAppInstallerActivity.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        if (Settings.Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1) {
            z = true;
        }
        return z;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:18:0x004d, code lost:
        return 0;
     */
    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getIntentVerificationStatus" + userId);
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    int intentFilterVerificationStatusLPr = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                    return intentFilterVerificationStatusLPr;
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x002f, code lost:
        if (r0 == false) goto L_0x0034;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x0031, code lost:
        scheduleWritePackageRestrictionsLocked(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x0034, code lost:
        return r0;
     */
    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            boolean result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                ParceledListSlice<IntentFilterVerificationInfo> emptyList = ParceledListSlice.emptyList();
                return emptyList;
            }
            ParceledListSlice<IntentFilterVerificationInfo> parceledListSlice = new ParceledListSlice<>(this.mSettings.getIntentFilterVerificationsLPr(packageName));
            return parceledListSlice;
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg != null) {
                if (pkg.activities != null) {
                    if (pkg.mExtras == null) {
                        ParceledListSlice<IntentFilter> emptyList = ParceledListSlice.emptyList();
                        return emptyList;
                    } else if (filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                        ParceledListSlice<IntentFilter> emptyList2 = ParceledListSlice.emptyList();
                        return emptyList2;
                    } else {
                        int count = pkg.activities.size();
                        ArrayList<IntentFilter> result = new ArrayList<>();
                        for (int n = 0; n < count; n++) {
                            PackageParser.Activity activity = (PackageParser.Activity) pkg.activities.get(n);
                            if (activity.intents != null && activity.intents.size() > 0) {
                                result.addAll(activity.intents);
                            }
                        }
                        ParceledListSlice<IntentFilter> parceledListSlice = new ParceledListSlice<>(result);
                        return parceledListSlice;
                    }
                }
            }
            PackageSetting ps = ParceledListSlice.emptyList();
            return ps;
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        boolean result;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        synchronized (this.mPackages) {
            result = this.mSettings.setDefaultBrowserPackageNameLPw(packageName, userId);
            if (packageName != null) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
            }
        }
        return result;
    }

    public String getDefaultBrowserPackageName(int userId) {
        String defaultBrowserPackageNameLPw;
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            defaultBrowserPackageNameLPw = this.mSettings.getDefaultBrowserPackageNameLPw(userId);
        }
        return defaultBrowserPackageNameLPw;
    }

    private int getUnknownSourcesSettings() {
        return Settings.Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        PackageSetting installerPackageSetting;
        Signature[] callerSignature;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    throw new IllegalArgumentException("Unknown target package: " + targetPackage);
                }
                if (installerPackageName != null) {
                    installerPackageSetting = this.mSettings.mPackages.get(installerPackageName);
                    if (installerPackageSetting == null) {
                        throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
                    }
                } else {
                    installerPackageSetting = null;
                }
                Object obj = this.mSettings.getUserIdLPr(callingUid);
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSigningDetails.signatures;
                    } else {
                        throw new SecurityException("Bad object " + obj + " for uid " + callingUid);
                    }
                    if (installerPackageSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, installerPackageSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
                        }
                    }
                    if (targetPackageSetting.installerPackageName != null) {
                        PackageSetting setting = this.mSettings.mPackages.get(targetPackageSetting.installerPackageName);
                        if (setting != null) {
                            if (PackageManagerServiceUtils.compareSignatures(callerSignature, setting.signatures.mSigningDetails.signatures) != 0) {
                                throw new SecurityException("Caller does not have same cert as old installer package " + targetPackageSetting.installerPackageName);
                            }
                        }
                    }
                    targetPackageSetting.installerPackageName = installerPackageName;
                    if (installerPackageName != null) {
                        this.mSettings.mInstallerPackages.add(installerPackageName);
                    }
                    scheduleWriteSettingsLocked();
                } else {
                    throw new SecurityException("Unknown calling UID: " + callingUid);
                }
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (!Objects.equals(callerPackageName, ps.installerPackageName)) {
                    throw new IllegalArgumentException("Calling package " + callerPackageName + " is not installer for " + packageName);
                } else if (ps.categoryHint != categoryHint) {
                    ps.categoryHint = categoryHint;
                    scheduleWriteSettingsLocked();
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* access modifiers changed from: private */
    public void processPendingInstall(final InstallArgs args, final int currentStatus) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.mHandler.removeCallbacks(this);
                PackageInstalledInfo res = new PackageInstalledInfo();
                res.setReturnCode(currentStatus);
                res.uid = -1;
                res.pkg = null;
                res.removedInfo = null;
                if (res.returnCode == 1) {
                    args.doPreInstall(res.returnCode);
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.installPackageTracedLI(args, res);
                        PackageParser.Package pkg = res.pkg;
                        String pkgName = null;
                        if (pkg != null) {
                            pkgName = pkg.packageName;
                        }
                        if (pkgName != null) {
                            InstallerMgr.getInstance().installPackage(1, args.installerPackageName, pkgName);
                        }
                    }
                    args.doPostInstall(res.returnCode, res.uid);
                }
                boolean doRestore = !(res.removedInfo != null && res.removedInfo.removedPackage != null) && (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) != 0;
                if (PackageManagerService.this.mNextInstallToken < 0) {
                    PackageManagerService.this.mNextInstallToken = 1;
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                int i = packageManagerService.mNextInstallToken;
                packageManagerService.mNextInstallToken = i + 1;
                int token = i;
                PackageManagerService.this.mRunningInstalls.put(token, new PostInstallData(args, res));
                if (PackageManagerService.DEBUG_INSTALL) {
                    Log.v(PackageManagerService.TAG, "+ starting restore round-trip " + token);
                }
                if (res.returnCode == 1 && doRestore) {
                    IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
                    if (bm != null) {
                        if (PackageManagerService.DEBUG_INSTALL) {
                            Log.v(PackageManagerService.TAG, "token " + token + " to BM for possible restore");
                        }
                        Trace.asyncTraceBegin(262144, "restore", token);
                        try {
                            if (bm.isBackupServiceActive(0)) {
                                bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);
                            } else {
                                doRestore = false;
                            }
                        } catch (RemoteException e) {
                        } catch (Exception e2) {
                            Slog.e(PackageManagerService.TAG, "Exception trying to enqueue restore", e2);
                            doRestore = false;
                        }
                    } else {
                        Slog.e(PackageManagerService.TAG, "Backup Manager not found!");
                        doRestore = false;
                    }
                }
                if (!doRestore) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Log.v(PackageManagerService.TAG, "No restore - queue post-install for " + token);
                    }
                    Trace.asyncTraceBegin(262144, "postInstall", token);
                    PackageManagerService.this.mHandler.sendMessage(PackageManagerService.this.mHandler.obtainMessage(9, token, 0));
                }
            }
        });
    }

    /* access modifiers changed from: package-private */
    public void notifyFirstLaunch(final String packageName, final String installerPackage, final int userId) {
        this.mHandler.post(new Runnable() {
            public void run() {
                for (int i = 0; i < PackageManagerService.this.mRunningInstalls.size(); i++) {
                    PostInstallData data = PackageManagerService.this.mRunningInstalls.valueAt(i);
                    if (data.res.returnCode == 1 && packageName.equals(data.res.pkg.applicationInfo.packageName)) {
                        for (int i2 : data.res.newUsers) {
                            if (userId == i2) {
                                if (PackageManagerService.DEBUG_BACKUP) {
                                    Slog.i(PackageManagerService.TAG, "Package " + packageName + " being restored so deferring FIRST_LAUNCH");
                                }
                                return;
                            }
                        }
                        continue;
                    }
                }
                if (PackageManagerService.DEBUG_BACKUP != 0) {
                    Slog.i(PackageManagerService.TAG, "Package " + packageName + " sending normal FIRST_LAUNCH");
                }
                boolean isInstantApp = PackageManagerService.this.isInstantApp(packageName, userId);
                PackageManagerService.this.sendFirstLaunchBroadcast(packageName, installerPackage, isInstantApp ? PackageManagerService.EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : PackageManagerService.EMPTY_INT_ARRAY);
            }
        });
    }

    /* access modifiers changed from: private */
    public void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds, instantUserIds);
    }

    private static void clearDirectory(IMediaContainerService mcs, File[] paths) {
        for (File path : paths) {
            try {
                mcs.clearDirectory(path.getAbsolutePath());
            } catch (RemoteException e) {
            }
        }
    }

    /* access modifiers changed from: private */
    public InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(this, params);
        }
        return new FileInstallArgs(this, params);
    }

    private InstallArgs createInstallArgsForExisting(int installFlags, String codePath, String resourcePath, String[] instructionSets) {
        return new FileInstallArgs(this, codePath, resourcePath, instructionSets);
    }

    /* access modifiers changed from: package-private */
    public void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (allCodePaths.isEmpty()) {
            return;
        }
        if (instructionSets != null) {
            String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
            for (String codePath : allCodePaths) {
                for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                    try {
                        this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                    } catch (Installer.InstallerException e) {
                    }
                }
            }
            return;
        }
        throw new IllegalStateException("instructionSet == null");
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    static String cidFromCodePath(String fullCodePath) {
        int eidx = fullCodePath.lastIndexOf(SliceClientPermissions.SliceAuthority.DELIMITER);
        String subStr1 = fullCodePath.substring(0, eidx);
        return subStr1.substring(subStr1.lastIndexOf(SliceClientPermissions.SliceAuthority.DELIMITER) + 1, eidx);
    }

    static String getAsecPackageName(String packageCid) {
        int idx = packageCid.lastIndexOf(INSTALL_PACKAGE_SUFFIX);
        if (idx == -1) {
            return packageCid;
        }
        return packageCid.substring(0, idx);
    }

    private static String getNextCodePath(String oldCodePath, String prefix, String suffix) {
        int idx = 1;
        if (oldCodePath != null) {
            String subStr = oldCodePath;
            if (suffix != null && subStr.endsWith(suffix)) {
                subStr = subStr.substring(0, subStr.length() - suffix.length());
            }
            int sidx = subStr.lastIndexOf(prefix);
            if (sidx != -1) {
                String subStr2 = subStr.substring(prefix.length() + sidx);
                if (subStr2 != null) {
                    if (subStr2.startsWith(INSTALL_PACKAGE_SUFFIX)) {
                        subStr2 = subStr2.substring(INSTALL_PACKAGE_SUFFIX.length());
                    }
                    try {
                        int idx2 = Integer.parseInt(subStr2);
                        idx = idx2 <= 1 ? idx2 + 1 : idx2 - 1;
                    } catch (NumberFormatException e) {
                    }
                }
            }
        }
        String idxStr = INSTALL_PACKAGE_SUFFIX + Integer.toString(idx);
        return prefix + idxStr;
    }

    /* access modifiers changed from: private */
    public File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            String suffix = Base64.encodeToString(bytes, 10);
            result = new File(targetDir, packageName + INSTALL_PACKAGE_SUFFIX + suffix);
        } while (result.exists());
        return result;
    }

    static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        Slog.w(TAG, "Odd, " + codePath + " doesn't look like an APK");
        return null;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:15:?, code lost:
        r0 = scanPackageTracedLI(r11, r18, r19, java.lang.System.currentTimeMillis(), r20);
        updateSettingsLI(r0, r21, null, r12, r20, r24);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:16:0x0095, code lost:
        if (r12.returnCode != 1) goto L_0x009b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0097, code lost:
        prepareAppDataAfterInstallLIF(r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x009b, code lost:
        android.util.Flog.i(207, "updateSettingsLI failed: " + r12.returnCode + ", delete pkg: " + r15);
        deletePackageLIF(r15, android.os.UserHandle.ALL, false, null, 1, r12.removedInfo, true, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x00c9, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x00ca, code lost:
        r12.setError("Package couldn't be installed in " + r11.codePath, r0);
     */
    private void installNewPackageLIF(PackageParser.Package pkg, int parseFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res, int installReason) {
        PackageParser.Package packageR = pkg;
        PackageInstalledInfo packageInstalledInfo = res;
        Trace.traceBegin(262144, "installNewPackage");
        String pkgName = packageR.packageName;
        Flog.i(207, "installNewPackageLI: " + packageR);
        synchronized (this.mPackages) {
            String renamedPackage = this.mSettings.getRenamedPackageLPr(pkgName);
            if (renamedPackage != null) {
                packageInstalledInfo.setError(-1, "Attempt to re-install " + pkgName + " without first uninstalling package running as " + renamedPackage);
                return;
            } else if (this.mPackages.containsKey(pkgName)) {
                packageInstalledInfo.setError(-1, "Attempt to re-install " + pkgName + " without first uninstalling.");
                return;
            }
        }
        Trace.traceEnd(262144);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:12:0x001b, code lost:
        $closeResource(r1, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:13:0x001e, code lost:
        throw r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:8:0x0017, code lost:
        r2 = move-exception;
     */
    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        DigestInputStream digestStream = new DigestInputStream(new FileInputStream(file), digest);
        do {
        } while (digestStream.read() != -1);
        $closeResource(null, digestStream);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:140:0x028e, code lost:
        r8 = r4;
        r6 = r0;
        r14.removedInfo = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r11);
        r14.removedInfo.uid = r8.applicationInfo.uid;
        r14.removedInfo.removedPackage = r8.packageName;
        r14.removedInfo.installerPackageName = r7.installerPackageName;
        r0 = r14.removedInfo;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x02af, code lost:
        if (r12.staticSharedLibName == null) goto L_0x02b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x02b1, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x02b3, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02b4, code lost:
        r0.isStaticSharedLib = r1;
        r14.removedInfo.isUpdate = true;
        r14.removedInfo.origUsers = r5;
        r14.removedInfo.installReasons = new android.util.SparseArray<>(r5.length);
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x02cb, code lost:
        if (r0 >= r5.length) goto L_0x02e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:147:0x02cd, code lost:
        r1 = r5[r0];
        r14.removedInfo.installReasons.put(r1, java.lang.Integer.valueOf(r7.getInstallReason(r1)));
        r0 = r0 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x02e3, code lost:
        if (r8.childPackages == null) goto L_0x02ec;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02e5, code lost:
        r1 = r8.childPackages.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x02ec, code lost:
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02ed, code lost:
        r3 = r1;
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02ef, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02f0, code lost:
        if (r1 >= r3) goto L_0x039d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:0x02f2, code lost:
        r2 = (android.content.pm.PackageParser.Package) r8.childPackages.get(r1);
        r32 = false;
        r4 = r11.mSettings.getPackageLPr(r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x0307, code lost:
        if (r14.addedChildPackages == null) goto L_0x0343;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:157:0x0309, code lost:
        r33 = r3;
        r0 = r14.addedChildPackages.get(r2.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x0315, code lost:
        if (r0 == null) goto L_0x0340;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x0317, code lost:
        r34 = r5;
        r0.removedInfo.uid = r2.applicationInfo.uid;
        r0.removedInfo.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x0327, code lost:
        if (r4 == null) goto L_0x032f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:161:0x0329, code lost:
        r0.removedInfo.installerPackageName = r4.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x032f, code lost:
        r0.removedInfo.isUpdate = true;
        r0.removedInfo.installReasons = r14.removedInfo.installReasons;
        r32 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x0340, code lost:
        r34 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x0343, code lost:
        r33 = r3;
        r34 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x0347, code lost:
        if (r32 != false) goto L_0x038f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x0349, code lost:
        r3 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r11);
        r3.removedPackage = r2.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x0353, code lost:
        if (r4 == null) goto L_0x0359;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x0355, code lost:
        r3.installerPackageName = r4.installerPackageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x0359, code lost:
        r3.isUpdate = false;
        r3.dataRemoved = true;
        r5 = r11.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x0361, code lost:
        monitor-enter(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x0362, code lost:
        if (r4 == null) goto L_0x0370;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0364, code lost:
        r35 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:?, code lost:
        r3.origUsers = r4.queryInstalledUsers(r6, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x036e, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x0370, code lost:
        r35 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0373, code lost:
        monitor-exit(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0378, code lost:
        if (r14.removedInfo.removedChildPackages != null) goto L_0x0383;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x037a, code lost:
        r14.removedInfo.removedChildPackages = new android.util.ArrayMap<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0383, code lost:
        r14.removedInfo.removedChildPackages.put(r2.packageName, r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x038e, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x038f, code lost:
        r35 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x0392, code lost:
        r0 = r1 + 1;
        r3 = r33;
        r5 = r34;
        r7 = r35;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x039d, code lost:
        r33 = r3;
        r34 = r5;
        r35 = r7;
        r0 = true;
        r1 = isSystemApp(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x03a8, code lost:
        if (r1 == false) goto L_0x03b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x03b0, code lost:
        if (mHwPMSEx.isSystemAppGrantByMdm(r12) == false) goto L_0x03b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x03b2, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x03b5, code lost:
        if (r1 == false) goto L_0x042f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x03be, code lost:
        if ((r8.applicationInfo.privateFlags & 8) == 0) goto L_0x03c2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x03c0, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x03c2, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x03c3, code lost:
        r18 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x03cc, code lost:
        if ((r8.applicationInfo.privateFlags & 131072) == 0) goto L_0x03d0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x03ce, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x03d0, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x03d1, code lost:
        r19 = r1;
        r3 = 262144;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x03da, code lost:
        if ((r8.applicationInfo.privateFlags & 262144) == 0) goto L_0x03de;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:205:0x03dc, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x03de, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x03df, code lost:
        r20 = r1;
        r5 = 524288;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:208:0x03e8, code lost:
        if ((r8.applicationInfo.privateFlags & 524288) == 0) goto L_0x03eb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:209:0x03eb, code lost:
        r0 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x03ec, code lost:
        r4 = r9;
        r1 = r13 | 131072;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:0x03ef, code lost:
        if (r18 == false) goto L_0x03f2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x03f2, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:213:0x03f3, code lost:
        r1 = r1 | r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x03f4, code lost:
        if (r19 == false) goto L_0x03f7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x03f7, code lost:
        r5 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x03f8, code lost:
        r1 = r1 | r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:217:0x03f9, code lost:
        if (r20 == false) goto L_0x03fe;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x03fb, code lost:
        r2 = 1048576;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x03fe, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:220:0x03ff, code lost:
        r1 = r1 | r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:221:0x0400, code lost:
        if (r0 == false) goto L_0x0405;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:222:0x0402, code lost:
        r2 = 2097152;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:223:0x0405, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:224:0x0406, code lost:
        mHwPMSEx.resolvePersistentFlagForPackage(r8.applicationInfo.flags, r12);
        r22 = r33;
        r23 = r34;
        r25 = r35;
        r26 = r8;
        r27 = r10;
        replaceSystemPackageLIF(r8, r12, r4, r1 | r2, r40, r6, r41, r14, r43);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:225:0x042f, code lost:
        r27 = r10;
        r22 = r33;
        r23 = r34;
        r25 = r35;
        replaceNonSystemPackageLIF(r8, r12, r38, r13, r40, r6, r41, r14, r43);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:0x044e, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x006b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x006c, code lost:
        r27 = r10;
     */
    /* JADX WARNING: Exception block dominator not found, dom blocks: [B:21:0x0063, B:65:0x012b] */
    /* JADX WARNING: Removed duplicated region for block: B:90:0x019a  */
    /* JADX WARNING: Removed duplicated region for block: B:95:0x01bb A[SYNTHETIC, Splitter:B:95:0x01bb] */
    private void replacePackageLIF(PackageParser.Package pkg, int parseFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res, int installReason) {
        int i;
        String invalidPackageName;
        PackageParser.Package packageR = pkg;
        int i2 = scanFlags;
        PackageInstalledInfo packageInstalledInfo = res;
        boolean isInstantApp = (i2 & 16384) != 0;
        String pkgName = packageR.packageName;
        synchronized (this.mPackages) {
            PackageParser.Package oldPackage = this.mPackages.get(pkgName);
            Flog.i(207, "replacePackageLI: new=" + packageR + ", old=" + oldPackage);
            boolean oldTargetsPreRelease = oldPackage.applicationInfo.targetSdkVersion == 10000;
            boolean newTargetsPreRelease = packageR.applicationInfo.targetSdkVersion == 10000;
            if (!oldTargetsPreRelease || newTargetsPreRelease) {
                i = parseFlags;
            } else {
                i = parseFlags;
                if ((i & 128) == 0) {
                    Slog.w(TAG, "Can't install package targeting released sdk");
                    packageInstalledInfo.setReturnCode(-7);
                    return;
                }
            }
            try {
                PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
                if (ksms.shouldCheckUpgradeKeySetLocked(ps, i2)) {
                    if (!ksms.checkUpgradeKeySetLocked(ps, packageR)) {
                        packageInstalledInfo.setError(-7, "New package not signed by keys specified by upgrade-keysets: " + pkgName);
                        return;
                    }
                } else if (!packageR.mSigningDetails.checkCapability(oldPackage.mSigningDetails, 1)) {
                    if (!oldPackage.mSigningDetails.checkCapability(packageR.mSigningDetails, 8)) {
                        if (mHwPMSEx.isSystemSignatureUpdated(oldPackage.mSigningDetails.signatures, packageR.mSigningDetails.signatures)) {
                            Slog.i(TAG, "CertCompat: " + packageR.packageName + " system signature updated. Ignore signature matching.");
                        } else {
                            packageInstalledInfo.setError(-7, "New package has a different signature: " + pkgName);
                            return;
                        }
                    }
                }
                if (oldPackage.restrictUpdateHash != null) {
                    if (oldPackage.isSystem()) {
                        try {
                            MessageDigest digest = MessageDigest.getInstance("SHA-512");
                            try {
                                updateDigest(digest, new File(packageR.baseCodePath));
                                if (!ArrayUtils.isEmpty(packageR.splitCodePaths)) {
                                    String[] strArr = packageR.splitCodePaths;
                                    boolean z = newTargetsPreRelease;
                                    int i3 = 0;
                                    for (int length = strArr.length; i3 < length; length = length) {
                                        updateDigest(digest, new File(strArr[i3]));
                                        i3++;
                                        strArr = strArr;
                                    }
                                }
                                if (!Arrays.equals(oldPackage.restrictUpdateHash, digest.digest())) {
                                    packageInstalledInfo.setError(-2, "New package fails restrict-update check: " + pkgName);
                                    return;
                                }
                                packageR.restrictUpdateHash = oldPackage.restrictUpdateHash;
                                invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, packageR);
                                if (invalidPackageName == null) {
                                    packageInstalledInfo.setError(-8, "Package " + invalidPackageName + " tried to change user " + oldPackage.mSharedUserId);
                                    return;
                                }
                                boolean oldPkgSupportMultiArch = oldPackage.applicationInfo.secondaryCpuAbi != null;
                                boolean newPkgSupportMultiArch = packageR.applicationInfo.secondaryCpuAbi != null;
                                if (!isSystemApp(oldPackage) || !oldPkgSupportMultiArch || newPkgSupportMultiArch) {
                                    int[] allUsers = sUserManager.getUserIds();
                                    int[] installedUsers = ps.queryInstalledUsers(allUsers, true);
                                    if (isInstantApp) {
                                        boolean z2 = oldPkgSupportMultiArch;
                                        if (user != null) {
                                            boolean z3 = newPkgSupportMultiArch;
                                            if (user.getIdentifier() == -1) {
                                                boolean z4 = oldTargetsPreRelease;
                                            } else if (!ps.getInstantApp(user.getIdentifier())) {
                                                StringBuilder sb = new StringBuilder();
                                                boolean z5 = oldTargetsPreRelease;
                                                sb.append("Can't replace full app with instant app: ");
                                                sb.append(pkgName);
                                                sb.append(" for user: ");
                                                sb.append(user.getIdentifier());
                                                Slog.w(TAG, sb.toString());
                                                packageInstalledInfo.setReturnCode(-116);
                                                return;
                                            }
                                        } else {
                                            boolean z6 = oldTargetsPreRelease;
                                        }
                                        int length2 = allUsers.length;
                                        int i4 = 0;
                                        while (i4 < length2) {
                                            int currentUser = allUsers[i4];
                                            if (!ps.getInstantApp(currentUser)) {
                                                StringBuilder sb2 = new StringBuilder();
                                                KeySetManagerService keySetManagerService = ksms;
                                                sb2.append("Can't replace full app with instant app: ");
                                                sb2.append(pkgName);
                                                sb2.append(" for user: ");
                                                sb2.append(currentUser);
                                                Slog.w(TAG, sb2.toString());
                                                packageInstalledInfo.setReturnCode(-116);
                                                return;
                                            }
                                            i4++;
                                            ksms = ksms;
                                        }
                                    }
                                } else {
                                    StringBuilder sb3 = new StringBuilder();
                                    String str = invalidPackageName;
                                    sb3.append("Update to package ");
                                    sb3.append(pkgName);
                                    sb3.append(" doesn't support multi arch");
                                    packageInstalledInfo.setError(-7, sb3.toString());
                                    return;
                                }
                            } catch (IOException | NoSuchAlgorithmException e) {
                                boolean z7 = newTargetsPreRelease;
                                packageInstalledInfo.setError(-2, "Could not compute hash: " + pkgName);
                                return;
                            }
                        } catch (IOException | NoSuchAlgorithmException e2) {
                            boolean z8 = newTargetsPreRelease;
                            packageInstalledInfo.setError(-2, "Could not compute hash: " + pkgName);
                            return;
                        }
                    }
                }
                invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, packageR);
                if (invalidPackageName == null) {
                }
            } catch (Throwable th) {
                th = th;
                String str2 = pkgName;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th2) {
                        th = th2;
                    }
                }
                throw th;
            }
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r2v1, resolved type: int} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r5v3, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r11v3, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r11v4, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r11v5, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r5v7, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r5v8, resolved type: boolean} */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x0236, code lost:
        android.util.Slog.i(TAG, "Successfully restored package : " + r7 + " after failed upgrade");
     */
    /* JADX WARNING: Multi-variable type inference failed */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x02a5  */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x018d  */
    private void replaceNonSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, int parseFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        boolean deletedPkg;
        String pkgName;
        int i;
        PackageParser.Package packageR = deletedPackage;
        PackageParser.Package packageR2 = pkg;
        int i2 = scanFlags;
        PackageInstalledInfo packageInstalledInfo = res;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "replaceNonSystemPackageLI: new=" + packageR2 + ", old=" + packageR);
        }
        if (!mHwPMSEx.isMDMDisallowedInstallPackage(packageR2, packageInstalledInfo)) {
            String pkgName2 = packageR.packageName;
            boolean addedPkg = false;
            boolean killApp = (i2 & 2048) == 0;
            int i3 = 8;
            int deleteFlags = 1 | (killApp ? 0 : 8);
            String pkgName3 = pkgName2;
            long origUpdateTime = packageR2.mExtras != null ? ((PackageSetting) packageR2.mExtras).lastUpdateTime : 0;
            PackageInstalledInfo packageInstalledInfo2 = packageInstalledInfo;
            if (!deletePackageLIF(pkgName2, null, true, allUsers, deleteFlags, packageInstalledInfo.removedInfo, true, packageR2)) {
                packageInstalledInfo2.setError(-10, "replaceNonSystemPackageLI");
                deletedPkg = false;
                pkgName = pkgName3;
                i = 1;
            } else {
                if (deletedPackage.isForwardLocked() || isExternal(deletedPackage)) {
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + packageR + " is ASEC-hosted -> UNAVAILABLE");
                    }
                    i = 1;
                    int[] uidArray = {packageR.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList<>(1);
                    pkgList.add(packageR.applicationInfo.packageName);
                    sendResourcesChangedBroadcast(false, true, pkgList, uidArray, (IIntentReceiver) null);
                } else {
                    i = 1;
                }
                clearAppDataLIF(packageR2, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                try {
                    PackageParser.Package newPackage = scanPackageTracedLI(packageR2, parseFlags, i2 | 8, System.currentTimeMillis(), user);
                    updateSettingsLI(newPackage, installerPackageName, allUsers, packageInstalledInfo2, user, installReason);
                    pkgName = pkgName3;
                    try {
                        PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                        if (!killApp) {
                            if (ps.oldCodePaths == null) {
                                ps.oldCodePaths = new ArraySet();
                            }
                            Set set = ps.oldCodePaths;
                            String[] strArr = new String[i];
                            strArr[0] = packageR.baseCodePath;
                            Collections.addAll(set, strArr);
                            if (packageR.splitCodePaths != null) {
                                Collections.addAll(ps.oldCodePaths, packageR.splitCodePaths);
                            }
                        } else {
                            ps.oldCodePaths = null;
                        }
                        if (ps.childPackageNames != null) {
                            for (int i4 = ps.childPackageNames.size() - i; i4 >= 0; i4--) {
                                this.mSettings.mPackages.get((String) ps.childPackageNames.get(i4)).oldCodePaths = ps.oldCodePaths;
                            }
                        }
                        prepareAppDataAfterInstallLIF(newPackage);
                        addedPkg = true;
                        this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
                    } catch (PackageManagerException e) {
                        e = e;
                        packageInstalledInfo2.setError("Package couldn't be installed in " + packageR2.codePath, e);
                        deletedPkg = true;
                        if (packageInstalledInfo2.returnCode != i) {
                        }
                    }
                } catch (PackageManagerException e2) {
                    e = e2;
                    pkgName = pkgName3;
                    packageInstalledInfo2.setError("Package couldn't be installed in " + packageR2.codePath, e);
                    deletedPkg = true;
                    if (packageInstalledInfo2.returnCode != i) {
                    }
                }
                deletedPkg = true;
            }
            if (packageInstalledInfo2.returnCode != i) {
                if (DEBUG_INSTALL) {
                    Slog.d(TAG, "Install failed, rolling pack: " + pkgName);
                }
                if (addedPkg) {
                    deletePackageLIF(pkgName, null, true, allUsers, deleteFlags, packageInstalledInfo2.removedInfo, true, null);
                }
                if (deletedPkg) {
                    if (DEBUG_INSTALL) {
                        Slog.d(TAG, "Install failed, reinstalling: " + packageR);
                    }
                    File restoreFile = new File(packageR.codePath);
                    boolean oldExternal = isExternal(deletedPackage);
                    int i5 = this.mDefParseFlags | Integer.MIN_VALUE | (deletedPackage.isForwardLocked() ? 4 : 0);
                    if (!oldExternal) {
                        i3 = 0;
                    }
                    int oldParseFlags = i5 | i3;
                    PackageParser.Package packageR3 = packageR2;
                    PackageParser.Package packageR4 = packageR;
                    PackageInstalledInfo packageInstalledInfo3 = packageInstalledInfo2;
                    String pkgName4 = pkgName;
                    try {
                        scanPackageTracedLI(restoreFile, oldParseFlags, 10, origUpdateTime, (UserHandle) null);
                        synchronized (this.mPackages) {
                            try {
                                setInstallerPackageNameLPw(packageR4, installerPackageName);
                                try {
                                    boolean z = oldExternal;
                                    int i6 = oldParseFlags;
                                    PackageInstalledInfo packageInstalledInfo4 = res;
                                } catch (Throwable th) {
                                    th = th;
                                    boolean z2 = oldExternal;
                                    int i7 = oldParseFlags;
                                    PackageInstalledInfo packageInstalledInfo5 = res;
                                    String str = pkgName4;
                                    throw th;
                                }
                                try {
                                    this.mPermissionManager.updatePermissions(packageR4.packageName, packageR4, false, this.mPackages.values(), this.mPermissionCallback);
                                } catch (Throwable th2) {
                                    th = th2;
                                    throw th;
                                }
                                try {
                                    this.mSettings.writeLPr();
                                } catch (Throwable th3) {
                                    th = th3;
                                    throw th;
                                }
                            } catch (Throwable th4) {
                                th = th4;
                                boolean z3 = oldExternal;
                                int i8 = oldParseFlags;
                                String str2 = pkgName4;
                                PackageInstalledInfo packageInstalledInfo6 = packageInstalledInfo3;
                                throw th;
                            }
                        }
                    } catch (PackageManagerException e3) {
                        String str3 = installerPackageName;
                        boolean z4 = oldExternal;
                        int i9 = oldParseFlags;
                        PackageInstalledInfo packageInstalledInfo7 = packageInstalledInfo3;
                        PackageManagerException packageManagerException = e3;
                        Slog.e(TAG, "Failed to restore package : " + pkgName + " after failed upgrade: " + e3.getMessage());
                    }
                } else {
                    PackageParser.Package packageR5 = packageR2;
                    PackageInstalledInfo packageInstalledInfo8 = packageInstalledInfo2;
                    String str4 = pkgName;
                    long j = origUpdateTime;
                    String str5 = installerPackageName;
                }
            } else {
                int i10 = i;
                PackageParser.Package packageR6 = packageR2;
                PackageInstalledInfo packageInstalledInfo9 = packageInstalledInfo2;
                String str6 = pkgName;
                long j2 = origUpdateTime;
                String str7 = installerPackageName;
                synchronized (this.mPackages) {
                    PackageSetting ps2 = this.mSettings.getPackageLPr(packageR6.packageName);
                    if (ps2 != null) {
                        packageInstalledInfo9.removedInfo.removedForAllUsers = this.mPackages.get(ps2.name) == null ? i10 : 0;
                        if (packageInstalledInfo9.removedInfo.removedChildPackages != null) {
                            for (int i11 = packageInstalledInfo9.removedInfo.removedChildPackages.size() - 1; i11 >= 0; i11--) {
                                if (packageInstalledInfo9.addedChildPackages.containsKey(packageInstalledInfo9.removedInfo.removedChildPackages.keyAt(i11))) {
                                    packageInstalledInfo9.removedInfo.removedChildPackages.removeAt(i11);
                                } else {
                                    PackageRemovedInfo childInfo = packageInstalledInfo9.removedInfo.removedChildPackages.valueAt(i11);
                                    childInfo.removedForAllUsers = this.mPackages.get(childInfo.removedPackage) == null ? i10 : 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:133:? A[ORIG_RETURN, RETURN, SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:91:0x01f3  */
    private void replaceSystemPackageLIF(PackageParser.Package deletedPackage, PackageParser.Package pkg, int parseFlags, int scanFlags, UserHandle user, int[] allUsers, String installerPackageName, PackageInstalledInfo res, int installReason) {
        boolean disabledSystem;
        PackageParser.Package newPackage;
        PackageParser.Package newPackage2;
        int i;
        boolean childPackageDeleted;
        int newChildCount;
        int i2;
        int deletedChildCount;
        PackageParser.Package packageR = deletedPackage;
        PackageParser.Package packageR2 = pkg;
        PackageInstalledInfo packageInstalledInfo = res;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "replaceSystemPackageLI: new=" + packageR2 + ", old=" + packageR);
        }
        String packageName = packageR.packageName;
        PackageSetting deletePackageSetting = this.mSettings.mPackages.get(packageName);
        removePackageLI(packageR, true);
        synchronized (this.mPackages) {
            disabledSystem = disableSystemPackageLPw(deletedPackage, pkg);
        }
        if (!disabledSystem) {
            packageInstalledInfo.removedInfo.args = createInstallArgsForExisting(0, packageR.applicationInfo.getCodePath(), packageR.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(packageR.applicationInfo));
        } else {
            packageInstalledInfo.removedInfo.args = null;
        }
        clearAppDataLIF(packageR2, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
        packageInstalledInfo.setReturnCode(1);
        packageR2.setApplicationInfoFlags(128, 128);
        synchronized (this.mPackages) {
            String disableSysPath = this.mSettings.getDisabledSysPackagesPath(packageName);
            PackageSetting disableSysSetting = this.mSettings.getDisabledSystemPkgLPr(packageName);
            boolean disableSysPathInDel = false;
            boolean disableSysInData = false;
            if (disableSysPath != null && (mHwPMSEx.containDelPath(disableSysPath) || mHwPMSEx.isPreRemovableApp(disableSysPath))) {
                disableSysPathInDel = true;
            }
            if (disableSysSetting != null && mHwPMSEx.isDelappInData(disableSysSetting)) {
                disableSysInData = true;
            }
            if (mHwPMSEx.containDelPath(packageR.applicationInfo.sourceDir) || mHwPMSEx.isPreRemovableApp(packageR.applicationInfo.sourceDir) || mHwPMSEx.isDelappInData(deletePackageSetting) || disableSysPathInDel || disableSysInData) {
                packageR2.applicationInfo.hwFlags |= 67108864;
            }
        }
        int i3 = 0;
        try {
            newPackage2 = scanPackageTracedLI(packageR2, parseFlags, scanFlags, 0, user);
            try {
                PackageSetting deletedPkgSetting = (PackageSetting) packageR.mExtras;
                PackageSetting packageSetting = deletedPkgSetting;
                setInstallAndUpdateTime(newPackage2, deletedPkgSetting.firstInstallTime, System.currentTimeMillis());
                if (packageInstalledInfo.returnCode == 1) {
                    if (packageR.childPackages != null) {
                        try {
                            i = packageR.childPackages.size();
                        } catch (PackageManagerException e) {
                            e = e;
                            packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
                            packageInstalledInfo.setError("Package couldn't be installed in " + packageR2.codePath, e);
                            newPackage = newPackage2;
                            if (packageInstalledInfo.returnCode == 1) {
                            }
                        }
                    } else {
                        i = 0;
                    }
                    int deletedChildCount2 = i;
                    int newChildCount2 = newPackage2.childPackages != null ? newPackage2.childPackages.size() : 0;
                    int i4 = 0;
                    while (true) {
                        int i5 = i4;
                        if (i5 >= deletedChildCount2) {
                            break;
                        }
                        PackageParser.Package deletedChildPkg = (PackageParser.Package) packageR.childPackages.get(i5);
                        boolean childPackageDeleted2 = true;
                        int j = i3;
                        while (true) {
                            if (j >= newChildCount2) {
                                childPackageDeleted = childPackageDeleted2;
                                break;
                            }
                            boolean childPackageDeleted3 = childPackageDeleted2;
                            if (deletedChildPkg.packageName.equals(((PackageParser.Package) newPackage2.childPackages.get(j)).packageName)) {
                                childPackageDeleted = false;
                                break;
                            } else {
                                j++;
                                childPackageDeleted2 = childPackageDeleted3;
                            }
                        }
                        if (childPackageDeleted) {
                            PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                            if (!(ps == null || packageInstalledInfo.removedInfo.removedChildPackages == null)) {
                                PackageRemovedInfo removedChildRes = packageInstalledInfo.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                                PackageParser.Package packageR3 = deletedChildPkg;
                                i2 = i5;
                                newChildCount = newChildCount2;
                                deletedChildCount = deletedChildCount2;
                                removePackageDataLIF(ps, allUsers, removedChildRes, 0, false);
                                removedChildRes.removedForAllUsers = this.mPackages.get(ps.name) == null;
                                i4 = i2 + 1;
                                deletedChildCount2 = deletedChildCount;
                                newChildCount2 = newChildCount;
                                i3 = 0;
                            }
                        }
                        i2 = i5;
                        newChildCount = newChildCount2;
                        deletedChildCount = deletedChildCount2;
                        i4 = i2 + 1;
                        deletedChildCount2 = deletedChildCount;
                        newChildCount2 = newChildCount;
                        i3 = 0;
                    }
                    int i6 = deletedChildCount2;
                    newPackage = newPackage2;
                    try {
                        updateSettingsLI(newPackage2, installerPackageName, allUsers, packageInstalledInfo, user, installReason);
                        prepareAppDataAfterInstallLIF(newPackage);
                        this.mDexManager.notifyPackageUpdated(newPackage.packageName, newPackage.baseCodePath, newPackage.splitCodePaths);
                    } catch (PackageManagerException e2) {
                        e = e2;
                        newPackage2 = newPackage;
                    }
                } else {
                    newPackage = newPackage2;
                }
            } catch (PackageManagerException e3) {
                e = e3;
                PackageParser.Package packageR4 = newPackage2;
                packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
                packageInstalledInfo.setError("Package couldn't be installed in " + packageR2.codePath, e);
                newPackage = newPackage2;
                if (packageInstalledInfo.returnCode == 1) {
                }
            }
        } catch (PackageManagerException e4) {
            e = e4;
            newPackage2 = null;
            packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
            packageInstalledInfo.setError("Package couldn't be installed in " + packageR2.codePath, e);
            newPackage = newPackage2;
            if (packageInstalledInfo.returnCode == 1) {
            }
        }
        if (packageInstalledInfo.returnCode == 1) {
            if (newPackage != null) {
                Flog.i(207, "replace syspkg, Install failed: " + packageInstalledInfo.returnCode + ", pkg: " + newPackage.packageName);
                removeInstalledPackageLI(newPackage, true);
            }
            try {
                scanPackageTracedLI(packageR, parseFlags, 2, 0, user);
            } catch (PackageManagerException e5) {
                PackageManagerException packageManagerException = e5;
                Slog.e(TAG, "Failed to restore original package: " + e5.getMessage());
            }
            synchronized (this.mPackages) {
                if (disabledSystem) {
                    try {
                        enableSystemPackageLPw(deletedPackage);
                    } catch (Throwable th) {
                        while (true) {
                            throw th;
                        }
                    }
                }
                setInstallerPackageNameLPw(packageR, installerPackageName);
                this.mPermissionManager.updatePermissions(packageR.packageName, packageR, false, this.mPackages.values(), this.mPermissionCallback);
                this.mSettings.writeLPr();
            }
            Slog.i(TAG, "Successfully restored package : " + packageR.packageName + " after failed upgrade");
        }
    }

    private String getParentOrChildPackageChangedSharedUser(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        int newChildCount = newPkg.childPackages != null ? newPkg.childPackages.size() : 0;
        for (int i = 0; i < newChildCount; i++) {
            PackageParser.Package newChildPkg = (PackageParser.Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                PackageParser.Package oldChildPkg = (PackageParser.Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && !Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId)) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        PackageSetting childPs;
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
            }
        }
    }

    private void enableSystemPackageLPw(PackageParser.Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.enableSystemPackageLPw(((PackageParser.Package) pkg.childPackages.get(i)).packageName);
        }
    }

    private boolean disableSystemPackageLPw(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        int childCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = (PackageParser.Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
        }
        return disabled;
    }

    private void setInstallerPackageNameLPw(PackageParser.Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.setInstallerPackageName(((PackageParser.Package) pkg.childPackages.get(i)).packageName, installerPackageName);
        }
    }

    /* access modifiers changed from: protected */
    public void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        PackageParser.Package packageR = newPackage;
        PackageInstalledInfo packageInstalledInfo = res;
        updateSettingsInternalLI(packageR, installerPackageName, allUsers, packageInstalledInfo.origUsers, packageInstalledInfo, user, installReason);
        int childCount = packageR.childPackages != null ? packageR.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPackage = (PackageParser.Package) packageR.childPackages.get(i);
            PackageInstalledInfo childRes = packageInstalledInfo.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
        }
    }

    private void updateSettingsInternalLI(PackageParser.Package pkg, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        int i;
        int i2;
        int origUserId;
        PackageParser.Package packageR = pkg;
        String str = installerPackageName;
        int[] iArr = allUsers;
        int[] iArr2 = installedForUsers;
        PackageInstalledInfo packageInstalledInfo = res;
        int i3 = installReason;
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = packageR.packageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "New package installed in " + packageR.codePath);
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                arrayMap = arrayMap2;
                String pkgName2 = pkgName;
                try {
                    this.mPermissionManager.updatePermissions(packageR.packageName, packageR, true, this.mPackages.values(), this.mPermissionCallback);
                    PackageSetting ps = this.mSettings.mPackages.get(pkgName2);
                    HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
                    int userId = user.getIdentifier();
                    if (ps != null) {
                        if (isSystemApp(pkg)) {
                            if (DEBUG_INSTALL) {
                                Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName2);
                            }
                            if (packageInstalledInfo.origUsers != null) {
                                for (int origUserId2 : packageInstalledInfo.origUsers) {
                                    if (userId != -1) {
                                        origUserId = origUserId2;
                                        if (userId != origUserId) {
                                        }
                                    } else {
                                        origUserId = origUserId2;
                                    }
                                    ps.setEnabled(0, origUserId, str);
                                }
                            }
                            if (!(iArr == null || iArr2 == null)) {
                                int length = iArr.length;
                                int i4 = 0;
                                while (i4 < length) {
                                    int currentUserId = iArr[i4];
                                    boolean installed = ArrayUtils.contains(iArr2, currentUserId);
                                    if (DEBUG_INSTALL) {
                                        StringBuilder sb = new StringBuilder();
                                        i2 = length;
                                        sb.append("    user ");
                                        sb.append(currentUserId);
                                        sb.append(" => ");
                                        sb.append(installed);
                                        Slog.d(TAG, sb.toString());
                                    } else {
                                        i2 = length;
                                    }
                                    ps.setInstalled(installed, currentUserId);
                                    i4++;
                                    length = i2;
                                }
                            }
                        }
                        if (userId != -1) {
                            ps.setInstalled(true, userId);
                            i = 0;
                            ps.setEnabled(0, userId, str);
                        } else {
                            i = 0;
                        }
                        Set<Integer> previousUserIds = new ArraySet<>();
                        if (!(packageInstalledInfo.removedInfo == null || packageInstalledInfo.removedInfo.installReasons == null)) {
                            int installReasonCount = packageInstalledInfo.removedInfo.installReasons.size();
                            for (int i5 = i; i5 < installReasonCount; i5++) {
                                int previousUserId = packageInstalledInfo.removedInfo.installReasons.keyAt(i5);
                                ps.setInstallReason(packageInstalledInfo.removedInfo.installReasons.valueAt(i5).intValue(), previousUserId);
                                previousUserIds.add(Integer.valueOf(previousUserId));
                            }
                        }
                        if (userId == -1) {
                            for (int currentUserId2 : sUserManager.getUserIds()) {
                                if (!previousUserIds.contains(Integer.valueOf(currentUserId2))) {
                                    ps.setInstallReason(i3, currentUserId2);
                                }
                            }
                        } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                            ps.setInstallReason(i3, userId);
                        }
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                    packageInstalledInfo.name = pkgName2;
                    packageInstalledInfo.uid = packageR.applicationInfo.uid;
                    packageInstalledInfo.pkg = packageR;
                    this.mSettings.setInstallerPackageName(pkgName2, str);
                    packageInstalledInfo.setReturnCode(1);
                    Trace.traceBegin(262144, "writeSettings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    Trace.traceEnd(262144);
                } catch (Throwable th) {
                    th = th;
                    throw th;
                }
            } catch (Throwable th2) {
                th = th2;
                arrayMap = arrayMap2;
                String str2 = pkgName;
                throw th;
            }
        }
    }

    /* access modifiers changed from: private */
    public void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) {
        try {
            Trace.traceBegin(262144, "installPackage");
            installPackageLI(args, res);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:634:0x0dba, code lost:
        if (r0.getLongVersionCode() > r14.getLongVersionCode()) goto L_0x0dd1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:635:0x0dbd, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:636:0x0dbe, code lost:
        r39 = r6;
        r24 = r7;
        r6 = r8;
        r73 = r13;
        r75 = r15;
        r22 = r26;
        r7 = r37;
        r25 = r40;
        r20 = r46;
        r3 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:648:0x0e01, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:649:0x0e02, code lost:
        r3 = r0;
        r39 = r6;
        r24 = r7;
        r6 = r8;
        r73 = r13;
        r75 = r15;
        r22 = r26;
        r7 = r37;
        r25 = r40;
        r20 = r46;
        r13 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:726:0x0fbc, code lost:
        if (r12.returnCode != 1) goto L_0x0fca;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:727:0x0fbe, code lost:
        mHwPMSEx.recordInstallAppInfo(r14.packageName, r71, r74);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:728:0x0fca, code lost:
        r7 = r71;
        r6 = r74;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:729:0x0fce, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:748:0x1003, code lost:
        $closeResource(r3, r13);
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:240:0x04f8  */
    /* JADX WARNING: Removed duplicated region for block: B:245:0x0523  */
    /* JADX WARNING: Removed duplicated region for block: B:372:0x080c A[SYNTHETIC, Splitter:B:372:0x080c] */
    /* JADX WARNING: Removed duplicated region for block: B:386:0x0859  */
    /* JADX WARNING: Removed duplicated region for block: B:422:0x08f6 A[SYNTHETIC, Splitter:B:422:0x08f6] */
    /* JADX WARNING: Removed duplicated region for block: B:438:0x0931 A[Catch:{ all -> 0x0945 }] */
    /* JADX WARNING: Removed duplicated region for block: B:439:0x0933 A[Catch:{ all -> 0x0945 }] */
    /* JADX WARNING: Removed duplicated region for block: B:459:0x0997 A[SYNTHETIC, Splitter:B:459:0x0997] */
    /* JADX WARNING: Removed duplicated region for block: B:491:0x0a50 A[Catch:{ all -> 0x0b68 }] */
    /* JADX WARNING: Removed duplicated region for block: B:500:0x0b19 A[Catch:{ all -> 0x0b68 }] */
    /* JADX WARNING: Removed duplicated region for block: B:577:0x0cc1  */
    /* JADX WARNING: Removed duplicated region for block: B:579:0x0cc8  */
    /* JADX WARNING: Removed duplicated region for block: B:648:0x0e01 A[ExcHandler: Throwable (r0v126 'th' java.lang.Throwable A[CUSTOM_DECLARE]), Splitter:B:626:0x0d9a] */
    /* JADX WARNING: Removed duplicated region for block: B:748:0x1003  */
    private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
        PackageParser.Package pkg;
        File tmpPackageFile;
        boolean replace;
        long installBeginTime;
        String installerPackageName;
        int installFlags;
        String volumeUuid;
        boolean systemApp;
        String oldCodePath;
        String volumeUuid2;
        boolean replace2;
        PackageSetting ps;
        boolean replace3;
        int installFlags2;
        int parseFlags;
        String oldCodePath2;
        int i;
        int scanFlags;
        boolean replace4;
        PackageFreezer freezer;
        Throwable th;
        int installFlags3;
        long installBeginTime2;
        boolean forwardLocked;
        String pkgName;
        int i2;
        Throwable th2;
        int scanFlags2;
        PackageSetting ps2;
        int N;
        String installerPackageName2;
        boolean sigsOk;
        PackageSetting signatureCheckPs;
        KeySetManagerService ksms;
        String oldName;
        boolean replace5;
        String pkgName2;
        boolean replace6;
        boolean replace7;
        File tmpPackageFile2;
        InstallArgs installArgs = args;
        PackageInstalledInfo packageInstalledInfo = res;
        if (Settings.Secure.getInt(this.mContext.getContentResolver(), SUW_FRP_STATE, 0) != 1 || Settings.Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0) == 1) {
            int installFlags4 = installArgs.installFlags;
            String installerPackageName3 = installArgs.installerPackageName;
            String volumeUuid3 = installArgs.volumeUuid;
            File tmpPackageFile3 = new File(args.getCodePath());
            boolean forwardLocked2 = (installFlags4 & 1) != 0;
            boolean onExternal = ((installFlags4 & 8) == 0 && installArgs.volumeUuid == null) ? false : true;
            boolean instantApp = (installFlags4 & 2048) != 0;
            boolean fullApp = (installFlags4 & 16384) != 0;
            boolean forceSdk = (installFlags4 & 8192) != 0;
            boolean virtualPreload = (installFlags4 & 65536) != 0;
            boolean replace8 = false;
            int scanFlags3 = 6;
            if (installArgs.move != null) {
                scanFlags3 = 6 | 512;
            }
            if ((installFlags4 & 4096) != 0) {
                scanFlags3 |= 2048;
            }
            if (instantApp) {
                scanFlags3 |= 16384;
            }
            if (fullApp) {
                scanFlags3 |= 32768;
            }
            if (virtualPreload) {
                scanFlags3 |= 65536;
            }
            packageInstalledInfo.setReturnCode(1);
            packageInstalledInfo.installerPackageName = installerPackageName3;
            int installFlags5 = installFlags4;
            long installBeginTime3 = SystemClock.elapsedRealtime();
            if (DEBUG_INSTALL) {
                Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile3);
            }
            if (!instantApp || (!forwardLocked2 && !onExternal)) {
                int parseFlags2 = this.mDefParseFlags | Integer.MIN_VALUE | 64 | (forwardLocked2 ? 4 : 0) | (onExternal ? 8 : 0) | (forceSdk ? 128 : 0);
                PackageParser pp = new PackageParser();
                pp.setSeparateProcesses(this.mSeparateProcesses);
                pp.setDisplayMetrics(this.mMetrics);
                pp.setCallback(this.mPackageParserCallback);
                boolean onExternal2 = onExternal;
                long j = 262144;
                Trace.traceBegin(262144, "parsePackage");
                try {
                    PackageParser.Package pkg2 = pp.parsePackage(tmpPackageFile3, parseFlags2);
                    DexMetadataHelper.validatePackageDexMetadata(pkg2);
                    if (pkg2 != null) {
                        try {
                            if (mHwPMSEx.isInMultiWinWhiteList(pkg2.packageName)) {
                                pkg2.forceResizeableAllActivity();
                            }
                        } catch (PackageParser.PackageParserException e) {
                            e = e;
                            boolean z = forwardLocked2;
                            File file = tmpPackageFile3;
                            String str = volumeUuid3;
                            int i3 = parseFlags2;
                            PackageParser packageParser = pp;
                            String str2 = installerPackageName3;
                            boolean z2 = onExternal2;
                            j = 262144;
                            long j2 = installBeginTime3;
                            try {
                                packageInstalledInfo.setError("Failed parse during installPackageLI", e);
                                Trace.traceEnd(j);
                                return;
                            } catch (Throwable th3) {
                                pkg = th3;
                                Trace.traceEnd(j);
                                throw pkg;
                            }
                        } catch (Throwable th4) {
                            pkg = th4;
                            boolean z3 = forwardLocked2;
                            File file2 = tmpPackageFile3;
                            String str3 = volumeUuid3;
                            int i4 = parseFlags2;
                            PackageParser packageParser2 = pp;
                            String str4 = installerPackageName3;
                            boolean z4 = onExternal2;
                            j = 262144;
                            long j3 = installBeginTime3;
                            Trace.traceEnd(j);
                            throw pkg;
                        }
                    }
                    if (pkg2 != null && DISABLE_SPLIT_PKG.contains(pkg2.packageName)) {
                        pkg2.clearResizeableAllActivity();
                    }
                    Trace.traceEnd(262144);
                    PackageParser.Package pkg3 = pkg2;
                    PackageParser packageParser3 = pp;
                    if (instantApp) {
                        pkg = pkg3;
                        if (pkg.applicationInfo.targetSdkVersion < 26) {
                            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target at least O");
                            packageInstalledInfo.setError(-116, "Instant app package must target at least O");
                            return;
                        } else if (pkg.applicationInfo.targetSandboxVersion != 2) {
                            Slog.w(TAG, "Instant app package " + pkg.packageName + " does not target targetSandboxVersion 2");
                            packageInstalledInfo.setError(-116, "Instant app package must use targetSandboxVersion 2");
                            return;
                        } else if (pkg.mSharedUserId != null) {
                            Slog.w(TAG, "Instant app package " + pkg.packageName + " may not declare sharedUserId.");
                            packageInstalledInfo.setError(-116, "Instant app package may not declare a sharedUserId");
                            return;
                        }
                    } else {
                        pkg = pkg3;
                    }
                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                        renameStaticSharedLibraryPackage(pkg);
                        if (onExternal2) {
                            Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                            packageInstalledInfo.setError(-19, "Packages declaring static-shared libs cannot be updated");
                            return;
                        }
                    }
                    if (pkg.childPackages != null) {
                        synchronized (this.mPackages) {
                            try {
                                int childCount = pkg.childPackages.size();
                                int i5 = 0;
                                while (i5 < childCount) {
                                    int childCount2 = childCount;
                                    PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i5);
                                    long installBeginTime4 = installBeginTime3;
                                    try {
                                        PackageInstalledInfo childRes = new PackageInstalledInfo();
                                        childRes.setReturnCode(1);
                                        childRes.pkg = childPkg;
                                        childRes.name = childPkg.packageName;
                                        boolean replace9 = replace8;
                                        try {
                                            PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                                            if (childPs != null) {
                                                tmpPackageFile2 = tmpPackageFile3;
                                                childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                            } else {
                                                tmpPackageFile2 = tmpPackageFile3;
                                            }
                                            if (this.mPackages.containsKey(childPkg.packageName)) {
                                                childRes.removedInfo = new PackageRemovedInfo(this);
                                                childRes.removedInfo.removedPackage = childPkg.packageName;
                                                childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                                            }
                                            if (packageInstalledInfo.addedChildPackages == null) {
                                                packageInstalledInfo.addedChildPackages = new ArrayMap<>();
                                            }
                                            packageInstalledInfo.addedChildPackages.put(childPkg.packageName, childRes);
                                            i5++;
                                            childCount = childCount2;
                                            installBeginTime3 = installBeginTime4;
                                            replace8 = replace9;
                                            tmpPackageFile3 = tmpPackageFile2;
                                        } catch (Throwable th5) {
                                            th = th5;
                                            throw th;
                                        }
                                    } catch (Throwable th6) {
                                        th = th6;
                                        boolean z5 = replace8;
                                        File file3 = tmpPackageFile3;
                                        throw th;
                                    }
                                }
                                installBeginTime = installBeginTime3;
                                replace = replace8;
                                tmpPackageFile = tmpPackageFile3;
                            } catch (Throwable th7) {
                                th = th7;
                                long j4 = installBeginTime3;
                                File file4 = tmpPackageFile3;
                                throw th;
                            }
                        }
                    } else {
                        installBeginTime = installBeginTime3;
                        replace = false;
                        tmpPackageFile = tmpPackageFile3;
                    }
                    if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
                        pkg.cpuAbiOverride = installArgs.abiOverride;
                    }
                    String str5 = pkg.packageName;
                    packageInstalledInfo.name = str5;
                    String pkgName3 = str5;
                    if (!mHwPMSEx.isAppInstallAllowed(installerPackageName3, pkgName3)) {
                        String str6 = volumeUuid3;
                        int i6 = parseFlags2;
                        installerPackageName = installerPackageName3;
                        boolean z6 = onExternal2;
                        long j5 = installBeginTime;
                        File file5 = tmpPackageFile;
                    } else if (installArgs.origin != null && mHwPMSEx.isUnAppInstallAllowed(installArgs.origin.resolvedPath)) {
                        boolean z7 = forwardLocked2;
                        String str7 = volumeUuid3;
                        int i7 = parseFlags2;
                        installerPackageName = installerPackageName3;
                        boolean z8 = onExternal2;
                        long j6 = installBeginTime;
                        File file6 = tmpPackageFile;
                    } else if ((pkg.applicationInfo.flags & 256) == 0 || (installFlags5 & 4) != 0) {
                        try {
                            if (installArgs.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                                try {
                                    pkg.setSigningDetails(installArgs.signingDetails);
                                } catch (PackageParser.PackageParserException e2) {
                                    e = e2;
                                    boolean z9 = forwardLocked2;
                                    String str8 = volumeUuid3;
                                    int i8 = parseFlags2;
                                    String str9 = installerPackageName3;
                                    boolean z10 = onExternal2;
                                    long j7 = installBeginTime;
                                    File file7 = tmpPackageFile;
                                }
                            } else {
                                PackageParser.collectCertificates(pkg, false);
                            }
                            if (instantApp && pkg.mSigningDetails.signatureSchemeVersion < 2) {
                                Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
                                packageInstalledInfo.setError(-116, "Instant app package must be signed with APK Signature Scheme v2 or greater");
                                return;
                            } else if (mHwPMSEx.isInValidApkPatchPkg(pkg)) {
                                packageInstalledInfo.setError(-2, "PackageName is disallowd to be installed");
                                Slog.i(TAG, " this apk is invalid apk patch");
                                return;
                            } else if (mHwPMSEx.isDisallowedInstallApk(pkg)) {
                                packageInstalledInfo.setError(-111, "PackageName is disallowd to be installed");
                                Slog.i(TAG, installerPackageName3 + " is disallowed to be installed");
                                return;
                            } else {
                                try {
                                    if (mHwPMSEx.checkUninstalledSystemApp(pkg, installArgs, packageInstalledInfo)) {
                                        try {
                                            Slog.i(TAG, "restore the uninstalled app and upgrad it");
                                            installFlags = installFlags5 | 2;
                                        } catch (PackageManagerException e3) {
                                            boolean z11 = forwardLocked2;
                                            String str10 = volumeUuid3;
                                            int i9 = parseFlags2;
                                            String str11 = installerPackageName3;
                                            boolean z12 = onExternal2;
                                            long j8 = installBeginTime;
                                            File file8 = tmpPackageFile;
                                            Slog.i(TAG, "downgrade package from preset system app, just restore the uninstalled system app");
                                            return;
                                        }
                                    } else {
                                        installFlags = installFlags5;
                                    }
                                    synchronized (this.mPackages) {
                                        if ((installFlags & 2) != 0) {
                                            try {
                                                oldName = this.mSettings.getRenamedPackageLPr(pkgName3);
                                                if (pkg.mOriginalPackages != null) {
                                                    try {
                                                        if (pkg.mOriginalPackages.contains(oldName) && this.mPackages.containsKey(oldName)) {
                                                            pkg.setPackageName(oldName);
                                                            pkgName3 = pkg.packageName;
                                                            try {
                                                                if (DEBUG_INSTALL) {
                                                                    oldCodePath = null;
                                                                    systemApp = false;
                                                                    try {
                                                                        StringBuilder sb = new StringBuilder();
                                                                        replace7 = true;
                                                                        try {
                                                                            sb.append("Replacing existing renamed package: oldName=");
                                                                            sb.append(oldName);
                                                                            sb.append(" pkgName=");
                                                                            sb.append(pkgName3);
                                                                            Slog.d(TAG, sb.toString());
                                                                        } catch (Throwable th8) {
                                                                            oldPackage = th8;
                                                                            boolean z13 = forwardLocked2;
                                                                            int i10 = installFlags;
                                                                            String str12 = volumeUuid3;
                                                                            int i11 = parseFlags2;
                                                                            String str13 = installerPackageName3;
                                                                            boolean z14 = onExternal2;
                                                                            long j9 = installBeginTime;
                                                                            File file9 = tmpPackageFile;
                                                                        }
                                                                    } catch (Throwable th9) {
                                                                        oldPackage = th9;
                                                                        boolean z15 = forwardLocked2;
                                                                        int i12 = installFlags;
                                                                        String str14 = volumeUuid3;
                                                                        int i13 = parseFlags2;
                                                                        String str15 = installerPackageName3;
                                                                        boolean z16 = onExternal2;
                                                                        long j10 = installBeginTime;
                                                                        File file10 = tmpPackageFile;
                                                                        while (true) {
                                                                            try {
                                                                                break;
                                                                            } catch (Throwable th10) {
                                                                                oldPackage = th10;
                                                                            }
                                                                        }
                                                                        throw oldPackage;
                                                                    }
                                                                } else {
                                                                    oldCodePath = null;
                                                                    systemApp = false;
                                                                    replace7 = true;
                                                                }
                                                                String str16 = oldName;
                                                                replace5 = replace7;
                                                                try {
                                                                    if (pkg.parentPackage == null) {
                                                                        packageInstalledInfo.setError(-106, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                                        return;
                                                                    }
                                                                    if (replace5) {
                                                                        PackageParser.Package oldPackage = this.mPackages.get(pkgName3);
                                                                        int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                                                                        int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                                                                        replace6 = replace5;
                                                                        if (oldTargetSdk <= 22 || newTargetSdk > 22) {
                                                                            volumeUuid = volumeUuid3;
                                                                            try {
                                                                                if ((oldPackage.applicationInfo.flags & 8) != 0) {
                                                                                    if (!mHwPMSEx.isPersistentUpdatable(pkg)) {
                                                                                        packageInstalledInfo.setError(-2, "Package " + oldPackage.packageName + " is a persistent app. Persistent apps are not updateable.");
                                                                                        return;
                                                                                    }
                                                                                }
                                                                                if (oldPackage.parentPackage != null) {
                                                                                    packageInstalledInfo.setError(-106, "Package " + pkg.packageName + " is child of package " + oldPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                                                    return;
                                                                                } else if (!isSystemApp(oldPackage) || pkgName3 == null || "com.android.vending".equals(pkgName3) || pkgName3.equals(this.mRequiredVerifierPackage) || pkgName3.equals(this.mRequiredInstallerPackage) || pkgName3.equals(this.mRequiredUninstallerPackage)) {
                                                                                    pkgName2 = pkgName3;
                                                                                } else {
                                                                                    Iterator it = pkg.activities.iterator();
                                                                                    while (it.hasNext()) {
                                                                                        PackageParser.Package oldPackage2 = oldPackage;
                                                                                        PackageParser.Package oldPackage3 = ((PackageParser.Activity) it.next()).intents.iterator();
                                                                                        while (oldPackage3.hasNext()) {
                                                                                            PackageParser.Package packageR = oldPackage3;
                                                                                            String pkgName4 = pkgName3;
                                                                                            PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) oldPackage3.next();
                                                                                            try {
                                                                                                boolean hasInstallAction = filter.matchAction("android.intent.action.INSTALL_PACKAGE");
                                                                                                int oldTargetSdk2 = oldTargetSdk;
                                                                                                boolean hasDefaultCategory = filter.hasCategory("android.intent.category.DEFAULT");
                                                                                                Iterator it2 = it;
                                                                                                boolean hasPackageMimeType = filter.hasDataType(PACKAGE_MIME_TYPE);
                                                                                                if (!hasInstallAction || !hasDefaultCategory || !hasPackageMimeType) {
                                                                                                    boolean z17 = hasPackageMimeType;
                                                                                                    boolean hasUninstallAction = filter.matchAction("android.intent.action.UNINSTALL_PACKAGE");
                                                                                                    boolean hasPackageScheme = filter.hasDataScheme("package");
                                                                                                    if (!hasUninstallAction || !hasDefaultCategory || !hasPackageScheme) {
                                                                                                        oldPackage3 = packageR;
                                                                                                        pkgName3 = pkgName4;
                                                                                                        oldTargetSdk = oldTargetSdk2;
                                                                                                        it = it2;
                                                                                                    } else {
                                                                                                        boolean z18 = hasUninstallAction;
                                                                                                        PackageParser.ActivityIntentInfo activityIntentInfo = filter;
                                                                                                        packageInstalledInfo.setError(-112, "Detect dangerous App, may cause system problem!");
                                                                                                        packageInstalledInfo.origPackage = this.mRequiredUninstallerPackage;
                                                                                                        return;
                                                                                                    }
                                                                                                } else {
                                                                                                    boolean z19 = hasInstallAction;
                                                                                                    boolean z20 = hasPackageMimeType;
                                                                                                    packageInstalledInfo.setError(-112, "Detect dangerous App, may cause system problem!");
                                                                                                    packageInstalledInfo.origPackage = this.mRequiredInstallerPackage;
                                                                                                    return;
                                                                                                }
                                                                                            } catch (Throwable th11) {
                                                                                                oldPackage = th11;
                                                                                                boolean z21 = forwardLocked2;
                                                                                                int i14 = installFlags;
                                                                                                int i15 = parseFlags2;
                                                                                                String str17 = installerPackageName3;
                                                                                                boolean z22 = onExternal2;
                                                                                                long j11 = installBeginTime;
                                                                                                File file11 = tmpPackageFile;
                                                                                                String str18 = oldCodePath;
                                                                                                boolean z23 = replace6;
                                                                                                String str19 = volumeUuid;
                                                                                                String str20 = pkgName4;
                                                                                                while (true) {
                                                                                                    break;
                                                                                                }
                                                                                                throw oldPackage;
                                                                                            }
                                                                                        }
                                                                                        int i16 = oldTargetSdk;
                                                                                        Iterator it3 = it;
                                                                                        oldPackage = oldPackage2;
                                                                                    }
                                                                                    pkgName2 = pkgName3;
                                                                                    int i17 = oldTargetSdk;
                                                                                    Iterator it4 = pkg.receivers.iterator();
                                                                                    while (it4.hasNext()) {
                                                                                        PackageParser.Activity a = (PackageParser.Activity) it4.next();
                                                                                        Iterator it5 = a.intents.iterator();
                                                                                        while (it5.hasNext()) {
                                                                                            PackageParser.ActivityIntentInfo filter2 = (PackageParser.ActivityIntentInfo) it5.next();
                                                                                            boolean hasVerifierAction = filter2.matchAction("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                                                                                            Iterator it6 = it4;
                                                                                            boolean hasPackageMimeType2 = filter2.hasDataType(PACKAGE_MIME_TYPE);
                                                                                            if (!hasVerifierAction || !hasPackageMimeType2) {
                                                                                                it4 = it6;
                                                                                                a = a;
                                                                                            } else {
                                                                                                PackageParser.Activity activity = a;
                                                                                                packageInstalledInfo.setError(-112, "Detect dangerous App, may cause system problem!");
                                                                                                packageInstalledInfo.origPackage = this.mRequiredVerifierPackage;
                                                                                                return;
                                                                                            }
                                                                                        }
                                                                                        Iterator it7 = it4;
                                                                                    }
                                                                                }
                                                                            } catch (Throwable th12) {
                                                                                oldPackage = th12;
                                                                                String str21 = pkgName3;
                                                                                boolean z24 = forwardLocked2;
                                                                                int i18 = installFlags;
                                                                                int i19 = parseFlags2;
                                                                                String str22 = installerPackageName3;
                                                                                boolean z25 = onExternal2;
                                                                                long j12 = installBeginTime;
                                                                                File file12 = tmpPackageFile;
                                                                                String str23 = oldCodePath;
                                                                                boolean z26 = replace6;
                                                                                String str24 = volumeUuid;
                                                                                while (true) {
                                                                                    break;
                                                                                }
                                                                                throw oldPackage;
                                                                            }
                                                                        } else {
                                                                            try {
                                                                                StringBuilder sb2 = new StringBuilder();
                                                                                volumeUuid = volumeUuid3;
                                                                                try {
                                                                                    sb2.append("Package ");
                                                                                    sb2.append(pkg.packageName);
                                                                                    sb2.append(" new target SDK ");
                                                                                    sb2.append(newTargetSdk);
                                                                                    sb2.append(" doesn't support runtime permissions but the old target SDK ");
                                                                                    sb2.append(oldTargetSdk);
                                                                                    sb2.append(" does.");
                                                                                    packageInstalledInfo.setError(-26, sb2.toString());
                                                                                    return;
                                                                                } catch (Throwable th13) {
                                                                                    oldPackage = th13;
                                                                                    boolean z27 = forwardLocked2;
                                                                                    int i20 = installFlags;
                                                                                    int i21 = parseFlags2;
                                                                                    String str25 = installerPackageName3;
                                                                                    boolean z28 = onExternal2;
                                                                                    long j13 = installBeginTime;
                                                                                    File file13 = tmpPackageFile;
                                                                                    String str26 = oldCodePath;
                                                                                    boolean z29 = replace6;
                                                                                    while (true) {
                                                                                        break;
                                                                                    }
                                                                                    throw oldPackage;
                                                                                }
                                                                            } catch (Throwable th14) {
                                                                                oldPackage = th14;
                                                                                boolean z30 = forwardLocked2;
                                                                                int i22 = installFlags;
                                                                                String str27 = volumeUuid3;
                                                                                int i23 = parseFlags2;
                                                                                String str28 = installerPackageName3;
                                                                                boolean z31 = onExternal2;
                                                                                long j14 = installBeginTime;
                                                                                File file14 = tmpPackageFile;
                                                                                String str29 = oldCodePath;
                                                                                boolean z32 = replace6;
                                                                                while (true) {
                                                                                    break;
                                                                                }
                                                                                throw oldPackage;
                                                                            }
                                                                        }
                                                                    } else {
                                                                        pkgName2 = pkgName3;
                                                                        replace6 = replace5;
                                                                        volumeUuid = volumeUuid3;
                                                                    }
                                                                    replace2 = replace6;
                                                                    volumeUuid2 = pkgName2;
                                                                } catch (Throwable th15) {
                                                                    oldPackage = th15;
                                                                    String str30 = pkgName3;
                                                                    boolean z33 = replace5;
                                                                    boolean z34 = forwardLocked2;
                                                                    int i24 = installFlags;
                                                                    String str31 = volumeUuid3;
                                                                    int i25 = parseFlags2;
                                                                    String str32 = installerPackageName3;
                                                                    boolean z35 = onExternal2;
                                                                    long j15 = installBeginTime;
                                                                    File file15 = tmpPackageFile;
                                                                    String str33 = oldCodePath;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw oldPackage;
                                                                }
                                                            } catch (Throwable th16) {
                                                                oldPackage = th16;
                                                                boolean z36 = forwardLocked2;
                                                                int i26 = installFlags;
                                                                String str34 = volumeUuid3;
                                                                int i27 = parseFlags2;
                                                                String str35 = installerPackageName3;
                                                                boolean z37 = onExternal2;
                                                                long j16 = installBeginTime;
                                                                File file16 = tmpPackageFile;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw oldPackage;
                                                            }
                                                        }
                                                    } catch (Throwable th17) {
                                                        oldPackage = th17;
                                                        boolean z38 = forwardLocked2;
                                                        int i28 = installFlags;
                                                        String str36 = volumeUuid3;
                                                        int i29 = parseFlags2;
                                                        String str37 = installerPackageName3;
                                                        boolean z39 = onExternal2;
                                                        long j17 = installBeginTime;
                                                        boolean systemApp2 = replace;
                                                        File file17 = tmpPackageFile;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw oldPackage;
                                                    }
                                                }
                                                oldCodePath = null;
                                                systemApp = false;
                                            } catch (Throwable th18) {
                                                oldPackage = th18;
                                                boolean z40 = forwardLocked2;
                                                int i30 = installFlags;
                                                String str38 = volumeUuid3;
                                                int i31 = parseFlags2;
                                                String str39 = installerPackageName3;
                                                boolean z41 = onExternal2;
                                                long j18 = installBeginTime;
                                                boolean systemApp3 = replace;
                                                File file18 = tmpPackageFile;
                                                while (true) {
                                                    break;
                                                }
                                                throw oldPackage;
                                            }
                                            try {
                                                if (this.mPackages.containsKey(pkgName3)) {
                                                    replace5 = true;
                                                    try {
                                                        if (DEBUG_INSTALL) {
                                                            StringBuilder sb3 = new StringBuilder();
                                                            String str40 = oldName;
                                                            sb3.append("Replace existing pacakge: ");
                                                            sb3.append(pkgName3);
                                                            Slog.d(TAG, sb3.toString());
                                                        }
                                                    } catch (Throwable th19) {
                                                        oldPackage = th19;
                                                        boolean z42 = forwardLocked2;
                                                        int i32 = installFlags;
                                                        String str41 = volumeUuid3;
                                                        int i33 = parseFlags2;
                                                        String str42 = installerPackageName3;
                                                        boolean z43 = onExternal2;
                                                        long j19 = installBeginTime;
                                                        File file19 = tmpPackageFile;
                                                        String str43 = oldCodePath;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw oldPackage;
                                                    }
                                                } else {
                                                    String str44 = oldName;
                                                    replace5 = replace;
                                                }
                                                if (pkg.parentPackage == null) {
                                                }
                                            } catch (Throwable th20) {
                                                oldPackage = th20;
                                                boolean z44 = forwardLocked2;
                                                int i34 = installFlags;
                                                String str45 = volumeUuid3;
                                                int i35 = parseFlags2;
                                                String str46 = installerPackageName3;
                                                boolean z45 = onExternal2;
                                                long j20 = installBeginTime;
                                                boolean z46 = replace;
                                                File file20 = tmpPackageFile;
                                                while (true) {
                                                    break;
                                                }
                                                throw oldPackage;
                                            }
                                        } else {
                                            oldCodePath = null;
                                            systemApp = false;
                                            volumeUuid = volumeUuid3;
                                            volumeUuid2 = pkgName3;
                                            replace2 = replace;
                                        }
                                        try {
                                            ps = this.mSettings.mPackages.get(volumeUuid2);
                                            mHwPMSEx.checkHwCertification(pkg, true);
                                            mHwPMSEx.replaceSignatureIfNeeded(ps, pkg, false, true);
                                            if (ps != null) {
                                                try {
                                                    if (DEBUG_INSTALL) {
                                                        try {
                                                            Slog.d(TAG, "Existing package: " + ps);
                                                        } catch (Throwable th21) {
                                                            oldPackage = th21;
                                                            boolean z47 = replace2;
                                                            boolean z48 = forwardLocked2;
                                                            int i36 = installFlags;
                                                            String str47 = volumeUuid2;
                                                            int i37 = parseFlags2;
                                                        }
                                                    }
                                                    PackageSetting signatureCheckPs2 = ps;
                                                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                                        SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);
                                                        if (libraryEntry != null) {
                                                            PackageSetting packageSetting = signatureCheckPs2;
                                                            signatureCheckPs = this.mSettings.getPackageLPr(libraryEntry.apk);
                                                            ksms = this.mSettings.mKeySetManagerService;
                                                            if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags3)) {
                                                                try {
                                                                    if (!ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                                                                        StringBuilder sb4 = new StringBuilder();
                                                                        int i38 = parseFlags2;
                                                                        try {
                                                                            sb4.append("Package ");
                                                                            sb4.append(pkg.packageName);
                                                                            sb4.append(" upgrade keys do not match the previously installed version");
                                                                            packageInstalledInfo.setError(-7, sb4.toString());
                                                                            return;
                                                                        } catch (Throwable th22) {
                                                                            oldPackage = th22;
                                                                            boolean z49 = replace2;
                                                                            boolean z50 = forwardLocked2;
                                                                            int i39 = installFlags;
                                                                            String str48 = volumeUuid2;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw oldPackage;
                                                                        }
                                                                    } else {
                                                                        parseFlags = parseFlags2;
                                                                        PackageSetting packageSetting2 = signatureCheckPs;
                                                                        replace3 = replace2;
                                                                        installFlags2 = installFlags;
                                                                    }
                                                                } catch (Throwable th23) {
                                                                    oldPackage = th23;
                                                                    int i40 = parseFlags2;
                                                                    boolean z51 = replace2;
                                                                    boolean z52 = forwardLocked2;
                                                                    int i41 = installFlags;
                                                                    String str49 = volumeUuid2;
                                                                    String str50 = installerPackageName3;
                                                                    boolean z53 = onExternal2;
                                                                    long j21 = installBeginTime;
                                                                    File file21 = tmpPackageFile;
                                                                    String str51 = oldCodePath;
                                                                    String str52 = volumeUuid;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw oldPackage;
                                                                }
                                                            } else {
                                                                parseFlags = parseFlags2;
                                                                try {
                                                                    replace3 = replace2;
                                                                    installFlags2 = installFlags;
                                                                    try {
                                                                        if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(pkg), isRecoverSignatureUpdateNeeded(pkg))) {
                                                                            PackageSetting packageSetting3 = signatureCheckPs;
                                                                            try {
                                                                                synchronized (this.mPackages) {
                                                                                    ksms.removeAppKeySetDataLPw(pkg.packageName);
                                                                                }
                                                                            } catch (PackageManagerException e4) {
                                                                                e = e4;
                                                                            }
                                                                        }
                                                                    } catch (PackageManagerException e5) {
                                                                        e = e5;
                                                                        PackageSetting packageSetting4 = signatureCheckPs;
                                                                        try {
                                                                            if (ps.sharedUser == null || !mHwPMSEx.isSystemSignatureUpdated(ps.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures)) {
                                                                                packageInstalledInfo.setError(e.error, e.getMessage());
                                                                                return;
                                                                            }
                                                                            Slog.i(TAG, "CertCompat: " + pkg.packageName + " system signature updated. Update signatures.");
                                                                            ps.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                            if (SystemProperties.get("ro.config.hw_optb", "0").equals("156")) {
                                                                            }
                                                                            String oldCodePath3 = this.mSettings.mPackages.get(volumeUuid2).codePathString;
                                                                            systemApp = (ps.pkg.applicationInfo.flags & 1) != 0;
                                                                            packageInstalledInfo.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                                            oldCodePath2 = oldCodePath3;
                                                                            int N2 = pkg.permissions.size();
                                                                            i = N2 - 1;
                                                                            while (i >= 0) {
                                                                            }
                                                                            String installerPackageName4 = installerPackageName3;
                                                                            try {
                                                                                if (systemApp) {
                                                                                    if (onExternal2) {
                                                                                        packageInstalledInfo.setError(-19, "Cannot install updates to system apps on sdcard");
                                                                                        return;
                                                                                    } else if (instantApp) {
                                                                                        packageInstalledInfo.setError(-116, "Cannot update a system app with an instant app");
                                                                                        return;
                                                                                    }
                                                                                }
                                                                                InstallerMgr.getInstance().installPackage(0, installArgs.installerPackageName, volumeUuid2);
                                                                                if (installArgs.move != null) {
                                                                                    scanFlags2 = scanFlags3 | 1 | 256;
                                                                                    synchronized (this.mPackages) {
                                                                                        PackageSetting ps3 = this.mSettings.mPackages.get(volumeUuid2);
                                                                                        if (ps3 == null) {
                                                                                            packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Missing settings for moved package " + volumeUuid2);
                                                                                        }
                                                                                        pkg.applicationInfo.primaryCpuAbi = ps3.primaryCpuAbiString;
                                                                                        pkg.applicationInfo.secondaryCpuAbi = ps3.secondaryCpuAbiString;
                                                                                        Slog.d(TAG, "installPackageLI-> install move case, pkg=" + pkg + ", primaryCpuAbi=" + pkg.applicationInfo.primaryCpuAbi);
                                                                                    }
                                                                                } else if (forwardLocked2 || pkg.applicationInfo.isExternalAsec()) {
                                                                                    scanFlags = scanFlags3;
                                                                                    if (this.mCustPms != null && this.mCustPms.needDerivePkgAbi(pkg)) {
                                                                                        derivePackageAbi(pkg, installArgs.abiOverride, true);
                                                                                    }
                                                                                    if (installArgs.doRename(packageInstalledInfo.returnCode, pkg, oldCodePath2)) {
                                                                                        packageInstalledInfo.setError(-4, "Failed rename");
                                                                                        return;
                                                                                    }
                                                                                    if (PackageManagerServiceUtils.isApkVerityEnabled()) {
                                                                                        String apkPath = null;
                                                                                        synchronized (this.mPackages) {
                                                                                            PackageSetting ps4 = this.mSettings.mPackages.get(volumeUuid2);
                                                                                            if (ps4 != null && ps4.isPrivileged()) {
                                                                                                apkPath = pkg.baseCodePath;
                                                                                            }
                                                                                        }
                                                                                        if (apkPath != null) {
                                                                                            VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(apkPath);
                                                                                            if (result.isOk()) {
                                                                                                if (Build.IS_DEBUGGABLE) {
                                                                                                    Slog.i(TAG, "Enabling apk verity to " + apkPath);
                                                                                                }
                                                                                                FileDescriptor fd = result.getUnownedFileDescriptor();
                                                                                                try {
                                                                                                    byte[] signedRootHash = VerityUtils.generateFsverityRootHash(apkPath);
                                                                                                    this.mInstaller.installApkVerity(apkPath, fd, result.getContentSize());
                                                                                                    this.mInstaller.assertFsverityRootHashMatches(apkPath, signedRootHash);
                                                                                                } catch (Installer.InstallerException | IOException | DigestException | NoSuchAlgorithmException e6) {
                                                                                                    packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Failed to set up verity: " + e6);
                                                                                                    return;
                                                                                                } finally {
                                                                                                    IoUtils.closeQuietly(fd);
                                                                                                }
                                                                                            } else if (result.isFailed()) {
                                                                                                packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Failed to generate verity");
                                                                                                return;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    if (!instantApp) {
                                                                                        replace4 = replace3;
                                                                                        startIntentFilterVerifications(installArgs.user.getIdentifier(), replace4, pkg);
                                                                                    } else {
                                                                                        replace4 = replace3;
                                                                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                                                                            Slog.d(TAG, "Not verifying instant app install for app links: " + volumeUuid2);
                                                                                        }
                                                                                    }
                                                                                    int installFlags6 = installFlags2;
                                                                                    PackageFreezer freezer2 = freezePackageForInstall(volumeUuid2, installFlags6, "installPackageLI");
                                                                                    if (replace4) {
                                                                                        try {
                                                                                            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                                                                                try {
                                                                                                    PackageParser.Package existingPkg = this.mPackages.get(pkg.packageName);
                                                                                                    if (existingPkg != null) {
                                                                                                        if ("com.huawei.androidx".equals(pkg.manifestPackageName)) {
                                                                                                        }
                                                                                                        if (existingPkg.getLongVersionCode() != pkg.getLongVersionCode()) {
                                                                                                            packageInstalledInfo.setError(-5, "Packages declaring static-shared libs cannot be updated");
                                                                                                            if (freezer2 != null) {
                                                                                                                $closeResource(null, freezer2);
                                                                                                            }
                                                                                                            return;
                                                                                                        }
                                                                                                    }
                                                                                                } catch (Throwable th24) {
                                                                                                    existingPkg = th24;
                                                                                                    th = null;
                                                                                                    boolean z54 = replace4;
                                                                                                    boolean z55 = forwardLocked2;
                                                                                                    int i42 = installFlags6;
                                                                                                    String str53 = oldCodePath2;
                                                                                                    int i43 = scanFlags;
                                                                                                    boolean z56 = onExternal2;
                                                                                                    long j22 = installBeginTime;
                                                                                                    File file22 = tmpPackageFile;
                                                                                                    String str54 = volumeUuid;
                                                                                                    freezer = freezer2;
                                                                                                    String pkgName5 = volumeUuid2;
                                                                                                    if (freezer != null) {
                                                                                                    }
                                                                                                    throw existingPkg;
                                                                                                }
                                                                                            }
                                                                                            installBeginTime2 = installBeginTime;
                                                                                            String str55 = oldCodePath2;
                                                                                            freezer = freezer2;
                                                                                            boolean z57 = replace4;
                                                                                            boolean z58 = onExternal2;
                                                                                            forwardLocked = forwardLocked2;
                                                                                            installFlags3 = installFlags6;
                                                                                            File file23 = tmpPackageFile;
                                                                                            try {
                                                                                                replacePackageLIF(pkg, parseFlags, scanFlags, installArgs.user, installerPackageName4, packageInstalledInfo, installArgs.installReason);
                                                                                                int i44 = scanFlags;
                                                                                                String str56 = volumeUuid;
                                                                                                pkgName = volumeUuid2;
                                                                                            } catch (Throwable th25) {
                                                                                                existingPkg = th25;
                                                                                                int i45 = scanFlags;
                                                                                                String str57 = volumeUuid;
                                                                                                long j23 = installBeginTime2;
                                                                                                int i46 = installFlags3;
                                                                                                th = null;
                                                                                                String pkgName52 = volumeUuid2;
                                                                                                if (freezer != null) {
                                                                                                }
                                                                                                throw existingPkg;
                                                                                            }
                                                                                        } catch (Throwable th26) {
                                                                                            existingPkg = th26;
                                                                                            boolean z59 = replace4;
                                                                                            boolean z60 = forwardLocked2;
                                                                                            String str58 = oldCodePath2;
                                                                                            boolean z61 = onExternal2;
                                                                                            File file24 = tmpPackageFile;
                                                                                            freezer = freezer2;
                                                                                            int i47 = installFlags6;
                                                                                            int i48 = scanFlags;
                                                                                            long j24 = installBeginTime;
                                                                                            String str59 = volumeUuid;
                                                                                            th = null;
                                                                                            String str60 = volumeUuid2;
                                                                                            if (freezer != null) {
                                                                                            }
                                                                                            throw existingPkg;
                                                                                        }
                                                                                    } else {
                                                                                        forwardLocked = forwardLocked2;
                                                                                        installFlags3 = installFlags6;
                                                                                        String str61 = oldCodePath2;
                                                                                        boolean z62 = onExternal2;
                                                                                        installBeginTime2 = installBeginTime;
                                                                                        File file25 = tmpPackageFile;
                                                                                        freezer = freezer2;
                                                                                        int i49 = scanFlags | 64;
                                                                                        try {
                                                                                            int i50 = scanFlags;
                                                                                            String str62 = volumeUuid;
                                                                                            pkgName = volumeUuid2;
                                                                                            try {
                                                                                                installNewPackageLIF(pkg, parseFlags, i49, installArgs.user, installerPackageName4, volumeUuid, packageInstalledInfo, installArgs.installReason);
                                                                                            } catch (Throwable th27) {
                                                                                                existingPkg = th27;
                                                                                                long j25 = installBeginTime2;
                                                                                                int i51 = installFlags3;
                                                                                                th = null;
                                                                                                if (freezer != null) {
                                                                                                }
                                                                                                throw existingPkg;
                                                                                            }
                                                                                        } catch (Throwable th28) {
                                                                                            existingPkg = th28;
                                                                                            int i52 = scanFlags;
                                                                                            String str63 = volumeUuid;
                                                                                            long j26 = installBeginTime2;
                                                                                            int i53 = installFlags3;
                                                                                            String str64 = volumeUuid2;
                                                                                            th = null;
                                                                                            if (freezer != null) {
                                                                                            }
                                                                                            throw existingPkg;
                                                                                        }
                                                                                    }
                                                                                    if (freezer != null) {
                                                                                        $closeResource(null, freezer);
                                                                                    }
                                                                                    HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(1, pkg.applicationInfo.uid, 0, pkg.packageName, installArgs.installerPackageName);
                                                                                    this.mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(installArgs.user.getIdentifier()));
                                                                                    if (packageInstalledInfo.returnCode == 1 && !forwardLocked && !pkg.applicationInfo.isExternalAsec() && (!instantApp || Settings.Global.getInt(this.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) != 0) && (pkg.applicationInfo.flags & 2) == 0) {
                                                                                        Trace.traceBegin(262144, "dexopt");
                                                                                        this.mPackageDexOptimizer.performDexOpt(pkg, pkg.usesLibraryFiles, null, getOrCreateCompilerPackageStats(pkg), this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName), new DexoptOptions(pkg.packageName, 2, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS));
                                                                                        Trace.traceEnd(262144);
                                                                                    }
                                                                                    BackgroundDexOptService.notifyPackageChanged(pkg.packageName);
                                                                                    synchronized (this.mPackages) {
                                                                                        PackageSetting ps5 = this.mSettings.mPackages.get(pkgName);
                                                                                        if (ps5 != null) {
                                                                                            try {
                                                                                                packageInstalledInfo.newUsers = ps5.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                                                                ps5.setUpdateAvailable(false);
                                                                                            } catch (Throwable th29) {
                                                                                                th = th29;
                                                                                                long j27 = installBeginTime2;
                                                                                                int i54 = installFlags3;
                                                                                            }
                                                                                        }
                                                                                        try {
                                                                                            if (packageInstalledInfo.returnCode == 1) {
                                                                                                i2 = 0;
                                                                                                mHwPMSEx.writeCertCompatPackages(false);
                                                                                            } else {
                                                                                                i2 = 0;
                                                                                            }
                                                                                            int childCount3 = pkg.childPackages != null ? pkg.childPackages.size() : i2;
                                                                                            while (i2 < childCount3) {
                                                                                                PackageParser.Package childPkg2 = (PackageParser.Package) pkg.childPackages.get(i2);
                                                                                                PackageInstalledInfo childRes2 = packageInstalledInfo.addedChildPackages.get(childPkg2.packageName);
                                                                                                PackageSetting childPs2 = this.mSettings.getPackageLPr(childPkg2.packageName);
                                                                                                if (childPs2 != null) {
                                                                                                    childRes2.newUsers = childPs2.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                                                                }
                                                                                                i2++;
                                                                                            }
                                                                                            if (packageInstalledInfo.returnCode == 1) {
                                                                                                updateSequenceNumberLP(ps5, packageInstalledInfo.newUsers);
                                                                                                updateInstantAppInstallerLocked(pkgName);
                                                                                            }
                                                                                        } catch (Throwable th30) {
                                                                                            th = th30;
                                                                                            long j28 = installBeginTime2;
                                                                                            int i55 = installFlags3;
                                                                                            while (true) {
                                                                                                try {
                                                                                                    break;
                                                                                                } catch (Throwable th31) {
                                                                                                    th = th31;
                                                                                                }
                                                                                            }
                                                                                            throw th;
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    scanFlags2 = scanFlags3 | 1;
                                                                                    try {
                                                                                        derivePackageAbi(pkg, TextUtils.isEmpty(pkg.cpuAbiOverride) ? installArgs.abiOverride : pkg.cpuAbiOverride, !pkg.isLibrary());
                                                                                        Slog.d(TAG, "installPackageLI-> install derivePackageAbi case, pkg=" + pkg + ", primaryCpuAbi=" + pkg.applicationInfo.primaryCpuAbi);
                                                                                        synchronized (this.mPackages) {
                                                                                            try {
                                                                                                updateSharedLibrariesLPr(pkg, null);
                                                                                            } catch (PackageManagerException e7) {
                                                                                                PackageManagerException packageManagerException = e7;
                                                                                                Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e7.getMessage());
                                                                                            }
                                                                                        }
                                                                                    } catch (PackageManagerException pme) {
                                                                                        Slog.e(TAG, "Error deriving application ABI", pme);
                                                                                        packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
                                                                                        return;
                                                                                    }
                                                                                }
                                                                                scanFlags = scanFlags2;
                                                                                try {
                                                                                    derivePackageAbi(pkg, installArgs.abiOverride, true);
                                                                                    if (installArgs.doRename(packageInstalledInfo.returnCode, pkg, oldCodePath2)) {
                                                                                    }
                                                                                } catch (PackageManagerException pme2) {
                                                                                    Slog.e(TAG, "Error deriving application ABI install app to sdcard", pme2);
                                                                                    packageInstalledInfo.setError((int) RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
                                                                                    return;
                                                                                }
                                                                            } catch (Throwable th32) {
                                                                                oldPackage = th32;
                                                                                boolean z63 = forwardLocked2;
                                                                                boolean z64 = onExternal2;
                                                                                long j29 = installBeginTime;
                                                                                File file26 = tmpPackageFile;
                                                                                String str65 = volumeUuid;
                                                                                int i56 = installFlags2;
                                                                                String str66 = volumeUuid2;
                                                                                boolean z65 = replace3;
                                                                                String str67 = oldCodePath2;
                                                                                while (true) {
                                                                                    break;
                                                                                }
                                                                                throw oldPackage;
                                                                            }
                                                                        } catch (PackageManagerException e8) {
                                                                            packageInstalledInfo.setError(e8.error, e8.getMessage());
                                                                            return;
                                                                        } catch (Throwable th33) {
                                                                            oldPackage = th33;
                                                                            boolean z66 = forwardLocked2;
                                                                            String str68 = volumeUuid2;
                                                                            String str69 = installerPackageName3;
                                                                            boolean z67 = onExternal2;
                                                                            long j30 = installBeginTime;
                                                                            File file27 = tmpPackageFile;
                                                                            String str70 = oldCodePath;
                                                                            while (true) {
                                                                                break;
                                                                            }
                                                                            throw oldPackage;
                                                                        }
                                                                    }
                                                                } catch (PackageManagerException e9) {
                                                                    e = e9;
                                                                    PackageSetting packageSetting5 = signatureCheckPs;
                                                                    replace3 = replace2;
                                                                    installFlags2 = installFlags;
                                                                    if (ps.sharedUser == null) {
                                                                    }
                                                                    packageInstalledInfo.setError(e.error, e.getMessage());
                                                                    return;
                                                                } catch (Throwable th34) {
                                                                    oldPackage = th34;
                                                                    boolean z68 = replace2;
                                                                    boolean z69 = forwardLocked2;
                                                                    int i57 = installFlags;
                                                                    String str71 = volumeUuid2;
                                                                    String str72 = installerPackageName3;
                                                                    boolean z70 = onExternal2;
                                                                    long j31 = installBeginTime;
                                                                    File file28 = tmpPackageFile;
                                                                    String str73 = oldCodePath;
                                                                    String str74 = volumeUuid;
                                                                    boolean z71 = z68;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw oldPackage;
                                                                }
                                                            }
                                                            if (SystemProperties.get("ro.config.hw_optb", "0").equals("156")) {
                                                                verifyValidVerifierInstall(installerPackageName3, volumeUuid2, installArgs.user.getIdentifier(), Binder.getCallingUid());
                                                            }
                                                            String oldCodePath32 = this.mSettings.mPackages.get(volumeUuid2).codePathString;
                                                            if (!(ps.pkg == null || ps.pkg.applicationInfo == null)) {
                                                                systemApp = (ps.pkg.applicationInfo.flags & 1) != 0;
                                                            }
                                                            packageInstalledInfo.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                            oldCodePath2 = oldCodePath32;
                                                        }
                                                    }
                                                    signatureCheckPs = signatureCheckPs2;
                                                    ksms = this.mSettings.mKeySetManagerService;
                                                    if (!ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags3)) {
                                                    }
                                                    if (SystemProperties.get("ro.config.hw_optb", "0").equals("156")) {
                                                    }
                                                    String oldCodePath322 = this.mSettings.mPackages.get(volumeUuid2).codePathString;
                                                } catch (Throwable th35) {
                                                    oldPackage = th35;
                                                    boolean z72 = replace2;
                                                    int i58 = parseFlags2;
                                                    boolean z73 = forwardLocked2;
                                                    int i59 = installFlags;
                                                    String str75 = volumeUuid2;
                                                    String str76 = installerPackageName3;
                                                    boolean z74 = onExternal2;
                                                    long j32 = installBeginTime;
                                                    File file29 = tmpPackageFile;
                                                    String str77 = oldCodePath;
                                                    String str78 = volumeUuid;
                                                    boolean z75 = z72;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw oldPackage;
                                                }
                                                try {
                                                    systemApp = (ps.pkg.applicationInfo.flags & 1) != 0;
                                                    packageInstalledInfo.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                    oldCodePath2 = oldCodePath322;
                                                } catch (Throwable th36) {
                                                    oldPackage = th36;
                                                    boolean z76 = forwardLocked2;
                                                    String str79 = volumeUuid2;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw oldPackage;
                                                }
                                            } else {
                                                replace3 = replace2;
                                                installFlags2 = installFlags;
                                                parseFlags = parseFlags2;
                                                oldCodePath2 = oldCodePath;
                                            }
                                        } catch (Throwable th37) {
                                            oldPackage = th37;
                                            boolean z77 = replace2;
                                            boolean z78 = forwardLocked2;
                                            int i60 = installFlags;
                                            int i61 = parseFlags2;
                                            String str80 = installerPackageName3;
                                            boolean z79 = onExternal2;
                                            long j33 = installBeginTime;
                                            File file30 = tmpPackageFile;
                                            String str81 = volumeUuid;
                                            String str82 = volumeUuid2;
                                            boolean z80 = z77;
                                            String str83 = oldCodePath;
                                            while (true) {
                                                break;
                                            }
                                            throw oldPackage;
                                        }
                                        try {
                                            int N22 = pkg.permissions.size();
                                            i = N22 - 1;
                                            while (i >= 0) {
                                                try {
                                                    PackageParser.Permission perm = (PackageParser.Permission) pkg.permissions.get(i);
                                                    BasePermission bp = this.mPermissionManager.getPermissionTEMP(perm.info.name);
                                                    if ((perm.info.protectionLevel & 4096) == 0 || systemApp) {
                                                        N = N22;
                                                        ps2 = ps;
                                                    } else {
                                                        N = N22;
                                                        try {
                                                            StringBuilder sb5 = new StringBuilder();
                                                            ps2 = ps;
                                                            sb5.append("Non-System package ");
                                                            sb5.append(pkg.packageName);
                                                            sb5.append(" attempting to delcare ephemeral permission ");
                                                            sb5.append(perm.info.name);
                                                            sb5.append("; Removing ephemeral.");
                                                            Slog.w(TAG, sb5.toString());
                                                            perm.info.protectionLevel &= -4097;
                                                        } catch (Throwable th38) {
                                                            oldPackage = th38;
                                                            boolean z81 = forwardLocked2;
                                                            String str84 = volumeUuid2;
                                                            String str85 = oldCodePath2;
                                                        }
                                                    }
                                                    if (bp != null) {
                                                        String sourcePackageName = bp.getSourcePackageName();
                                                        PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                                                        KeySetManagerService ksms2 = this.mSettings.mKeySetManagerService;
                                                        installerPackageName2 = installerPackageName3;
                                                        try {
                                                            if (!sourcePackageName.equals(pkg.packageName) || !ksms2.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags3)) {
                                                                String str86 = sourcePackageName;
                                                                KeySetManagerService keySetManagerService = ksms2;
                                                                if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                                                                    sigsOk = true;
                                                                } else {
                                                                    if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, 4)) {
                                                                        sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                        sigsOk = true;
                                                                    } else {
                                                                        sigsOk = false;
                                                                    }
                                                                    if (!sigsOk) {
                                                                        if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName) && (perm.info.protectionLevel & 15) == 1 && bp != null && !bp.isRuntime()) {
                                                                            Slog.w(TAG, "Package " + pkg.packageName + " trying to change a non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                                                                            perm.info.protectionLevel = bp.getProtectionLevel();
                                                                        }
                                                                    } else if (bp.getSourcePackageName().equals(PLATFORM_PACKAGE_NAME)) {
                                                                        Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                                                                        pkg.permissions.remove(i);
                                                                    } else if (((bp.getProtectionLevel() | perm.info.protectionLevel) & 15) == 2) {
                                                                        packageInstalledInfo.setError(-112, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.getSourcePackageName());
                                                                        packageInstalledInfo.origPermission = perm.info.name;
                                                                        packageInstalledInfo.origPackage = bp.getSourcePackageName();
                                                                        return;
                                                                    } else {
                                                                        StringBuilder sb6 = new StringBuilder();
                                                                        boolean z82 = sigsOk;
                                                                        sb6.append("Package ");
                                                                        sb6.append(pkg.packageName);
                                                                        sb6.append(" attempting to redeclare permission ");
                                                                        sb6.append(perm.info.name);
                                                                        sb6.append(" already owned by ");
                                                                        sb6.append(bp.getSourcePackageName());
                                                                        sb6.append("; ignoring new declaration");
                                                                        Slog.w(TAG, sb6.toString());
                                                                        pkg.permissions.remove(i);
                                                                    }
                                                                }
                                                            } else {
                                                                String str87 = sourcePackageName;
                                                                KeySetManagerService keySetManagerService2 = ksms2;
                                                                sigsOk = ksms2.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                                                            }
                                                            if (!sigsOk) {
                                                            }
                                                        } catch (Throwable th39) {
                                                            oldPackage = th39;
                                                            boolean z83 = forwardLocked2;
                                                            String str88 = volumeUuid2;
                                                            String str89 = oldCodePath2;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw oldPackage;
                                                        }
                                                    } else {
                                                        installerPackageName2 = installerPackageName3;
                                                    }
                                                    i--;
                                                    N22 = N;
                                                    ps = ps2;
                                                    installerPackageName3 = installerPackageName2;
                                                } catch (Throwable th40) {
                                                    oldPackage = th40;
                                                    String str90 = installerPackageName3;
                                                    boolean z84 = forwardLocked2;
                                                    String str91 = volumeUuid2;
                                                    String str92 = oldCodePath2;
                                                    boolean z85 = onExternal2;
                                                    long j34 = installBeginTime;
                                                    File file31 = tmpPackageFile;
                                                    String str93 = volumeUuid;
                                                    int i62 = installFlags2;
                                                    boolean z86 = replace3;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw oldPackage;
                                                }
                                            }
                                            String installerPackageName42 = installerPackageName3;
                                        } catch (Throwable th41) {
                                            oldPackage = th41;
                                            boolean z87 = forwardLocked2;
                                            String str94 = installerPackageName3;
                                            boolean z88 = onExternal2;
                                            long j35 = installBeginTime;
                                            File file32 = tmpPackageFile;
                                            String str95 = volumeUuid;
                                            int i63 = installFlags2;
                                            String str96 = volumeUuid2;
                                            boolean z89 = replace3;
                                            String str97 = oldCodePath2;
                                            while (true) {
                                                break;
                                            }
                                            throw oldPackage;
                                        }
                                    }
                                } catch (PackageManagerException e10) {
                                    boolean z90 = forwardLocked2;
                                    String str98 = volumeUuid3;
                                    int i64 = parseFlags2;
                                    String str99 = installerPackageName3;
                                    boolean z91 = onExternal2;
                                    long j36 = installBeginTime;
                                    File file33 = tmpPackageFile;
                                    Slog.i(TAG, "downgrade package from preset system app, just restore the uninstalled system app");
                                    return;
                                }
                            }
                        } catch (PackageParser.PackageParserException e11) {
                            e = e11;
                            boolean z92 = forwardLocked2;
                            String str100 = volumeUuid3;
                            int i65 = parseFlags2;
                            String str101 = installerPackageName3;
                            boolean z93 = onExternal2;
                            long j37 = installBeginTime;
                            File file34 = tmpPackageFile;
                        }
                    } else {
                        packageInstalledInfo.setError(-15, "installPackageLI");
                        return;
                    }
                    packageInstalledInfo.setError(-111, "Disallow install new apps");
                    Slog.i(TAG, installerPackageName + " is disallowed to install new app " + pkgName3);
                    return;
                } catch (PackageParser.PackageParserException e12) {
                    e = e12;
                    boolean z94 = forwardLocked2;
                    File file35 = tmpPackageFile3;
                    String str102 = volumeUuid3;
                    int i66 = parseFlags2;
                    PackageParser packageParser4 = pp;
                    String str103 = installerPackageName3;
                    boolean z95 = onExternal2;
                    long j38 = installBeginTime3;
                    packageInstalledInfo.setError("Failed parse during installPackageLI", e);
                    Trace.traceEnd(j);
                    return;
                } catch (Throwable th42) {
                    pkg = th42;
                    boolean z96 = forwardLocked2;
                    File file36 = tmpPackageFile3;
                    String str104 = volumeUuid3;
                    int i67 = parseFlags2;
                    PackageParser packageParser5 = pp;
                    String str105 = installerPackageName3;
                    boolean z97 = onExternal2;
                    long j39 = installBeginTime3;
                    Trace.traceEnd(j);
                    throw pkg;
                }
            } else {
                Slog.i(TAG, "Incompatible ephemeral install; fwdLocked=" + forwardLocked2 + " external=" + onExternal);
                packageInstalledInfo.setReturnCode(-116);
                return;
            }
        } else {
            packageInstalledInfo.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
            Log.w(TAG, "can not install packages before FRP unlock");
            return;
        }
        packageInstalledInfo.setError("Failed collect during installPackageLI", e);
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
        if (this.mIntentFilterVerifierComponent == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int verifierUid = getPackageUid(this.mIntentFilterVerifierComponent.getPackageName(), 268435456, userId == -1 ? 0 : userId);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            Message msg2 = this.mHandler.obtainMessage(17);
            msg2.obj = new IFVerificationParams((PackageParser.Package) pkg.childPackages.get(i), replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg2);
        }
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x008a, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x015b, code lost:
        if (r2 <= 0) goto L_0x0196;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x015f, code lost:
        if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x0190;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0161, code lost:
        r3 = new java.lang.StringBuilder();
        r3.append("Starting ");
        r3.append(r2);
        r3.append(" IntentFilter verification");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0176, code lost:
        if (r2 <= 1) goto L_0x017c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x0178, code lost:
        r4 = "s";
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x017c, code lost:
        r4 = com.android.server.backup.BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x017e, code lost:
        r3.append(r4);
        r3.append(" for userId:");
        r3.append(r8);
        android.util.Slog.d(TAG, r3.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0190, code lost:
        r1.mIntentFilterVerifier.startVerifications(r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0198, code lost:
        if (DEBUG_DOMAIN_VERIFICATION == false) goto L_0x01b0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x019a, code lost:
        android.util.Slog.d(TAG, "No filters or not all autoVerify for " + r12);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01b0, code lost:
        return;
     */
    public void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, PackageParser.Package pkg) {
        Iterator it;
        PackageParser.Activity a;
        boolean needToVerify;
        Iterator it2;
        int i = userId;
        PackageParser.Package packageR = pkg;
        int size = packageR.activities.size();
        if (size == 0) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No activity, so no need to verify any IntentFilter!");
            }
        } else if (!hasDomainURLs(pkg)) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No domain URLs, so no need to verify any IntentFilter!");
            }
        } else {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "Checking for userId:" + i + " if any IntentFilter from the " + size + " Activities needs verification ...");
            }
            int count = 0;
            String packageName = packageR.packageName;
            synchronized (this.mPackages) {
                if (!replacing) {
                    IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(packageName);
                    if (ivi != null) {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            Slog.i(TAG, "Package " + packageName + " already verified: status=" + ivi.getStatusString());
                        }
                    }
                }
                boolean needToVerify2 = false;
                Iterator it3 = packageR.activities.iterator();
                while (it3.hasNext()) {
                    Iterator it4 = ((PackageParser.Activity) it3.next()).intents.iterator();
                    while (true) {
                        if (!it4.hasNext()) {
                            break;
                        }
                        PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it4.next();
                        if (filter.needsVerification() && needsNetworkVerificationLPr(filter)) {
                            if (DEBUG_DOMAIN_VERIFICATION) {
                                Slog.d(TAG, "Intent filter needs verification, so processing all filters");
                            }
                            needToVerify2 = true;
                        }
                    }
                }
                boolean z = true;
                if (needToVerify2) {
                    int verificationId = this.mIntentFilterVerificationToken;
                    this.mIntentFilterVerificationToken = verificationId + 1;
                    Iterator it5 = packageR.activities.iterator();
                    while (it5.hasNext()) {
                        PackageParser.Activity a2 = (PackageParser.Activity) it5.next();
                        Iterator it6 = a2.intents.iterator();
                        int count2 = count;
                        while (it6.hasNext() != 0) {
                            try {
                                PackageParser.ActivityIntentInfo filter2 = (PackageParser.ActivityIntentInfo) it6.next();
                                if (!filter2.handlesWebUris(z) || !needsNetworkVerificationLPr(filter2)) {
                                    needToVerify = needToVerify2;
                                    it2 = it6;
                                    a = a2;
                                    it = it5;
                                } else {
                                    if (DEBUG_DOMAIN_VERIFICATION) {
                                        StringBuilder sb = new StringBuilder();
                                        needToVerify = needToVerify2;
                                        sb.append("Verification needed for IntentFilter:");
                                        sb.append(filter2.toString());
                                        Slog.d(TAG, sb.toString());
                                    } else {
                                        needToVerify = needToVerify2;
                                    }
                                    it2 = it6;
                                    a = a2;
                                    it = it5;
                                    this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, i, verificationId, filter2, packageName);
                                    count2++;
                                }
                                it6 = it2;
                                needToVerify2 = needToVerify;
                                a2 = a;
                                it5 = it;
                                z = true;
                            } catch (Throwable th) {
                                ivi = th;
                                int i2 = count2;
                                throw ivi;
                            }
                        }
                        Iterator it7 = it5;
                        count = count2;
                        z = true;
                    }
                }
                try {
                } catch (Throwable th2) {
                    ivi = th2;
                    throw ivi;
                }
            }
        }
    }

    private boolean needsNetworkVerificationLPr(PackageParser.ActivityIntentInfo filter) {
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(filter.activity.getComponentName().getPackageName());
        if (ivi == null) {
            return true;
        }
        switch (ivi.getStatus()) {
            case 0:
            case 1:
                return true;
            default:
                return false;
        }
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isExternal(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isSystemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean isOemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 131072) != 0;
    }

    private static boolean isVendorApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 262144) != 0;
    }

    private static boolean isProductApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 524288) != 0;
    }

    private static boolean hasDomainURLs(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private int packageFlagsToInstallFlags(PackageSetting ps) {
        int installFlags = 0;
        if (isExternal(ps) && TextUtils.isEmpty(ps.volumeUuid)) {
            installFlags = 0 | 8;
        }
        if (ps.isForwardLocked()) {
            return installFlags | 1;
        }
        return installFlags;
    }

    private Settings.VersionInfo getSettingsVersionForPackage(PackageParser.Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        for (File file : sDrmAppPrivateInstallDir.listFiles(new FilenameFilter() {
            public boolean accept(File dir, String name) {
                return name.startsWith("vmdl") && name.endsWith(".tmp");
            }
        })) {
            file.delete();
        }
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new PackageManager.LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        mHwPMSEx.deletePackageVersioned(versionedPackage, observer, userId, deleteFlags);
    }

    /* JADX INFO: finally extract failed */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x014b, code lost:
        r0 = th;
     */
    public void deletePackageVersionedImpl(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        String internalPackageName;
        IPackageDeleteObserver2 iPackageDeleteObserver2 = observer;
        int i = userId;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        boolean canViewInstantApps = canViewInstantApps(callingUid, i);
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getLongVersionCode(), -1, JobStatus.NO_LATEST_RUNTIME, "versionCode must be >= -1");
        String packageName = versionedPackage.getPackageName();
        long versionCode = versionedPackage.getLongVersionCode();
        synchronized (this.mPackages) {
            try {
                internalPackageName = resolveInternalPackageNameLPr(packageName, versionCode);
            } catch (Throwable th) {
                th = th;
                long j = versionCode;
                String str = packageName;
                int i2 = callingUid;
                while (true) {
                    throw th;
                }
            }
        }
        int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || isCallerAllowedToSilentlyUninstall(uid, internalPackageName)) {
            boolean deleteAllUsers = (deleteFlags & 2) != 0;
            int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{i};
            if (UserHandle.getUserId(uid) != i || (deleteAllUsers && users.length > 1)) {
                Context context = this.mContext;
                context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "deletePackage for user " + i);
            }
            if (isUserRestricted(i, "no_uninstall_apps")) {
                try {
                    iPackageDeleteObserver2.onPackageDeleted(packageName, -3, null);
                } catch (RemoteException e) {
                }
            } else if (deleteAllUsers || !getBlockUninstallForUser(internalPackageName, i)) {
                if (DEBUG_REMOVE) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("deletePackageAsUser: pkg=");
                    sb.append(internalPackageName);
                    sb.append(" user=");
                    sb.append(i);
                    sb.append(" deleteAllUsers: ");
                    sb.append(deleteAllUsers);
                    sb.append(" version=");
                    sb.append(versionCode == -1 ? "VERSION_CODE_HIGHEST" : Long.valueOf(versionCode));
                    Slog.d(TAG, sb.toString());
                }
                PackageHandler packageHandler = this.mHandler;
                final String str2 = internalPackageName;
                int[] users2 = users;
                final int i3 = callingUid;
                boolean deleteAllUsers2 = deleteAllUsers;
                final boolean deleteAllUsers3 = canViewInstantApps;
                AnonymousClass15 r14 = r1;
                final boolean z = deleteAllUsers2;
                String str3 = internalPackageName;
                int i4 = uid;
                final long j2 = versionCode;
                long j3 = versionCode;
                final int i5 = i;
                final int i6 = deleteFlags;
                String packageName2 = packageName;
                final int[] iArr = users2;
                int i7 = callingUid;
                final IPackageDeleteObserver2 iPackageDeleteObserver22 = iPackageDeleteObserver2;
                final String str4 = packageName2;
                AnonymousClass15 r1 = new Runnable() {
                    public void run() {
                        int returnCode;
                        PackageManagerService.this.mHandler.removeCallbacks(this);
                        PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(str2);
                        boolean doDeletePackage = true;
                        if (ps != null) {
                            doDeletePackage = !ps.getInstantApp(UserHandle.getUserId(i3)) || deleteAllUsers3;
                        }
                        if (!doDeletePackage) {
                            returnCode = -1;
                        } else if (!z) {
                            returnCode = PackageManagerService.this.deletePackageX(str2, j2, i5, i6);
                        } else {
                            int[] blockUninstallUserIds = PackageManagerService.this.getBlockUninstallForUsers(str2, iArr);
                            if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                                returnCode = PackageManagerService.this.deletePackageX(str2, j2, i5, i6);
                            } else {
                                int userFlags = i6 & -3;
                                for (int userId : iArr) {
                                    if (!ArrayUtils.contains(blockUninstallUserIds, userId)) {
                                        if (PackageManagerService.this.deletePackageX(str2, j2, userId, userFlags) != 1) {
                                            Slog.w(PackageManagerService.TAG, "Package delete failed for user " + userId + ", returnCode " + returnCode);
                                        }
                                    }
                                }
                                returnCode = -4;
                            }
                        }
                        try {
                            iPackageDeleteObserver22.onPackageDeleted(str4, returnCode, null);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                };
                packageHandler.post(r14);
                setNeedClearDeviceForCTS(false, packageName2);
                Log.d(TAG, "setmNeedClearDeviceForCTS:false ");
            } else {
                try {
                    iPackageDeleteObserver2.onPackageDeleted(packageName, -4, null);
                } catch (RemoteException e2) {
                }
            }
        } else {
            try {
                Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
                intent.setData(Uri.fromParts("package", packageName, null));
                intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
                iPackageDeleteObserver2.onUserActionRequired(intent);
            } catch (RemoteException e3) {
            }
        }
    }

    private String resolveExternalPackageNameLPr(PackageParser.Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    /* access modifiers changed from: private */
    public String resolveInternalPackageNameLPr(String packageName, long versionCode) {
        String libName;
        int callingAppId;
        String str = packageName;
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(str);
        String packageName2 = normalizedPackageName != null ? normalizedPackageName : str;
        LongSparseArray<SharedLibraryEntry> versionedLib = this.mStaticLibsByDeclaringPackage.get(packageName2);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return packageName2;
        }
        LongSparseLongArray versionsCallerCanSee = null;
        int callingAppId2 = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId2 == 1000 || callingAppId2 == 2000 || callingAppId2 == 0)) {
            versionsCallerCanSee = new LongSparseLongArray();
            String libName2 = versionedLib.valueAt(0).info.getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                int length = uidPackages.length;
                int i = 0;
                while (i < length) {
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackages[i]);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName2);
                    if (libIdx >= 0) {
                        callingAppId = callingAppId2;
                        libName = libName2;
                        long libVersion = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(libVersion, libVersion);
                    } else {
                        callingAppId = callingAppId2;
                        libName = libName2;
                    }
                    i++;
                    callingAppId2 = callingAppId;
                    libName2 = libName;
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return packageName2;
        }
        SharedLibraryEntry highestVersion = null;
        int versionCount = versionedLib.size();
        int i2 = 0;
        while (true) {
            int i3 = i2;
            if (i3 < versionCount) {
                SharedLibraryEntry libEntry = versionedLib.valueAt(i3);
                if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libEntry.info.getLongVersion()) >= 0) {
                    long libVersionCode = libEntry.info.getDeclaringPackage().getLongVersionCode();
                    if (versionCode != -1) {
                        if (libVersionCode == versionCode) {
                            return libEntry.apk;
                        }
                    } else if (highestVersion == null) {
                        highestVersion = libEntry;
                    } else if (libVersionCode > highestVersion.info.getDeclaringPackage().getLongVersionCode()) {
                        highestVersion = libEntry;
                    }
                }
                i2 = i3 + 1;
            } else if (highestVersion != null) {
                return highestVersion.apk;
            } else {
                return packageName2;
            }
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        if (this.mRequiredVerifierPackage == null || callingUid != getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000) {
            return true;
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredVerifierPackage != null && callingUid == getPackageUid(this.mRequiredVerifierPackage, 0, callingUserId)) {
            return true;
        }
        if (this.mRequiredUninstallerPackage != null && callingUid == getPackageUid(this.mRequiredUninstallerPackage, 0, callingUserId)) {
            return true;
        }
        if ((this.mStorageManagerPackage == null || callingUid != getPackageUid(this.mStorageManagerPackage, 0, callingUserId)) && checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) != 0) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    public int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (checkUidPermission("android.permission.MANAGE_USERS", callingUid) != 0) {
            EventLog.writeEvent(1397638484, new Object[]{"128599183", -1, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS});
            throw new SecurityException("android.permission.MANAGE_USERS permission is required to call this API");
        } else if (getInstantAppPackageName(callingUid) == null || isCallerSameApp(packageName, callingUid)) {
            return isPackageDeviceAdmin(packageName, -1);
        } else {
            return false;
        }
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        String deviceOwnerPackageName;
        IDevicePolicyManager dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"));
        if (dpm != null) {
            try {
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                int[] users = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
                for (int packageHasActiveAdmins : users) {
                    if (dpm.packageHasActiveAdmins(packageName, packageHasActiveAdmins)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        return this.mKeepUninstalledPackages != null && this.mKeepUninstalledPackages.contains(packageName);
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:141:?, code lost:
        monitor-exit(r21);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x0282, code lost:
        if (r1 == false) goto L_0x02f7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x0284, code lost:
        com.android.server.pm.HwPackageManagerServiceUtils.reportException(com.android.server.pm.HwPackageManagerServiceUtils.EVENT_UNINSTALLED_APPLICATION, "userId : " + r14 + ",caller : " + getNameForUid(android.os.Binder.getCallingUid()) + ",pkg : " + r11);
        r7 = false;
        r8 = r4.isRemovedPackageSystemUpdate;
        r9 = r10.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x02b9, code lost:
        monitor-enter(r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x02ba, code lost:
        if (r8 != false) goto L_0x02c9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:148:0x02c2, code lost:
        if (r10.mPackages.get(r11) != null) goto L_0x02c9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:0x02c4, code lost:
        r7 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x02c7, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x02c9, code lost:
        monitor-exit(r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x02ca, code lost:
        if (r7 != false) goto L_0x02ce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x02cc, code lost:
        if (r8 == false) goto L_0x02dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:?, code lost:
        mHwPMSEx.updatePackageBlackListInfo(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02d5, code lost:
        android.util.Slog.e(TAG, "update BlackListApp info failed");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x02f6, code lost:
        throw r0;
     */
    /* JADX WARNING: Removed duplicated region for block: B:184:0x032d  */
    /* JADX WARNING: Removed duplicated region for block: B:206:0x0367 A[SYNTHETIC, Splitter:B:206:0x0367] */
    /* JADX WARNING: Removed duplicated region for block: B:84:0x01a7  */
    /* JADX WARNING: Removed duplicated region for block: B:89:0x01cf  */
    /* JADX WARNING: Removed duplicated region for block: B:92:0x01d5 A[SYNTHETIC, Splitter:B:92:0x01d5] */
    public int deletePackageX(String packageName, long versionCode, int userId, int deleteFlags) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        PackageParser.Package pkg;
        int[] allUsers;
        int freezeUser;
        int deleteFlags2;
        Object obj;
        Object obj2;
        PackageFreezer freezer;
        Throwable th;
        Throwable th2;
        boolean killApp;
        PackageParser.Package pkg2;
        PackageSetting uninstalledPs;
        int deleteFlags3;
        PackageRemovedInfo info;
        boolean res;
        final PackageRemovedInfo info2;
        int i;
        int i2;
        String str = packageName;
        long j = versionCode;
        int i3 = userId;
        int i4 = -1;
        if (!mHwPMSEx.isAllowUninstallApp(str)) {
            Slog.w(TAG, "Not removing package " + str + ": limited by its own");
            return -1;
        }
        HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(2, 0, 0, str, null);
        PackageRemovedInfo info3 = new PackageRemovedInfo(this);
        int removeUser = (deleteFlags & 2) != 0 ? -1 : i3;
        if (isPackageDeviceAdmin(str, removeUser)) {
            Slog.w(TAG, "Not removing package " + str + ": has active device admin");
            return -2;
        }
        if (HwDeviceManager.disallowOp(5, str)) {
            PackageRemovedInfo packageRemovedInfo = info3;
        } else if (mHwPMSEx == null || !mHwPMSEx.isDisallowUninstallApk(str)) {
            ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
            synchronized (arrayMap2) {
                try {
                    PackageSetting uninstalledPs2 = this.mSettings.mPackages.get(str);
                    if (uninstalledPs2 == null) {
                        try {
                            Slog.w(TAG, "Not removing non-existent package " + str);
                            return -1;
                        } catch (Throwable th3) {
                            th = th3;
                            arrayMap = arrayMap2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th4) {
                                    th = th4;
                                }
                            }
                            throw th;
                        }
                    } else if (j == -1 || uninstalledPs2.versionCode == j) {
                        try {
                            pkg = this.mPackages.get(str);
                            try {
                                allUsers = sUserManager.getUserIds();
                                if (pkg != null) {
                                    try {
                                        if (pkg.staticSharedLibName != null) {
                                            arrayMap = arrayMap2;
                                            try {
                                                SharedLibraryEntry libEntry = getSharedLibraryEntryLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                                                if (libEntry != null) {
                                                    int length = allUsers.length;
                                                    int i5 = 0;
                                                    while (i5 < length) {
                                                        int currUserId = allUsers[i5];
                                                        if (removeUser == i4 || removeUser == currUserId) {
                                                            i2 = length;
                                                            if (!ArrayUtils.isEmpty(getPackagesUsingSharedLibraryLPr(libEntry.info, 0, currUserId))) {
                                                                Slog.w(TAG, "Not removing package " + pkg.manifestPackageName + " hosting lib " + libEntry.info.getName() + " version " + libEntry.info.getLongVersion() + " used by " + libClientPackages + " for user " + currUserId);
                                                                return -6;
                                                            }
                                                        } else {
                                                            i2 = length;
                                                        }
                                                        i5++;
                                                        length = i2;
                                                        long j2 = versionCode;
                                                        i4 = -1;
                                                    }
                                                }
                                                info3.origUsers = uninstalledPs2.queryInstalledUsers(allUsers, true);
                                                if (isUpdatedSystemApp(uninstalledPs2) || (deleteFlags & 4) != 0) {
                                                    freezeUser = removeUser;
                                                } else {
                                                    freezeUser = -1;
                                                }
                                                int freezeUser2 = freezeUser;
                                                if (HwPackageManagerServiceUtils.isInAntiFillingWhiteList(str, hasSystemFeature("android.software.home_screen", 0))) {
                                                    deleteFlags2 = deleteFlags;
                                                } else if (isUpdatedSystemApp(uninstalledPs2)) {
                                                    deleteFlags2 = deleteFlags & -5;
                                                } else {
                                                    Slog.w(TAG, "Not removing package " + str + ": limited by anti-filling");
                                                    return -1;
                                                }
                                                obj = this.mInstallLock;
                                                synchronized (obj) {
                                                    try {
                                                        if (DEBUG_REMOVE) {
                                                            try {
                                                                Slog.d(TAG, "deletePackageX: pkg=" + str + " user=" + i3);
                                                            } catch (Throwable th5) {
                                                                th = th5;
                                                                obj2 = obj;
                                                                PackageParser.Package packageR = pkg;
                                                                int i6 = deleteFlags2;
                                                                int i7 = removeUser;
                                                                PackageRemovedInfo packageRemovedInfo2 = info3;
                                                            }
                                                        }
                                                        PackageFreezer freezer2 = freezePackageForDelete(str, freezeUser2, deleteFlags2, "deletePackageX");
                                                        try {
                                                            th = null;
                                                            freezer = freezer2;
                                                            killApp = false;
                                                            obj2 = obj;
                                                            pkg2 = pkg;
                                                            uninstalledPs = uninstalledPs2;
                                                            deleteFlags3 = deleteFlags2;
                                                            int i8 = removeUser;
                                                            info = info3;
                                                            try {
                                                                boolean res2 = deletePackageLIF(str, UserHandle.of(removeUser), true, allUsers, deleteFlags2 | Integer.MIN_VALUE, info3, true, null);
                                                                if (freezer != null) {
                                                                    try {
                                                                        $closeResource(null, freezer);
                                                                    } catch (Throwable th6) {
                                                                        th = th6;
                                                                        PackageParser.Package packageR2 = pkg2;
                                                                        PackageSetting packageSetting = uninstalledPs;
                                                                        PackageRemovedInfo packageRemovedInfo3 = info;
                                                                    }
                                                                }
                                                                res = res2;
                                                            } catch (Throwable th7) {
                                                                th = th7;
                                                                PackageParser.Package packageR3 = pkg2;
                                                                PackageSetting packageSetting2 = uninstalledPs;
                                                                PackageRemovedInfo packageRemovedInfo4 = info;
                                                                if (freezer != null) {
                                                                }
                                                                throw th;
                                                            }
                                                        } catch (Throwable th8) {
                                                            th = th8;
                                                            th = null;
                                                            freezer = freezer2;
                                                            obj2 = obj;
                                                            PackageParser.Package packageR4 = pkg;
                                                            int i9 = deleteFlags2;
                                                            int i10 = removeUser;
                                                            PackageRemovedInfo packageRemovedInfo5 = info3;
                                                            if (freezer != null) {
                                                                $closeResource(th, freezer);
                                                            }
                                                            throw th;
                                                        }
                                                        try {
                                                            synchronized (this.mPackages) {
                                                                if (res) {
                                                                    PackageParser.Package pkg3 = pkg2;
                                                                    if (pkg3 != null) {
                                                                        try {
                                                                            info2 = info;
                                                                            try {
                                                                                this.mInstantAppRegistry.onPackageUninstalledLPw(pkg3, info2.removedUsers);
                                                                            } catch (Throwable th9) {
                                                                                th = th9;
                                                                                PackageSetting packageSetting3 = uninstalledPs;
                                                                            }
                                                                        } catch (Throwable th10) {
                                                                            th = th10;
                                                                            PackageRemovedInfo packageRemovedInfo6 = info;
                                                                            PackageSetting packageSetting4 = uninstalledPs;
                                                                            throw th;
                                                                        }
                                                                    } else {
                                                                        info2 = info;
                                                                    }
                                                                    try {
                                                                        updateSequenceNumberLP(uninstalledPs, info2.removedUsers);
                                                                        updateInstantAppInstallerLocked(packageName);
                                                                    } catch (Throwable th11) {
                                                                        th = th11;
                                                                        throw th;
                                                                    }
                                                                } else {
                                                                    PackageSetting packageSetting5 = uninstalledPs;
                                                                    info2 = info;
                                                                }
                                                            }
                                                        } catch (Throwable th12) {
                                                            th = th12;
                                                            PackageParser.Package packageR5 = pkg2;
                                                            PackageSetting packageSetting6 = uninstalledPs;
                                                            PackageRemovedInfo packageRemovedInfo7 = info;
                                                            throw th;
                                                        }
                                                    } catch (Throwable th13) {
                                                        th = th13;
                                                    }
                                                }
                                            } catch (Throwable th14) {
                                                th = th14;
                                                while (true) {
                                                    break;
                                                }
                                                throw th;
                                            }
                                        }
                                    } catch (Throwable th15) {
                                        th = th15;
                                        arrayMap = arrayMap2;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                }
                                arrayMap = arrayMap2;
                            } catch (Throwable th16) {
                                th = th16;
                                arrayMap = arrayMap2;
                                PackageParser.Package packageR6 = pkg;
                                int i11 = removeUser;
                                PackageRemovedInfo packageRemovedInfo8 = info3;
                                PackageParser.Package pkg4 = packageR6;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } catch (Throwable th17) {
                            th = th17;
                            arrayMap = arrayMap2;
                            int i12 = removeUser;
                            PackageRemovedInfo packageRemovedInfo9 = info3;
                            PackageSetting packageSetting7 = uninstalledPs2;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                        try {
                            info3.origUsers = uninstalledPs2.queryInstalledUsers(allUsers, true);
                            if (isUpdatedSystemApp(uninstalledPs2)) {
                            }
                            freezeUser = removeUser;
                            int freezeUser22 = freezeUser;
                            if (HwPackageManagerServiceUtils.isInAntiFillingWhiteList(str, hasSystemFeature("android.software.home_screen", 0))) {
                            }
                            obj = this.mInstallLock;
                            synchronized (obj) {
                            }
                        } catch (Throwable th18) {
                            th = th18;
                            PackageParser.Package packageR62 = pkg;
                            int i112 = removeUser;
                            PackageRemovedInfo packageRemovedInfo82 = info3;
                            PackageParser.Package pkg42 = packageR62;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else {
                        Slog.w(TAG, "Not removing package " + str + " with versionCode " + uninstalledPs2.versionCode + " != " + j);
                        return -1;
                    }
                } catch (Throwable th19) {
                    th = th19;
                    arrayMap = arrayMap2;
                    int i13 = removeUser;
                    PackageRemovedInfo packageRemovedInfo10 = info3;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        } else {
            int i14 = removeUser;
            PackageRemovedInfo packageRemovedInfo11 = info3;
        }
        Flog.i(209, "Not removing package " + str + ": is disallowed!");
        return -4;
        mHwPMSEx.sendIncompatibleNotificationIfNeeded(str);
        if ((deleteFlags3 & 8) == 0) {
            killApp = true;
        }
        info2.sendPackageRemovedBroadcasts(killApp);
        info2.sendSystemPackageUpdatedBroadcasts();
        info2.sendSystemPackageAppearedBroadcasts();
        Runtime.getRuntime().gc();
        if (info2.args != null) {
            if (this.mCustPms == null || !this.mCustPms.isSdInstallEnabled()) {
                synchronized (this.mInstallLock) {
                    i = 1;
                    info2.args.doPostDeleteLI(true);
                }
                if (!res) {
                    i = -1;
                }
                return i;
            }
            this.mHandler.postDelayed(new Runnable() {
                public void run() {
                    synchronized (PackageManagerService.this.mInstallLock) {
                        info2.args.doPostDeleteLI(true);
                    }
                }
            }, 500);
        }
        i = 1;
        if (!res) {
        }
        return i;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:53:0x010d, code lost:
        r1.mHandler.post(new com.android.server.pm.PackageManagerService.AnonymousClass17(r1));
     */
    private void removePackageDataLIF(PackageSetting ps, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        PackageParser.Package deletedPkg;
        final PackageSetting deletedPs;
        boolean installedStateChanged;
        int i;
        PackageParser.Package resolvedPkg;
        int[] iArr;
        PackageSetting packageSetting = ps;
        int[] iArr2 = allUserHandles;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        String packageName = packageSetting.name;
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "removePackageDataLI: " + packageSetting);
        }
        synchronized (this.mPackages) {
            deletedPkg = this.mPackages.get(packageName);
            deletedPs = this.mSettings.mPackages.get(packageName);
            if (packageRemovedInfo != null) {
                packageRemovedInfo.removedPackage = packageName;
                packageRemovedInfo.installerPackageName = packageSetting.installerPackageName;
                packageRemovedInfo.isStaticSharedLib = (deletedPkg == null || deletedPkg.staticSharedLibName == null) ? false : true;
                if (deletedPs == null) {
                    iArr = null;
                } else {
                    iArr = deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
                packageRemovedInfo.populateUsers(iArr, deletedPs);
            }
        }
        PackageParser.Package deletedPkg2 = deletedPkg;
        removePackageLI(packageSetting, (flags & Integer.MIN_VALUE) != 0);
        if ((flags & 1) == 0) {
            if (deletedPkg2 != null) {
                resolvedPkg = deletedPkg2;
            } else {
                resolvedPkg = new PackageParser.Package(packageSetting.name);
                resolvedPkg.setVolumeUuid(packageSetting.volumeUuid);
            }
            destroyAppDataLIF(resolvedPkg, -1, 3);
            destroyAppProfilesLIF(resolvedPkg, -1);
            if (packageRemovedInfo != null) {
                packageRemovedInfo.dataRemoved = true;
            }
            schedulePackageCleaning(packageName, -1, true);
        } else {
            Flog.i(206, "removePackageDataLI : " + packageSetting.name + ", keep data");
        }
        int removedAppId = -1;
        synchronized (this.mPackages) {
            boolean installedStateChanged2 = false;
            if (deletedPs != null) {
                if ((flags & 1) == 0) {
                    try {
                        clearIntentFilterVerificationsLPw(deletedPs.name, -1);
                        clearDefaultBrowserIfNeeded(packageName);
                        this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                        removedAppId = this.mSettings.removePackageLPw(packageName);
                        if (packageRemovedInfo != null) {
                            packageRemovedInfo.removedAppId = removedAppId;
                        }
                        this.mPermissionManager.updatePermissions(deletedPs.name, null, false, this.mPackages.values(), this.mPermissionCallback);
                        if (deletedPs.sharedUser != null) {
                            int[] userIds = UserManagerService.getInstance().getUserIds();
                            int length = userIds.length;
                            int i2 = 0;
                            while (true) {
                                if (i2 >= length) {
                                    break;
                                }
                                int userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userIds[i2]);
                                installedStateChanged = installedStateChanged2;
                                if (userIdToKill == -1) {
                                    break;
                                } else if (userIdToKill >= 0) {
                                    break;
                                } else {
                                    i2++;
                                    installedStateChanged2 = installedStateChanged;
                                }
                            }
                        }
                        installedStateChanged = installedStateChanged2;
                        clearPackagePreferredActivitiesLPw(deletedPs.name, -1);
                    } catch (Throwable th) {
                        while (true) {
                            throw th;
                        }
                    }
                } else {
                    installedStateChanged = false;
                }
                if (!(iArr2 == null || packageRemovedInfo == null || packageRemovedInfo.origUsers == null)) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across downgrade");
                    }
                    int i3 = 0;
                    for (int length2 = iArr2.length; i3 < length2; length2 = i) {
                        int userId = iArr2[i3];
                        boolean installed = ArrayUtils.contains(packageRemovedInfo.origUsers, userId);
                        if (DEBUG_REMOVE) {
                            StringBuilder sb = new StringBuilder();
                            i = length2;
                            sb.append("    user ");
                            sb.append(userId);
                            sb.append(" => ");
                            sb.append(installed);
                            Slog.d(TAG, sb.toString());
                        } else {
                            i = length2;
                        }
                        if (installed != packageSetting.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        packageSetting.setInstalled(installed, userId);
                        i3++;
                    }
                }
            } else {
                installedStateChanged = false;
            }
            if (writeSettings) {
                this.mSettings.writeLPr();
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(packageSetting);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    static boolean locationIsPrivileged(String path) {
        boolean z = false;
        try {
            boolean isPrivilegedAppHw = mHwPMSEx.isPrivAppNonSystemPartitionDir(new File(path));
            if (isPrivilegedAppHw) {
                return isPrivilegedAppHw;
            }
            File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
            File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");
            File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
            File privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
            if (path.startsWith(privilegedAppDir.getCanonicalPath()) || path.startsWith(privilegedVendorAppDir.getCanonicalPath()) || path.startsWith(privilegedOdmAppDir.getCanonicalPath()) || path.startsWith(privilegedProductAppDir.getCanonicalPath())) {
                z = true;
            }
            return z;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOem(String path) {
        try {
            return path.startsWith(Environment.getOemDirectory().getCanonicalPath());
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsVendor(String path) {
        boolean z = false;
        try {
            if (path.startsWith(Environment.getVendorDirectory().getCanonicalPath()) || path.startsWith(Environment.getOdmDirectory().getCanonicalPath()) || HwPackageManagerServiceUtils.hwlocationIsVendor(path)) {
                z = true;
            }
            return z;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProduct(String path) {
        boolean z = false;
        try {
            if (path.startsWith(Environment.getProductDirectory().getCanonicalPath()) || HwPackageManagerServiceUtils.hwlocationIsProduct(path)) {
                z = true;
            }
            return z;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x01cd, code lost:
        r14 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x01ce, code lost:
        mHwPMSEx.recordUninstalledDelapp(r10.packageName, r15.codePathString);
        r14.removedPackage = r10.packageName;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x01db, code lost:
        if (r13 == null) goto L_0x01e0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x01dd, code lost:
        r13.isRemovedPackageSystemUpdate = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x01e0, code lost:
        r14.sendPackageRemovedBroadcasts(true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x01e4, code lost:
        r18 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x01e6, code lost:
        if (r0 != null) goto L_0x020d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x01e8, code lost:
        if (r18 == false) goto L_0x01fd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x01f0, code lost:
        if (r15.pkg.isStub == false) goto L_0x01fb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x01f2, code lost:
        r4 = true;
        r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x01fb, code lost:
        r4 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x01fc, code lost:
        return r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x0202, code lost:
        if (r15.pkg.isStub == false) goto L_0x020b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x0204, code lost:
        r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x020c, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x0211, code lost:
        if (r15.pkg.isStub == false) goto L_0x021c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0213, code lost:
        r2 = true;
        r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x021c, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x021d, code lost:
        return r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x021e, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0220, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:?, code lost:
        android.util.Slog.w(TAG, "Failed to restore system package:" + r10.packageName + ": " + r0.getMessage());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:129:0x024a, code lost:
        if (r15.pkg.isStub != false) goto L_0x024c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x024c, code lost:
        r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x0255, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x025a, code lost:
        if (r15.pkg.isStub != false) goto L_0x025c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x025c, code lost:
        r9.mSettings.disableSystemPackageLPw(r15.name, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x0264, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:0x0098, code lost:
        if (mHwPMSEx.isPreRemovableApp(r8.codePath.toString()) == false) goto L_0x00a6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x00a9, code lost:
        if (DEBUG_REMOVE == false) goto L_0x00e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x00ab, code lost:
        if (r16 == false) goto L_0x00e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00ad, code lost:
        android.util.Slog.d(TAG, "Remembering install states:");
        r0 = r12.length;
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00b6, code lost:
        if (r2 >= r0) goto L_0x00e1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00b8, code lost:
        r4 = com.android.internal.util.ArrayUtils.contains(r13.origUsers, r12[r2]);
        android.util.Slog.d(TAG, "   u=" + r3 + " inst=" + r4);
        r2 = r2 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x00e1, code lost:
        if (r13 == null) goto L_0x00e5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00e3, code lost:
        r13.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00e5, code lost:
        if (r13 == null) goto L_0x011d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00e9, code lost:
        if (r13.removedChildPackages == null) goto L_0x011d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00ed, code lost:
        if (r11.childPackageNames == null) goto L_0x00f6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x00ef, code lost:
        r0 = r11.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x00f6, code lost:
        r0 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x00f7, code lost:
        r2 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x00f8, code lost:
        if (r2 >= r0) goto L_0x011d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x00fa, code lost:
        r3 = (java.lang.String) r11.childPackageNames.get(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0104, code lost:
        if (r8.childPackageNames == null) goto L_0x011a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x010c, code lost:
        if (r8.childPackageNames.contains(r3) == false) goto L_0x011a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x010e, code lost:
        r4 = r13.removedChildPackages.get(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x0116, code lost:
        if (r4 == null) goto L_0x011a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0118, code lost:
        r4.isRemovedPackageSystemUpdate = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x011a, code lost:
        r2 = r2 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x0123, code lost:
        if (r8.versionCode >= r11.versionCode) goto L_0x012a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x0125, code lost:
        r0 = r24 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x0130, code lost:
        if (mHwPMSEx.isDelapp(r8) != false) goto L_0x0148;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0138, code lost:
        if (mHwPMSEx.isDelappInData(r8) != false) goto L_0x0148;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0146, code lost:
        if (mHwPMSEx.isPreRemovableApp(r8.codePath.toString()) == false) goto L_0x0153;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x014e, code lost:
        if (r8.versionCode != r11.versionCode) goto L_0x0153;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x0150, code lost:
        r0 = r24 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x0153, code lost:
        r0 = r24 | 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0156, code lost:
        r15 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0167, code lost:
        if (deleteInstalledPackageLIF(r11, true, r0, r12, r13, r26, r8.pkg) != false) goto L_0x016a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:81:0x0169, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x016a, code lost:
        r3 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x016c, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:?, code lost:
        enableSystemPackageLPw(r15.pkg);
        removeNativeBinariesLI(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x0175, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x0178, code lost:
        if (DEBUG_REMOVE == false) goto L_0x0190;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x017a, code lost:
        android.util.Slog.d(TAG, "Re-installing system package: " + r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0190, code lost:
        r0 = null;
        r18 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:?, code lost:
        r7 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x019f, code lost:
        if (mHwPMSEx.isDelapp(r15) != false) goto L_0x01cd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01a7, code lost:
        if (mHwPMSEx.isDelappInData(r15) != false) goto L_0x01cd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x01b5, code lost:
        if (mHwPMSEx.isPreRemovableApp(r15.codePath.toString()) == false) goto L_0x01b9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01b7, code lost:
        r14 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01b9, code lost:
        r14 = r7;
        r0 = installPackageFromSystemLIF(r15.codePathString, false, r12, r13.origUsers, r22.getPermissionsState(), r26);
     */
    private boolean deleteSystemPackageLIF(PackageParser.Package deletedPkg, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) {
        PackageSetting disabledPs;
        PackageParser.Package packageR = deletedPkg;
        PackageSetting packageSetting = deletedPs;
        int[] iArr = allUserHandles;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        if (packageSetting.parentPackageName != null) {
            Slog.w(TAG, "Attempt to delete child system package " + packageR.packageName);
            return false;
        }
        boolean applyUserRestrictions = (iArr == null || packageRemovedInfo.origUsers == null) ? false : true;
        synchronized (this.mPackages) {
            disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageSetting.name);
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deleteSystemPackageLI: newPs=" + packageR.packageName + " disabledPs=" + disabledPs);
        }
        if (disabledPs == null) {
        } else if (disabledPs.pkg == null) {
            PackageSetting packageSetting2 = disabledPs;
        } else {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Deleting system pkg from data partition");
            }
            synchronized (this.mPackages) {
                try {
                    if (!mHwPMSEx.isDelapp(disabledPs)) {
                        try {
                            if (!mHwPMSEx.isDelappInData(disabledPs)) {
                            }
                        } catch (Throwable th) {
                            th = th;
                            PackageSetting packageSetting3 = disabledPs;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th2) {
                                    th = th2;
                                }
                            }
                            throw th;
                        }
                    }
                    this.mSettings.removeDisabledSystemPackageLPw(packageSetting.name);
                } catch (Throwable th3) {
                    th = th3;
                    PackageSetting packageSetting4 = disabledPs;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        }
        Slog.w(TAG, "Attempt to delete unknown system package " + packageR.packageName);
        return false;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:61:0x0136, code lost:
        return r1;
     */
    private PackageParser.Package installPackageFromSystemLIF(String codePathString, boolean isPrivileged, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        int i;
        boolean applyUserRestrictions;
        File codePath;
        boolean installed;
        int[] iArr = allUserHandles;
        int[] iArr2 = origUserHandles;
        PermissionsState permissionsState = origPermissionState;
        boolean z = true;
        int parseFlags = this.mDefParseFlags | 1 | 16;
        int scanFlags = 131072;
        if (isPrivileged || locationIsPrivileged(codePathString)) {
            scanFlags = 131072 | 262144;
        }
        if (locationIsOem(codePathString)) {
            scanFlags |= 524288;
        }
        if (locationIsVendor(codePathString)) {
            scanFlags |= 1048576;
        }
        if (locationIsProduct(codePathString)) {
            scanFlags |= 2097152;
        }
        File codePath2 = new File(codePathString);
        PackageParser.Package pkg = scanPackageTracedLI(codePath2, parseFlags, scanFlags | 8192, 0, (UserHandle) null);
        try {
            updateSharedLibrariesLPr(pkg, null);
        } catch (PackageManagerException e) {
            PackageManagerException packageManagerException = e;
            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
        }
        prepareAppDataAfterInstallLIF(pkg);
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
            if (permissionsState != null) {
                try {
                    ps.getPermissionsState().copyFrom(permissionsState);
                } catch (Throwable th) {
                    th = th;
                    File file = codePath2;
                }
            }
            try {
                this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                if (iArr == null || iArr2 == null) {
                    z = false;
                }
                boolean applyUserRestrictions2 = z;
                if (applyUserRestrictions2) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across reinstall");
                    }
                    boolean installedStateChanged = false;
                    int i2 = 0;
                    for (int length = iArr.length; i2 < length; length = i) {
                        int userId = iArr[i2];
                        boolean installed2 = ArrayUtils.contains(iArr2, userId);
                        if (DEBUG_REMOVE) {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            StringBuilder sb = new StringBuilder();
                            i = length;
                            sb.append("    user ");
                            sb.append(userId);
                            sb.append(" => ");
                            installed = installed2;
                            sb.append(installed);
                            Slog.d(TAG, sb.toString());
                        } else {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            i = length;
                            installed = installed2;
                        }
                        if (installed != ps.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        ps.setInstalled(installed, userId);
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                        i2++;
                        codePath2 = codePath;
                        applyUserRestrictions2 = applyUserRestrictions;
                    }
                    boolean z2 = applyUserRestrictions2;
                    this.mSettings.writeAllUsersPackageRestrictionsLPr();
                    if (installedStateChanged) {
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                } else {
                    boolean z3 = applyUserRestrictions2;
                }
                if (writeSettings) {
                    this.mSettings.writeLPr();
                }
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0051, code lost:
        removePackageDataLIF(r8, r17, r9, r16, r19);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:27:0x005f, code lost:
        if (r8.childPackageNames == null) goto L_0x0068;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:28:0x0061, code lost:
        r1 = r8.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0068, code lost:
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x0069, code lost:
        r11 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x006b, code lost:
        r12 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x006c, code lost:
        if (r12 >= r11) goto L_0x00b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:33:0x006e, code lost:
        r1 = r7.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:34:0x0070, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:?, code lost:
        r0 = r7.mSettings.getPackageLPr((java.lang.String) r8.childPackageNames.get(r12));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x007f, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x0080, code lost:
        if (r0 == null) goto L_0x00b2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x0082, code lost:
        if (r9 == null) goto L_0x0093;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x0086, code lost:
        if (r9.removedChildPackages == null) goto L_0x0093;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x0088, code lost:
        r1 = r9.removedChildPackages.get(r0.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x0093, code lost:
        r1 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0094, code lost:
        r4 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x0097, code lost:
        if ((r16 & 1) == 0) goto L_0x00a7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0099, code lost:
        if (r10 == null) goto L_0x00a7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00a1, code lost:
        if (r10.hasChildPackage(r0.name) != false) goto L_0x00a7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x00a3, code lost:
        r5 = r16 & -2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x00a7, code lost:
        r5 = r16;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x00a9, code lost:
        removePackageDataLIF(r0, r17, r4, r5, r19);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x00b2, code lost:
        r0 = r12 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x00ba, code lost:
        if (r8.parentPackageName != null) goto L_0x00d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x00bc, code lost:
        if (r15 == false) goto L_0x00d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x00be, code lost:
        if (r9 == null) goto L_0x00d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x00c0, code lost:
        r9.args = createInstallArgsForExisting(packageFlagsToInstallFlags(r8), r8.codePathString, r8.resourcePathString, com.android.server.pm.InstructionSets.getAppDexInstructionSets(r8));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x00d3, code lost:
        return true;
     */
    private boolean deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        PackageSetting packageSetting = ps;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        PackageParser.Package packageR = replacingPackage;
        synchronized (this.mPackages) {
            if (packageRemovedInfo != null) {
                try {
                    packageRemovedInfo.uid = packageSetting.appId;
                } catch (Throwable th) {
                    while (true) {
                        throw th;
                    }
                }
            }
            int i = 0;
            if (!(packageRemovedInfo == null || packageRemovedInfo.removedChildPackages == null)) {
                int childCount = packageSetting.childPackageNames != null ? packageSetting.childPackageNames.size() : 0;
                for (int i2 = 0; i2 < childCount; i2++) {
                    String childPackageName = (String) packageSetting.childPackageNames.get(i2);
                    PackageSetting childPs = this.mSettings.mPackages.get(childPackageName);
                    if (childPs == null) {
                        return false;
                    }
                    PackageRemovedInfo childInfo = packageRemovedInfo.removedChildPackages.get(childPackageName);
                    if (childInfo != null) {
                        childInfo.uid = childPs.appId;
                    }
                }
            }
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            Slog.w(TAG, "Cannot block uninstall of package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                    boolean blockUninstallLPr = this.mSettings.getBlockUninstallLPr(userId, packageName);
                    return blockUninstallLPr;
                }
            }
            return false;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Log.w(TAG, "Package doesn't exist: " + packageName);
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r3v6, resolved type: int} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v5, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r3v7, resolved type: int} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v7, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v8, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r6v9, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v14, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r0v15, resolved type: boolean} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r3v9, resolved type: int} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r3v10, resolved type: int} */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x01d9, code lost:
        if (clearPackageStateForUserLIF(r14, r23.getIdentifier(), r13) != false) goto L_0x01dc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x01db, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x01dc, code lost:
        scheduleWritePackageRestrictionsLocked(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x01df, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:0x01e2, code lost:
        if (DEBUG_REMOVE == false) goto L_0x01eb;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x01e4, code lost:
        android.util.Slog.d(TAG, "Deleting system app");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x01f3, code lost:
        if (clearPackageStateForUserLIF(r14, r23.getIdentifier(), r13) != false) goto L_0x01f6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x01f5, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x01fd, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) == 0) goto L_0x0201;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x01ff, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x0201, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0209, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & 67108864) == 0) goto L_0x020d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x020b, code lost:
        r0 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x020d, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x020e, code lost:
        if (r1 == false) goto L_0x021e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0210, code lost:
        mHwPMSEx.recordUninstalledDelapp(r14.pkg.packageName, r14.pkg.codePath);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x021e, code lost:
        if (r2 == false) goto L_0x023d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0220, code lost:
        r3 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0222, code lost:
        monitor-enter(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:?, code lost:
        r0 = r9.mSettings.getDisabledSystemPkgLPr(r14.pkg.packageName);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x022d, code lost:
        monitor-exit(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x022e, code lost:
        mHwPMSEx.recordUninstalledDelapp(r14.pkg.packageName, r0.codePathString);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x023d, code lost:
        scheduleWritePackageRestrictionsLocked(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x0240, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:135:0x0243, code lost:
        if (r14.childPackageNames == null) goto L_0x0289;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:0x0245, code lost:
        if (r13 == null) goto L_0x0289;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x0247, code lost:
        r1 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:138:0x0249, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:?, code lost:
        r2 = r14.childPackageNames.size();
        r13.removedChildPackages = new android.util.ArrayMap<>(r2);
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:141:0x0258, code lost:
        if (r3 >= r2) goto L_0x0284;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:142:0x025a, code lost:
        r4 = (java.lang.String) r14.childPackageNames.get(r3);
        r6 = new com.android.server.pm.PackageManagerService.PackageRemovedInfo(r9);
        r6.removedPackage = r4;
        r6.installerPackageName = r14.installerPackageName;
        r13.removedChildPackages.put(r4, r6);
        r7 = r9.mSettings.getPackageLPr(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x0278, code lost:
        if (r7 == null) goto L_0x0280;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:144:0x027a, code lost:
        r6.origUsers = r7.queryInstalledUsers(r12, true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:0x0280, code lost:
        r3 = r3 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x0284, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x028e, code lost:
        if (isSystemApp(r14) == false) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:154:0x0297, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02a1, code lost:
        if (mHwPMSEx.isSystemAppGrantByMdm(r29) != false) goto L_0x02d2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x02a5, code lost:
        if (DEBUG_REMOVE == false) goto L_0x02bf;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x02a7, code lost:
        android.util.Slog.d(TAG, "Removing system package: " + r14.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:160:0x02bf, code lost:
        r1 = deleteSystemPackageLIF(r14.pkg, r14, r12, r17, r13, r28);
        r20 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x02d4, code lost:
        if (DEBUG_REMOVE == false) goto L_0x02ee;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x02d6, code lost:
        android.util.Slog.d(TAG, "Removing non-system package: " + r14.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:164:0x02ee, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x02f6, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) == 0) goto L_0x02f9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:166:0x02f8, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:167:0x02f9, code lost:
        r18 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x02fd, code lost:
        if ((r17 & 8) != 0) goto L_0x0301;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x02ff, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:170:0x0301, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:172:0x0304, code lost:
        if (r1 == false) goto L_0x030e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x0306, code lost:
        killApplication(r10, r14.appId, "uninstall pkg");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x030e, code lost:
        r20 = r8;
        r1 = deleteInstalledPackageLIF(r14, r24, r17, r12, r13, r28, r29);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x0320, code lost:
        if (r18 == false) goto L_0x0331;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x0322, code lost:
        if (r1 == false) goto L_0x0331;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x0324, code lost:
        mHwPMSEx.recordUninstalledDelapp(r14.pkg.packageName, r14.pkg.codePath);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0331, code lost:
        if (r1 == false) goto L_0x0343;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x0333, code lost:
        r2 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0335, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:?, code lost:
        mHwPMSEx.updateCertCompatPackage(r14.pkg, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x033e, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x0343, code lost:
        if (r1 == false) goto L_0x0353;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:189:0x0345, code lost:
        r2 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:190:0x0347, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:?, code lost:
        r3 = 0;
        mHwPMSEx.writeCertCompatPackages(false);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x034e, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x0353, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:199:0x0354, code lost:
        if (r13 == null) goto L_0x040c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x035e, code lost:
        if (r9.mPackages.get(r14.name) != null) goto L_0x0362;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x0360, code lost:
        r0 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:203:0x0362, code lost:
        r0 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x0363, code lost:
        r13.removedForAllUsers = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:205:0x0367, code lost:
        if (r13.removedChildPackages == null) goto L_0x0396;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:206:0x0369, code lost:
        r2 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:207:0x036b, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:209:?, code lost:
        r0 = r13.removedChildPackages.size();
        r4 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:210:0x0373, code lost:
        if (r4 >= r0) goto L_0x0391;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:211:0x0375, code lost:
        r5 = r13.removedChildPackages.valueAt(r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:212:0x037d, code lost:
        if (r5 == null) goto L_0x038e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:214:0x0387, code lost:
        if (r9.mPackages.get(r5.removedPackage) != null) goto L_0x038b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:215:0x0389, code lost:
        r6 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:216:0x038b, code lost:
        r6 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:217:0x038c, code lost:
        r5.removedForAllUsers = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x038e, code lost:
        r4 = r4 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:219:0x0391, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:225:0x039a, code lost:
        if (isSystemApp(r14) == false) goto L_0x040c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:226:0x039c, code lost:
        r2 = r9.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:227:0x039e, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:229:?, code lost:
        r0 = r9.mSettings.getPackageLPr(r14.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:230:0x03a7, code lost:
        if (r0 == null) goto L_0x03b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:232:0x03ab, code lost:
        if (r0.childPackageNames == null) goto L_0x03b4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:233:0x03ad, code lost:
        r4 = r0.childPackageNames.size();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:234:0x03b4, code lost:
        r4 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:235:0x03b6, code lost:
        if (r3 >= r4) goto L_0x0407;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:236:0x03b8, code lost:
        r5 = (java.lang.String) r0.childPackageNames.get(r3);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:237:0x03c2, code lost:
        if (r13.removedChildPackages == null) goto L_0x03cc;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:239:0x03ca, code lost:
        if (r13.removedChildPackages.indexOfKey(r5) >= 0) goto L_0x0404;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:240:0x03cc, code lost:
        r6 = r9.mSettings.getPackageLPr(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:241:0x03d2, code lost:
        if (r6 != null) goto L_0x03d5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:243:0x03d5, code lost:
        r7 = new com.android.server.pm.PackageManagerService.PackageInstalledInfo();
        r7.name = r5;
        r7.newUsers = r6.queryInstalledUsers(r12, true);
        r7.pkg = r9.mPackages.get(r5);
        r7.uid = r6.pkg.applicationInfo.uid;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:244:0x03f6, code lost:
        if (r13.appearedChildPackages != null) goto L_0x03ff;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:245:0x03f8, code lost:
        r13.appearedChildPackages = new android.util.ArrayMap<>();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:246:0x03ff, code lost:
        r13.appearedChildPackages.put(r5, r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:247:0x0404, code lost:
        r3 = r3 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:248:0x0407, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:253:0x040c, code lost:
        return r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00c3, code lost:
        if (r14.pkg != null) goto L_0x00ce;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:40:0x00c5, code lost:
        android.util.Slog.w(TAG, "ps.pkg is null!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x00cd, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00d2, code lost:
        if (r14.pkg.applicationInfo != null) goto L_0x00dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x00d4, code lost:
        android.util.Slog.w(TAG, "ps.pkg.applicationInfo is null!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:45:0x00dc, code lost:
        return false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x00df, code lost:
        if (DEBUG_REMOVE == false) goto L_0x0111;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x00e1, code lost:
        android.util.Flog.i(209, "deletePackageLI: pkg " + r10 + " isSysApp: " + isSystemApp(r14) + " hwflag: " + r14.pkg.applicationInfo.hwFlags);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0119, code lost:
        if (isSystemApp(r14) == false) goto L_0x012f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x0122, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x012d;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x012b, code lost:
        if ((r14.pkg.applicationInfo.hwFlags & 67108864) == 0) goto L_0x012f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x012d, code lost:
        r2 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x012f, code lost:
        r2 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0132, code lost:
        if (r2 == false) goto L_0x0165;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x0134, code lost:
        if (r11 == null) goto L_0x0165;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x013a, code lost:
        if (r23.getIdentifier() == -1) goto L_0x0165;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x0143, code lost:
        if (sUserManager.getUserIds().length <= 1) goto L_0x0165;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0145, code lost:
        r2 = r14.queryInstalledUsers(sUserManager.getUserIds(), true);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0150, code lost:
        if (r2.length == 0) goto L_0x0160;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x0153, code lost:
        if (r2.length != 1) goto L_0x015e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x015b, code lost:
        if (r2[0] != r23.getIdentifier()) goto L_0x015e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x015e, code lost:
        r6 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0160, code lost:
        r6 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0161, code lost:
        if (r6 != false) goto L_0x0165;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0163, code lost:
        r1 = r1 | 4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0165, code lost:
        r17 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0167, code lost:
        if (r11 != null) goto L_0x016b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x0169, code lost:
        r1 = -1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x016b, code lost:
        r1 = r23.getIdentifier();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x016f, code lost:
        r8 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x017a, code lost:
        if (r14.getPermissionsState().hasPermission("android.permission.SUSPEND_APPS", r8) == false) goto L_0x017f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x017c, code lost:
        unsuspendForSuspendingPackage(r10, r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x0183, code lost:
        if (isSystemApp(r14) == false) goto L_0x0189;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x0187, code lost:
        if ((r17 & 4) == 0) goto L_0x0241;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x0189, code lost:
        if (r11 == null) goto L_0x0241;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x018f, code lost:
        if (r23.getIdentifier() == -1) goto L_0x0241;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x0191, code lost:
        markPackageUninstalledForUserLPw(r14, r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x0198, code lost:
        if (isSystemApp(r14) != false) goto L_0x01e0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x019a, code lost:
        r1 = shouldKeepUninstalledPackageLPr(r22);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01a8, code lost:
        if (r14.isAnyInstalled(sUserManager.getUserIds()) != false) goto L_0x01c6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:92:0x01aa, code lost:
        if (r1 == false) goto L_0x01ad;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01af, code lost:
        if (DEBUG_REMOVE == false) goto L_0x01b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01b1, code lost:
        android.util.Slog.d(TAG, "Not installed by other users, full delete");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x01b8, code lost:
        r14.setInstalled(true, r23.getIdentifier());
        r9.mSettings.writeKernelMappingLPr(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:98:0x01c8, code lost:
        if (DEBUG_REMOVE == false) goto L_0x01d1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x01ca, code lost:
        android.util.Slog.d(TAG, "Still installed by other users");
     */
    /* JADX WARNING: Multi-variable type inference failed */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        String str = packageName;
        UserHandle userHandle = user;
        int[] iArr = allUserHandles;
        int i = flags;
        PackageRemovedInfo packageRemovedInfo = outInfo;
        boolean z = false;
        if (str == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deletePackageLI: " + str + " user " + userHandle + " flags " + i);
        }
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(str);
            if (ps == null) {
                Slog.w(TAG, "Package named '" + str + "' doesn't exist.");
                return false;
            }
            int removedUserId = -1;
            if (ps.parentPackageName != null && (!isSystemApp(ps) || (i & 4) != 0)) {
                if (DEBUG_REMOVE) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Uninstalled child package:");
                    sb.append(str);
                    sb.append(" for user:");
                    sb.append(userHandle == null ? -1 : userHandle);
                    Slog.d(TAG, sb.toString());
                }
                if (userHandle != null) {
                    removedUserId = user.getIdentifier();
                }
                if (!clearPackageStateForUserLIF(ps, removedUserId, packageRemovedInfo)) {
                    return false;
                }
                markPackageUninstalledForUserLPw(ps, userHandle);
                scheduleWritePackageRestrictionsLocked(userHandle);
                return true;
            }
        }
    }

    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        PackageSetting packageSetting = ps;
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int length = userIds.length;
        int i = 0;
        while (i < length) {
            int nextUserId = userIds[i];
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Marking package:" + packageSetting.name + " uninstalled for user:" + nextUserId);
            }
            int i2 = nextUserId;
            packageSetting.setUserState(nextUserId, 0, 0, false, true, true, false, false, null, null, null, null, false, false, null, null, null, packageSetting.readUserState(nextUserId).domainVerificationStatus, 0, 0, null);
            i++;
            length = length;
            userIds = userIds;
            packageSetting = ps;
        }
        this.mSettings.writeKernelMappingLPr(ps);
    }

    private boolean clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(ps.name);
        }
        boolean z = false;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Updating package:" + ps.name + " install state for user:" + nextUserId);
            }
            destroyAppDataLIF(pkg, userId, 3);
            destroyAppProfilesLIF(pkg, userId);
            clearDefaultBrowserIfNeededForUser(ps.name, userId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            schedulePackageCleaning(ps.name, nextUserId, false);
            synchronized (this.mPackages) {
                if (clearPackagePreferredActivitiesLPw(ps.name, nextUserId)) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
        return true;
    }

    /* access modifiers changed from: private */
    public void clearExternalStorageDataSync(String packageName, int userId, boolean allData) {
        boolean mounted;
        String str = packageName;
        int i = userId;
        if (str == null) {
            Slog.w(TAG, "clearExternalStorageDataSync packageName is null!");
        } else if (!DEFAULT_CONTAINER_PACKAGE.equals(str)) {
            if (Environment.isExternalStorageEmulated()) {
                mounted = true;
            } else {
                String status = Environment.getExternalStorageState();
                mounted = status.equals("mounted") || status.equals("mounted_ro");
            }
            if (mounted) {
                Intent containerIntent = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
                int[] users = i == -1 ? sUserManager.getUserIds() : new int[]{i};
                ClearStorageConnection conn = new ClearStorageConnection();
                if (this.mContext.bindServiceAsUser(containerIntent, conn, 1, UserHandle.SYSTEM)) {
                    try {
                        for (int curUser : users) {
                            long timeout = SystemClock.uptimeMillis() + 480000;
                            synchronized (conn) {
                                while (conn.mContainerService == null) {
                                    long uptimeMillis = SystemClock.uptimeMillis();
                                    long now = uptimeMillis;
                                    if (uptimeMillis >= timeout) {
                                        break;
                                    }
                                    try {
                                        conn.wait(timeout - now);
                                    } catch (InterruptedException e) {
                                    }
                                    long uptimeMillis2 = SystemClock.uptimeMillis();
                                }
                            }
                            if (conn.mContainerService == null) {
                                Slog.w(TAG, "clearExternalStorageDataSync fail reason: Bind ContainerService Timeout");
                                this.mContext.unbindService(conn);
                                return;
                            }
                            Environment.UserEnvironment userEnv = new Environment.UserEnvironment(curUser);
                            clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppCacheDirs(str));
                            if (allData) {
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppDataDirs(str));
                                clearDirectory(conn.mContainerService, userEnv.buildExternalStorageAppMediaDirs(str));
                            }
                        }
                        this.mContext.unbindService(conn);
                    } catch (Throwable th) {
                        this.mContext.unbindService(conn);
                        throw th;
                    }
                }
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0029, code lost:
        r3 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x002d, code lost:
        if (r0 != null) goto L_0x002f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x002f, code lost:
        $closeResource(r2, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:26:0x0032, code lost:
        throw r3;
     */
    public void clearApplicationProfileData(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        PackageFreezer freezer = freezePackage(packageName, "clearApplicationProfileData");
        synchronized (this.mInstallLock) {
            clearAppProfilesLIF(pkg, -1);
        }
        if (freezer != null) {
            $closeResource(null, freezer);
        }
    }

    public void clearApplicationUserData(String packageName, IPackageDataObserver observer, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        boolean filterApp = ps != null && filterAppAccessLPr(ps, callingUid, userId);
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            PackageHandler packageHandler = this.mHandler;
            final boolean z = filterApp;
            final String str = packageName;
            final int i = userId;
            final IPackageDataObserver iPackageDataObserver = observer;
            AnonymousClass18 r3 = new Runnable() {
                /* JADX WARNING: Code restructure failed: missing block: B:40:0x00c0, code lost:
                    r2 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:44:0x00c4, code lost:
                    if (r0 != null) goto L_0x00c6;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:45:0x00c6, code lost:
                    if (r1 != null) goto L_0x00c8;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:47:?, code lost:
                    r0.close();
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:48:0x00cc, code lost:
                    r3 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:49:0x00cd, code lost:
                    r1.addSuppressed(r3);
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:50:0x00d1, code lost:
                    r0.close();
                 */
                public void run() {
                    boolean succeeded;
                    boolean succeeded2;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (!z) {
                        PackageFreezer freezer = PackageManagerService.this.freezePackage(str, "clearApplicationUserData");
                        long start = SystemClock.uptimeMillis();
                        synchronized (PackageManagerService.this.mInstallLock) {
                            succeeded2 = PackageManagerService.this.clearApplicationUserDataLIF(str, i);
                        }
                        long start2 = PackageManagerService.this.printClearDataTimeoutLogs("UserData", start, str);
                        PackageManagerService.this.clearExternalStorageDataSync(str, i, true);
                        long start3 = PackageManagerService.this.printClearDataTimeoutLogs("ExternalStorageData", start2, str);
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(str, i);
                        }
                        long start4 = PackageManagerService.this.printClearDataTimeoutLogs("Metadata", start3, str);
                        Slog.i(PackageManagerService.TAG, "clearApplicationUserData, finish freeze package:" + str);
                        if (freezer != null) {
                            freezer.close();
                        }
                        succeeded = succeeded2;
                        if (succeeded) {
                            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                            if (dsm != null) {
                                dsm.checkMemory();
                            }
                            IIndexClearManager indexClearManager = HwFrameworkFactory.getIndexClearManager();
                            if (indexClearManager != null) {
                                indexClearManager.clearUserIndexSearchData(str, i);
                            }
                            if (PackageManagerService.this.checkPermission("android.permission.SUSPEND_APPS", str, i) == 0) {
                                PackageManagerService.this.unsuspendForSuspendingPackage(str, i);
                            }
                        }
                    } else {
                        succeeded = false;
                    }
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(str, succeeded);
                            return;
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                            return;
                        }
                    } else {
                        return;
                    }
                    throw th;
                }
            };
            packageHandler.post(r3);
            return;
        }
        throw new SecurityException("Cannot clear data for a protected package: " + packageName);
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x004e, code lost:
        r1 = r2;
        clearAppDataLIF(r1, r8, 3);
        removeKeystoreDataIfNeeded(r8, android.os.UserHandle.getAppId(r1.applicationInfo.uid));
        r3 = getUserManagerInternal();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0066, code lost:
        if (r3.isUserUnlockingOrUnlocked(r8) == false) goto L_0x006a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x0068, code lost:
        r0 = 3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x006e, code lost:
        if (r3.isUserRunning(r8) == false) goto L_0x0073;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x0070, code lost:
        r0 = 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0073, code lost:
        prepareAppDataContentsLIF(r1, r8, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:25:0x0077, code lost:
        return true;
     */
    public boolean clearApplicationUserDataLIF(String packageName, int userId) {
        int flags = 0;
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    pkg = ps.pkg;
                }
            }
            if (pkg == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
    }

    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) this.mPackages.valueAt(i).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(PackageSetting ps, int userId) {
        int userSettableMask;
        PackageSetting packageSetting = ps;
        final int i = userId;
        if (packageSetting.pkg != null) {
            int userSettableMask2 = 75;
            boolean writeRuntimePermissions = false;
            int permissionCount = packageSetting.pkg.requestedPermissions.size();
            boolean writeInstallPermissions = false;
            int i2 = 0;
            while (i2 < permissionCount) {
                String permName = (String) packageSetting.pkg.requestedPermissions.get(i2);
                BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                if (bp == null) {
                    userSettableMask = userSettableMask2;
                } else {
                    if (packageSetting.sharedUser != null) {
                        boolean used = false;
                        int packageCount = packageSetting.sharedUser.packages.size();
                        int j = 0;
                        while (true) {
                            if (j < packageCount) {
                                PackageSetting pkg = packageSetting.sharedUser.packages.valueAt(j);
                                if (pkg.pkg != null) {
                                    userSettableMask = userSettableMask2;
                                    if (!pkg.pkg.packageName.equals(packageSetting.pkg.packageName) && pkg.pkg.requestedPermissions.contains(permName)) {
                                        used = true;
                                    }
                                } else {
                                    userSettableMask = userSettableMask2;
                                }
                                j++;
                                userSettableMask2 = userSettableMask;
                            } else {
                                userSettableMask = userSettableMask2;
                            }
                        }
                        if (used) {
                        }
                    } else {
                        userSettableMask = userSettableMask2;
                    }
                    PermissionsState permissionsState = ps.getPermissionsState();
                    int oldFlags = permissionsState.getPermissionFlags(permName, i);
                    boolean hasInstallState = permissionsState.getInstallPermissionState(permName) != null;
                    int flags = 0;
                    if (this.mSettings.mPermissions.mPermissionReviewRequired && packageSetting.pkg.applicationInfo.targetSdkVersion < 23) {
                        flags = 0 | 64;
                    }
                    if (permissionsState.updatePermissionFlags(bp, i, 75, flags)) {
                        if (hasInstallState) {
                            writeInstallPermissions = true;
                        } else {
                            writeRuntimePermissions = true;
                        }
                    }
                    if (bp.isRuntime() && (oldFlags & 20) == 0) {
                        if ((oldFlags & 32) != 0) {
                            if (permissionsState.grantRuntimePermission(bp, i) != -1) {
                                writeRuntimePermissions = true;
                            }
                        } else if ((flags & 64) == 0) {
                            switch (permissionsState.revokeRuntimePermission(bp, i)) {
                                case 0:
                                case 1:
                                    writeRuntimePermissions = true;
                                    final int appId = packageSetting.appId;
                                    PermissionsState permissionsState2 = permissionsState;
                                    this.mHandler.post(new Runnable() {
                                        public void run() {
                                            PackageManagerService.this.killUid(appId, i, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
                                        }
                                    });
                                    break;
                            }
                        }
                    }
                }
                i2++;
                userSettableMask2 = userSettableMask;
                packageSetting = ps;
            }
            if (writeRuntimePermissions) {
                this.mSettings.writeRuntimePermissionsForUserLPr(i, true);
            }
            if (writeInstallPermissions) {
                this.mSettings.writeLPr();
            }
        }
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                Slog.w(TAG, "Could not contact keystore to clear entries for app id " + appId);
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        if (packageName == null) {
            Slog.w(TAG, "Failed to delete cache files, for packageName is null!");
        } else {
            deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
        }
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        final PackageParser.Package pkg;
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES") == 0) {
                Slog.w(TAG, "Calling uid " + callingUid + " does not have " + "android.permission.INTERNAL_DELETE_CACHE_FILES" + ", silently ignoring");
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES", null);
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        PackageHandler packageHandler = this.mHandler;
        final int i = callingUid;
        final int i2 = hasAccessInstantApps;
        final int i3 = userId;
        final String str = packageName;
        final IPackageDataObserver iPackageDataObserver = observer;
        AnonymousClass20 r0 = new Runnable() {
            public void run() {
                PackageSetting ps = pkg == null ? null : (PackageSetting) pkg.mExtras;
                boolean doClearData = true;
                if (ps != null) {
                    doClearData = !ps.getInstantApp(UserHandle.getUserId(i)) || i2 == 0;
                }
                if (doClearData) {
                    synchronized (PackageManagerService.this.mInstallLock) {
                        PackageManagerService.this.clearAppDataLIF(pkg, i3, LightsManager.LIGHT_ID_MANUALCUSTOMBACKLIGHT);
                        PackageManagerService.this.clearAppDataLIF(pkg, i3, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                    }
                    PackageManagerService.this.clearExternalStorageDataSync(str, i3, false);
                }
                if (iPackageDataObserver != null) {
                    try {
                        iPackageDataObserver.onRemoveCompleted(str, true);
                    } catch (RemoteException e) {
                        Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                }
            }
        };
        packageHandler.post(r0);
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    /* JADX WARNING: Code restructure failed: missing block: B:11:?, code lost:
        r12.mInstaller.getAppSize(r1.volumeUuid, new java.lang.String[]{r13}, r14, 0, r1.appId, new long[]{r1.getCeDataInode(r14)}, new java.lang.String[]{r1.codePathString}, r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x004c, code lost:
        if (isSystemApp(r1) == false) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:14:0x0052, code lost:
        if (isUpdatedSystemApp(r1) != false) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:16:0x005d, code lost:
        if ((r1.pkg.applicationInfo.hwFlags & com.android.server.pm.DumpState.DUMP_HANDLE) != 0) goto L_0x0063;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:17:0x005f, code lost:
        r15.codeSize = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0063, code lost:
        r15.dataSize -= r15.cacheSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x006b, code lost:
        return true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:20:0x006c, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:21:0x006d, code lost:
        android.util.Slog.w(TAG, java.lang.String.valueOf(r0));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x0076, code lost:
        return false;
     */
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Failed to find settings for " + packageName);
                return false;
            }
        }
    }

    /* access modifiers changed from: private */
    public int getUidTargetSdkVersionLockedLPr(int uid) {
        Object obj = this.mSettings.getUserIdLPr(uid);
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.pkg != null) {
                    int v = ps.pkg.applicationInfo.targetSdkVersion;
                    if (v < vers) {
                        vers = v;
                    }
                }
            }
            return vers;
        }
        if (obj instanceof PackageSetting) {
            PackageSetting ps2 = (PackageSetting) obj;
            if (ps2.pkg != null) {
                return ps2.pkg.applicationInfo.targetSdkVersion;
            }
        }
        return 10000;
    }

    /* access modifiers changed from: private */
    public int getPackageTargetSdkVersionLockedLPr(String packageName) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            return p.applicationInfo.targetSdkVersion;
        }
        return 10000;
    }

    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_ADDPREFERREDACTIVITY);
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
    }

    /* access modifiers changed from: protected */
    public void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        IntentFilter intentFilter = filter;
        ComponentName componentName = activity;
        int i = userId;
        String str = opname;
        int callingUid = Binder.getCallingUid();
        if (componentName != null) {
            Slog.d(TAG, str + "add pref activity " + activity.flattenToShortString() + " from uid " + Binder.getCallingUid());
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, i, true, false, "add preferred activity");
        if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
            return;
        }
        if (intentFilter.hasCategory("android.intent.category.HOME") && componentName != null) {
            if (intentFilter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                Settings.Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
            } else if (!mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, i), i)) {
                Slog.i(TAG, "NOT ALLOWED TO add preferred activity current time!");
                return;
            }
        }
        synchronized (this.mPackages) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                    Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                    return;
                }
                this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
            }
            PreferredIntentResolver pir = this.mSettings.editPreferredActivitiesLPw(i);
            if (componentName == null) {
                Slog.w(TAG, "Cannot set a preferred activity with activity is null");
                return;
            }
            Slog.i(TAG, str + " activity " + activity.flattenToShortString() + " for user " + i + ":");
            intentFilter.dump(new LogPrinter(4, TAG), "  ");
            PreferredActivity preferredActivity = new PreferredActivity(intentFilter, match, set, componentName, always);
            pir.addFilter(preferredActivity);
            scheduleWritePackageRestrictionsLocked(i);
            postPreferredActivityChangedBroadcast(i);
            mHwPMSEx.hwAddRequirementForDefaultHome(intentFilter, componentName, i);
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new Runnable(userId) {
            private final /* synthetic */ int f$0;

            {
                this.f$0 = r1;
            }

            public final void run() {
                PackageManagerService.lambda$postPreferredActivityChangedBroadcast$7(this.f$0);
            }
        });
    }

    static /* synthetic */ void lambda$postPreferredActivityChangedBroadcast$7(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            Intent intent2 = intent;
            try {
                am.broadcastIntent(null, intent, null, null, 0, null, null, null, -1, null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:58:0x0204, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x0279, code lost:
        addPreferredActivityInternal(r10, r17, r14, r11, true, r12, "Replacing preferred");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x0286, code lost:
        return;
     */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x0209 A[Catch:{ all -> 0x028c }] */
    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        ComponentName[] componentNameArr;
        IntentFilter intentFilter = filter;
        ComponentName componentName = activity;
        int i = userId;
        if (filter.countActions() != 1) {
            ComponentName[] componentNameArr2 = set;
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
        } else if (filter.countDataAuthorities() == 0 && filter.countDataPaths() == 0 && filter.countDataSchemes() <= 1 && filter.countDataTypes() == 0) {
            int i2 = 0;
            if (intentFilter.hasCategory("android.intent.category.HOME") && componentName != null) {
                if (intentFilter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                    Settings.Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
                } else if (!mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, i), i)) {
                    Slog.i(TAG, "NOT ALLOWED TO replace preferred activity current time!");
                    throw new IllegalArgumentException("Component " + componentName + " not allowed to be home on user " + i);
                }
            }
            int callingUid = Binder.getCallingUid();
            this.mPermissionManager.enforceCrossUserPermission(callingUid, i, true, false, "replace preferred activity");
            synchronized (this.mPackages) {
                try {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                        if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                            Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                            return;
                        }
                        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                    }
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(i);
                    if (pir != null) {
                        ArrayList<PreferredActivity> existing = pir.findFilters(intentFilter);
                        if (existing != null && existing.size() == 1) {
                            PreferredActivity cur = existing.get(0);
                            if (DEBUG_PREFERRED) {
                                Slog.i(TAG, "Checking replace of preferred:");
                                intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                if (!cur.mPref.mAlways) {
                                    Slog.i(TAG, "  -- CUR; not mAlways!");
                                } else {
                                    Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                                    Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                                    Slog.i(TAG, "  -- NEW: mMatch=" + (match & 268369920));
                                    Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                                    Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                                }
                            }
                            if (cur.mPref.mAlways && cur.mPref.mComponent.equals(componentName) && cur.mPref.mMatch == (match & 268369920)) {
                                componentNameArr = set;
                                try {
                                    if (cur.mPref.sameSet(componentNameArr)) {
                                        if (DEBUG_PREFERRED) {
                                            Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + i + ":");
                                            intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                        }
                                    }
                                    if (existing != null) {
                                        if (DEBUG_PREFERRED) {
                                            Slog.i(TAG, existing.size() + " existing preferred matches for:");
                                            intentFilter.dump(new LogPrinter(4, TAG), "  ");
                                        }
                                        while (true) {
                                            int i3 = i2;
                                            if (i3 >= existing.size()) {
                                                break;
                                            }
                                            PreferredActivity pa = existing.get(i3);
                                            if (DEBUG_PREFERRED) {
                                                Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                                                pa.dump(new LogPrinter(4, TAG), "  ");
                                            }
                                            pir.removeFilter(pa);
                                            i2 = i3 + 1;
                                        }
                                    }
                                } catch (Throwable th) {
                                    th = th;
                                    throw th;
                                }
                            }
                        }
                        componentNameArr = set;
                        if (existing != null) {
                        }
                    } else {
                        componentNameArr = set;
                    }
                } catch (Throwable th2) {
                    th = th2;
                    ComponentName[] componentNameArr3 = set;
                    throw th;
                }
            }
        } else {
            ComponentName[] componentNameArr4 = set;
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:28:0x007b, code lost:
        return;
     */
    public void clearPackagePreferredActivities(String packageName) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_CLEARPACKAGEPREFERREDACTIVITIES);
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                if ((pkg == null || pkg.applicationInfo.uid != callingUid) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        Slog.w(TAG, "Ignoring clearPackagePreferredActivities() from uid " + callingUid);
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps == null || !filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    int user = UserHandle.getCallingUserId();
                    if (clearPackagePreferredActivitiesLPw(packageName, user)) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public boolean clearPackagePreferredActivitiesLPw(String packageName, int userId) {
        Slog.d(TAG, "clear pref activity " + packageName + " from uid " + Binder.getCallingUid());
        boolean changed = false;
        ArrayList<PreferredActivity> removed = null;
        for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
            int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
            if (userId == -1 || userId == thisUserId) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (!HwDeviceManager.disallowOp(17) || !pa.hasAction("android.intent.action.MAIN") || !pa.hasCategory("android.intent.category.HOME") || !pa.hasCategory("android.intent.category.DEFAULT")) {
                            if (removed == null) {
                                removed = new ArrayList<>();
                            }
                            removed.add(pa);
                        }
                    }
                }
                if (removed != null) {
                    for (int j = 0; j < removed.size(); j++) {
                        pir.removeFilter(removed.get(j));
                    }
                    changed = true;
                }
            }
        }
        if (changed) {
            postPreferredActivityChangedBroadcast(userId);
        }
        return changed;
    }

    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(this.mPackages.valueAt(i).packageName, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void clearIntentFilterVerificationsLPw(String packageName, int userId) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                clearPackagePreferredActivitiesLPw(null, userId);
                this.mSettings.applyDefaultPreferredAppsLPw(this, userId);
                applyFactoryDefaultBrowserLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            resetNetworkPolicies(userId);
            Binder.restoreCallingIdentity(identity);
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
            throw th;
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else {
            if (filter.hasCategory("android.intent.category.HOME") && activity != null) {
                if (filter.hasAction("android.intent.action.MDM_SET_DEFAULT_LAUNCHER_FOR_ANTIMAL")) {
                    Settings.Global.putInt(this.mContext.getContentResolver(), "hwMdmActionForAntimalFlag", 1);
                } else if (!mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                    Slog.i(TAG, "NOT ALLOWED TO add persistent preferred activity current time!");
                    return;
                }
            }
            synchronized (this.mPackages) {
                Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() == 1000) {
            boolean changed = false;
            synchronized (this.mPackages) {
                ArrayList<PersistentPreferredActivity> removed = null;
                for (int i = 0; i < this.mSettings.mPersistentPreferredActivities.size(); i++) {
                    int thisUserId = this.mSettings.mPersistentPreferredActivities.keyAt(i);
                    PersistentPreferredIntentResolver ppir = this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == thisUserId) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (it.hasNext()) {
                            PersistentPreferredActivity ppa = it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed == null) {
                                    removed = new ArrayList<>();
                                }
                                removed.add(ppa);
                            }
                        }
                        if (removed != null) {
                            for (int j = 0; j < removed.size(); j++) {
                                ppir.removeFilter(removed.get(j));
                            }
                            changed = true;
                        }
                    }
                }
                if (changed) {
                    scheduleWritePackageRestrictionsLocked(userId);
                    postPreferredActivityChangedBroadcast(userId);
                }
            }
            return;
        }
        throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
    }

    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        int next;
        do {
            int next2 = parser.next();
            type = next2;
            if (next2 == 2) {
                break;
            }
        } while (type != 1);
        if (type != 2) {
            if (DEBUG_BACKUP) {
                Slog.e(TAG, "Didn't find start tag during restore");
            }
            return;
        }
        Slog.v(TAG, ":: restoreFromXml() : got to tag " + parser.getName());
        if (!expectedStartTag.equals(parser.getName())) {
            if (DEBUG_BACKUP) {
                Slog.e(TAG, "Found unexpected tag " + parser.getName());
            }
            return;
        }
        do {
            next = parser.next();
            int type2 = next;
        } while (next == 4);
        Slog.v(TAG, ":: stepped forward, applying functor at tag " + parser.getName());
        functor.apply(parser, userId);
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_PREFERRED_BACKUP);
                synchronized (this.mPackages) {
                    this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
                }
                serializer.endTag(null, TAG_PREFERRED_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write preferred activities for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getPreferredActivityBackup()");
        }
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readPreferredActivitiesLPw(parser, userId);
                        }
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_DEFAULT_APPS);
                synchronized (this.mPackages) {
                    this.mSettings.writeDefaultAppsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_DEFAULT_APPS);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getDefaultAppsBackup()");
        }
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readDefaultAppsLPw(parser, userId);
                        }
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring default apps: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restoreDefaultApps()");
        }
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
                synchronized (this.mPackages) {
                    this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
        }
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mSettings.readAllDomainVerificationsLPr(parser, userId);
                            PackageManagerService.this.mSettings.writeLPr();
                        }
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public byte[] getPermissionGrantBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_PERMISSION_BACKUP);
                synchronized (this.mPackages) {
                    serializeRuntimePermissionGrantsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_PERMISSION_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getPermissionGrantBackup()");
        }
    }

    public void restorePermissionGrants(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PERMISSION_BACKUP, new BlobXmlRestorer() {
                    public void apply(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.processRestoredPermissionGrantsLPr(parser, userId);
                        }
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePermissionGrants()");
        }
    }

    private void serializeRuntimePermissionGrantsLPr(XmlSerializer serializer, int userId) throws IOException {
        PackageManagerService packageManagerService = this;
        XmlSerializer xmlSerializer = serializer;
        xmlSerializer.startTag(null, TAG_ALL_GRANTS);
        int N = packageManagerService.mSettings.mPackages.size();
        int i = 0;
        while (i < N) {
            boolean pkgGrantsKnown = false;
            for (PermissionsState.PermissionState state : packageManagerService.mSettings.mPackages.valueAt(i).getPermissionsState().getRuntimePermissionStates(userId)) {
                int grantFlags = state.getFlags();
                if ((grantFlags & 52) == 0) {
                    boolean isGranted = state.isGranted();
                    if (isGranted || (grantFlags & 11) != 0) {
                        String packageName = packageManagerService.mSettings.mPackages.keyAt(i);
                        if (!pkgGrantsKnown) {
                            xmlSerializer.startTag(null, TAG_GRANT);
                            xmlSerializer.attribute(null, "pkg", packageName);
                            pkgGrantsKnown = true;
                        }
                        boolean revoke = true;
                        boolean userSet = (grantFlags & 1) != 0;
                        boolean userFixed = (grantFlags & 2) != 0;
                        if ((grantFlags & 8) == 0) {
                            revoke = false;
                        }
                        xmlSerializer.startTag(null, TAG_PERMISSION);
                        xmlSerializer.attribute(null, "name", state.getName());
                        if (isGranted) {
                            xmlSerializer.attribute(null, ATTR_IS_GRANTED, "true");
                        }
                        if (userSet) {
                            xmlSerializer.attribute(null, ATTR_USER_SET, "true");
                        }
                        if (userFixed) {
                            xmlSerializer.attribute(null, ATTR_USER_FIXED, "true");
                        }
                        if (revoke) {
                            xmlSerializer.attribute(null, ATTR_REVOKE_ON_UPGRADE, "true");
                        }
                        xmlSerializer.endTag(null, TAG_PERMISSION);
                    }
                }
                packageManagerService = this;
            }
            if (pkgGrantsKnown) {
                xmlSerializer.endTag(null, TAG_GRANT);
            }
            i++;
            packageManagerService = this;
        }
        int i2 = userId;
        xmlSerializer.endTag(null, TAG_ALL_GRANTS);
    }

    /* access modifiers changed from: private */
    public void processRestoredPermissionGrantsLPr(XmlPullParser parser, int userId) throws XmlPullParserException, IOException {
        XmlPullParser xmlPullParser = parser;
        int i = userId;
        int outerDepth = parser.getDepth();
        String pkgName = null;
        while (true) {
            int outerDepth2 = outerDepth;
            int next = parser.next();
            int type = next;
            if (next == 1 || (type == 3 && parser.getDepth() <= outerDepth2)) {
                scheduleWriteSettingsLocked();
                this.mSettings.writeRuntimePermissionsForUserLPr(i, false);
            } else {
                if (!(type == 3 || type == 4)) {
                    String tagName = parser.getName();
                    if (tagName.equals(TAG_GRANT)) {
                        pkgName = xmlPullParser.getAttributeValue(null, "pkg");
                        if (DEBUG_BACKUP) {
                            Slog.v(TAG, "+++ Restoring grants for package " + pkgName);
                        }
                    } else if (tagName.equals(TAG_PERMISSION)) {
                        boolean isGranted = "true".equals(xmlPullParser.getAttributeValue(null, ATTR_IS_GRANTED));
                        String permName = xmlPullParser.getAttributeValue(null, "name");
                        int newFlagSet = 0;
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_USER_SET))) {
                            newFlagSet = 0 | 1;
                        }
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_USER_FIXED))) {
                            newFlagSet |= 2;
                        }
                        if ("true".equals(xmlPullParser.getAttributeValue(null, ATTR_REVOKE_ON_UPGRADE))) {
                            newFlagSet |= 8;
                        }
                        int newFlagSet2 = newFlagSet;
                        if (DEBUG_BACKUP) {
                            Slog.v(TAG, "  + Restoring grant: pkg=" + pkgName + " perm=" + permName + " granted=" + isGranted + " bits=0x" + Integer.toHexString(newFlagSet2));
                        }
                        PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                        if (ps != null) {
                            if (DEBUG_BACKUP) {
                                Slog.v(TAG, "        + already installed; applying");
                            }
                            PermissionsState perms = ps.getPermissionsState();
                            BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                            if (bp != null) {
                                if (isGranted) {
                                    perms.grantRuntimePermission(bp, i);
                                }
                                if (newFlagSet2 != 0) {
                                    perms.updatePermissionFlags(bp, i, 11, newFlagSet2);
                                }
                            }
                        } else {
                            if (DEBUG_BACKUP) {
                                Slog.v(TAG, "        - not yet installed; saving for later");
                            }
                            PackageSetting packageSetting = ps;
                            this.mSettings.processRestoredPermissionGrantLPr(pkgName, permName, isGranted, newFlagSet2, i);
                        }
                    } else {
                        reportSettingsProblem(5, "Unknown element under <perm-grant-backup>: " + tagName);
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                outerDepth = outerDepth2;
            }
        }
        scheduleWriteSettingsLocked();
        this.mSettings.writeRuntimePermissionsForUserLPr(i, false);
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                int i = 0;
                while (i < size) {
                    if (!newFilter.equalsIgnoreFilter(existing.get(i))) {
                        i++;
                    } else {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            Iterator<CrossProfileIntentFilter> it = new ArraySet<>(resolver.filterSet()).iterator();
            while (it.hasNext()) {
                CrossProfileIntentFilter filter = it.next();
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, 0, callingUserId);
            if (pi == null) {
                throw new IllegalArgumentException("Unknown package " + pkg + " on user " + callingUserId);
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                throw new SecurityException("Calling uid " + callingUid + " does not own package " + pkg);
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionCommitBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
        }
    }

    /* access modifiers changed from: private */
    public ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList<>();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    /* access modifiers changed from: package-private */
    public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        Intent intent = getHomeIntent();
        ComponentName componentName = null;
        List<ResolveInfo> list = queryIntentActivitiesInternal(intent, null, 128, userId);
        if (this.mCustPms != null && !this.mCustPms.containsCustHome(list)) {
            return null;
        }
        ResolveInfo preferred = findPreferredActivity(intent, null, 0, list, 0, true, false, false, userId);
        allHomeCandidates.clear();
        if (list != null) {
            for (ResolveInfo ri : list) {
                allHomeCandidates.add(ri);
            }
        }
        if (!(preferred == null || preferred.activityInfo == null)) {
            componentName = new ComponentName(preferred.activityInfo.packageName, preferred.activityInfo.name);
        }
        return componentName;
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList<>();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = homeActivities.get(i).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), 1048576, set, comp, userId);
                return;
            }
            throw new IllegalArgumentException("Component " + comp + " cannot be home on user " + userId);
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one setup wizard; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one storage manager; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    public String getSystemTextClassifierPackageName() {
        return this.mContext.getString(17039791);
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETAPPLICATIONENABLEDSETTING);
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            Log.v(TAG, "Setting application enabled setting: appPackageName=" + appPackageName + " newState=" + newState + " flags=" + flags + " userId=" + userId + " callingPackage=" + callingPackage);
            setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETCOMPONENTENABLEDSETTING, new Object[]{Integer.valueOf(newState)});
        if (sUserManager.exists(userId) && componentName != null) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:100:0x025f, code lost:
        r1 = r8.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x0261, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0266, code lost:
        if (r6.getEnabled(r13) != r11) goto L_0x0272;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:106:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:0x0269, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:108:0x026a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x026b, code lost:
        r32 = r5;
        r12 = r6;
        r34 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0273, code lost:
        r7 = r6.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x0277, code lost:
        if (r7.isStub == false) goto L_0x0281;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x027d, code lost:
        if (r7.isSystem() == false) goto L_0x0281;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x027f, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x0281, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x0285, code lost:
        if (r1 == false) goto L_0x0509;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x0287, code lost:
        if (r11 == 0) goto L_0x0294;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x0289, code lost:
        if (r11 != 1) goto L_0x028c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x028c, code lost:
        r32 = r5;
        r12 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0294, code lost:
        r4 = decompressPackage(r7);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0298, code lost:
        if (r4 != null) goto L_0x02b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x029a, code lost:
        android.util.Slog.e(TAG, "couldn't decompress pkg: " + r6.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x02b2, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x02b3, code lost:
        r3 = new android.content.pm.PackageParser();
        r3.setSeparateProcesses(r8.mSeparateProcesses);
        r3.setDisplayMetrics(r8.mMetrics);
        r3.setCallback(r8.mPackageParserCallback);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:0x02d0, code lost:
        r2 = r3.parsePackage(r4, 16 | (r8.mDefParseFlags | 1));
        r1 = r8.mInstallLock;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x02d5, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:?, code lost:
        removePackageLI(r7, true);
        r14 = r8.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x02db, code lost:
        monitor-enter(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:136:?, code lost:
        disableSystemPackageLPw(r7, r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:137:0x02df, code lost:
        monitor-exit(r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:140:0x02e9, code lost:
        r14 = freezePackage(r7.packageName, "setEnabledSetting");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:143:0x02ed, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r31 = r4;
        r32 = r5;
        r33 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:145:?, code lost:
        r7 = scanPackageTracedLI(r4, (r8.mDefParseFlags | Integer.MIN_VALUE) | 64, 0, 0, (android.os.UserHandle) null);
        prepareAppDataAfterInstallLIF(r7);
        r6 = r8.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:146:0x031a, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:149:?, code lost:
        updateSharedLibrariesLPr(r7, null);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:150:0x0320, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:151:0x0321, code lost:
        r25 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:152:0x0324, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:153:0x0325, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:155:?, code lost:
        android.util.Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:175:0x036b, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x036c, code lost:
        r1 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x036e, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x036f, code lost:
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:179:0x0371, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x0372, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r31 = r4;
        r32 = r5;
        r33 = r6;
        r34 = r15;
        r15 = r7;
        r1 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x0383, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:182:0x0384, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r31 = r4;
        r32 = r5;
        r33 = r6;
        r34 = r15;
        r15 = r7;
        r1 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:?, code lost:
        throw r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x0395, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x0396, code lost:
        if (r14 != null) goto L_0x0398;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:?, code lost:
        $closeResource(r1, r14);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x03a5, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:194:0x03a6, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x03a7, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r32 = r5;
        r34 = r15;
        r15 = r7;
        r25 = r4;
        r12 = r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x03b7, code lost:
        r0 = e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x03b8, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r31 = r4;
        r32 = r5;
        r33 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:250:0x0445, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:300:0x04bf, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:301:0x04c0, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r25 = r4;
        r32 = r5;
        r12 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:305:?, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:306:0x04d0, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:308:0x04d2, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:309:0x04d3, code lost:
        r28 = r1;
        r29 = r2;
        r30 = r3;
        r25 = r4;
        r32 = r5;
        r12 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:312:0x04e3, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:313:0x04e5, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:314:0x04e6, code lost:
        r30 = r3;
        r25 = r4;
        r32 = r5;
        r34 = r15;
        r15 = r7;
        android.util.Slog.w(TAG, "Failed to parse compressed system package:" + r6.name, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:315:0x0508, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:316:0x0509, code lost:
        r32 = r5;
        r12 = r6;
        r34 = r15;
        r15 = r7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:331:0x0526, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:332:0x0527, code lost:
        r32 = r5;
        r12 = r6;
        r34 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:334:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:335:0x052d, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:336:0x052e, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:337:0x0530, code lost:
        r32 = r5;
        r12 = r6;
        r34 = r15;
        r1 = r8.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:338:0x0537, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:340:?, code lost:
        r2 = r12.pkg;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:341:0x053a, code lost:
        if (r2 == null) goto L_0x054a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:344:0x0540, code lost:
        if (r2.hasComponentClassName(r10) != false) goto L_0x0590;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:346:0x0543, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:347:0x0544, code lost:
        r6 = r32;
        r7 = r42;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:348:0x054a, code lost:
        if (r2 == null) goto L_0x0572;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:350:0x0550, code lost:
        if (r2.applicationInfo.targetSdkVersion >= 16) goto L_0x0553;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:353:0x0571, code lost:
        throw new java.lang.IllegalArgumentException("Component class " + r10 + " does not exist in " + r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:356:?, code lost:
        android.util.Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + r10 + " does not exist in " + r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:357:0x0590, code lost:
        switch(r11) {
            case 0: goto L_0x05ab;
            case 1: goto L_0x05a3;
            case 2: goto L_0x059b;
            default: goto L_0x0593;
        };
     */
    /* JADX WARNING: Code restructure failed: missing block: B:358:0x0593, code lost:
        r6 = r32;
        r7 = r42;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:361:0x059f, code lost:
        if (r12.disableComponentLPw(r10, r13) != false) goto L_0x05b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:362:0x05a1, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:363:0x05a2, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:365:0x05a7, code lost:
        if (r12.enableComponentLPw(r10, r13) != false) goto L_0x05b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:366:0x05a9, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:367:0x05aa, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:370:0x05af, code lost:
        if (r12.restoreComponentLPw(r10, r13) != false) goto L_0x05b3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:372:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:373:0x05b2, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:375:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:376:0x05b4, code lost:
        r2 = r44;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:422:0x0633, code lost:
        r1 = r0;
        r2 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:423:0x0638, code lost:
        if (r19 == false) goto L_0x0655;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:426:0x0640, code lost:
        r4 = android.os.UserHandle.getUid(r13, r12.appId);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:427:0x0643, code lost:
        if ((r7 & 1) == 0) goto L_0x0646;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:428:0x0646, code lost:
        r15 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:430:?, code lost:
        sendPackageChangedBroadcast(r9, r15, r1, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:431:0x064c, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:432:0x064d, code lost:
        r22 = r4;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:433:0x0650, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:434:0x0651, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:435:0x0654, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:437:0x0657, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:438:0x065b, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:454:?, code lost:
        android.util.Slog.e(TAG, "Invalid new component state: " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:455:0x0691, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:456:0x0692, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:457:0x0693, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:458:0x0694, code lost:
        r6 = r32;
        r7 = r42;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:459:0x0698, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:460:0x0699, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:461:0x069a, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:462:0x069c, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:463:0x069d, code lost:
        r7 = r12;
        r34 = r15;
        r12 = r6;
        r6 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:465:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:466:0x06a3, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:467:0x06a4, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x018d, code lost:
        if (android.os.UserHandle.isSameApp(r15, r6.appId) != false) goto L_0x020b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x018f, code lost:
        if (r18 == false) goto L_0x01b8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0195, code lost:
        if (filterAppAccessLPr(r6, r15, r13) == false) goto L_0x0198;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x019e, code lost:
        if (r8.mProtectedPackages.isPackageStateProtected(r13, r9) != false) goto L_0x01a1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:69:0x01b7, code lost:
        throw new java.lang.SecurityException("Cannot disable a protected package: " + r9);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x01b8, code lost:
        r1 = new java.lang.StringBuilder();
        r1.append("Attempt to change component state; pid=");
        r1.append(android.os.Binder.getCallingPid());
        r1.append(", uid=");
        r1.append(r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x01d3, code lost:
        if (r10 != null) goto L_0x01e7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x01d5, code lost:
        r2 = ", package=" + r9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x01e7, code lost:
        r2 = ", component=" + r9 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r10;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x0200, code lost:
        r1.append(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x020a, code lost:
        throw new java.lang.SecurityException(r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x020b, code lost:
        r2 = r8.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x020d, code lost:
        monitor-enter(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x0210, code lost:
        if (r15 != 2000) goto L_0x025a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x0216, code lost:
        if ((r6.pkgFlags & 256) != 0) goto L_0x025a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0218, code lost:
        r0 = r6.getEnabled(r13);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x021c, code lost:
        if (r10 != null) goto L_0x022b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x021e, code lost:
        if (r0 == 3) goto L_0x0224;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x0220, code lost:
        if (r0 == 0) goto L_0x0224;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x0222, code lost:
        if (r0 != 1) goto L_0x022b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:88:0x0224, code lost:
        if (r11 == 3) goto L_0x025a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:0x0226, code lost:
        if (r11 == 0) goto L_0x025a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x0228, code lost:
        if (r11 != 1) goto L_0x022b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:0x0251, code lost:
        throw new java.lang.SecurityException("Shell cannot change component state for " + r9 + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r10 + " to " + r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x0252, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x0253, code lost:
        r7 = r12;
        r34 = r15;
        r12 = r6;
        r6 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:?, code lost:
        monitor-exit(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:99:0x025d, code lost:
        if (r10 != null) goto L_0x0530;
     */
    /* JADX WARNING: Removed duplicated region for block: B:187:0x0398 A[SYNTHETIC, Splitter:B:187:0x0398] */
    /* JADX WARNING: Removed duplicated region for block: B:213:0x03f5 A[SYNTHETIC, Splitter:B:213:0x03f5] */
    /* JADX WARNING: Removed duplicated region for block: B:223:0x0414  */
    /* JADX WARNING: Removed duplicated region for block: B:229:0x041b A[SYNTHETIC, Splitter:B:229:0x041b] */
    /* JADX WARNING: Removed duplicated region for block: B:260:0x0459 A[SYNTHETIC, Splitter:B:260:0x0459] */
    /* JADX WARNING: Removed duplicated region for block: B:275:0x0484 A[SYNTHETIC, Splitter:B:275:0x0484] */
    /* JADX WARNING: Removed duplicated region for block: B:288:0x049c A[SYNTHETIC, Splitter:B:288:0x049c] */
    /* JADX WARNING: Unknown top exception splitter block from list: {B:278:0x0493=Splitter:B:278:0x0493, B:226:0x0418=Splitter:B:226:0x0418, B:285:0x0499=Splitter:B:285:0x0499, B:235:0x042d=Splitter:B:235:0x042d, B:302:0x04ce=Splitter:B:302:0x04ce} */
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        int permission;
        boolean sendNow;
        String componentName;
        boolean z;
        Object obj;
        PackageSetting pkgSetting;
        File codePath;
        PackageParser.Package deletedPkg;
        Throwable th;
        PackageFreezer freezer;
        Throwable th2;
        PackageFreezer freezer2;
        PackageParser.Package pkg;
        ArrayMap<String, PackageParser.Package> arrayMap;
        PackageParser.Package pkg2;
        String str;
        String str2 = packageName;
        String str3 = className;
        int i = newState;
        int i2 = flags;
        int i3 = userId;
        if (i == 0 || i == 1 || i == 2 || i == 3 || i == 4) {
            Flog.i(206, "setEnabledSetting pkg:" + str2 + ", className:" + str3 + ", newState:" + i + ", flags:" + i2 + ", userId:" + i3 + ", CallingPid:" + Binder.getCallingPid() + ", CallingUid:" + Binder.getCallingUid());
            if (TextUtils.isEmpty(packageName) || (!(i == 2 || i == 3 || i == 4) || mHwPMSEx == null || mHwPMSEx.isAllowedToBeDisabled(str2))) {
                int callingUid = Binder.getCallingUid();
                if (callingUid == 1000) {
                    permission = 0;
                } else {
                    permission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
                }
                int permission2 = permission;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, i3, false, true, "set enabled");
                boolean allowedByPermission = permission2 == 0;
                sendNow = false;
                boolean isApp = str3 == null;
                boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
                String componentName2 = isApp ? str2 : str3;
                synchronized (this.mPackages) {
                    try {
                        PackageSetting pkgSetting2 = this.mSettings.mPackages.get(str2);
                        if (pkgSetting2 == null) {
                            if (isCallerInstantApp) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Attempt to change component state; pid=");
                                sb.append(Binder.getCallingPid());
                                sb.append(", uid=");
                                sb.append(callingUid);
                                if (str3 == null) {
                                    str = ", package=" + str2;
                                } else {
                                    str = ", component=" + str2 + SliceClientPermissions.SliceAuthority.DELIMITER + str3;
                                }
                                sb.append(str);
                                throw new SecurityException(sb.toString());
                            } else if (str3 == null) {
                                try {
                                    throw new IllegalArgumentException("Unknown package: " + str2);
                                } catch (Throwable th3) {
                                    th = th3;
                                    String str4 = componentName2;
                                    int i4 = i2;
                                    int i5 = callingUid;
                                    while (true) {
                                        try {
                                            break;
                                        } catch (Throwable th4) {
                                            th = th4;
                                        }
                                    }
                                    throw th;
                                }
                            } else {
                                throw new IllegalArgumentException("Unknown component: " + str2 + SliceClientPermissions.SliceAuthority.DELIMITER + str3);
                            }
                        }
                    } catch (Throwable th5) {
                        th = th5;
                        String str5 = componentName2;
                        int i6 = i2;
                        int i7 = callingUid;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } else {
                return;
            }
        } else {
            throw new IllegalArgumentException("Invalid new component state: " + i);
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = arrayMap;
        try {
            this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
            this.mSettings.writeLPr();
            if (freezer2 != null) {
                try {
                    $closeResource(null, freezer2);
                } catch (PackageManagerException e) {
                    e = e;
                    PackageManagerException e2 = e;
                    try {
                        StringBuilder sb2 = new StringBuilder();
                        sb2.append("Failed to install compressed system package:");
                        PackageSetting pkgSetting3 = pkgSetting;
                        try {
                            sb2.append(pkgSetting3.name);
                            Slog.w(TAG, sb2.toString(), e2);
                            File codePath2 = codePath;
                            try {
                                removeCodePathLI(codePath2);
                                try {
                                    PackageFreezer freezer3 = freezePackage(deletedPkg.packageName, "setEnabledSetting");
                                    try {
                                        synchronized (this.mPackages) {
                                            try {
                                                enableSystemPackageLPw(deletedPkg);
                                            } catch (Throwable th6) {
                                                th = th6;
                                                if (freezer != null) {
                                                }
                                                throw th;
                                            }
                                        }
                                        PackageFreezer freezer4 = freezer3;
                                        File file = codePath2;
                                        PackageSetting packageSetting = pkgSetting3;
                                        try {
                                            installPackageFromSystemLIF(deletedPkg.codePath, false, null, null, null, true);
                                            PackageFreezer freezer5 = freezer4;
                                            if (freezer5 != null) {
                                                try {
                                                    $closeResource(null, freezer5);
                                                } catch (PackageManagerException e3) {
                                                    pme = e3;
                                                    try {
                                                        Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme);
                                                        synchronized (this.mPackages) {
                                                            try {
                                                                this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                                                                this.mSettings.writeLPr();
                                                            } catch (Throwable th7) {
                                                                while (true) {
                                                                    th = th7;
                                                                }
                                                                throw th;
                                                            }
                                                        }
                                                        return;
                                                    } catch (Throwable th8) {
                                                        th = th8;
                                                        synchronized (this.mPackages) {
                                                        }
                                                        throw th;
                                                    }
                                                }
                                            }
                                            synchronized (this.mPackages) {
                                                try {
                                                    this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                                                    this.mSettings.writeLPr();
                                                } catch (Throwable th9) {
                                                    th = th9;
                                                    throw th;
                                                }
                                            }
                                            return;
                                        } catch (Throwable th10) {
                                            th = th10;
                                            freezer = freezer4;
                                            th = null;
                                            if (freezer != null) {
                                                $closeResource(th, freezer);
                                            }
                                            throw th;
                                        }
                                    } catch (Throwable th11) {
                                        th = th11;
                                        freezer = freezer3;
                                        File file2 = codePath2;
                                        PackageSetting packageSetting2 = pkgSetting3;
                                        th = null;
                                        if (freezer != null) {
                                        }
                                        throw th;
                                    }
                                } catch (PackageManagerException e4) {
                                    pme = e4;
                                    File file3 = codePath2;
                                    PackageSetting packageSetting3 = pkgSetting3;
                                    Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName, pme);
                                    synchronized (this.mPackages) {
                                    }
                                    return;
                                } catch (Throwable th12) {
                                    th = th12;
                                    File file4 = codePath2;
                                    PackageSetting packageSetting4 = pkgSetting3;
                                    synchronized (this.mPackages) {
                                        try {
                                            this.mSettings.disableSystemPackageLPw(deletedPkg.packageName, true);
                                            this.mSettings.writeLPr();
                                        } catch (Throwable th13) {
                                            th = th13;
                                        }
                                    }
                                    throw th;
                                }
                            } catch (Throwable th14) {
                                th = th14;
                                File file5 = codePath2;
                                PackageSetting packageSetting5 = pkgSetting3;
                                throw th;
                            }
                        } catch (Throwable th15) {
                            th = th15;
                            PackageSetting packageSetting6 = pkgSetting3;
                            File file6 = codePath;
                            throw th;
                        }
                    } catch (Throwable th16) {
                        th = th16;
                        File file7 = codePath;
                        PackageSetting packageSetting7 = pkgSetting;
                        throw th;
                    }
                }
            }
            pkg2 = pkg;
        } catch (Throwable th17) {
            th = th17;
            throw th;
        }
        try {
            clearAppDataLIF(pkg2, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
            this.mDexManager.notifyPackageUpdated(pkg2.packageName, pkg2.baseCodePath, pkg2.splitCodePaths);
            PackageSetting pkgSetting4 = pkgSetting;
            String callingPackage2 = (i == 0 || i == 1) ? null : callingPackage;
            synchronized (this.mPackages) {
                pkgSetting4.setEnabled(i, i3, callingPackage2);
            }
            synchronized (this.mPackages) {
                try {
                    scheduleWritePackageRestrictionsLocked(i3);
                    updateSequenceNumberLP(pkgSetting4, new int[]{i3});
                    long callingId = Binder.clearCallingIdentity();
                    try {
                        updateInstantAppInstallerLocked(packageName);
                        Binder.restoreCallingIdentity(callingId);
                        ArrayList<String> components = this.mPendingBroadcasts.get(i3, str2);
                        boolean newPackage = components == null;
                        if (newPackage) {
                            try {
                                components = new ArrayList<>();
                            } catch (Throwable th18) {
                                th = th18;
                                String str6 = callingPackage2;
                                String str7 = componentName;
                                int i8 = flags;
                                throw th;
                            }
                        }
                        String componentName3 = componentName;
                        try {
                            if (!components.contains(componentName3)) {
                                try {
                                    components.add(componentName3);
                                } catch (Throwable th19) {
                                    th = th19;
                                    String str8 = callingPackage2;
                                }
                            }
                            int i9 = flags;
                            if ((i9 & 1) == 0) {
                                sendNow = true;
                                try {
                                    this.mPendingBroadcasts.remove(i3, str2);
                                    String str9 = callingPackage2;
                                    z = true;
                                } catch (Throwable th20) {
                                    th = th20;
                                    String str10 = callingPackage2;
                                    throw th;
                                }
                            } else {
                                if (newPackage) {
                                    this.mPendingBroadcasts.put(i3, str2, components);
                                }
                                try {
                                    z = true;
                                    if (!this.mHandler.hasMessages(1)) {
                                        boolean z2 = newPackage;
                                        String str11 = callingPackage2;
                                        this.mHandler.sendEmptyMessageDelayed(1, 10000);
                                    }
                                } catch (Throwable th21) {
                                    th = th21;
                                    String str12 = callingPackage2;
                                    throw th;
                                }
                            }
                        } catch (Throwable th22) {
                            th = th22;
                            String str13 = callingPackage2;
                            int i10 = flags;
                            throw th;
                        }
                    } catch (Throwable th23) {
                        th = th23;
                        throw th;
                    }
                } catch (Throwable th24) {
                    th = th24;
                    String str14 = callingPackage2;
                    String str15 = componentName;
                    int i11 = flags;
                    throw th;
                }
            }
        } catch (Throwable th25) {
            th = th25;
            File file8 = codePath;
            PackageSetting packageSetting8 = pkgSetting;
            throw th;
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    /* access modifiers changed from: protected */
    public void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        String str = packageName;
        ArrayList<String> arrayList = componentNames;
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + str + " components=" + arrayList);
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", arrayList.get(0));
        String[] nameList = new String[componentNames.size()];
        arrayList.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        int flags = !arrayList.contains(str) ? 1073741824 : 0;
        int userId = UserHandle.getUserId(packageUid);
        boolean isInstantApp = isInstantApp(str, userId);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", str, extras, flags, null, null, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:27:0x005d, code lost:
        return;
     */
    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        int callingUid = userId;
        if (sUserManager.exists(callingUid)) {
            int callingUid2 = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid2) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid2, callingUid, true, true, "stop package");
                synchronized (this.mPackages) {
                    try {
                        String str = packageName;
                        try {
                            if (!filterAppAccessLPr(this.mSettings.mPackages.get(str), callingUid2, callingUid)) {
                                int i = callingUid2;
                                if (this.mSettings.setPackageStoppedStateLPw(this, str, stopped, allowedByPermission, callingUid2, callingUid)) {
                                    scheduleWritePackageRestrictionsLocked(callingUid);
                                }
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        String str2 = packageName;
                        int i2 = callingUid2;
                        throw th;
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            String installerPackageNameLPr = this.mSettings.getInstallerPackageNameLPr(packageName);
            return installerPackageNameLPr;
        }
    }

    public boolean isOrphaned(String packageName) {
        boolean isOrphaned;
        synchronized (this.mPackages) {
            isOrphaned = this.mSettings.isOrphaned(packageName);
        }
        return isOrphaned;
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            int applicationEnabledSettingLPr = this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
            return applicationEnabledSettingLPr;
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (component == null) {
                try {
                    return 2;
                } catch (Throwable th) {
                    throw th;
                }
            } else {
                if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                    return 2;
                }
                int componentEnabledSettingLPr = this.mSettings.getComponentEnabledSettingLPr(component, userId);
                return componentEnabledSettingLPr;
            }
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:40:0x015a, code lost:
        sUserManager.systemReady();
        android.hwtheme.HwThemeManager.applyDefaultHwTheme(true, r1.mContext, 0);
        r0 = r11.length;
        r6 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:0x0168, code lost:
        if (r6 >= r0) goto L_0x0174;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x016a, code lost:
        r1.mDefaultPermissionPolicy.grantDefaultPermissions(r11[r6]);
        r6 = r6 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x0174, code lost:
        if (r5 == false) goto L_0x0180;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:44:0x0176, code lost:
        com.android.server.pm.Settings.resetPackageSettingsError();
        android.util.Slog.i(TAG, "booting after package manager settings file broken, systemReady now!");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:46:0x0182, code lost:
        if (r11 != EMPTY_INT_ARRAY) goto L_0x0189;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:47:0x0184, code lost:
        r1.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x0189, code lost:
        r0 = com.android.server.pm.UserManagerService.getInstance().getUserIds();
        r6 = r0.length;
        r7 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x0193, code lost:
        if (r7 >= r6) goto L_0x019f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x0195, code lost:
        r1.mDefaultPermissionPolicy.grantCustDefaultPermissions(r0[r7]);
        r7 = r7 + 1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x019f, code lost:
        r6 = r1.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x01a1, code lost:
        monitor-enter(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:?, code lost:
        r1.mPermissionManager.updateAllPermissions(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, false, r1.mPackages.values(), r1.mPermissionCallback);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:55:0x01b2, code lost:
        monitor-exit(r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x01b5, code lost:
        if (r1.mPostSystemReadyMessages == null) goto L_0x01d0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x01b7, code lost:
        r0 = r1.mPostSystemReadyMessages.iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x01c1, code lost:
        if (r0.hasNext() == false) goto L_0x01cd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x01c3, code lost:
        r0.next().sendToTarget();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x01cd, code lost:
        r1.mPostSystemReadyMessages = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x01d0, code lost:
        ((android.os.storage.StorageManager) r1.mContext.getSystemService(android.os.storage.StorageManager.class)).registerListener(r1.mStorageListener);
        r1.mInstallerService.systemReady();
        r1.mDexManager.systemReady();
        r1.mPackageDexOptimizer.systemReady();
        mHwPMSEx.systemReady();
        ((android.os.storage.StorageManagerInternal) com.android.server.LocalServices.getService(android.os.storage.StorageManagerInternal.class)).addExternalStoragePolicy(new com.android.server.pm.PackageManagerService.AnonymousClass26(r1));
        sUserManager.reconcileUsers(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        reconcileApps(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL);
        r1.mPermissionManager.systemReady();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0216, code lost:
        if (r1.mInstantAppResolverConnection == null) goto L_?;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0218, code lost:
        r1.mContext.registerReceiver(new com.android.server.pm.PackageManagerService.AnonymousClass27(r1), new android.content.IntentFilter("android.intent.action.BOOT_COMPLETED"));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:?, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:?, code lost:
        return;
     */
    public void systemReady() {
        boolean areDefaultGranted;
        PreferredActivity pa;
        enforceSystemOrRoot("Only the system can claim the system is ready");
        boolean z = true;
        this.mSystemReady = true;
        final ContentResolver resolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            public void onChange(boolean selfChange) {
                PackageManagerService packageManagerService = PackageManagerService.this;
                boolean z = true;
                if (!(Settings.Global.getInt(resolver, "enable_ephemeral_feature", 1) == 0 || Settings.Secure.getInt(resolver, "instant_apps_enabled", 1) == 0)) {
                    z = false;
                }
                boolean unused = packageManagerService.mWebInstantAppsDisabled = z;
            }
        };
        int i = 0;
        this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("enable_ephemeral_feature"), false, co, 0);
        this.mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor("instant_apps_enabled"), false, co, 0);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        PackageParser.setCompatibilityModeEnabled(Settings.Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
        }
        boolean isPackageSettingsError = this.mSettings.isPackageSettingsError();
        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            try {
                ArrayList<PreferredActivity> removed = new ArrayList<>();
                int i2 = 0;
                while (i2 < this.mSettings.mPreferredActivities.size()) {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i2);
                    removed.clear();
                    for (PreferredActivity pa2 : pir.filterSet()) {
                        if (this.mActivities.mActivities.get(pa2.mPref.mComponent) == null) {
                            removed.add(pa2);
                        }
                    }
                    if (removed.size() > 0) {
                        for (int r = i; r < removed.size(); r++) {
                            Slog.w(TAG, "Removing dangling preferred activity: " + removed.get(r).mPref.mComponent);
                            pir.removeFilter(pa);
                        }
                        this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i2));
                    }
                    i2++;
                    i = 0;
                }
                int[] userIds = UserManagerService.getInstance().getUserIds();
                int length = userIds.length;
                int[] grantPermissionsUserIds2 = grantPermissionsUserIds;
                int i3 = 0;
                while (i3 < length) {
                    try {
                        int userId = userIds[i3];
                        Slog.i(TAG, "TO DO, pms system ready grant default permission for user " + userId + ",default grant:" + areDefaultGranted + ", catch settings error:" + isPackageSettingsError);
                        if (isPackageSettingsError || areDefaultGranted) {
                            grantPermissionsUserIds2 = ArrayUtils.appendInt(grantPermissionsUserIds2, userId);
                        }
                        i3++;
                        z = true;
                    } catch (Throwable th) {
                        th = th;
                        int[] iArr = grantPermissionsUserIds2;
                        throw th;
                    }
                }
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    public void waitForAppDataPrepared() {
        if (this.mPrepareAppDataFuture != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(this.mPrepareAppDataFuture, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuffer buf = new StringBuffer(128);
        buf.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    buf.append(", ");
                }
                buf.append(array[i]);
            }
        }
        buf.append(']');
        return buf.toString();
    }

    /* JADX WARNING: type inference failed for: r1v0, types: [android.os.Binder] */
    /* JADX WARNING: Multi-variable type inference failed */
    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v17, resolved type: android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package>} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v18, resolved type: android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package>} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v19, resolved type: android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package>} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v21, resolved type: android.util.ArrayMap<java.lang.String, android.content.pm.PackageParser$Package>} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v25, resolved type: com.android.server.pm.PackageManagerService$SharedLibraryEntry} */
    /* JADX DEBUG: Multi-variable search result rejected for TypeSearchVarInfo{r20v26, resolved type: com.android.server.pm.PackageManagerService$SharedLibraryEntry} */
    /* JADX WARNING: type inference failed for: r7v13, types: [boolean] */
    /* JADX WARNING: type inference failed for: r20v20, types: [boolean] */
    /* access modifiers changed from: protected */
    /* JADX WARNING: Multi-variable type inference failed */
    /* JADX WARNING: Removed duplicated region for block: B:385:0x0834 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:386:0x0837 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:389:0x0849 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:397:0x0868 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:398:0x086b A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:401:0x087d A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:407:0x0892 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:408:0x0895 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:411:0x08a7 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:418:0x08c0 A[Catch:{ all -> 0x080e, all -> 0x084d }] */
    /* JADX WARNING: Removed duplicated region for block: B:427:0x0926 A[SYNTHETIC, Splitter:B:427:0x0926] */
    /* JADX WARNING: Removed duplicated region for block: B:466:0x09e2 A[Catch:{ IllegalArgumentException -> 0x09a0, IllegalStateException -> 0x0987, IOException -> 0x096e, all -> 0x0b68 }] */
    /* JADX WARNING: Removed duplicated region for block: B:467:0x09ec A[Catch:{ IllegalArgumentException -> 0x09a0, IllegalStateException -> 0x0987, IOException -> 0x096e, all -> 0x0b68 }] */
    /* JADX WARNING: Removed duplicated region for block: B:502:0x0b6f  */
    /* JADX WARNING: Removed duplicated region for block: B:519:0x0ba5 A[Catch:{ all -> 0x0b7f, all -> 0x0c58 }] */
    /* JADX WARNING: Removed duplicated region for block: B:533:0x0bf4 A[Catch:{ all -> 0x0b7f, all -> 0x0c58 }] */
    /* JADX WARNING: Removed duplicated region for block: B:559:0x0c76 A[Catch:{ all -> 0x0f67 }] */
    /* JADX WARNING: Removed duplicated region for block: B:563:0x0c86 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:566:0x0c92 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:569:0x0ca6 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:594:0x0d4d A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:597:0x0d6a A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:598:0x0d70 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:609:0x0d9d A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:612:0x0dba A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:613:0x0dc1 A[Catch:{ all -> 0x0f7f }, LOOP:15: B:613:0x0dc1->B:615:0x0dcb, LOOP_START, PHI: r19 
      PHI: (r19v1 'i' int) = (r19v0 'i' int), (r19v2 'i' int) binds: [B:611:0x0db8, B:615:0x0dcb] A[DONT_GENERATE, DONT_INLINE]] */
    /* JADX WARNING: Removed duplicated region for block: B:623:0x0dee A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:627:0x0e02 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:637:0x0e5f A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:645:0x0e9b A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:653:0x0eb3 A[Catch:{ all -> 0x0f7f }] */
    /* JADX WARNING: Removed duplicated region for block: B:667:0x0f10  */
    /* JADX WARNING: Removed duplicated region for block: B:675:0x0f31  */
    /* JADX WARNING: Removed duplicated region for block: B:715:0x0924 A[EDGE_INSN: B:715:0x0924->B:426:0x0924 ?: BREAK  , SYNTHETIC] */
    /* JADX WARNING: Unknown variable types count: 2 */
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String packageName;
        boolean fullPreferred;
        SharedLibraryEntry sharedLibraryEntry;
        boolean fullPreferred2;
        ArraySet<String> permissionNames;
        boolean fullPreferred3;
        ArraySet<String> permissionNames2;
        boolean z;
        int i;
        ArraySet<String> permissionNames3;
        int i2;
        ArraySet<String> permissionNames4;
        Iterator<PackageParser.ServiceIntentInfo> filterIterator;
        int K;
        int i3;
        Collection<PackageSetting> allPackageSettings;
        ? hasNext;
        String prefix;
        BufferedOutputStream str;
        FastXmlSerializer fastXmlSerializer;
        ArraySet<String> arraySet;
        int i4;
        int i5;
        String str2;
        ProviderIntentResolver providerIntentResolver;
        String str3;
        ServiceIntentResolver serviceIntentResolver;
        String str4;
        ActivityIntentResolver activityIntentResolver;
        String str5;
        String str6;
        SharedLibraryEntry sharedLibraryEntry2;
        Iterator<String> it;
        SharedLibraryEntry sharedLibraryEntry3;
        String libName;
        SharedLibraryEntry sharedLibraryEntry4;
        boolean fullPreferred4;
        PrintWriter printWriter = pw;
        String[] strArr = args;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, printWriter)) {
            int ppid = Process.getParentPid(Binder.getCallingPid());
            int callingUid = Binder.getCallingUid();
            Log.i(TAG, "Start dump, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            DumpState dumpState = new DumpState();
            ArraySet<String> permissionNames5 = null;
            boolean checkin = false;
            int opti = 0;
            while (opti < strArr.length) {
                String opt = strArr[opti];
                if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
                    break;
                }
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        printWriter.println("Package manager dump options:");
                        printWriter.println("  [-h] [-f] [--checkin] [cmd] ...");
                        printWriter.println("    --checkin: dump for a checkin");
                        printWriter.println("    -f: print details of intent filters");
                        printWriter.println("    -h: print this help");
                        printWriter.println("  cmd may be one of:");
                        printWriter.println("    l[ibraries]: list known shared libraries");
                        printWriter.println("    f[eatures]: list device features");
                        printWriter.println("    k[eysets]: print known keysets");
                        printWriter.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        printWriter.println("    perm[issions]: dump permissions");
                        printWriter.println("    permission [name ...]: dump declaration and use of given permission");
                        printWriter.println("    pref[erred]: print preferred package settings");
                        printWriter.println("    preferred-xml [--full]: print preferred package settings as xml");
                        printWriter.println("    prov[iders]: dump content providers");
                        printWriter.println("    p[ackages]: dump installed packages");
                        printWriter.println("    s[hared-users]: dump shared user IDs");
                        printWriter.println("    m[essages]: print collected runtime messages");
                        printWriter.println("    h[andle]: dump message list");
                        printWriter.println("    v[erifiers]: print package verifier info");
                        printWriter.println("    d[omain-preferred-apps]: print domains preferred apps");
                        printWriter.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        printWriter.println("    version: print database version info");
                        printWriter.println("    write: write current settings now");
                        printWriter.println("    maple: print disabled maple apps");
                        printWriter.println("    installs: details about install sessions");
                        printWriter.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        printWriter.println("    dexopt: dump dexopt state");
                        printWriter.println("    compiler-stats: dump compiler statistics");
                        printWriter.println("    service-permissions: dump permissions required by services");
                        printWriter.println("    <package.name>: info about given package");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if (PriorityDump.PROTO_ARG.equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        printWriter.println("Unknown argument: " + opt + "; use -h for help");
                    }
                }
            }
            if (opti < strArr.length) {
                String cmd = strArr[opti];
                int opti2 = opti + 1;
                if (PLATFORM_PACKAGE_NAME.equals(cmd)) {
                    fullPreferred4 = false;
                } else if (cmd.contains(".")) {
                    fullPreferred4 = false;
                } else if (!"check-permission".equals(cmd)) {
                    if ("l".equals(cmd) || "libraries".equals(cmd)) {
                        dumpState.setDump(1);
                    } else if ("f".equals(cmd) || "features".equals(cmd)) {
                        dumpState.setDump(2);
                    } else if ("r".equals(cmd) || "resolvers".equals(cmd)) {
                        if (opti2 >= strArr.length) {
                            dumpState.setDump(60);
                        } else {
                            int opti3 = opti2;
                            while (opti3 < strArr.length) {
                                String name = strArr[opti3];
                                if ("a".equals(name) || "activity".equals(name)) {
                                    dumpState.setDump(4);
                                } else if ("s".equals(name) || "service".equals(name)) {
                                    dumpState.setDump(8);
                                } else if ("r".equals(name) || HwBroadcastRadarUtil.KEY_RECEIVER.equals(name)) {
                                    dumpState.setDump(16);
                                } else if ("c".equals(name) || "content".equals(name)) {
                                    dumpState.setDump(32);
                                } else {
                                    printWriter.println("Error: unknown resolver table type: " + name);
                                    return;
                                }
                                opti3++;
                            }
                            int i6 = opti3;
                            fullPreferred = false;
                            packageName = null;
                        }
                    } else if (TAG_PERMISSION.equals(cmd) || "permissions".equals(cmd)) {
                        dumpState.setDump(64);
                    } else {
                        if ("permission".equals(cmd)) {
                            if (opti2 >= strArr.length) {
                                printWriter.println("Error: permission requires permission name");
                                return;
                            }
                            ArraySet<String> permissionNames6 = new ArraySet<>();
                            while (opti2 < strArr.length) {
                                permissionNames6.add(strArr[opti2]);
                                opti2++;
                            }
                            dumpState.setDump(448);
                            permissionNames5 = permissionNames6;
                            int i7 = opti2;
                            fullPreferred = false;
                        } else if ("pref".equals(cmd) || "preferred".equals(cmd)) {
                            dumpState.setDump(4096);
                        } else if ("preferred-xml".equals(cmd)) {
                            dumpState.setDump(8192);
                            if (opti2 < strArr.length && "--full".equals(strArr[opti2])) {
                                int i8 = opti2 + 1;
                                fullPreferred = true;
                            }
                        } else if ("d".equals(cmd) || "domain-preferred-apps".equals(cmd)) {
                            dumpState.setDump(262144);
                        } else if ("p".equals(cmd) || "packages".equals(cmd)) {
                            dumpState.setDump(128);
                        } else if ("s".equals(cmd) || "shared-users".equals(cmd)) {
                            dumpState.setDump(256);
                        } else if ("prov".equals(cmd) || "providers".equals(cmd)) {
                            dumpState.setDump(1024);
                        } else if ("m".equals(cmd) || "messages".equals(cmd)) {
                            dumpState.setDump(512);
                        } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
                            dumpState.setDump(2048);
                        } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
                            dumpState.setDump(131072);
                        } else if ("version".equals(cmd)) {
                            dumpState.setDump(32768);
                        } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
                            dumpState.setDump(16384);
                        } else if ("installs".equals(cmd)) {
                            dumpState.setDump(65536);
                        } else if ("frozen".equals(cmd)) {
                            dumpState.setDump(524288);
                        } else if ("volumes".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_VOLUMES);
                        } else if ("dexopt".equals(cmd)) {
                            dumpState.setDump(1048576);
                        } else if ("compiler-stats".equals(cmd)) {
                            dumpState.setDump(2097152);
                        } else if ("changes".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_CHANGES);
                        } else if ("service-permissions".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_SERVICE_PERMISSIONS);
                        } else if ("h".equals(cmd) || "handle".equals(cmd)) {
                            dumpState.setDump(DumpState.DUMP_HANDLE);
                        } else if ("write".equals(cmd)) {
                            synchronized (this.mPackages) {
                                this.mSettings.writeLPr();
                                printWriter.println("Settings written.");
                            }
                            return;
                        } else if ("maple".equals(cmd)) {
                            if (sIsMygote) {
                                HwMaplePMServiceUtils.dumpDisabledMaplePkgs(pw);
                            } else {
                                printWriter.println("The system not run in maple.");
                            }
                            return;
                        }
                        packageName = null;
                    }
                    int i9 = opti2;
                    fullPreferred = false;
                    packageName = null;
                } else if (opti2 >= strArr.length) {
                    printWriter.println("Error: check-permission missing permission argument");
                    return;
                } else {
                    String perm = strArr[opti2];
                    int opti4 = opti2 + 1;
                    if (opti4 >= strArr.length) {
                        printWriter.println("Error: check-permission missing package argument");
                        return;
                    }
                    String pkg = strArr[opti4];
                    int opti5 = opti4 + 1;
                    int user = UserHandle.getUserId(Binder.getCallingUid());
                    if (opti5 < strArr.length) {
                        try {
                            user = Integer.parseInt(strArr[opti5]);
                        } catch (NumberFormatException e) {
                            NumberFormatException numberFormatException = e;
                            printWriter.println("Error: check-permission user argument is not a number: " + strArr[opti5]);
                            return;
                        }
                    }
                    printWriter.println(checkPermission(perm, resolveInternalPackageNameLPr(pkg, -1), user));
                    return;
                }
                String packageName2 = cmd;
                dumpState.setOptionEnabled(1);
                int i10 = opti2;
                fullPreferred = fullPreferred4;
                packageName = packageName2;
            } else {
                int i11 = opti;
                fullPreferred = false;
                packageName = null;
            }
            if (checkin) {
                printWriter.println("vers,1");
            }
            Log.i(TAG, "Start dump with packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            ArrayMap<String, PackageParser.Package> arrayMap = this.mPackages;
            synchronized (arrayMap) {
                try {
                    if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                        try {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            printWriter.println("Database versions:");
                            this.mSettings.dumpVersionLPr(new IndentingPrintWriter(printWriter, "  "));
                        } catch (Throwable th) {
                            th = th;
                            FileDescriptor fileDescriptor = fd;
                            sharedLibraryEntry = arrayMap;
                            ArraySet<String> arraySet2 = permissionNames5;
                            boolean z2 = fullPreferred;
                            throw th;
                        }
                    }
                    if (dumpState.isDumping(2048) && packageName == null) {
                        if (!checkin) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            printWriter.println("Verifiers:");
                            printWriter.print("  Required: ");
                            printWriter.print(this.mRequiredVerifierPackage);
                            printWriter.print(" (uid=");
                            printWriter.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                            printWriter.println(")");
                        } else if (this.mRequiredVerifierPackage != null) {
                            printWriter.print("vrfy,");
                            printWriter.print(this.mRequiredVerifierPackage);
                            printWriter.print(",");
                            printWriter.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                        }
                    }
                    if (dumpState.isDumping(131072) && packageName == null) {
                        if (this.mIntentFilterVerifierComponent != null) {
                            String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                            if (!checkin) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                printWriter.println("Intent Filter Verifier:");
                                printWriter.print("  Using: ");
                                printWriter.print(verifierPackageName);
                                printWriter.print(" (uid=");
                                printWriter.print(getPackageUid(verifierPackageName, 268435456, 0));
                                printWriter.println(")");
                            } else if (verifierPackageName != null) {
                                printWriter.print("ifv,");
                                printWriter.print(verifierPackageName);
                                printWriter.print(",");
                                printWriter.println(getPackageUid(verifierPackageName, 268435456, 0));
                            }
                        } else {
                            pw.println();
                            printWriter.println("No Intent Filter Verifier available!");
                        }
                    }
                    if (dumpState.isDumping(1) && packageName == null) {
                        boolean printedHeader = false;
                        try {
                            Iterator<String> it2 = this.mSharedLibraries.keySet().iterator();
                            while (it2.hasNext()) {
                                String libName2 = it2.next();
                                LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(libName2);
                                if (versionedLib == null) {
                                    sharedLibraryEntry2 = sharedLibraryEntry2;
                                } else {
                                    int versionCount = versionedLib.size();
                                    boolean printedHeader2 = printedHeader;
                                    int i12 = 0;
                                    SharedLibraryEntry sharedLibraryEntry5 = sharedLibraryEntry2;
                                    while (true) {
                                        int versionCount2 = versionCount;
                                        if (i12 >= versionCount2) {
                                            break;
                                        }
                                        SharedLibraryEntry valueAt = versionedLib.valueAt(i12);
                                        SharedLibraryEntry libEntry = valueAt;
                                        if (!checkin) {
                                            if (!printedHeader2) {
                                                ? onTitlePrinted = dumpState.onTitlePrinted();
                                                if (onTitlePrinted != 0) {
                                                    pw.println();
                                                }
                                                it = it2;
                                                printWriter.println("Libraries:");
                                                printedHeader2 = true;
                                                sharedLibraryEntry4 = onTitlePrinted;
                                            } else {
                                                it = it2;
                                                sharedLibraryEntry4 = valueAt;
                                            }
                                            printWriter.print("  ");
                                            sharedLibraryEntry3 = sharedLibraryEntry4;
                                        } else {
                                            it = it2;
                                            printWriter.print("lib,");
                                            sharedLibraryEntry3 = valueAt;
                                        }
                                        permissionNames = permissionNames5;
                                        SharedLibraryEntry libEntry2 = libEntry;
                                        try {
                                            printWriter.print(libEntry2.info.getName());
                                            if (libEntry2.info.isStatic()) {
                                                StringBuilder sb = new StringBuilder();
                                                fullPreferred2 = fullPreferred;
                                                try {
                                                    sb.append(" version=");
                                                    libName = libName2;
                                                    sb.append(libEntry2.info.getLongVersion());
                                                    printWriter.print(sb.toString());
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                    FileDescriptor fileDescriptor2 = fd;
                                                    sharedLibraryEntry = arrayMap;
                                                    ArraySet<String> arraySet3 = permissionNames;
                                                    boolean z3 = fullPreferred2;
                                                }
                                            } else {
                                                fullPreferred2 = fullPreferred;
                                                libName = libName2;
                                            }
                                            if (!checkin) {
                                                printWriter.print(" -> ");
                                            }
                                            if (libEntry2.path != null) {
                                                printWriter.print(" (jar) ");
                                                printWriter.print(libEntry2.path);
                                            } else {
                                                printWriter.print(" (apk) ");
                                                printWriter.print(libEntry2.apk);
                                            }
                                            pw.println();
                                            i12++;
                                            versionCount = versionCount2;
                                            it2 = it;
                                            permissionNames5 = permissionNames;
                                            fullPreferred = fullPreferred2;
                                            libName2 = libName;
                                            sharedLibraryEntry5 = sharedLibraryEntry3;
                                        } catch (Throwable th3) {
                                            th = th3;
                                            FileDescriptor fileDescriptor3 = fd;
                                            sharedLibraryEntry = arrayMap;
                                            boolean z4 = fullPreferred;
                                            ArraySet<String> arraySet4 = permissionNames;
                                            throw th;
                                        }
                                    }
                                    Iterator<String> it3 = it2;
                                    ArraySet<String> arraySet5 = permissionNames5;
                                    boolean z5 = fullPreferred;
                                    printedHeader = printedHeader2;
                                    sharedLibraryEntry2 = sharedLibraryEntry5;
                                }
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            FileDescriptor fileDescriptor4 = fd;
                            sharedLibraryEntry = arrayMap;
                            ArraySet<String> arraySet6 = permissionNames5;
                            boolean z6 = fullPreferred;
                            throw th;
                        }
                    }
                    permissionNames = permissionNames5;
                    fullPreferred2 = fullPreferred;
                    try {
                        if (dumpState.isDumping(2) && packageName == null) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            if (!checkin) {
                                printWriter.println("Features:");
                            }
                            synchronized (this.mAvailableFeatures) {
                                for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                                    if (checkin) {
                                        printWriter.print("feat,");
                                        printWriter.print(feat.name);
                                        printWriter.print(",");
                                        printWriter.println(feat.version);
                                    } else {
                                        printWriter.print("  ");
                                        printWriter.print(feat.name);
                                        if (feat.version > 0) {
                                            printWriter.print(" version=");
                                            printWriter.print(feat.version);
                                        }
                                        pw.println();
                                    }
                                }
                            }
                        }
                        if (!checkin) {
                            try {
                                sharedLibraryEntry = sharedLibraryEntry2;
                                if (dumpState.isDumping(4)) {
                                    ActivityIntentResolver activityIntentResolver2 = this.mActivities;
                                    if (dumpState.getTitlePrinted()) {
                                        str6 = "\nActivity Resolver Table:";
                                    } else {
                                        str6 = "Activity Resolver Table:";
                                    }
                                    String str7 = str6;
                                    sharedLibraryEntry = arrayMap;
                                    permissionNames2 = permissionNames;
                                    fullPreferred3 = fullPreferred2;
                                    i = 8192;
                                    z = true;
                                    if (activityIntentResolver2.dump(printWriter, str7, "  ", packageName, dumpState.isOptionEnabled(1), true)) {
                                        dumpState.setTitlePrinted(true);
                                    }
                                    if (!checkin && dumpState.isDumping(16)) {
                                        activityIntentResolver = this.mReceivers;
                                        if (!dumpState.getTitlePrinted()) {
                                            str5 = "\nReceiver Resolver Table:";
                                        } else {
                                            str5 = "Receiver Resolver Table:";
                                        }
                                        if (activityIntentResolver.dump(printWriter, str5, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                                            dumpState.setTitlePrinted(z);
                                        }
                                    }
                                    if (!checkin && dumpState.isDumping(8)) {
                                        serviceIntentResolver = this.mServices;
                                        if (!dumpState.getTitlePrinted()) {
                                            str4 = "\nService Resolver Table:";
                                        } else {
                                            str4 = "Service Resolver Table:";
                                        }
                                        if (serviceIntentResolver.dump(printWriter, str4, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                                            dumpState.setTitlePrinted(z);
                                        }
                                    }
                                    if (!checkin && dumpState.isDumping(32)) {
                                        providerIntentResolver = this.mProviders;
                                        if (!dumpState.getTitlePrinted()) {
                                            str3 = "\nProvider Resolver Table:";
                                        } else {
                                            str3 = "Provider Resolver Table:";
                                        }
                                        if (providerIntentResolver.dump(printWriter, str3, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                                            dumpState.setTitlePrinted(z);
                                        }
                                    }
                                    if (!checkin && dumpState.isDumping(4096)) {
                                        i4 = 0;
                                        while (true) {
                                            i5 = i4;
                                            if (i5 < this.mSettings.mPreferredActivities.size()) {
                                                break;
                                            }
                                            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i5);
                                            int user2 = this.mSettings.mPreferredActivities.keyAt(i5);
                                            if (dumpState.getTitlePrinted()) {
                                                str2 = "\nPreferred Activities User " + user2 + ":";
                                            } else {
                                                str2 = "Preferred Activities User " + user2 + ":";
                                            }
                                            int i13 = user2;
                                            int i14 = i5;
                                            if (pir.dump(printWriter, str2, "  ", packageName, true, false)) {
                                                dumpState.setTitlePrinted(z);
                                            }
                                            i4 = i14 + 1;
                                        }
                                    }
                                    if (!checkin) {
                                        try {
                                            if (dumpState.isDumping(i)) {
                                                pw.flush();
                                                try {
                                                    str = new BufferedOutputStream(new FileOutputStream(fd));
                                                    fastXmlSerializer = new FastXmlSerializer();
                                                    permissionNames3 = arraySet;
                                                    if (!checkin && dumpState.isDumping(262144) && packageName == null) {
                                                        pw.println();
                                                        if (this.mSettings.mPackages.size() != 0) {
                                                            printWriter.println("No applications!");
                                                            pw.println();
                                                        } else {
                                                            String prefix2 = "  ";
                                                            Collection<PackageSetting> allPackageSettings2 = this.mSettings.mPackages.values();
                                                            if (allPackageSettings2.size() == 0) {
                                                                printWriter.println("No domain preferred apps!");
                                                                pw.println();
                                                            } else {
                                                                printWriter.println("App verification status:");
                                                                pw.println();
                                                                int count = 0;
                                                                for (PackageSetting ps : allPackageSettings2) {
                                                                    IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                                                                    if (ivi == null) {
                                                                        prefix = prefix2;
                                                                    } else if (ivi.getPackageName() == null) {
                                                                        prefix = prefix2;
                                                                    } else {
                                                                        StringBuilder sb2 = new StringBuilder();
                                                                        prefix = prefix2;
                                                                        sb2.append("  Package: ");
                                                                        sb2.append(ivi.getPackageName());
                                                                        printWriter.println(sb2.toString());
                                                                        printWriter.println("  Domains: " + ivi.getDomainsString());
                                                                        printWriter.println("  Status:  " + ivi.getStatusString());
                                                                        pw.println();
                                                                        count++;
                                                                    }
                                                                    prefix2 = prefix;
                                                                    permissionNames3 = null;
                                                                }
                                                                String str8 = prefix2;
                                                                if (count == 0) {
                                                                    printWriter.println("  No app verification established.");
                                                                    pw.println();
                                                                }
                                                                int[] userIds = sUserManager.getUserIds();
                                                                int length = userIds.length;
                                                                int i15 = count;
                                                                int count2 = 0;
                                                                ArraySet<String> arraySet7 = permissionNames3;
                                                                while (count2 < i3) {
                                                                    int userId = userIds[count2];
                                                                    StringBuilder sb3 = new StringBuilder();
                                                                    int[] iArr = userIds;
                                                                    sb3.append("App linkages for user ");
                                                                    sb3.append(userId);
                                                                    sb3.append(":");
                                                                    printWriter.println(sb3.toString());
                                                                    pw.println();
                                                                    int count3 = 0;
                                                                    Iterator<PackageSetting> it4 = allPackageSettings.iterator();
                                                                    while (true) {
                                                                        hasNext = it4.hasNext();
                                                                        if (hasNext == 0) {
                                                                            break;
                                                                        }
                                                                        PackageSetting ps2 = it4.next();
                                                                        Collection<PackageSetting> allPackageSettings3 = allPackageSettings;
                                                                        int i16 = i3;
                                                                        long status = ps2.getDomainVerificationStatusForUser(userId);
                                                                        if ((status >> 32) != 0 || DEBUG_DOMAIN_VERIFICATION) {
                                                                            Iterator<PackageSetting> it5 = it4;
                                                                            StringBuilder sb4 = new StringBuilder();
                                                                            int userId2 = userId;
                                                                            sb4.append("  Package: ");
                                                                            sb4.append(ps2.name);
                                                                            printWriter.println(sb4.toString());
                                                                            printWriter.println("  Domains: " + dumpDomainString(ps2.name));
                                                                            String statusStr = IntentFilterVerificationInfo.getStatusStringFromValue(status);
                                                                            StringBuilder sb5 = new StringBuilder();
                                                                            long j = status;
                                                                            sb5.append("  Status:  ");
                                                                            sb5.append(statusStr);
                                                                            printWriter.println(sb5.toString());
                                                                            pw.println();
                                                                            count3++;
                                                                            allPackageSettings = allPackageSettings3;
                                                                            i3 = i16;
                                                                            it4 = it5;
                                                                            userId = userId2;
                                                                        } else {
                                                                            allPackageSettings = allPackageSettings3;
                                                                            i3 = i16;
                                                                        }
                                                                    }
                                                                    Collection<PackageSetting> allPackageSettings4 = allPackageSettings;
                                                                    int i17 = i3;
                                                                    int i18 = userId;
                                                                    if (count3 == 0) {
                                                                        printWriter.println("  No configured app linkages.");
                                                                        pw.println();
                                                                    }
                                                                    count2++;
                                                                    int i19 = count3;
                                                                    userIds = iArr;
                                                                    allPackageSettings2 = allPackageSettings4;
                                                                    length = i17;
                                                                    arraySet7 = hasNext;
                                                                }
                                                                permissionNames3 = arraySet7;
                                                            }
                                                        }
                                                    }
                                                    if (!checkin) {
                                                        try {
                                                            if (dumpState.isDumping(64)) {
                                                                permissionNames3 = permissionNames2;
                                                                this.mSettings.dumpPermissionsLPr(printWriter, packageName, permissionNames3, dumpState);
                                                                if (!checkin && dumpState.isDumping(1024)) {
                                                                    boolean printedSomething = false;
                                                                    for (PackageParser.Provider p : this.mProviders.mProviders.values()) {
                                                                        if (packageName == null || packageName.equals(p.info.packageName)) {
                                                                            if (!printedSomething) {
                                                                                if (dumpState.onTitlePrinted()) {
                                                                                    pw.println();
                                                                                }
                                                                                printWriter.println("Registered ContentProviders:");
                                                                                printedSomething = true;
                                                                            }
                                                                            printWriter.print("  ");
                                                                            p.printComponentShortName(printWriter);
                                                                            printWriter.println(":");
                                                                            printWriter.print("    ");
                                                                            printWriter.println(p.toString());
                                                                        }
                                                                    }
                                                                    boolean printedSomething2 = false;
                                                                    for (Map.Entry<String, PackageParser.Provider> entry : this.mProvidersByAuthority.entrySet()) {
                                                                        PackageParser.Provider p2 = entry.getValue();
                                                                        if (packageName == null || packageName.equals(p2.info.packageName)) {
                                                                            if (!printedSomething2) {
                                                                                if (dumpState.onTitlePrinted()) {
                                                                                    pw.println();
                                                                                }
                                                                                printWriter.println("ContentProvider Authorities:");
                                                                                printedSomething2 = true;
                                                                            }
                                                                            printWriter.print("  [");
                                                                            printWriter.print(entry.getKey());
                                                                            printWriter.println("]:");
                                                                            printWriter.print("    ");
                                                                            printWriter.println(p2.toString());
                                                                            if (!(p2.info == null || p2.info.applicationInfo == null)) {
                                                                                String appInfo = p2.info.applicationInfo.toString();
                                                                                printWriter.print("      applicationInfo=");
                                                                                printWriter.println(appInfo);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                if (!checkin && dumpState.isDumping(16384)) {
                                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                                }
                                                                if (dumpState.isDumping(128)) {
                                                                    permissionNames4 = permissionNames3;
                                                                    i2 = 0;
                                                                    try {
                                                                        this.mSettings.dumpPackagesLPr(printWriter, packageName, permissionNames3, dumpState, checkin);
                                                                    } catch (Throwable th5) {
                                                                        th = th5;
                                                                        throw th;
                                                                    }
                                                                } else {
                                                                    permissionNames4 = permissionNames3;
                                                                    i2 = 0;
                                                                }
                                                                if (dumpState.isDumping(256)) {
                                                                    this.mSettings.dumpSharedUsersLPr(printWriter, packageName, permissionNames4, dumpState, checkin);
                                                                }
                                                                if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    printWriter.println("Package Changes:");
                                                                    printWriter.print("  Sequence number=");
                                                                    printWriter.println(this.mChangedPackagesSequenceNumber);
                                                                    int K2 = this.mChangedPackages.size();
                                                                    int i20 = i2;
                                                                    while (i20 < K2) {
                                                                        SparseArray<String> changes = this.mChangedPackages.valueAt(i20);
                                                                        printWriter.print("  User ");
                                                                        printWriter.print(this.mChangedPackages.keyAt(i20));
                                                                        printWriter.println(":");
                                                                        int N = changes.size();
                                                                        if (N == 0) {
                                                                            printWriter.print("    ");
                                                                            printWriter.println("No packages changed");
                                                                            K = K2;
                                                                        } else {
                                                                            int j2 = i2;
                                                                            while (j2 < N) {
                                                                                int sequenceNumber = changes.keyAt(j2);
                                                                                printWriter.print("    ");
                                                                                printWriter.print("seq=");
                                                                                printWriter.print(sequenceNumber);
                                                                                printWriter.print(", package=");
                                                                                printWriter.println(changes.valueAt(j2));
                                                                                j2++;
                                                                                K2 = K2;
                                                                            }
                                                                            K = K2;
                                                                        }
                                                                        i20++;
                                                                        K2 = K;
                                                                    }
                                                                }
                                                                if (!checkin && dumpState.isDumping(64) && packageName == null) {
                                                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                                }
                                                                if (!checkin && dumpState.isDumping(524288) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    IndentingPrintWriter ipw = new IndentingPrintWriter(printWriter, "  ", 120);
                                                                    ipw.println();
                                                                    ipw.println("Frozen packages:");
                                                                    ipw.increaseIndent();
                                                                    if (this.mFrozenPackages.size() == 0) {
                                                                        ipw.println("(none)");
                                                                    } else {
                                                                        for (int i21 = i2; i21 < this.mFrozenPackages.size(); i21++) {
                                                                            ipw.println(this.mFrozenPackages.valueAt(i21));
                                                                        }
                                                                    }
                                                                    ipw.decreaseIndent();
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_VOLUMES) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    IndentingPrintWriter ipw2 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                                    ipw2.println();
                                                                    ipw2.println("Loaded volumes:");
                                                                    ipw2.increaseIndent();
                                                                    if (this.mLoadedVolumes.size() != 0) {
                                                                        while (true) {
                                                                            int i22 = i2;
                                                                            if (i22 >= this.mLoadedVolumes.size()) {
                                                                                break;
                                                                            }
                                                                            ipw2.println(this.mLoadedVolumes.valueAt(i22));
                                                                            i2 = i22 + 1;
                                                                        }
                                                                    } else {
                                                                        ipw2.println("(none)");
                                                                    }
                                                                    ipw2.decreaseIndent();
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_PERMISSIONS) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    printWriter.println("Service permissions:");
                                                                    filterIterator = this.mServices.filterIterator();
                                                                    while (filterIterator.hasNext()) {
                                                                        ServiceInfo serviceInfo = filterIterator.next().service.info;
                                                                        String permission = serviceInfo.permission;
                                                                        if (permission != null) {
                                                                            printWriter.print("    ");
                                                                            printWriter.print(serviceInfo.getComponentName().flattenToShortString());
                                                                            printWriter.print(": ");
                                                                            printWriter.println(permission);
                                                                        }
                                                                    }
                                                                }
                                                                Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(1048576)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    dumpDexoptStateLPr(printWriter, packageName);
                                                                }
                                                                Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(2097152)) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    dumpCompilerStatsLPr(printWriter, packageName);
                                                                }
                                                                if (!checkin && dumpState.isDumping(512) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                                    pw.println();
                                                                    printWriter.println("Package warning messages:");
                                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                                }
                                                                if (checkin && dumpState.isDumping(512)) {
                                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                                }
                                                                Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                                if (!checkin && dumpState.isDumping(65536) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                                }
                                                                if (!checkin && dumpState.isDumping(DumpState.DUMP_HANDLE) && packageName == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                                }
                                                                Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            }
                                                        } catch (Throwable th6) {
                                                            th = th6;
                                                            ArraySet<String> arraySet8 = permissionNames3;
                                                            throw th;
                                                        }
                                                    }
                                                    permissionNames3 = permissionNames2;
                                                    boolean printedSomething3 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    boolean printedSomething22 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw3 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw3.println();
                                                    ipw3.println("Frozen packages:");
                                                    ipw3.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw3.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw22 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw22.println();
                                                    ipw22.println("Loaded volumes:");
                                                    ipw22.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw22.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, packageName);
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, packageName);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                    pw.println();
                                                    printWriter.println("Package warning messages:");
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                } catch (Throwable th7) {
                                                    th = th7;
                                                    boolean z7 = fullPreferred3;
                                                    throw th;
                                                }
                                                try {
                                                    fastXmlSerializer.setOutput(str, StandardCharsets.UTF_8.name());
                                                    fastXmlSerializer.startDocument(null, Boolean.valueOf(z));
                                                    fastXmlSerializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", z);
                                                    arraySet = null;
                                                    try {
                                                        this.mSettings.writePreferredActivitiesLPr(fastXmlSerializer, 0, fullPreferred3);
                                                        fastXmlSerializer.endDocument();
                                                        fastXmlSerializer.flush();
                                                    } catch (IllegalArgumentException e2) {
                                                        e = e2;
                                                    } catch (IllegalStateException e3) {
                                                        e = e3;
                                                        printWriter.println("Failed writing: " + e);
                                                        arraySet = arraySet;
                                                        permissionNames3 = arraySet;
                                                        pw.println();
                                                        if (this.mSettings.mPackages.size() != 0) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames3 = permissionNames2;
                                                        boolean printedSomething32 = false;
                                                        while (r2.hasNext()) {
                                                        }
                                                        boolean printedSomething222 = false;
                                                        while (r2.hasNext()) {
                                                        }
                                                        this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                        }
                                                        this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw32 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw32.println();
                                                        ipw32.println("Frozen packages:");
                                                        ipw32.increaseIndent();
                                                        if (this.mFrozenPackages.size() == 0) {
                                                        }
                                                        ipw32.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw222.println();
                                                        ipw222.println("Loaded volumes:");
                                                        ipw222.increaseIndent();
                                                        if (this.mLoadedVolumes.size() != 0) {
                                                        }
                                                        ipw222.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        printWriter.println("Service permissions:");
                                                        filterIterator = this.mServices.filterIterator();
                                                        while (filterIterator.hasNext()) {
                                                        }
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpDexoptStateLPr(printWriter, packageName);
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(printWriter, packageName);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                        pw.println();
                                                        printWriter.println("Package warning messages:");
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    } catch (IOException e4) {
                                                        e = e4;
                                                        printWriter.println("Failed writing: " + e);
                                                        permissionNames3 = arraySet;
                                                        pw.println();
                                                        if (this.mSettings.mPackages.size() != 0) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames3 = permissionNames2;
                                                        boolean printedSomething322 = false;
                                                        while (r2.hasNext()) {
                                                        }
                                                        boolean printedSomething2222 = false;
                                                        while (r2.hasNext()) {
                                                        }
                                                        this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                        }
                                                        this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw322 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw322.println();
                                                        ipw322.println("Frozen packages:");
                                                        ipw322.increaseIndent();
                                                        if (this.mFrozenPackages.size() == 0) {
                                                        }
                                                        ipw322.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw2222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                        ipw2222.println();
                                                        ipw2222.println("Loaded volumes:");
                                                        ipw2222.increaseIndent();
                                                        if (this.mLoadedVolumes.size() != 0) {
                                                        }
                                                        ipw2222.decreaseIndent();
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        printWriter.println("Service permissions:");
                                                        filterIterator = this.mServices.filterIterator();
                                                        while (filterIterator.hasNext()) {
                                                        }
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpDexoptStateLPr(printWriter, packageName);
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(printWriter, packageName);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                        pw.println();
                                                        printWriter.println("Package warning messages:");
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    }
                                                } catch (IllegalArgumentException e5) {
                                                    e = e5;
                                                    boolean z8 = fullPreferred3;
                                                    arraySet = null;
                                                    printWriter.println("Failed writing: " + e);
                                                    arraySet = arraySet;
                                                    permissionNames3 = arraySet;
                                                    pw.println();
                                                    if (this.mSettings.mPackages.size() != 0) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames3 = permissionNames2;
                                                    boolean printedSomething3222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    boolean printedSomething22222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw3222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw3222.println();
                                                    ipw3222.println("Frozen packages:");
                                                    ipw3222.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw3222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw22222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw22222.println();
                                                    ipw22222.println("Loaded volumes:");
                                                    ipw22222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw22222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, packageName);
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, packageName);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                    pw.println();
                                                    printWriter.println("Package warning messages:");
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                } catch (IllegalStateException e6) {
                                                    e = e6;
                                                    boolean z9 = fullPreferred3;
                                                    arraySet = null;
                                                    printWriter.println("Failed writing: " + e);
                                                    arraySet = arraySet;
                                                    permissionNames3 = arraySet;
                                                    pw.println();
                                                    if (this.mSettings.mPackages.size() != 0) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames3 = permissionNames2;
                                                    boolean printedSomething32222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    boolean printedSomething222222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw32222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw32222.println();
                                                    ipw32222.println("Frozen packages:");
                                                    ipw32222.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw32222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw222222.println();
                                                    ipw222222.println("Loaded volumes:");
                                                    ipw222222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw222222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, packageName);
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, packageName);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                    pw.println();
                                                    printWriter.println("Package warning messages:");
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                } catch (IOException e7) {
                                                    e = e7;
                                                    boolean z10 = fullPreferred3;
                                                    arraySet = null;
                                                    printWriter.println("Failed writing: " + e);
                                                    permissionNames3 = arraySet;
                                                    pw.println();
                                                    if (this.mSettings.mPackages.size() != 0) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames3 = permissionNames2;
                                                    boolean printedSomething322222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    boolean printedSomething2222222 = false;
                                                    while (r2.hasNext()) {
                                                    }
                                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                                    }
                                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw322222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw322222.println();
                                                    ipw322222.println("Frozen packages:");
                                                    ipw322222.increaseIndent();
                                                    if (this.mFrozenPackages.size() == 0) {
                                                    }
                                                    ipw322222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw2222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                                    ipw2222222.println();
                                                    ipw2222222.println("Loaded volumes:");
                                                    ipw2222222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() != 0) {
                                                    }
                                                    ipw2222222.decreaseIndent();
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    printWriter.println("Service permissions:");
                                                    filterIterator = this.mServices.filterIterator();
                                                    while (filterIterator.hasNext()) {
                                                    }
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpDexoptStateLPr(printWriter, packageName);
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(printWriter, packageName);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                                    pw.println();
                                                    printWriter.println("Package warning messages:");
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                } catch (Throwable th8) {
                                                    th = th8;
                                                    ArraySet<String> arraySet9 = permissionNames2;
                                                    throw th;
                                                }
                                            }
                                        } catch (Throwable th9) {
                                            th = th9;
                                            FileDescriptor fileDescriptor5 = fd;
                                            boolean z72 = fullPreferred3;
                                            throw th;
                                        }
                                    }
                                    FileDescriptor fileDescriptor6 = fd;
                                    boolean z11 = fullPreferred3;
                                    permissionNames3 = null;
                                    pw.println();
                                    if (this.mSettings.mPackages.size() != 0) {
                                    }
                                    if (!checkin) {
                                    }
                                    permissionNames3 = permissionNames2;
                                    boolean printedSomething3222222 = false;
                                    while (r2.hasNext()) {
                                    }
                                    boolean printedSomething22222222 = false;
                                    while (r2.hasNext()) {
                                    }
                                    this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                                    if (dumpState.isDumping(128)) {
                                    }
                                    if (dumpState.isDumping(256)) {
                                    }
                                    if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                                    }
                                    this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    IndentingPrintWriter ipw3222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                    ipw3222222.println();
                                    ipw3222222.println("Frozen packages:");
                                    ipw3222222.increaseIndent();
                                    if (this.mFrozenPackages.size() == 0) {
                                    }
                                    ipw3222222.decreaseIndent();
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    IndentingPrintWriter ipw22222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                                    ipw22222222.println();
                                    ipw22222222.println("Loaded volumes:");
                                    ipw22222222.increaseIndent();
                                    if (this.mLoadedVolumes.size() != 0) {
                                    }
                                    ipw22222222.decreaseIndent();
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    printWriter.println("Service permissions:");
                                    filterIterator = this.mServices.filterIterator();
                                    while (filterIterator.hasNext()) {
                                    }
                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpDexoptStateLPr(printWriter, packageName);
                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpCompilerStatsLPr(printWriter, packageName);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                                    pw.println();
                                    printWriter.println("Package warning messages:");
                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                                    PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                                    Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                                    Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                }
                            } catch (Throwable th10) {
                                th = th10;
                                FileDescriptor fileDescriptor7 = fd;
                                ArraySet<String> arraySet10 = permissionNames2;
                                boolean z12 = fullPreferred3;
                                sharedLibraryEntry = sharedLibraryEntry;
                                throw th;
                            }
                        }
                        sharedLibraryEntry = arrayMap;
                        permissionNames2 = permissionNames;
                        fullPreferred3 = fullPreferred2;
                        i = 8192;
                        z = true;
                        activityIntentResolver = this.mReceivers;
                        if (!dumpState.getTitlePrinted()) {
                        }
                        if (activityIntentResolver.dump(printWriter, str5, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                        }
                        serviceIntentResolver = this.mServices;
                        if (!dumpState.getTitlePrinted()) {
                        }
                        if (serviceIntentResolver.dump(printWriter, str4, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                        }
                        providerIntentResolver = this.mProviders;
                        if (!dumpState.getTitlePrinted()) {
                        }
                        if (providerIntentResolver.dump(printWriter, str3, "  ", packageName, dumpState.isOptionEnabled(z), true)) {
                        }
                        i4 = 0;
                        while (true) {
                            i5 = i4;
                            if (i5 < this.mSettings.mPreferredActivities.size()) {
                            }
                            i4 = i14 + 1;
                        }
                        if (!checkin) {
                        }
                        FileDescriptor fileDescriptor62 = fd;
                        boolean z112 = fullPreferred3;
                        permissionNames3 = null;
                        pw.println();
                        if (this.mSettings.mPackages.size() != 0) {
                        }
                        if (!checkin) {
                        }
                        permissionNames3 = permissionNames2;
                        boolean printedSomething32222222 = false;
                        while (r2.hasNext()) {
                        }
                        boolean printedSomething222222222 = false;
                        while (r2.hasNext()) {
                        }
                        this.mSettings.mKeySetManagerService.dumpLPr(printWriter, packageName, dumpState);
                    } catch (Throwable th11) {
                        th = th11;
                        FileDescriptor fileDescriptor8 = fd;
                        sharedLibraryEntry = arrayMap;
                        ArraySet<String> arraySet11 = permissionNames;
                        boolean z13 = fullPreferred2;
                        throw th;
                    }
                    try {
                        if (dumpState.isDumping(128)) {
                        }
                        if (dumpState.isDumping(256)) {
                        }
                        if (dumpState.isDumping(DumpState.DUMP_CHANGES)) {
                        }
                        this.mSettings.dumpRestoredPermissionGrantsLPr(printWriter, dumpState);
                        if (dumpState.onTitlePrinted()) {
                        }
                        IndentingPrintWriter ipw32222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                        ipw32222222.println();
                        ipw32222222.println("Frozen packages:");
                        ipw32222222.increaseIndent();
                        if (this.mFrozenPackages.size() == 0) {
                        }
                        ipw32222222.decreaseIndent();
                        if (dumpState.onTitlePrinted()) {
                        }
                        IndentingPrintWriter ipw222222222 = new IndentingPrintWriter(printWriter, "  ", 120);
                        ipw222222222.println();
                        ipw222222222.println("Loaded volumes:");
                        ipw222222222.increaseIndent();
                        if (this.mLoadedVolumes.size() != 0) {
                        }
                        ipw222222222.decreaseIndent();
                        if (dumpState.onTitlePrinted()) {
                        }
                        printWriter.println("Service permissions:");
                        filterIterator = this.mServices.filterIterator();
                        while (filterIterator.hasNext()) {
                        }
                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        dumpDexoptStateLPr(printWriter, packageName);
                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        dumpCompilerStatsLPr(printWriter, packageName);
                        if (dumpState.onTitlePrinted()) {
                        }
                        this.mSettings.dumpReadMessagesLPr(printWriter, dumpState);
                        pw.println();
                        printWriter.println("Package warning messages:");
                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, null);
                        PackageManagerServiceUtils.dumpCriticalInfo(printWriter, "msg,");
                        Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        this.mInstallerService.dump(new IndentingPrintWriter(printWriter, "  ", 120));
                        if (dumpState.onTitlePrinted()) {
                        }
                        this.mHandler.dump(new PrintWriterPrinter(printWriter), " ");
                        Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                    } catch (Throwable th12) {
                        th = th12;
                        ArraySet<String> arraySet12 = permissionNames3;
                        throw th;
                    }
                } catch (Throwable th13) {
                    th = th13;
                    FileDescriptor fileDescriptor9 = fd;
                    sharedLibraryEntry = arrayMap;
                    ArraySet<String> arraySet13 = permissionNames5;
                    boolean z14 = fullPreferred;
                    throw th;
                }
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1146756268033L);
            proto.write(1138166333441L, this.mRequiredVerifierPackage);
            proto.write(1120986464258L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1146756268034L);
                proto.write(1138166333441L, verifierPackageName);
                proto.write(1120986464258L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            PackageManagerServiceUtils.dumpCriticalInfo(proto);
        }
        proto.flush();
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                this.mAvailableFeatures.valueAt(i).writeToProto(proto, 2246267895812L);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            LongSparseArray<SharedLibraryEntry> versionedLib = this.mSharedLibraries.get(this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryEntry libEntry = versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2246267895811L);
                    proto.write(1138166333441L, libEntry.info.getName());
                    boolean isJar = libEntry.path != null;
                    proto.write(1133871366146L, isJar);
                    if (isJar) {
                        proto.write(1138166333443L, libEntry.path);
                    } else {
                        proto.write(1138166333444L, libEntry.apk);
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        if (sIsMygote) {
            MplDexOptAdaptor.getInstance().dumpPkgListDexoptState(ipw, packages, this.mDexManager);
            return;
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            CompilerStats.PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet<>();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                for (String host : ivi.getDomains()) {
                    result.add(host);
                }
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        Iterator<String> it = result.iterator();
        while (it.hasNext()) {
            String domain = it.next();
            if (sb.length() > 0) {
                sb.append(" ");
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey == null) {
                sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME);
                if (sdEncKey == null) {
                    Slog.e(TAG, "Failed to create encryption keys");
                    return null;
                }
            }
            return sdEncKey;
        } catch (NoSuchAlgorithmException nsae) {
            Slog.e(TAG, "Failed to create encryption keys with exception: " + nsae);
            return null;
        } catch (IOException ioe) {
            Slog.e(TAG, "Failed to retrieve encryption keys with exception: " + ioe);
            return null;
        }
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        String action;
        boolean z = replacing;
        String[] strArr = pkgList;
        int[] iArr = uidArr;
        if (strArr.length > 0) {
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", strArr);
            if (iArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", iArr);
            }
            if (z) {
                extras.putBoolean("android.intent.extra.REPLACING", z);
            }
            if (mediaStatus) {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null, null);
        }
    }

    /* access modifiers changed from: private */
    public void loadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.loadPrivatePackagesInner(vol);
            }
        });
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:62:0x0122, code lost:
        r21 = r2;
     */
    /* JADX WARNING: Removed duplicated region for block: B:35:0x00b7 A[Catch:{ all -> 0x00c5, all -> 0x00ca }] */
    public void loadPrivatePackagesInner(VolumeInfo vol) {
        Settings.VersionInfo ver;
        List<PackageSetting> packages;
        Iterator it;
        int flags;
        Object obj;
        Iterator<PackageSetting> it2;
        PackageSetting ps;
        PackageSetting ps2;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList arrayList = new ArrayList();
        ArrayList arrayList2 = new ArrayList();
        int parseFlags = this.mDefParseFlags | 8;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        for (Iterator<PackageSetting> it3 = packages.iterator(); it3.hasNext(); it3 = it2) {
            PackageSetting ps3 = it3.next();
            arrayList.add(freezePackage(ps3.name, "loadPrivatePackagesInner"));
            Object obj2 = this.mInstallLock;
            synchronized (obj2) {
                try {
                    ps2 = ps3;
                    obj = obj2;
                    it2 = it3;
                    try {
                        arrayList2.add(scanPackageTracedLI(ps3.codePath, parseFlags, 512, 0, (UserHandle) null).applicationInfo);
                        ps = ps2;
                    } catch (PackageManagerException e) {
                        e = e;
                        try {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Failed to scan ");
                            ps = ps2;
                            sb.append(ps.codePath);
                            sb.append(": ");
                            sb.append(e.getMessage());
                            Slog.w(TAG, sb.toString());
                            if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                            }
                        } catch (Throwable th) {
                            pkg = th;
                            throw pkg;
                        }
                    } catch (Throwable th2) {
                        pkg = th2;
                        PackageSetting packageSetting = ps2;
                        throw pkg;
                    }
                } catch (PackageManagerException e2) {
                    e = e2;
                    ps2 = ps3;
                    obj = obj2;
                    it2 = it3;
                    StringBuilder sb2 = new StringBuilder();
                    sb2.append("Failed to scan ");
                    ps = ps2;
                    sb2.append(ps.codePath);
                    sb2.append(": ");
                    sb2.append(e.getMessage());
                    Slog.w(TAG, sb2.toString());
                    if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                    }
                } catch (Throwable th3) {
                    pkg = th3;
                    obj = obj2;
                    PackageSetting packageSetting2 = ps3;
                    throw pkg;
                }
                if (!Build.FINGERPRINT.equals(ver.fingerprint)) {
                    clearAppDataLIF(ps.pkg, -1, UsbTerminalTypes.TERMINAL_IN_PERSONAL_MIC);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        Iterator it4 = ((UserManager) this.mContext.getSystemService(UserManager.class)).getUsers().iterator();
        while (it4.hasNext()) {
            UserInfo user = (UserInfo) it4.next();
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            int flags2 = flags;
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags2);
                synchronized (this.mInstallLock) {
                    try {
                        it = it4;
                        reconcileAppsDataLI(volumeUuid, user.id, flags2, true);
                    } catch (Throwable th4) {
                        th = th4;
                        throw th;
                    }
                }
            } catch (IllegalStateException e3) {
                e = e3;
                it = it4;
                StringBuilder sb3 = new StringBuilder();
                StorageManager sm2 = sm;
                sb3.append("Failed to prepare storage: ");
                sb3.append(e);
                Slog.w(TAG, sb3.toString());
                it4 = it;
                sm = sm2;
            }
        }
        synchronized (this.mPackages) {
            boolean sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                PackageManagerServiceUtils.logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for " + volumeUuid);
            }
            this.mPermissionManager.updateAllPermissions(volumeUuid, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        Iterator it5 = arrayList.iterator();
        while (it5.hasNext()) {
            ((PackageFreezer) it5.next()).close();
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Loaded packages " + arrayList2);
        }
        sendResourcesChangedBroadcast(true, false, arrayList2, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    /* access modifiers changed from: private */
    public void unloadPrivatePackages(final VolumeInfo vol) {
        this.mHandler.post(new Runnable() {
            public void run() {
                PackageManagerService.this.unloadPrivatePackagesInner(vol);
            }
        });
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Removed duplicated region for block: B:66:0x0103 A[SYNTHETIC, Splitter:B:66:0x0103] */
    public void unloadPrivatePackagesInner(VolumeInfo vol) {
        Throwable th;
        PackageFreezer freezer;
        Throwable th2;
        PackageSetting ps;
        StringBuilder sb;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList arrayList = new ArrayList();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                List<PackageSetting> packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
                for (PackageSetting ps2 : packages) {
                    if (ps2.pkg != null) {
                        ApplicationInfo info = ps2.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        PackageFreezer freezer2 = freezePackageForDelete(ps2.name, 1, "unloadPrivatePackagesInner");
                        try {
                            PackageFreezer freezer3 = freezer2;
                            ApplicationInfo info2 = info;
                            PackageSetting ps3 = ps2;
                            List<PackageSetting> packages2 = packages;
                            try {
                                if (deletePackageLIF(ps2.name, null, false, null, 1, outInfo, false, null)) {
                                    try {
                                        arrayList.add(info2);
                                        ps = ps3;
                                    } catch (Throwable th3) {
                                        th = th3;
                                        freezer = freezer3;
                                        PackageSetting packageSetting = ps3;
                                        th = null;
                                        if (freezer != null) {
                                        }
                                        throw th;
                                    }
                                } else {
                                    try {
                                        sb = new StringBuilder();
                                        sb.append("Failed to unload ");
                                        ps = ps3;
                                    } catch (Throwable th4) {
                                        th = th4;
                                        freezer = freezer3;
                                        PackageSetting packageSetting2 = ps3;
                                        th = null;
                                        if (freezer != null) {
                                        }
                                        throw th;
                                    }
                                    try {
                                        sb.append(ps.codePath);
                                        Slog.w(TAG, sb.toString());
                                    } catch (Throwable th5) {
                                        th = th5;
                                        freezer = freezer3;
                                        th = null;
                                        if (freezer != null) {
                                            $closeResource(th, freezer);
                                        }
                                        throw th;
                                    }
                                }
                                PackageFreezer freezer4 = freezer3;
                                if (freezer4 != null) {
                                    $closeResource(null, freezer4);
                                }
                                AttributeCache.instance().removePackage(ps.name);
                                packages = packages2;
                            } catch (Throwable th6) {
                                th = th6;
                                freezer = freezer3;
                                ApplicationInfo applicationInfo = info2;
                                PackageSetting packageSetting3 = ps3;
                                th = null;
                                if (freezer != null) {
                                }
                                throw th;
                            }
                        } catch (Throwable th7) {
                            th = th7;
                            freezer = freezer2;
                            ApplicationInfo applicationInfo2 = info;
                            PackageSetting packageSetting4 = ps2;
                            th = null;
                            List<PackageSetting> list = packages;
                            if (freezer != null) {
                            }
                            throw th;
                        }
                    }
                }
                List<PackageSetting> list2 = packages;
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Unloaded packages " + arrayList);
        }
        sendResourcesChangedBroadcast(false, false, arrayList, null);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        for (int i = 0; i < 3; i++) {
            System.gc();
            System.runFinalization();
        }
    }

    private void assertPackageKnown(String volumeUuid, String packageName) throws PackageManagerException {
        synchronized (this.mPackages) {
            String packageName2 = normalizePackageNameLPr(packageName);
            PackageSetting ps = this.mSettings.mPackages.get(packageName2);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName2 + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName2 + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            }
        }
    }

    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            String packageName2 = normalizePackageNameLPr(packageName);
            PackageSetting ps = this.mSettings.mPackages.get(packageName2);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName2 + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName2 + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            } else if (!ps.getInstalled(userId)) {
                throw new PackageManagerException("Package " + packageName2 + " not installed for user " + userId);
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList<>();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(this.mSettings.mPackages.valueAt(i).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    /* access modifiers changed from: private */
    public void reconcileApps(String volumeUuid) {
        File fileToDelete;
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        int i = 0;
        List<File> filesToDelete = null;
        for (File file : FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid))) {
            if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                int i2 = 0;
                while (true) {
                    if (i2 >= absoluteCodePathCount) {
                        break;
                    } else if (absolutePath.startsWith(absoluteCodePaths.get(i2))) {
                        pathValid = true;
                        break;
                    } else {
                        i2++;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete == null) {
                        filesToDelete = new ArrayList<>();
                    }
                    filesToDelete.add(file);
                }
            }
        }
        if (filesToDelete != null) {
            int fileToDeleteCount = filesToDelete.size();
            while (true) {
                int i3 = i;
                if (i3 < fileToDeleteCount) {
                    PackageManagerServiceUtils.logCriticalInfo(5, "Destroying orphaned" + fileToDelete);
                    synchronized (this.mInstallLock) {
                        removeCodePathLI(fileToDelete);
                    }
                    i = i3 + 1;
                } else {
                    return;
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    private List<String> reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData, boolean onlyCoreApps) {
        boolean z;
        List<PackageSetting> packages;
        File[] files;
        int i;
        int i2;
        File deDir;
        char c;
        File deDir2;
        File ceDir;
        File[] files2;
        int i3;
        int i4;
        int i5;
        String packageName = volumeUuid;
        int i6 = userId;
        int i7 = flags;
        Slog.v(TAG, "reconcileAppsData for " + packageName + " u" + i6 + " 0x" + Integer.toHexString(flags) + " migrateAppData=" + z);
        List<String> result = onlyCoreApps ? new ArrayList<>() : null;
        File ceDir2 = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir3 = Environment.getDataUserDeDirectory(volumeUuid, userId);
        if ((i7 & 2) != 0) {
            if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
                File[] files3 = FileUtils.listFilesOrEmpty(ceDir2);
                int length = files3.length;
                int i8 = 0;
                while (i8 < length) {
                    File file = files3[i8];
                    File deDir4 = deDir3;
                    String packageName2 = file.getName();
                    if (!this.mIsUpgrade || this.mCustPms == null || this.mCustPms.isListedApp(packageName2) != 1) {
                        try {
                            assertPackageKnownAndInstalled(packageName, packageName2, i6);
                        } catch (PackageManagerException e) {
                            PackageManagerException e2 = e;
                            if (!this.mIsUpgrade || this.mCustPms == null || this.mCustPms.isListedApp(packageName2) != 1) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Destroying ");
                                sb.append(file);
                                sb.append(" due to: ");
                                PackageManagerException e3 = e2;
                                sb.append(e3);
                                PackageManagerServiceUtils.logCriticalInfo(5, sb.toString());
                                if (sIsMygote && !HwMaplePMServiceUtils.getMapleEnableFlag(packageName2)) {
                                    HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName2);
                                }
                                try {
                                    File file2 = file;
                                    i4 = i8;
                                    i3 = length;
                                    files2 = files3;
                                    ceDir = ceDir2;
                                    i5 = 5;
                                    PackageManagerException packageManagerException = e3;
                                    deDir2 = deDir4;
                                    String str = packageName2;
                                    try {
                                        this.mInstaller.destroyAppData(packageName, packageName2, i6, 2, 0);
                                    } catch (Installer.InstallerException e4) {
                                        e2 = e4;
                                    }
                                } catch (Installer.InstallerException e5) {
                                    e2 = e5;
                                    File file3 = file;
                                    i4 = i8;
                                    i3 = length;
                                    files2 = files3;
                                    PackageManagerException packageManagerException2 = e3;
                                    ceDir = ceDir2;
                                    deDir2 = deDir4;
                                    i5 = 5;
                                    String str2 = packageName2;
                                    PackageManagerServiceUtils.logCriticalInfo(i5, "Failed to destroy: " + e2);
                                    i8 = i4 + 1;
                                    length = i3;
                                    files3 = files2;
                                    ceDir2 = ceDir;
                                    deDir3 = deDir2;
                                }
                            } else {
                                Slog.w(TAG, "Skip destroy " + file + " due to: " + packageName2);
                            }
                        }
                    }
                    i4 = i8;
                    i3 = length;
                    files2 = files3;
                    ceDir = ceDir2;
                    deDir2 = deDir4;
                    i8 = i4 + 1;
                    length = i3;
                    files3 = files2;
                    ceDir2 = ceDir;
                    deDir3 = deDir2;
                }
            } else {
                throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + i6 + " was still locked; this would have caused massive data loss!");
            }
        }
        File deDir5 = deDir3;
        File file4 = ceDir2;
        char c2 = 5;
        if ((i7 & 1) != 0) {
            File deDir6 = deDir5;
            File[] files4 = FileUtils.listFilesOrEmpty(deDir6);
            int length2 = files4.length;
            int i9 = 0;
            while (i9 < length2) {
                File file5 = files4[i9];
                String packageName3 = file5.getName();
                try {
                    assertPackageKnownAndInstalled(packageName, packageName3, i6);
                    i2 = i9;
                    i = length2;
                    files = files4;
                    c = c2;
                    deDir = deDir6;
                } catch (PackageManagerException e6) {
                    PackageManagerException e7 = e6;
                    PackageManagerServiceUtils.logCriticalInfo(5, "Destroying " + file5 + " due to: " + e7);
                    try {
                        PackageManagerException packageManagerException3 = e7;
                        File file6 = file5;
                        i2 = i9;
                        i = length2;
                        deDir = deDir6;
                        files = files4;
                        try {
                            this.mInstaller.destroyAppData(packageName, packageName3, i6, 1, 0);
                            c = 5;
                        } catch (Installer.InstallerException e8) {
                            e2 = e8;
                            c = 5;
                            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to destroy: " + e2);
                            i9 = i2 + 1;
                            deDir6 = deDir;
                            length2 = i;
                            files4 = files;
                            c2 = c;
                        }
                    } catch (Installer.InstallerException e9) {
                        e2 = e9;
                        PackageManagerException packageManagerException4 = e7;
                        String str3 = packageName3;
                        File file7 = file5;
                        i2 = i9;
                        i = length2;
                        deDir = deDir6;
                        files = files4;
                        c = 5;
                        PackageManagerServiceUtils.logCriticalInfo(5, "Failed to destroy: " + e2);
                        i9 = i2 + 1;
                        deDir6 = deDir;
                        length2 = i;
                        files4 = files;
                        c2 = c;
                    }
                }
                i9 = i2 + 1;
                deDir6 = deDir;
                length2 = i;
                files4 = files;
                c2 = c;
            }
        }
        synchronized (this.mPackages) {
            packages = this.mSettings.getVolumePackagesLPr(packageName);
        }
        if ((i7 & 2) != 0) {
            try {
                UniPerf.getInstance().uniPerfEvent(4099, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS, new int[0]);
            } catch (RuntimeException e10) {
                Slog.v(TAG, "raise cpu error!");
            }
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            String packageName4 = ps.name;
            if (ps.pkg == null) {
                if (ps.codePathString != null && ps.codePathString.startsWith("/data/app")) {
                    HwPackageManagerServiceUtils.reportException(HwPackageManagerServiceUtils.EVENT_APK_LOST_EXCEPTION, "package : " + packageName4 + ", codePath = " + ps.codePathString);
                }
                Slog.w(TAG, "Odd, missing scanned package " + packageName4);
            } else if (onlyCoreApps && !ps.pkg.coreApp) {
                result.add(packageName4);
            } else if (ps.getInstalled(i6)) {
                prepareAppDataAndMigrateLIF(ps.pkg, i6, i7, z);
                preparedCount++;
            }
        }
        Slog.v(TAG, "reconcileAppsData finished " + preparedCount + " packages");
        return result;
    }

    /* access modifiers changed from: protected */
    public void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {
        PackageSetting ps;
        int flags;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : ((UserManager) this.mContext.getSystemService(UserManager.class)).getUsers()) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps != null && ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataAndMigrateLIF(PackageParser.Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        ApplicationInfo app;
        long ceDataInode;
        PackageParser.Package packageR = pkg;
        int i = userId;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(packageR.packageName);
        }
        String volumeUuid = packageR.volumeUuid;
        String packageName = packageR.packageName;
        if (ps == null) {
            app = packageR.applicationInfo;
        } else {
            app = PackageParser.generateApplicationInfo(packageR, 0, ps.readUserState(i), i);
        }
        if (app == null) {
            app = packageR.applicationInfo;
        }
        ApplicationInfo app2 = app;
        int appId = UserHandle.getAppId(app2.uid);
        Preconditions.checkNotNull(app2.seInfo);
        StringBuilder sb = new StringBuilder();
        sb.append(app2.seInfo);
        sb.append(app2.seInfoUser != null ? app2.seInfoUser : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
        try {
            ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, i, flags, appId, sb.toString(), app2.targetSdkVersion);
        } catch (Installer.InstallerException e) {
            Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
            ceDataInode = -1;
        }
        if (this.mIsUpgrade || this.mFirstBoot || i != 0) {
            this.mArtManagerService.prepareAppProfiles(packageR, i);
        }
        if (!((flags & 2) == 0 || ceDataInode == -1)) {
            synchronized (this.mPackages) {
                if (ps != null) {
                    try {
                        ps.setCeDataInode(ceDataInode, i);
                    } catch (Throwable th) {
                        throw th;
                    }
                }
            }
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
    }

    private void prepareAppDataContentsLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataContentsLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && !VMRuntime.is64BitAbi(app.primaryCpuAbi)) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (Installer.InstallerException e) {
                Slog.e(TAG, "Failed to link native for " + packageName + ": " + e);
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(PackageParser.Package pkg, int userId) {
        if (!pkg.isSystem() || StorageManager.isFileEncryptedNativeOrEmulated()) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (Installer.InstallerException e) {
            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to migrate " + pkg.packageName + ": " + e.getMessage());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                Slog.wtf(TAG, "Expected " + packageName + " to be frozen!", new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        int callingUid = Binder.getCallingUid();
        final UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        int moveId = this.mNextMoveId.getAndIncrement();
        PackageHandler packageHandler = this.mHandler;
        final String str = packageName;
        final String str2 = volumeUuid;
        final int i = moveId;
        final int i2 = callingUid;
        AnonymousClass30 r3 = new Runnable() {
            public void run() {
                try {
                    PackageManagerService.this.movePackageInternal(str, str2, i, i2, user);
                } catch (PackageManagerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move " + str, e);
                    PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(i, e.error);
                }
            }
        };
        packageHandler.post(r3);
        return moveId;
    }

    /* access modifiers changed from: private */
    /* JADX WARNING: Code restructure failed: missing block: B:100:0x020c, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Failed to measure package size");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:101:0x020d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:102:0x020e, code lost:
        r42 = r4;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r2 = r14;
        r9 = r15;
        r38 = r39;
        r37 = r43;
        r39 = r5;
        r43 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:103:0x0220, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:104:0x0221, code lost:
        r37 = r2;
        r42 = r4;
        r43 = r8;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r2 = r14;
        r9 = r15;
        r38 = r39;
        r39 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:105:0x0233, code lost:
        r43 = r2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:107:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:109:0x0238, code lost:
        if (DEBUG_INSTALL == false) goto L_0x025c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:110:0x023a, code lost:
        android.util.Slog.d(TAG, "Measured code size " + r4.codeSize + ", data size " + r4.dataSize);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:111:0x025c, code lost:
        r35 = r5.getUsableSpace();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:112:0x0260, code lost:
        if (r34 == false) goto L_0x0268;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:113:0x0262, code lost:
        r0 = r4.codeSize + r4.dataSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:114:0x0268, code lost:
        r0 = r4.codeSize;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:115:0x026a, code lost:
        r40 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:116:0x0272, code lost:
        if (r40 > r13.getStorageBytesUntilLow(r5)) goto L_0x0335;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:117:0x0274, code lost:
        com.android.server.pm.PackageManagerService.MoveCallbacks.access$6800(r15.mMoveCallbacks, r10, 10);
        r0 = new java.util.concurrent.CountDownLatch(1);
        r3 = r14;
        r14 = new com.android.server.pm.PackageManagerService.AnonymousClass31(r15);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:118:0x0288, code lost:
        if (r34 == false) goto L_0x02c7;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:119:0x028a, code lost:
        r44 = r13;
        r37 = r43;
        r13 = r1;
        r45 = r3;
        r38 = r39;
        r3 = r0;
        r42 = r4;
        r4 = r35;
        r46 = r14;
        r14 = r6;
        r6 = r5;
        r43 = r8;
        r7 = r40;
        r47 = r9;
        r9 = r10;
        r1 = new com.android.server.pm.PackageManagerService.AnonymousClass32(r15);
        r13.start();
        r24 = new com.android.server.pm.PackageManagerService.MoveInfo(r10, r26, r11, r12, r14.getName(), r30, r31, r32);
        r13 = r24;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:120:0x02c7, code lost:
        r45 = r3;
        r42 = r4;
        r47 = r9;
        r44 = r13;
        r46 = r14;
        r38 = r39;
        r37 = r43;
        r39 = r5;
        r14 = r6;
        r43 = r8;
        r13 = null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x02db, code lost:
        r4 = r44;
        r2 = r15.mHandler.obtainMessage(5);
        r6 = r14;
        r14 = r46;
        r10 = new com.android.server.pm.PackageManagerService.InstallParams(r15, com.android.server.pm.PackageManagerService.OriginInfo.fromExistingFile(r14), r13, r14, r18 | 2, r16, r11, null, r53, r20, null, android.content.pm.PackageParser.SigningDetails.UNKNOWN, 0);
        r10.setTraceMethod("movePackage").setTraceCookie(java.lang.System.identityHashCode(r10));
        r2.obj = r10;
        android.os.Trace.asyncTraceBegin(262144, "movePackage", java.lang.System.identityHashCode(r2.obj));
        android.os.Trace.asyncTraceBegin(262144, "queueInstall", java.lang.System.identityHashCode(r2.obj));
        r15.mHandler.sendMessage(r2);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0334, code lost:
        return;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0335, code lost:
        r42 = r4;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r9 = r15;
        r38 = r39;
        r37 = r43;
        r39 = r5;
        r43 = r8;
        r14.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0353, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Not enough free space to move");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:125:0x0354, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:126:0x0355, code lost:
        r42 = r4;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r2 = r14;
        r9 = r15;
        r38 = r39;
        r37 = r43;
        r39 = r5;
        r43 = r8;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:127:0x0366, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:128:0x0367, code lost:
        r37 = r2;
        r42 = r4;
        r43 = r8;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r2 = r14;
        r9 = r15;
        r38 = r39;
        r39 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:130:?, code lost:
        monitor-exit(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:131:0x0378, code lost:
        throw r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:132:0x0379, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:133:0x037b, code lost:
        r37 = r2;
        r38 = r3;
        r43 = r8;
        r47 = r9;
        r7 = r11;
        r4 = r13;
        r9 = r15;
        r14.close();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:134:0x0392, code lost:
        throw new com.android.server.pm.PackageManagerException(-6, "Move location not mounted private volume");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:48:0x011a, code lost:
        r33 = r5;
        r26 = r8;
        r8 = new android.os.Bundle();
        r8.putString("android.intent.extra.PACKAGE_NAME", r12);
        r8.putString("android.intent.extra.TITLE", r3);
        com.android.server.pm.PackageManagerService.MoveCallbacks.access$6900(r15.mMoveCallbacks, r10, r8);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:49:0x0139, code lost:
        if (java.util.Objects.equals(android.os.storage.StorageManager.UUID_PRIVATE_INTERNAL, r11) == false) goto L_0x0147;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:50:0x013b, code lost:
        r0 = 16;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:51:0x013d, code lost:
        if (r33 != false) goto L_0x0141;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:52:0x013f, code lost:
        r5 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:53:0x0141, code lost:
        r5 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:54:0x0142, code lost:
        r17 = android.os.Environment.getDataAppDirectory(r50);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:56:0x014e, code lost:
        if (java.util.Objects.equals("primary_physical", r11) == false) goto L_0x0160;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:57:0x0150, code lost:
        r0 = 8;
        r5 = false;
        r17 = r13.getPrimaryPhysicalVolume().getPath();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:58:0x015b, code lost:
        r18 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:59:0x015d, code lost:
        r34 = r5;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:60:0x0160, code lost:
        r0 = r13.findVolumeByUuid(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:61:0x0166, code lost:
        if (r15.mCustPms == null) goto L_0x017a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:63:0x016e, code lost:
        if (r15.mCustPms.canAppMoveToPublicSd(r0) == false) goto L_0x017a;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:64:0x0170, code lost:
        r1 = 8;
        r5 = false;
        r17 = r0.getPath();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x0177, code lost:
        r18 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x017a, code lost:
        if (r0 == null) goto L_0x037b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x0180, code lost:
        if (r0.getType() != 1) goto L_0x037b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:70:0x0186, code lost:
        if (r0.isMountedWritable() == false) goto L_0x037b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:71:0x0188, code lost:
        if (r33 != false) goto L_0x018c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:72:0x018a, code lost:
        r1 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:73:0x018c, code lost:
        r1 = false;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:74:0x018d, code lost:
        com.android.internal.util.Preconditions.checkState(r1);
        r1 = 16;
        r5 = true;
        r17 = android.os.Environment.getDataAppDirectory(r50);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:75:0x0198, code lost:
        r5 = r17;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:76:0x019a, code lost:
        if (r34 == false) goto L_0x01d9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:77:0x019c, code lost:
        r0 = r2.length;
        r1 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:78:0x019e, code lost:
        if (r1 >= r0) goto L_0x01d9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:79:0x01a0, code lost:
        r4 = r2[r1];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x01a6, code lost:
        if (android.os.storage.StorageManager.isFileEncryptedNativeOrEmulated() == false) goto L_0x01d3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:82:0x01ac, code lost:
        if (android.os.storage.StorageManager.isUserKeyUnlocked(r4) == false) goto L_0x01b1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x01b1, code lost:
        r1 = new java.lang.StringBuilder();
        r39 = r3;
        r1.append("User ");
        r1.append(r4);
        r1.append(" must be unlocked");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:84:0x01d0, code lost:
        throw new com.android.server.pm.PackageManagerException(-10, r1.toString());
     */
    /* JADX WARNING: Code restructure failed: missing block: B:85:0x01d3, code lost:
        r1 = r1 + 1;
        r3 = r3;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:86:0x01d9, code lost:
        r39 = r3;
        r4 = new android.content.pm.PackageStats(null, -1);
        r1 = r15.mInstaller;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:87:0x01e5, code lost:
        monitor-enter(r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:89:?, code lost:
        r0 = r2.length;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:90:0x01e7, code lost:
        r3 = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:91:0x01e8, code lost:
        if (r3 >= r0) goto L_0x0233;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:93:?, code lost:
        r41 = r0;
        r0 = r2[r3];
     */
    /* JADX WARNING: Code restructure failed: missing block: B:94:0x01f6, code lost:
        if (getPackageSizeInfoLI(r12, r0, r4) == false) goto L_0x01fd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:95:0x01f8, code lost:
        r3 = r3 + 1;
        r0 = r41;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:96:0x01fd, code lost:
        r14.close();
        r42 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:97:0x0206, code lost:
        r43 = r2;
     */
    /* JADX WARNING: Removed duplicated region for block: B:139:0x03a5 A[Catch:{ all -> 0x03f8, all -> 0x0400 }] */
    /* JADX WARNING: Removed duplicated region for block: B:35:0x00b4 A[Catch:{ all -> 0x03f8, all -> 0x0400 }] */
    public void movePackageInternal(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        String currentVolumeUuid;
        boolean currentAsec;
        String str = packageName;
        String str2 = volumeUuid;
        final int i = moveId;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(str);
            PackageSetting ps = this.mSettings.mPackages.get(str);
            if (!(pkg == null || ps == null)) {
                if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                    if (!pkg.applicationInfo.isSystemApp()) {
                        boolean isInternalStorage = "private".equals(str2);
                        boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17956869);
                        if (!isInternalStorage || allow3rdPartyOnInternal) {
                            try {
                                if (pkg.applicationInfo.isExternalAsec()) {
                                    currentAsec = true;
                                    currentVolumeUuid = "primary_physical";
                                } else if (pkg.applicationInfo.isForwardLocked()) {
                                    currentAsec = true;
                                    currentVolumeUuid = "forward_locked";
                                } else {
                                    currentAsec = false;
                                    currentVolumeUuid = ps.volumeUuid;
                                    File probe = new File(pkg.codePath);
                                    boolean z = isInternalStorage;
                                    File probeOat = new File(probe, "oat");
                                    if (!probe.isDirectory() || !probeOat.isDirectory()) {
                                        boolean z2 = allow3rdPartyOnInternal;
                                        PackageManager packageManager = pm;
                                        String str3 = str2;
                                        StorageManager storageManager = storage;
                                        throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                                    }
                                    if (Objects.equals(currentVolumeUuid, str2)) {
                                        if (pkg.applicationInfo.isInternal()) {
                                            if (isPackageDeviceAdminOnAnyUser(packageName)) {
                                                throw new PackageManagerException(-8, "Device admin cannot be moved");
                                            }
                                        }
                                        if (!this.mFrozenPackages.contains(str)) {
                                            File codeFile = new File(pkg.codePath);
                                            String installerPackageName = ps.installerPackageName;
                                            String packageAbiOverride = ps.cpuAbiOverrideString;
                                            int appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                                            String seinfo = pkg.applicationInfo.seInfo;
                                            String label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                                            int targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                                            final PackageFreezer freezer = freezePackage(str, "movePackageInternal");
                                            PackageParser.Package packageR = pkg;
                                            boolean z3 = allow3rdPartyOnInternal;
                                            int[] installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                        } else {
                                            PackageParser.Package packageR2 = pkg;
                                            boolean z4 = allow3rdPartyOnInternal;
                                            PackageManager packageManager2 = pm;
                                            String str4 = str2;
                                            StorageManager storageManager2 = storage;
                                            throw new PackageManagerException(-7, "Failed to move already frozen package");
                                        }
                                    } else {
                                        boolean z5 = allow3rdPartyOnInternal;
                                        PackageManager packageManager3 = pm;
                                        StorageManager storageManager3 = storage;
                                        throw new PackageManagerException(-6, "Package already moved to " + str2);
                                    }
                                }
                                if (Objects.equals(currentVolumeUuid, str2)) {
                                }
                            } catch (Throwable th) {
                                pkg = th;
                                throw pkg;
                            }
                        } else {
                            try {
                                throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                            } catch (Throwable th2) {
                                pkg = th2;
                                PackageManager packageManager4 = pm;
                                String str5 = str2;
                                StorageManager storageManager4 = storage;
                                throw pkg;
                            }
                        }
                    } else {
                        PackageManager packageManager5 = pm;
                        String str6 = str2;
                        StorageManager storageManager5 = storage;
                        throw new PackageManagerException(-3, "Cannot move system application");
                    }
                }
            }
            PackageManager packageManager6 = pm;
            String str7 = str2;
            StorageManager storageManager6 = storage;
            throw new PackageManagerException(-2, "Missing package");
        }
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        }
        Settings.Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
        return true;
    }

    public int getInstallLocation() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    /* access modifiers changed from: package-private */
    public void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
        mHwPMSEx.onUserRemoved(userHandle);
    }

    private void removeUnusedPackagesLPw(UserManagerService userManager, final int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                final String packageName = ps.pkg.packageName;
                boolean isPreRemovable = true;
                int i = 0;
                if ((ps.pkgFlags & 1) != 0) {
                    if (ps.pkg.applicationInfo == null || ((ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0 && (ps.pkg.applicationInfo.hwFlags & 67108864) == 0)) {
                        isPreRemovable = false;
                    }
                    if (!isPreRemovable) {
                    }
                }
                boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                if (!keep) {
                    while (true) {
                        int i2 = i;
                        if (i2 < users.length) {
                            if (users[i2] != userHandle && ps.getInstalled(users[i2])) {
                                keep = true;
                                break;
                            }
                            i = i2 + 1;
                        } else {
                            break;
                        }
                    }
                }
                if (!keep) {
                    this.mHandler.post(new Runnable() {
                        public void run() {
                            PackageManagerService.this.deletePackageX(packageName, -1, userHandle, 0);
                        }
                    });
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            applyFactoryDefaultBrowserLPw(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        synchronized (this.mPackages) {
            if (this.mSettings.mPermissions.mPermissionReviewRequired) {
                this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, true, this.mPackages.values(), this.mPermissionCallback);
            }
        }
        mHwPMSEx.onNewUserCreated(userId);
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = enforced ? Boolean.TRUE : Boolean.FALSE;
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(token);
                    throw th;
                }
                Binder.restoreCallingIdentity(token);
                return;
            }
            return;
        }
        throw new IllegalArgumentException("No selective enforcement for " + permission);
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                return dsm.isMemoryLow();
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    public IArtManager getArtManager() {
        return this.mArtManagerService;
    }

    /* access modifiers changed from: private */
    public boolean userNeedsBadging(int userId) {
        boolean b;
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        KeySet keySet;
        if (packageName == null || alias == null) {
            return null;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        KeySet keySet;
        if (packageName == null) {
            return null;
        }
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                if (pkg.applicationInfo.uid != callingUid) {
                    if (1000 != callingUid) {
                        throw new SecurityException("May not access signing KeySet of other apps.");
                    }
                }
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName + ", uid:" + callingUid);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            boolean packageIsSignedByLPr = this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
            return packageIsSignedByLPr;
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            boolean packageIsSignedByExactlyLPr = this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
            return packageIsSignedByExactlyLPr;
        }
    }

    /* access modifiers changed from: private */
    public void deletePackageIfUnusedLPr(final String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps != null && !ps.isAnyInstalled(sUserManager.getUserIds())) {
            this.mHandler.post(new Runnable() {
                public void run() {
                    PackageManagerService.this.deletePackageX(packageName, -1, 0, 2);
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public static void checkDowngrade(PackageParser.Package before, PackageInfoLite after) throws PackageManagerException {
        if (after.getLongVersionCode() < before.getLongVersionCode()) {
            throw new PackageManagerException(-25, "Update version code " + after.versionCode + " is older than current " + before.getLongVersionCode());
        } else if (after.getLongVersionCode() != before.getLongVersionCode()) {
        } else {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(-25, "Update base revision code " + after.baseRevisionCode + " is older than current " + before.baseRevisionCode);
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                for (int i = 0; i < after.splitNames.length; i++) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j != -1) {
                        if (after.isPlugin && after.splitVersionCodes[i] < before.splitVersionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " version code " + after.splitVersionCodes[i] + " is older than current " + before.splitVersionCodes[j]);
                        } else if (after.splitRevisionCodes[i] < before.splitRevisionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " revision code " + after.splitRevisionCodes[i] + " is older than current " + before.splitRevisionCodes[j]);
                        }
                    }
                }
            }
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServices(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledTelephonyDataServices(this.f$1, this.f$2);
                }
            });
        }
    }

    public void revokeDefaultPermissionsFromDisabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromDisabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromDisabledTelephonyDataServices(this.f$1, this.f$2);
                }
            });
        }
    }

    public void grantDefaultPermissionsToActiveLuiApp(String packageName, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToActiveLuiApp");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToActiveLuiApp(packageName, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void revokeDefaultPermissionsFromLuiApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromLuiApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromLuiApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            throw new SecurityException("Cannot call " + tag + " from UID " + callingUid);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    /* access modifiers changed from: package-private */
    public Collection<PackageParser.Package> getPackages() {
        ArrayList arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString(IZRHungService.PARA_PROCNAME, processName);
            data.putInt("uid", uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt(IZRHungService.PARAM_PID, pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    public CompilerStats.PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(PackageParser.Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            }
            if (ps == null) {
                return 0;
            }
            int installReason = ps.getInstallReason(userId);
            return installReason;
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        int callingUid = Binder.getCallingUid();
        boolean z = false;
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26 || isInstantApp(packageName, userId)) {
                return false;
            }
            if (!ArrayUtils.contains(getAppOpPermissionPackages("android.permission.REQUEST_INSTALL_PACKAGES"), packageName)) {
                if (!throwIfPermNotDeclared) {
                    Slog.e(TAG, "Need to declare " + "android.permission.REQUEST_INSTALL_PACKAGES" + " to call this api");
                    return false;
                }
                throw new SecurityException("Need to declare " + "android.permission.REQUEST_INSTALL_PACKAGES" + " to call this api");
            } else if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId)) {
                return false;
            } else {
                if (this.mExternalSourcesPolicy != null) {
                    int isTrusted = this.mExternalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid);
                    if (isTrusted != 2) {
                        if (isTrusted == 0) {
                            z = true;
                        }
                        return z;
                    }
                }
                if (checkUidPermission("android.permission.REQUEST_INSTALL_PACKAGES", uid) == 0) {
                    z = true;
                }
                return z;
            }
        } else {
            throw new SecurityException("Caller uid " + callingUid + " does not own package " + packageName);
        }
    }

    /* access modifiers changed from: private */
    public void parseInstalledPkgInfo(InstallArgs args, PackageInstalledInfo res) {
        StringBuilder pkgPath = new StringBuilder(100);
        int pkgInstallResult = 0;
        int pkgVersionCode = 0;
        String pkgVersionName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        String pkgName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        boolean pkgUpdate = false;
        if (!(args == null || args.origin == null || args.origin.file == null)) {
            pkgPath.append(args.origin.file.toString());
            pkgPath.append(";");
        }
        if (!(args == null || args.installerPackageName == null)) {
            pkgPath.append(args.installerPackageName);
        }
        if (res != null) {
            pkgInstallResult = res.returnCode;
            if (res.pkg != null) {
                pkgVersionCode = res.pkg.mVersionCode;
                pkgVersionName = res.pkg.mVersionName;
                if (res.pkg.applicationInfo != null) {
                    pkgName = res.pkg.applicationInfo.packageName;
                }
            }
            if (res.removedInfo != null) {
                pkgUpdate = res.removedInfo.removedPackage != null;
            }
        }
        mHwPMSEx.parseInstalledPkgInfo(pkgPath.toString(), pkgName, pkgVersionName, pkgVersionCode, pkgInstallResult, pkgUpdate);
    }

    /* access modifiers changed from: protected */
    public void addGrantedInstalledPkg(String pkgName, boolean grant) {
    }

    /* access modifiers changed from: private */
    public void uploadInstallErrRadar(String reason) {
        Bundle data = new Bundle();
        data.putString("package", "PMS");
        data.putString(HwBroadcastRadarUtil.KEY_VERSION_NAME, "0");
        data.putString("extra", reason);
        if (this.mMonitor != null) {
            this.mMonitor.monitor(907400000, data);
        }
    }

    private void writeNetQinFlag(String pkgName) {
        if ("com.nqmobile.antivirus20.hw".equalsIgnoreCase(pkgName)) {
            File file = new File(new File(Environment.getDataDirectory(), "system"), "netqin.tmp");
            synchronized (this.mPackages) {
                if (!file.exists()) {
                    try {
                        if (file.createNewFile()) {
                            FileUtils.setPermissions(file.getPath(), 416, -1, -1);
                            Log.i(TAG, "Create netqin flag successfully");
                        }
                    } catch (IOException e) {
                        Log.i(TAG, "Fail to create netqin flag");
                    }
                }
            }
        }
    }

    public static String getCallingAppName(Context context, PackageParser.Package pkg) {
        PackageManager pm = context.getPackageManager();
        String displayName = pkg.packageName;
        if (pm != null) {
            return String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
        }
        return displayName;
    }

    private void connectBootAnimation() {
        IBinder binder = ServiceManager.getService("BootAnimationBinderServer");
        if (binder != null) {
            this.mIBootAnmation = IBootAnmation.Stub.asInterface(binder);
        } else {
            Slog.w(TAG, "BootAnimationBinderServer not found; can not display dexoat process!");
        }
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ComponentName componentName = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        if (this.mInstantAppInstallerActivity != null) {
            componentName = this.mInstantAppInstallerActivity.getComponentName();
        }
        return componentName;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        String instantAppAndroidIdLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    /* access modifiers changed from: package-private */
    public boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            boolean canHaveOatDir = p.canHaveOatDir();
            return canHaveOatDir;
        }
    }

    private String getOatDir(PackageParser.Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    /* access modifiers changed from: package-private */
    public void deleteOatArtifactsOfPackage(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (Installer.InstallerException e) {
                    Log.e(TAG, "Failed deleting oat files for " + codePath, e);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Set<String> unusedPackages = new HashSet<>();
        long currentTimeInMillis = System.currentTimeMillis();
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                Iterator<PackageParser.Package> it = this.mPackages.values().iterator();
                while (it.hasNext()) {
                    PackageParser.Package pkg = it.next();
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null) {
                        PackageDexUsage.PackageUseInfo packageUseInfo = getDexManager().getPackageUseInfoOrDefault(pkg.packageName);
                        PackageSetting packageSetting = ps;
                        Iterator<PackageParser.Package> it2 = it;
                        arrayMap = arrayMap2;
                        PackageParser.Package pkg2 = pkg;
                        if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, packageUseInfo, pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                            unusedPackages.add(pkg2.packageName);
                        }
                        arrayMap2 = arrayMap;
                        it = it2;
                    }
                }
                return unusedPackages;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    public void setHarmfulAppWarning(String packageName, CharSequence warning, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "setHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                this.mSettings.setHarmfulAppWarningLPw(packageName, warning, userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            return;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public CharSequence getHarmfulAppWarning(String packageName, int userId) {
        String harmfulAppWarningLPr;
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "getHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                harmfulAppWarningLPr = this.mSettings.getHarmfulAppWarningLPr(packageName, userId);
            }
            return harmfulAppWarningLPr;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public boolean isPackageStateProtected(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "isPackageStateProtected");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.MANAGE_DEVICE_ADMINS", callingUid) == 0) {
            return this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }
        throw new SecurityException("Caller must have the android.permission.MANAGE_DEVICE_ADMINS permission.");
    }

    public ArrayMap<String, PackageParser.Package> getPackagesLock() {
        return this.mPackages;
    }

    public Settings getSettings() {
        return this.mSettings;
    }

    /* JADX WARNING: type inference failed for: r0v0, types: [com.android.server.pm.PackageManagerService$HwInnerPackageManagerService, android.os.IBinder] */
    public IBinder getHwInnerService() {
        return this.mHwInnerService;
    }

    public IHwPackageManagerServiceEx getHwPMSEx() {
        return mHwPMSEx;
    }

    public boolean getIsDefaultPreferredActivityChangedInner() {
        return this.mIsDefaultPreferredActivityChanged;
    }

    public boolean getIsDefaultGoogleCalendarInner() {
        return this.mIsDefaultGoogleCalendar;
    }

    public HwCustPackageManagerService getHwPMSCustPackageManagerService() {
        return getCustPackageManagerService();
    }

    public boolean isFirstBootInner() {
        return isFirstBoot();
    }

    public Installer getInstallerInner() {
        return this.mInstaller;
    }

    public List<ResolveInfo> queryIntentActivitiesInternalInner(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
    }

    public String getNameForUidInner(int uid) {
        return getNameForUid(uid);
    }

    public int checkSignaturesInner(String pkg1, String pkg2) {
        return checkSignatures(pkg1, pkg2);
    }

    public boolean getCotaFlagInner() {
        return this.mCotaFlag;
    }

    public void setHwPMSCotaApksInstallStatus(int value) {
        setCotaApksInstallStatus(value);
    }

    public void scanPackageFilesLIInner(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    public HashMap<String, HashSet<String>> getHwPMSCotaDelInstallMap() {
        return getCotaDelInstallMap();
    }

    public ArrayMap<String, FeatureInfo> getAvailableFeaturesInner() {
        return this.mAvailableFeatures;
    }

    public ActivityInfo getResolveActivityInner() {
        return this.mResolveActivity;
    }

    public void setUpCustomResolverActivityInner(PackageParser.Package pkg) {
        setUpCustomResolverActivity(pkg);
    }

    public PackageParser.Package scanPackageLIInner(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
    }

    public int installExistingPackageAsUserInternalInner(String packageName, int userId, int installFlags, int installReason) {
        return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason);
    }

    public void prepareAppDataAfterInstallLIFInner(PackageParser.Package pkg) {
        prepareAppDataAfterInstallLIF(pkg);
    }

    public void updateSettingsLIInner(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
    }

    public UserManagerInternal getUserManagerInternalInner() {
        return getUserManagerInternal();
    }

    public void sendPackageBroadcastInner(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast(action, pkg, extras, flags, targetPkg, finishedReceiver, userIds, instantUserIds);
    }

    public boolean getSystemReadyInner() {
        return this.mSystemReady;
    }

    public HashMap<String, HashSet<String>> getHwPMSCotaInstallMap() {
        return getCotaInstallMap();
    }

    public int getComponentEnabledSettingInner(ComponentName component, int userId) {
        return getComponentEnabledSetting(component, userId);
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceiversInner(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentReceivers(intent, resolvedType, flags, userId);
    }

    public void killApplicationInner(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, reason);
    }

    public void removePackageLIInner(PackageParser.Package pkg, boolean chatty) {
        removePackageLI(pkg, chatty);
    }

    public void scheduleWritePackageRestrictionsLockedInner(int userId) {
        scheduleWritePackageRestrictionsLocked(userId);
    }

    public PackageInfo getPackageInfoInner(String packageName, int flags, int userId) {
        return getPackageInfo(packageName, flags, userId);
    }

    public int checkPermissionInner(String permName, String pkgName, int userId) {
        return checkPermission(permName, pkgName, userId);
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivitiesInner(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivities(intent, resolvedType, flags, userId);
    }

    public void setComponentEnabledSettingInner(ComponentName componentName, int newState, int flags, int userId) {
        setComponentEnabledSetting(componentName, newState, flags, userId);
    }

    public void deleteNonRequiredAppsForClone(int clonedProfileUserId, boolean isFirstCreat) {
        mHwPMSEx.deleteNonRequiredAppsForClone(clonedProfileUserId, isFirstCreat);
    }

    public void grantRuntimePermissionInner(String packageName, String permName, int userId) {
        grantRuntimePermission(packageName, permName, userId);
    }

    public void restoreAppDataForClone(String pkgName, int parentUserId, int clonedProfileUserId) {
        mHwPMSEx.restoreAppDataForClone(pkgName, parentUserId, clonedProfileUserId);
    }

    public void setPackageStoppedStateInner(String packageName, boolean stopped, int userId) {
        setPackageStoppedState(packageName, stopped, userId);
    }

    public ActivityInfo getActivityInfoInternalInner(ComponentName component, int flags, int filterCallingUid, int userId) {
        return getActivityInfoInternal(component, flags, filterCallingUid, userId);
    }

    public int deletePackageInner(String packageName, long versionCode, int userId, int deleteFlags) {
        return deletePackageX(packageName, versionCode, userId, deleteFlags);
    }

    public void scanDirLIInner(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanDirLI(scanDir, parseFlags, scanFlags, currentTime, hwFlags);
    }

    /* access modifiers changed from: private */
    public long printClearDataTimeoutLogs(String type, long start, String packageName) {
        long end = SystemClock.uptimeMillis();
        if (end - start > 1000) {
            Slog.i(TAG, "printClearDataTimeoutLogs type: " + type + ",cost: " + (end - start) + "ms for packageName: " + packageName);
        }
        return end;
    }

    public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
        return mHwPMSEx.getHwCertPermission(allowed, pkg, perm);
    }

    public int getSdkVersion() {
        return this.tSdkVersion;
    }

    public Handler getPackageHandler() {
        return this.mHandler;
    }

    public PermissionManagerInternal getPermissionManager() {
        return this.mPermissionManager;
    }

    public InstallParams createInstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, PackageParser.SigningDetails signingDetails, int installReason) {
        InstallParams installParams = new InstallParams(origin, move, observer, installFlags, installerPackageName, volumeUuid, verificationInfo, user, packageAbiOverride, grantedPermissions, signingDetails, installReason);
        return installParams;
    }

    public Signature[] getRealSignature(PackageParser.Package pkg) {
        if (pkg == null || !pkg.mRealSigningDetails.hasSignatures()) {
            return new Signature[0];
        }
        return pkg.mRealSigningDetails.signatures;
    }

    public void setRealSigningDetails(PackageParser.Package pkg, PackageParser.SigningDetails real) {
        if (real != null) {
            pkg.mRealSigningDetails = real;
        }
    }

    /* access modifiers changed from: package-private */
    public CompilerStats getCompilerStats() {
        return this.mCompilerStats;
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> getOptimizablePkgList() {
        List<PackageParser.Package> pkgs = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p);
                }
            }
        }
        return pkgs;
    }

    public boolean getIsPreNUpgradeInner() {
        return this.mIsPreNUpgrade;
    }
}
