package com.android.server.pm;

import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.AppOpsManager;
import android.app.BroadcastOptions;
import android.app.IActivityManager;
import android.app.IApplicationThread;
import android.app.ResourcesManager;
import android.app.admin.IDevicePolicyManager;
import android.app.admin.SecurityLog;
import android.app.backup.IBackupManager;
import android.common.HwFrameworkFactory;
import android.common.HwFrameworkSecurityPartsFactory;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IIntentReceiver;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.AppsQueryHelper;
import android.content.pm.AuxiliaryResolveInfo;
import android.content.pm.ChangedPackages;
import android.content.pm.ComponentInfo;
import android.content.pm.FallbackCategoryProvider;
import android.content.pm.FeatureInfo;
import android.content.pm.IDexModuleRegisterCallback;
import android.content.pm.IOnPermissionsChangeListener;
import android.content.pm.IPackageDataObserver;
import android.content.pm.IPackageDeleteObserver;
import android.content.pm.IPackageDeleteObserver2;
import android.content.pm.IPackageInstallObserver2;
import android.content.pm.IPackageInstaller;
import android.content.pm.IPackageManager;
import android.content.pm.IPackageManagerNative;
import android.content.pm.IPackageMoveObserver;
import android.content.pm.IPackageStatsObserver;
import android.content.pm.InstantAppInfo;
import android.content.pm.InstantAppRequest;
import android.content.pm.InstrumentationInfo;
import android.content.pm.IntentFilterVerificationInfo;
import android.content.pm.KeySet;
import android.content.pm.ModuleInfo;
import android.content.pm.PackageBackwardCompatibility;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInfoLite;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageList;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.PackageParser;
import android.content.pm.PackageStats;
import android.content.pm.PackageUserState;
import android.content.pm.ParceledListSlice;
import android.content.pm.PermissionGroupInfo;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.SELinuxUtil;
import android.content.pm.ServiceInfo;
import android.content.pm.SharedLibraryInfo;
import android.content.pm.Signature;
import android.content.pm.SuspendDialogInfo;
import android.content.pm.UserInfo;
import android.content.pm.VerifierDeviceIdentity;
import android.content.pm.VerifierInfo;
import android.content.pm.VersionedPackage;
import android.content.pm.dex.ArtManager;
import android.content.pm.dex.DexMetadataHelper;
import android.content.pm.dex.IArtManager;
import android.content.res.Resources;
import android.content.rollback.IRollbackManager;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.hardware.biometrics.fingerprint.V2_1.RequestStatus;
import android.hardware.display.DisplayManager;
import android.hdm.HwDeviceManager;
import android.hwtheme.HwThemeManager;
import android.iawareperf.UniPerf;
import android.installermanager.InstallerMgr;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.Environment;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBackupSessionCallback;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.SELinux;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.UserManagerInternal;
import android.os.storage.DiskInfo;
import android.os.storage.IStorageManager;
import android.os.storage.StorageEventListener;
import android.os.storage.StorageManager;
import android.os.storage.StorageManagerInternal;
import android.os.storage.VolumeInfo;
import android.provider.DeviceConfig;
import android.provider.MediaStore;
import android.provider.Settings;
import android.security.KeyStore;
import android.security.SystemKeyStore;
import android.system.ErrnoException;
import android.system.Os;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Base64;
import android.util.ByteStringUtils;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.ExceptionUtils;
import android.util.Flog;
import android.util.IntArray;
import android.util.Jlog;
import android.util.Log;
import android.util.LogPrinter;
import android.util.LongSparseArray;
import android.util.LongSparseLongArray;
import android.util.MathUtils;
import android.util.PackageUtils;
import android.util.Pair;
import android.util.PrintStreamPrinter;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseBooleanArray;
import android.util.SparseIntArray;
import android.util.StatsLog;
import android.util.TimingsTraceLog;
import android.util.Xml;
import android.util.jar.StrictJarFile;
import android.util.proto.ProtoOutputStream;
import android.widget.Toast;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.app.IntentForwarderActivity;
import com.android.internal.app.ResolverActivity;
import com.android.internal.content.NativeLibraryHelper;
import com.android.internal.content.PackageHelper;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.SomeArgs;
import com.android.internal.os.ZygoteInit;
import com.android.internal.telephony.CarrierAppUtils;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.ConcurrentUtils;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.FunctionalUtils;
import com.android.internal.util.IndentingPrintWriter;
import com.android.internal.util.IntPair;
import com.android.internal.util.Preconditions;
import com.android.internal.util.function.TriFunction;
import com.android.server.AttributeCache;
import com.android.server.BatteryService;
import com.android.server.DeviceIdleController;
import com.android.server.EventLogTags;
import com.android.server.FgThread;
import com.android.server.HwServiceExFactory;
import com.android.server.HwServiceFactory;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.PackageWatchdog;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.SystemServerInitThreadPool;
import com.android.server.Watchdog;
import com.android.server.am.HwBroadcastRadarUtil;
import com.android.server.backup.BackupAgentTimeoutParameters;
import com.android.server.job.controllers.JobStatus;
import com.android.server.net.NetworkPolicyManagerInternal;
import com.android.server.net.watchlist.WatchlistLoggingHandler;
import com.android.server.pm.CompilerStats;
import com.android.server.pm.Installer;
import com.android.server.pm.PackageDexOptimizer;
import com.android.server.pm.PackageInstallerService;
import com.android.server.pm.PackageManagerService;
import com.android.server.pm.ParallelPackageParser;
import com.android.server.pm.Settings;
import com.android.server.pm.dex.ArtManagerService;
import com.android.server.pm.dex.DexManager;
import com.android.server.pm.dex.DexoptOptions;
import com.android.server.pm.dex.PackageDexUsage;
import com.android.server.pm.dex.ViewCompiler;
import com.android.server.pm.permission.BasePermission;
import com.android.server.pm.permission.DefaultPermissionGrantPolicy;
import com.android.server.pm.permission.PermissionManagerService;
import com.android.server.pm.permission.PermissionManagerServiceInternal;
import com.android.server.pm.permission.PermissionsState;
import com.android.server.policy.PermissionPolicyInternal;
import com.android.server.security.VerityUtils;
import com.android.server.slice.SliceClientPermissions;
import com.android.server.storage.DeviceStorageMonitorInternal;
import com.android.server.usage.AppStandbyController;
import com.android.server.usage.UnixCalendar;
import com.android.server.usb.descriptors.UsbTerminalTypes;
import com.android.server.utils.PriorityDump;
import com.android.server.wm.ActivityTaskManagerInternal;
import com.huawei.android.app.HwActivityTaskManager;
import com.huawei.android.content.pm.HwHepPackageInfo;
import com.huawei.android.content.pm.HwPresetPackage;
import com.huawei.android.content.pm.IExtServiceProvider;
import com.huawei.android.content.pm.IHwPackageManager;
import com.huawei.android.permission.ZosPermissionAdapter;
import dalvik.system.CloseGuard;
import dalvik.system.VMRuntime;
import huawei.android.app.HwCustEmergDataManager;
import huawei.android.security.IHwBehaviorCollectManager;
import huawei.cust.HwCfgFilePolicy;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.nio.charset.StandardCharsets;
import java.security.DigestException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Predicate;
import libcore.io.IoUtils;
import libcore.util.EmptyArray;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlSerializer;

public class PackageManagerService extends AbsPackageManagerService implements PackageSender, IHwPackageManagerInner {
    private static final int AIENGINE_UID = 5514;
    private static final String APP_UPDATE_FORBIDDEN = "AUF";
    private static final String ATTR_IS_GRANTED = "g";
    private static final String ATTR_PACKAGE_NAME = "pkg";
    private static final String ATTR_PERMISSION_NAME = "name";
    private static final String ATTR_REVOKE_ON_UPGRADE = "rou";
    private static final String ATTR_USER_FIXED = "fixed";
    private static final String ATTR_USER_SET = "set";
    private static final int BLUETOOTH_UID = 1002;
    static final long BROADCAST_DELAY = 1000;
    private static final long BROADCAST_DELAY_DURING_STARTUP = 10000;
    private static final String BROADCAST_INTENT_VALUE = "value";
    static final int CHECK_PENDING_VERIFICATION = 16;
    private static final String CHILDMODE_STATE_OOBE = "childmode_status_oobe";
    static final boolean CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE = false;
    private static final int CLOUDSERVICE_UID = 5513;
    public static final String COMPRESSED_EXTENSION = ".gz";
    private static final int DDMP_UID = 5511;
    private static final boolean DEBUG_ABI_SELECTION = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_APP_DATA = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_BACKUP = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_BROADCASTS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_COMPRESSION = Build.IS_DEBUGGABLE;
    public static final boolean DEBUG_DEXOPT = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_DOMAIN_VERIFICATION = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_GET_PACKAGE = SystemProperties.getBoolean("persist.pms_debug_getpackage", false);
    private static final boolean DEBUG_GUNSTALL = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_INSTALL = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_INSTANT = Build.IS_DEBUGGABLE;
    private static final boolean DEBUG_INTENT_MATCHING = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_PACKAGE_INFO = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_PACKAGE_SCANNING = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_PERMISSIONS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_PREFERRED = HwPackageManagerServiceUtils.DEBUG_FLAG;
    public static final boolean DEBUG_REMOVE = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_SD_INSTALL = false;
    public static final boolean DEBUG_SETTINGS = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_SHARED_LIBRARIES = HwPackageManagerServiceUtils.DEBUG_FLAG;
    static final boolean DEBUG_UPGRADE = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final boolean DEBUG_VERIFY = HwPackageManagerServiceUtils.DEBUG_FLAG;
    private static final long DEFAULT_ENABLE_ROLLBACK_TIMEOUT_MILLIS = 10000;
    private static final long DEFAULT_MANDATORY_FSTRIM_INTERVAL = 259200000;
    private static final boolean DEFAULT_PACKAGE_PARSER_CACHE_ENABLED = true;
    private static final long DEFAULT_UNUSED_STATIC_SHARED_LIB_MIN_CACHE_PERIOD = 7200000;
    private static final int DEFAULT_VERIFICATION_RESPONSE = 1;
    private static final long DEFAULT_VERIFICATION_TIMEOUT = 10000;
    private static final boolean DEFAULT_VERIFY_ENABLE = true;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER = 24;
    static final int DEFERRED_NO_KILL_INSTALL_OBSERVER_DELAY_MS = 500;
    static final int DEFERRED_NO_KILL_POST_DELETE = 23;
    static final int DEFERRED_NO_KILL_POST_DELETE_DELAY_MS = 3000;
    private static final int DMSDPDEVICE_UID = 5512;
    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final boolean ENABLE_FREE_CACHE_V2 = SystemProperties.getBoolean("fw.free_cache_v2", true);
    static final int ENABLE_ROLLBACK_STATUS = 21;
    static final int ENABLE_ROLLBACK_TIMEOUT = 22;
    private static final String FORBID_ENABLE_COMPONENT = "FEC";
    private static final int FREQUEBTLY_DELETE_PACKAGE_BASELINE = 5;
    private static final String GMS_CORE_NAME = "com.google.android.gms";
    private static final String HARMFUL_PACKAGE_FORBIDDEN = "HPF";
    private static final boolean HIDE_EPHEMERAL_APIS = false;
    private static final String HOTA_NIGHT_MAX_PROFILEGUIDED_NUM = "hw_sc.hota.night_max_opt_num";
    private static final String HOTA_NIGHT_UPDATE = "persist.sys.hota.night.update";
    private static final String HW_PLATFORM = SystemProperties.get("ro.board.platform", "");
    private static final String HW_SYSTEMUI_PKGNAME = "com.android.systemui";
    static final int INIT_COPY = 5;
    private static final String[] INSTANT_APP_BROADCAST_PERMISSION = {"android.permission.ACCESS_INSTANT_APPS"};
    static final int INSTANT_APP_RESOLUTION_PHASE_TWO = 20;
    static final int INTENT_FILTER_VERIFIED = 18;
    private static final boolean IS_AUTO_INSTALL_ENABLE = SystemProperties.getBoolean("hw_mc.pms.recovery_preset_app", false);
    private static boolean IS_BOPD = SystemProperties.getBoolean("sys.bopd", false);
    private static final boolean IS_GMS_SCHEME = (!TextUtils.isEmpty(SystemProperties.get("ro.com.google.gmsversion", "")));
    private static final boolean IS_HW_PREFER_APP_POLICY = SystemProperties.getBoolean("hw_mc.pms.prefer_app_policy", true);
    private static final boolean IS_SUPPORT_RESERVE_PROFILE = SystemProperties.getBoolean("hw_mc.pms.reserve_profile", false);
    private static final String KILL_APP_REASON_GIDS_CHANGED = "permission grant or revoke changed gids";
    private static final String KILL_APP_REASON_PERMISSIONS_REVOKED = "permissions revoked";
    private static final int LOG_UID = 1007;
    private static final String MAPLE_DECOUPLE_CACHE_ENABLE = "maple.decouple.cache.enable";
    private static final boolean MAPLE_ENABLE = "1".equals(SystemProperties.get("ro.maple.enable", "0"));
    private static final ArrayMap<String, Boolean> MDM_SYS_APP_PREALOAD_LIST = new ArrayMap<>();
    private static final int NETWORKSTACK_UID = 1073;
    private static final int NFC_UID = 1027;
    private static final String ODM_OVERLAY_DIR = "/odm/overlay";
    private static final String OEM_OVERLAY_DIR = "/oem/overlay";
    private static final String PACKAGE_FORBIDDEN = "PF";
    private static final String PACKAGE_MIME_TYPE = "application/vnd.android.package-archive";
    private static final String PACKAGE_SCHEME = "package";
    static final int PACKAGE_VERIFIED = 15;
    public static final String PLATFORM_PACKAGE_NAME = "android";
    static final int POST_INSTALL = 9;
    private static final String PREAS_APP_UPDATE_FORBIDDEN = "PAUF";
    private static final String PRECOMPILE_LAYOUTS = "pm.precompile_layouts";
    private static final int PRIME_DOMAIN_DEFAULT = 0;
    private static final int PRIME_DOMAIN_UPGRADE = 1;
    private static final String PRODUCT_OVERLAY_DIR = "/product/overlay";
    private static final String PRODUCT_SERVICES_OVERLAY_DIR = "/product_services/overlay";
    private static final String PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS = "enable_rollback_timeout";
    private static final int RADIO_UID = 1001;
    public static final int REASON_AB_OTA = 4;
    public static final int REASON_BACKGROUND_DEXOPT = 3;
    public static final int REASON_BOOT = 1;
    public static final int REASON_FIRST_BOOT = 0;
    public static final int REASON_INACTIVE_PACKAGE_DOWNGRADE = 5;
    public static final int REASON_INSTALL = 2;
    public static final int REASON_LAST = 6;
    public static final int REASON_SHARED = 6;
    public static final int REASON_UNKNOWN = -1;
    static final int SCAN_AS_FULL_APP = 32768;
    static final int SCAN_AS_INSTANT_APP = 16384;
    static final int SCAN_AS_ODM = 8388608;
    static final int SCAN_AS_OEM = 524288;
    static final int SCAN_AS_PRIVILEGED = 262144;
    static final int SCAN_AS_PRODUCT = 2097152;
    static final int SCAN_AS_PRODUCT_SERVICES = 4194304;
    static final int SCAN_AS_SYSTEM = 131072;
    static final int SCAN_AS_VENDOR = 1048576;
    static final int SCAN_AS_VIRTUAL_PRELOAD = 65536;
    static final int SCAN_BOOTING = 16;
    static final int SCAN_CHECK_ONLY = 1024;
    static final int SCAN_DONT_KILL_APP = 2048;
    static final int SCAN_FIRST_BOOT_OR_UPGRADE = 8192;
    static final int SCAN_IGNORE_FROZEN = 4096;
    static final int SCAN_INITIAL = 512;
    static final int SCAN_MOVE = 256;
    static final int SCAN_NEW_INSTALL = 4;
    static final int SCAN_NO_DEX = 1;
    static final int SCAN_REQUIRE_KNOWN = 128;
    static final int SCAN_UPDATE_SIGNATURE = 2;
    static final int SCAN_UPDATE_TIME = 8;
    private static final String SD_ENCRYPTION_ALGORITHM = "AES";
    private static final String SD_ENCRYPTION_KEYSTORE_NAME = "AppsOnSD";
    static final int SEND_PENDING_BROADCAST = 1;
    private static final int SE_UID = 1068;
    private static final int SHELL_UID = 2000;
    static final int START_INTENT_FILTER_VERIFICATIONS = 17;
    private static final String STATIC_SHARED_LIB_DELIMITER = "_";
    private static final int STATUS_UPDATED = 1;
    private static final int STATUS_UPDATING = 0;
    public static final String STUB_SUFFIX = "-Stub";
    private static final String SUW_FRP_STATE = "hw_suw_frp_state";
    private static final String SYSTEMUI_SCAN_ERROR = "persist.sys.systemui_scan_error";
    private static final String SYSTEM_MANAGER_PERMISSION = "com.huawei.systemmanager.permission.ACCESS_INTERFACE";
    private static final String SYSTEM_ROOT_DIR = "/system";
    private static final int SYSTEM_RUNTIME_GRANT_MASK = 52;
    static final String TAG = "PackageManager";
    private static final String TAG_ALL_GRANTS = "rt-grants";
    private static final String TAG_DEFAULT_APPS = "da";
    private static final String TAG_GRANT = "grant";
    private static final String TAG_INTENT_FILTER_VERIFICATION = "iv";
    private static final String TAG_PERMISSION = "perm";
    private static final String TAG_PERMISSION_BACKUP = "perm-grant-backup";
    private static final String TAG_PREFERRED_BACKUP = "pa";
    private static final int TYPE_ACTIVITY = 1;
    private static final int TYPE_PROVIDER = 4;
    private static final int TYPE_RECEIVER = 2;
    private static final int TYPE_SERVICE = 3;
    private static final int TYPE_UNKNOWN = 0;
    private static final String UPDATE_NOTIFICATION_SUPERWHITELIST = "com.huawei.notificationmanager.superwhitelist";
    private static final int USER_RUNTIME_GRANT_MASK = 11;
    private static final String VENDOR_OVERLAY_DIR = "/vendor/overlay";
    static final long WATCHDOG_TIMEOUT = 600000;
    static final int WRITE_PACKAGE_LIST = 19;
    static final int WRITE_PACKAGE_RESTRICTIONS = 14;
    static final int WRITE_SETTINGS = 13;
    static final int WRITE_SETTINGS_DELAY = 10000;
    static IHwPackageManagerServiceEx mHwPMSEx = null;
    private static final File sAppInstallDir = new File(Environment.getDataDirectory(), "app");
    protected static final File sAppLib32InstallDir = new File(Environment.getDataDirectory(), "app-lib");
    private static final Intent sBrowserIntent = new Intent();
    private static final Comparator<ProviderInfo> sProviderInitOrderSorter = $$Lambda$PackageManagerService$UNDOQ9SMFcIDWsoP2jqlhlLC9E.INSTANCE;
    static UserManagerService sUserManager;
    private int callingSessionUid = -1;
    private boolean isSystemUIScanned;
    private ActivityManagerInternal mActivityManagerInternal;
    private ActivityTaskManagerInternal mActivityTaskManagerInternal;
    ApplicationInfo mAndroidApplication;
    private final ApexManager mApexManager;
    private AppOpsManager mAppOpsManager;
    final String mAppPredictionServicePackage;
    final ArtManagerService mArtManagerService;
    @GuardedBy({"mAvailableFeatures"})
    final ArrayMap<String, FeatureInfo> mAvailableFeatures;
    @GuardedBy({"mAvailableHwFeatures"})
    final ArrayMap<String, FeatureInfo> mAvailableHwFeatures;
    private File mCacheDir;
    @GuardedBy({"mPackages"})
    final SparseArray<SparseArray<String>> mChangedPackages = new SparseArray<>();
    @GuardedBy({"mPackages"})
    int mChangedPackagesSequenceNumber;
    @GuardedBy({"mPackages"})
    final SparseArray<Map<String, Integer>> mChangedPackagesSequenceNumbers = new SparseArray<>();
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.CheckPermissionDelegate mCheckPermissionDelegate;
    private final CompilerStats mCompilerStats;
    private final ComponentResolver mComponentResolver;
    final String mConfiguratorPackage;
    final Context mContext;
    protected boolean mCotaFlag = false;
    ComponentName mCustomResolverComponentName;
    final int mDefParseFlags;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultBrowserProvider mDefaultBrowserProvider;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultDialerProvider mDefaultDialerProvider;
    @GuardedBy({"mPackages"})
    private PackageManagerInternal.DefaultHomeProvider mDefaultHomeProvider;
    protected final DefaultPermissionGrantPolicy mDefaultPermissionPolicy;
    @GuardedBy({"mPackages"})
    private final SparseIntArray mDefaultPermissionsGrantedUsers = new SparseIntArray();
    private ArrayList<String> mDelPackageList;
    private Set<Integer> mDeleteCheckingSet = new HashSet();
    private Map<Integer, Set<Long>> mDeletePackageCallMap = new HashMap();
    private DeviceIdleController.LocalService mDeviceIdleController;
    private final DexManager mDexManager;
    @GuardedBy({"mPackages"})
    private boolean mDexOptDialogShown;
    private ArraySet<Integer> mDirtyUsers = new ArraySet<>();
    final String mDocumenterPackage;
    private final ArraySet<String> mExistingSystemPackages = new ArraySet<>();
    private final ArrayMap<String, File> mExpectingBetter = new ArrayMap<>();
    PackageManagerInternal.ExternalSourcesPolicy mExternalSourcesPolicy;
    final boolean mFactoryTest;
    boolean mFirstBoot;
    @GuardedBy({"mPackages"})
    final ArraySet<String> mFrozenPackages = new ArraySet<>();
    final PackageHandler mHandler;
    final ServiceThread mHandlerThread;
    volatile boolean mHasSystemUidErrors;
    HwInnerPackageManagerService mHwInnerService;
    final String mIncidentReportApproverPackage;
    final Object mInstallLock = new Object();
    @GuardedBy({"mInstallLock"})
    final Installer mInstaller;
    final PackageInstallerService mInstallerService;
    ActivityInfo mInstantAppInstallerActivity;
    final ResolveInfo mInstantAppInstallerInfo = new ResolveInfo();
    private final InstantAppRegistry mInstantAppRegistry;
    final InstantAppResolverConnection mInstantAppResolverConnection;
    final ComponentName mInstantAppResolverSettingsComponent;
    final ArrayMap<ComponentName, PackageParser.Instrumentation> mInstrumentation = new ArrayMap<>();
    final SparseArray<IntentFilterVerificationState> mIntentFilterVerificationStates = new SparseArray<>();
    private int mIntentFilterVerificationToken = 0;
    private final IntentFilterVerifier<PackageParser.ActivityIntentInfo> mIntentFilterVerifier;
    private final ComponentName mIntentFilterVerifierComponent;
    protected boolean mIsDefaultGoogleCalendar = SystemProperties.getBoolean("ro.default_GoogleCalendar", false);
    protected boolean mIsDefaultPreferredActivityChanged = false;
    final boolean mIsEmuiVersionUpgrade;
    boolean mIsPackageScanMultiThread = SystemProperties.getBoolean("ro.config.hw_packagescan_multi", false);
    final boolean mIsPreNMR1Upgrade;
    final boolean mIsPreNUpgrade;
    final boolean mIsPrePUpgrade;
    final boolean mIsPreQUpgrade;
    final boolean mIsUpgrade;
    @GuardedBy({"mPackages"})
    final SparseIntArray mIsolatedOwners = new SparseIntArray();
    private List<String> mKeepUninstalledPackages;
    @GuardedBy({"mLoadedVolumes"})
    final ArraySet<String> mLoadedVolumes = new ArraySet<>();
    private boolean mMediaMounted;
    DisplayMetrics mMetrics;
    private final ModuleInfoProvider mModuleInfoProvider;
    private final MoveCallbacks mMoveCallbacks;
    int mNextInstallToken;
    private AtomicInteger mNextMoveId = new AtomicInteger();
    private final Map<String, Pair<PackageInstalledInfo, IPackageInstallObserver2>> mNoKillInstallObservers = Collections.synchronizedMap(new HashMap());
    private final OnPermissionChangeListeners mOnPermissionChangeListeners;
    final boolean mOnlyCore;
    protected final PackageDexOptimizer mPackageDexOptimizer;
    @GuardedBy({"mPackages"})
    private final ArraySet<PackageManagerInternal.PackageListObserver> mPackageListObservers = new ArraySet<>();
    final PackageParser.Callback mPackageParserCallback = new PackageParserCallback();
    private final PackageUsage mPackageUsage;
    @GuardedBy({"mPackages"})
    final ArrayMap<String, PackageParser.Package> mPackages = new ArrayMap<>();
    final ParallelPackageParserCallback mParallelPackageParserCallback = new ParallelPackageParserCallback();
    final PendingPackageBroadcasts mPendingBroadcasts = new PendingPackageBroadcasts();
    final SparseArray<InstallParams> mPendingEnableRollback = new SparseArray<>();
    private int mPendingEnableRollbackToken = 0;
    final SparseArray<PackageVerificationState> mPendingVerification = new SparseArray<>();
    private int mPendingVerificationToken = 0;
    protected PermissionManagerServiceInternal.PermissionCallback mPermissionCallback;
    protected final PermissionManagerServiceInternal mPermissionManager;
    PackageParser.Package mPlatformPackage;
    private Future<?> mPrepareAppDataFuture;
    private final ProcessLoggingHandler mProcessLoggingHandler;
    boolean mPromoteSystemApps;
    @GuardedBy({"mProtectedBroadcasts"})
    final ArraySet<String> mProtectedBroadcasts = new ArraySet<>();
    final ProtectedPackages mProtectedPackages;
    final String mRequiredInstallerPackage;
    final String mRequiredPermissionControllerPackage;
    final String mRequiredUninstallerPackage;
    final String mRequiredVerifierPackage;
    final ActivityInfo mResolveActivity = new ActivityInfo();
    ComponentName mResolveComponentName;
    final ResolveInfo mResolveInfo = new ResolveInfo();
    boolean mResolverReplaced = false;
    final SparseArray<PostInstallData> mRunningInstalls = new SparseArray<>();
    volatile boolean mSafeMode;
    final int mSdkVersion = Build.VERSION.SDK_INT;
    final String[] mSeparateProcesses;
    private long mServiceStartWithDelay;
    final String mServicesSystemSharedLibraryPackageName;
    @GuardedBy({"mPackages"})
    final Settings mSettings;
    final String mSetupWizardPackage;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mSharedLibraries = new ArrayMap<>();
    final String mSharedSystemSharedLibraryPackageName;
    final ArrayMap<String, LongSparseArray<SharedLibraryInfo>> mStaticLibsByDeclaringPackage = new ArrayMap<>();
    private StorageEventListener mStorageListener;
    private StorageManagerInternal mStorageManagerInternal;
    final String mStorageManagerPackage;
    volatile boolean mSystemReady;
    final String mSystemTextClassifierPackage;
    protected ArrayList<PackageParser.Package> mTempPkgList = new ArrayList<>();
    final ArraySet<String> mTransferedPackages = new ArraySet<>();
    private UserManagerInternal mUserManagerInternal;
    private final SparseBooleanArray mUserNeedsBadging = new SparseBooleanArray();
    private final ViewCompiler mViewCompiler;
    private volatile SparseBooleanArray mWebInstantAppsDisabled = new SparseBooleanArray();
    final String mWellbeingPackage;
    int tSdkVersion = -1;
    private String updatePackageName;

    /* access modifiers changed from: private */
    public interface BlobXmlRestorer {
        void apply(XmlPullParser xmlPullParser, int i) throws IOException, XmlPullParserException;
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ComponentType {
    }

    /* access modifiers changed from: private */
    public interface IntentFilterVerifier<T extends IntentFilter> {
        boolean addOneIntentFilterVerification(int i, int i2, int i3, T t, String str);

        void receiveVerificationResponse(int i);

        void startVerifications(int i);
    }

    @Retention(RetentionPolicy.SOURCE)
    public @interface ScanFlags {
    }

    static /* synthetic */ int access$3408(PackageManagerService x0) {
        int i = x0.mPendingVerificationToken;
        x0.mPendingVerificationToken = i + 1;
        return i;
    }

    static /* synthetic */ int access$3708(PackageManagerService x0) {
        int i = x0.mPendingEnableRollbackToken;
        x0.mPendingEnableRollbackToken = i + 1;
        return i;
    }

    static {
        sBrowserIntent.setAction("android.intent.action.VIEW");
        sBrowserIntent.addCategory("android.intent.category.BROWSABLE");
        sBrowserIntent.setData(Uri.parse("http:"));
        sBrowserIntent.addFlags(512);
    }

    class PackageParserCallback implements PackageParser.Callback {
        PackageParserCallback() {
        }

        public final boolean hasFeature(String feature) {
            if (PackageManagerService.this.hasSystemFeature(feature, 0)) {
                return true;
            }
            if (PackageManagerService.this.mHwInnerService != null) {
                return PackageManagerService.this.mHwInnerService.hasHwSystemFeature(feature, 0);
            }
            return false;
        }

        /* access modifiers changed from: package-private */
        public final List<PackageParser.Package> getStaticOverlayPackages(Collection<PackageParser.Package> allPackages, String targetPackageName) {
            if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(targetPackageName)) {
                return null;
            }
            List<PackageParser.Package> overlayPackages = null;
            for (PackageParser.Package p : allPackages) {
                if (targetPackageName.equals(p.mOverlayTarget) && p.mOverlayIsStatic) {
                    if (overlayPackages == null) {
                        overlayPackages = new ArrayList<>();
                    }
                    overlayPackages.add(p);
                }
            }
            if (overlayPackages != null) {
                overlayPackages.sort(Comparator.comparingInt($$Lambda$PackageManagerService$PackageParserCallback$xinvBJUpQse3J1IBBKjvYTIW8MQ.INSTANCE));
            }
            return overlayPackages;
        }

        /* access modifiers changed from: package-private */
        public final String[] getStaticOverlayPaths(List<PackageParser.Package> overlayPackages, String targetPath) {
            if (overlayPackages == null || overlayPackages.isEmpty()) {
                return null;
            }
            List<String> overlayPathList = null;
            for (PackageParser.Package overlayPackage : overlayPackages) {
                if (targetPath == null) {
                    if (overlayPathList == null) {
                        overlayPathList = new ArrayList<>();
                    }
                    overlayPathList.add(overlayPackage.baseCodePath);
                } else {
                    try {
                        PackageManagerService.this.mInstaller.idmap(targetPath, overlayPackage.baseCodePath, UserHandle.getSharedAppGid(UserHandle.getUserGid(0)));
                        if (overlayPathList == null) {
                            overlayPathList = new ArrayList<>();
                        }
                        overlayPathList.add(overlayPackage.baseCodePath);
                    } catch (Installer.InstallerException e) {
                        Slog.e(PackageManagerService.TAG, "Failed to generate idmap for " + targetPath + " and " + overlayPackage.baseCodePath);
                    }
                }
            }
            if (overlayPathList == null) {
                return null;
            }
            return (String[]) overlayPathList.toArray(new String[0]);
        }

        /* access modifiers changed from: package-private */
        public String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            List<PackageParser.Package> overlayPackages;
            String[] staticOverlayPaths;
            synchronized (PackageManagerService.this.mInstallLock) {
                synchronized (PackageManagerService.this.mPackages) {
                    overlayPackages = getStaticOverlayPackages(PackageManagerService.this.mPackages.values(), targetPackageName);
                }
                staticOverlayPaths = getStaticOverlayPaths(overlayPackages, targetPath);
            }
            return staticOverlayPaths;
        }

        public final String[] getOverlayApks(String targetPackageName) {
            return getStaticOverlayPaths(targetPackageName, (String) null);
        }

        public final String[] getOverlayPaths(String targetPackageName, String targetPath) {
            return getStaticOverlayPaths(targetPackageName, targetPath);
        }
    }

    /* access modifiers changed from: package-private */
    public class ParallelPackageParserCallback extends PackageParserCallback {
        List<PackageParser.Package> mOverlayPackages = null;

        ParallelPackageParserCallback() {
            super();
        }

        /* access modifiers changed from: package-private */
        public void findStaticOverlayPackages() {
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayIsStatic) {
                        if (this.mOverlayPackages == null) {
                            this.mOverlayPackages = new ArrayList();
                        }
                        this.mOverlayPackages.add(p);
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.PackageParserCallback
        public synchronized String[] getStaticOverlayPaths(String targetPackageName, String targetPath) {
            String[] strArr;
            if (this.mOverlayPackages == null) {
                strArr = null;
            } else {
                strArr = getStaticOverlayPaths(getStaticOverlayPackages(this.mOverlayPackages, targetPackageName), targetPath);
            }
            return strArr;
        }
    }

    /* access modifiers changed from: private */
    public static class IFVerificationParams {
        PackageParser.Package pkg;
        boolean replacing;
        int userId;
        int verifierUid;

        public IFVerificationParams(PackageParser.Package _pkg, boolean _replacing, int _userId, int _verifierUid) {
            this.pkg = _pkg;
            this.replacing = _replacing;
            this.userId = _userId;
            this.verifierUid = _verifierUid;
        }
    }

    private class IntentVerifierProxy implements IntentFilterVerifier<PackageParser.ActivityIntentInfo> {
        private Context mContext;
        private ArrayList<Integer> mCurrentIntentFilterVerifications = new ArrayList<>();
        private ComponentName mIntentFilterVerifierComponent;

        public IntentVerifierProxy(Context context, ComponentName verifierComponent) {
            this.mContext = context;
            this.mIntentFilterVerifierComponent = verifierComponent;
        }

        private String getDefaultScheme() {
            return "https";
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void startVerifications(int userId) {
            int count = this.mCurrentIntentFilterVerifications.size();
            for (int n = 0; n < count; n++) {
                int verificationId = this.mCurrentIntentFilterVerifications.get(n).intValue();
                IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
                String packageName = ivs.getPackageName();
                ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
                int filterCount = filters.size();
                ArraySet<String> domainsSet = new ArraySet<>();
                for (int m = 0; m < filterCount; m++) {
                    domainsSet.addAll(filters.get(m).getHostsList());
                }
                synchronized (PackageManagerService.this.mPackages) {
                    if (PackageManagerService.this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domainsSet) != null) {
                        PackageManagerService.this.scheduleWriteSettingsLocked();
                    }
                }
                sendVerificationRequest(verificationId, ivs);
            }
            this.mCurrentIntentFilterVerifications.clear();
        }

        private void sendVerificationRequest(int verificationId, IntentFilterVerificationState ivs) {
            Intent verificationIntent = new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION");
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_ID", verificationId);
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_URI_SCHEME", getDefaultScheme());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_HOSTS", ivs.getHostsString());
            verificationIntent.putExtra("android.content.pm.extra.INTENT_FILTER_VERIFICATION_PACKAGE_NAME", ivs.getPackageName());
            verificationIntent.setComponent(this.mIntentFilterVerifierComponent);
            verificationIntent.addFlags(268435456);
            long whitelistTimeout = PackageManagerService.this.getVerificationTimeout();
            BroadcastOptions options = BroadcastOptions.makeBasic();
            options.setTemporaryAppWhitelistDuration(whitelistTimeout);
            PackageManagerService.this.getDeviceIdleController().addPowerSaveTempWhitelistApp(Process.myUid(), this.mIntentFilterVerifierComponent.getPackageName(), whitelistTimeout, 0, true, "intent filter verifier");
            this.mContext.sendBroadcastAsUser(verificationIntent, UserHandle.SYSTEM, null, options.toBundle());
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Sending IntentFilter verification broadcast");
            }
        }

        @Override // com.android.server.pm.PackageManagerService.IntentFilterVerifier
        public void receiveVerificationResponse(int verificationId) {
            IntentFilterVerificationInfo ivi;
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            boolean verified = ivs.isVerified();
            ArrayList<PackageParser.ActivityIntentInfo> filters = ivs.getFilters();
            int count = filters.size();
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.i(PackageManagerService.TAG, "Received verification response " + verificationId + " for " + count + " filters, verified=" + verified);
            }
            for (int n = 0; n < count; n++) {
                PackageParser.ActivityIntentInfo filter = filters.get(n);
                filter.setVerified(verified);
                if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                    Slog.d(PackageManagerService.TAG, "IntentFilter " + filter.toString() + " verified with result:" + verified + " and hosts:" + ivs.getHostsString());
                }
            }
            PackageManagerService.this.mIntentFilterVerificationStates.remove(verificationId);
            String packageName = ivs.getPackageName();
            synchronized (PackageManagerService.this.mPackages) {
                ivi = PackageManagerService.this.mSettings.getIntentFilterVerificationLPr(packageName);
            }
            if (ivi == null) {
                Slog.w(PackageManagerService.TAG, "IntentFilterVerificationInfo not found for verificationId:" + verificationId + " packageName:" + packageName);
                return;
            }
            synchronized (PackageManagerService.this.mPackages) {
                if (verified) {
                    ivi.setStatus(2);
                } else {
                    ivi.setStatus(1);
                }
                PackageManagerService.this.scheduleWriteSettingsLocked();
                int userId = ivs.getUserId();
                if (userId != -1) {
                    int userStatus = PackageManagerService.this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                    int updatedStatus = 0;
                    boolean needUpdate = false;
                    if (userStatus == 0) {
                        if (verified) {
                            updatedStatus = 2;
                        }
                        needUpdate = true;
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Applying update; old=" + userStatus + " new=" + updatedStatus);
                        }
                    } else if (userStatus != 1) {
                        if (userStatus == 2) {
                            if (!verified) {
                                if (!SystemConfig.getInstance().getLinkedApps().contains(packageName)) {
                                    needUpdate = true;
                                    if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                        Slog.d(PackageManagerService.TAG, "Formerly validated but now failing; demoting");
                                    }
                                } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                                    Slog.d(PackageManagerService.TAG, "Updating bundled package " + packageName + " failed autoVerify, but sysconfig supersedes");
                                }
                            }
                        }
                    } else if (verified) {
                        updatedStatus = 2;
                        needUpdate = true;
                    }
                    if (needUpdate) {
                        PackageManagerService.this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, updatedStatus, userId);
                        PackageManagerService.this.scheduleWritePackageRestrictionsLocked(userId);
                    }
                } else {
                    Slog.i(PackageManagerService.TAG, "autoVerify ignored when installing for all users");
                }
            }
        }

        public boolean addOneIntentFilterVerification(int verifierUid, int userId, int verificationId, PackageParser.ActivityIntentInfo filter, String packageName) {
            if (!PackageManagerService.hasValidDomains(filter)) {
                return false;
            }
            IntentFilterVerificationState ivs = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId);
            if (ivs == null) {
                ivs = createDomainVerificationState(verifierUid, userId, verificationId, packageName);
            }
            if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(PackageManagerService.TAG, "Adding verification filter for " + packageName + ": " + filter);
            }
            ivs.addFilter(filter);
            return true;
        }

        private IntentFilterVerificationState createDomainVerificationState(int verifierUid, int userId, int verificationId, String packageName) {
            IntentFilterVerificationState ivs = new IntentFilterVerificationState(verifierUid, userId, packageName);
            ivs.setPendingState();
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIntentFilterVerificationStates.append(verificationId, ivs);
                this.mCurrentIntentFilterVerifications.add(Integer.valueOf(verificationId));
            }
            return ivs;
        }
    }

    /* access modifiers changed from: private */
    public static boolean hasValidDomains(PackageParser.ActivityIntentInfo filter) {
        return filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"));
    }

    /* access modifiers changed from: package-private */
    public static class PendingPackageBroadcasts {
        final SparseArray<ArrayMap<String, ArrayList<String>>> mUidMap = new SparseArray<>(2);

        public ArrayList<String> get(int userId, String packageName) {
            return getOrAllocate(userId).get(packageName);
        }

        public void put(int userId, String packageName, ArrayList<String> components) {
            getOrAllocate(userId).put(packageName, components);
        }

        public void remove(int userId, String packageName) {
            ArrayMap<String, ArrayList<String>> packages = this.mUidMap.get(userId);
            if (packages != null) {
                packages.remove(packageName);
            }
        }

        public void remove(int userId) {
            this.mUidMap.remove(userId);
        }

        public int userIdCount() {
            return this.mUidMap.size();
        }

        public int userIdAt(int n) {
            return this.mUidMap.keyAt(n);
        }

        public ArrayMap<String, ArrayList<String>> packagesForUserId(int userId) {
            return this.mUidMap.get(userId);
        }

        public int size() {
            int num = 0;
            for (int i = 0; i < this.mUidMap.size(); i++) {
                num += this.mUidMap.valueAt(i).size();
            }
            return num;
        }

        public void clear() {
            this.mUidMap.clear();
        }

        private ArrayMap<String, ArrayList<String>> getOrAllocate(int userId) {
            ArrayMap<String, ArrayList<String>> map = this.mUidMap.get(userId);
            if (map != null) {
                return map;
            }
            ArrayMap<String, ArrayList<String>> map2 = new ArrayMap<>();
            this.mUidMap.put(userId, map2);
            return map2;
        }
    }

    /* access modifiers changed from: package-private */
    public static class PostInstallData {
        public final InstallArgs args;
        public final Runnable mPostInstallRunnable;
        public final PackageInstalledInfo res;

        PostInstallData(InstallArgs _a, PackageInstalledInfo _r, Runnable postInstallRunnable) {
            this.args = _a;
            this.res = _r;
            this.mPostInstallRunnable = postInstallRunnable;
        }
    }

    /* access modifiers changed from: package-private */
    public class PackageHandler extends Handler {
        PackageHandler(Looper looper) {
            super(looper);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            try {
                doHandleMessage(msg);
            } finally {
                Process.setThreadPriority(10);
            }
        }

        /* JADX INFO: Multiple debug info for r0v31 int: [D('verificationId' int), D('params' com.android.server.pm.PackageManagerService$IFVerificationParams)] */
        /* access modifiers changed from: package-private */
        public void doHandleMessage(Message msg) {
            String[] packages;
            ArrayList<String>[] components;
            int[] uids;
            int i;
            int i2;
            ArrayList whitelistedRestrictedPermissions;
            int i3 = msg.what;
            int childCount = 0;
            if (i3 == 1) {
                Process.setThreadPriority(0);
                synchronized (PackageManagerService.this.mPackages) {
                    int size = PackageManagerService.this.mPendingBroadcasts.size();
                    if (size > 0) {
                        packages = new String[size];
                        components = new ArrayList[size];
                        uids = new int[size];
                        i = 0;
                        while (childCount < PackageManagerService.this.mPendingBroadcasts.userIdCount()) {
                            int packageUserId = PackageManagerService.this.mPendingBroadcasts.userIdAt(childCount);
                            Iterator<Map.Entry<String, ArrayList<String>>> it = PackageManagerService.this.mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                            while (it.hasNext() && i < size) {
                                Map.Entry<String, ArrayList<String>> ent = it.next();
                                packages[i] = ent.getKey();
                                components[i] = ent.getValue();
                                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(ent.getKey());
                                if (ps != null) {
                                    i2 = UserHandle.getUid(packageUserId, ps.appId);
                                } else {
                                    i2 = -1;
                                }
                                uids[i] = i2;
                                i++;
                            }
                            childCount++;
                        }
                        PackageManagerService.this.mPendingBroadcasts.clear();
                    } else {
                        return;
                    }
                }
                for (int i4 = 0; i4 < i; i4++) {
                    PackageManagerService.this.sendPackageChangedBroadcast(packages[i4], true, components[i4], uids[i4]);
                }
                Process.setThreadPriority(10);
            } else if (i3 == 5) {
                HandlerParams params = (HandlerParams) msg.obj;
                if (params != null) {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.i(PackageManagerService.TAG, "init_copy: " + params);
                    }
                    Trace.asyncTraceEnd(262144, "queueInstall", System.identityHashCode(params));
                    Trace.traceBegin(262144, "startCopy");
                    params.startCopy();
                    Trace.traceEnd(262144);
                }
            } else if (i3 != 9) {
                switch (i3) {
                    case 13:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(13);
                            removeMessages(14);
                            PackageManagerService.this.mSettings.writeLPr();
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 14:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(14);
                            Iterator it2 = PackageManagerService.this.mDirtyUsers.iterator();
                            while (it2.hasNext()) {
                                PackageManagerService.this.mSettings.writePackageRestrictionsLPr(((Integer) it2.next()).intValue());
                            }
                            PackageManagerService.this.mDirtyUsers.clear();
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 15:
                        int verificationId = msg.arg1;
                        PackageVerificationState state = PackageManagerService.this.mPendingVerification.get(verificationId);
                        if (state == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid verification token " + verificationId + " received");
                            return;
                        }
                        PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                        state.setVerifierResponse(response.callerUid, response.code);
                        if (state.isVerificationComplete()) {
                            PackageManagerService.this.mPendingVerification.remove(verificationId);
                            InstallParams params2 = state.getInstallParams();
                            InstallArgs args = params2.mArgs;
                            Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                            if (state.isInstallAllowed()) {
                                PackageManagerService.this.broadcastPackageVerified(verificationId, originUri, response.code, args.getUser());
                            } else {
                                params2.setReturnCode(-22);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId);
                            params2.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 16:
                        int verificationId2 = msg.arg1;
                        PackageVerificationState state2 = PackageManagerService.this.mPendingVerification.get(verificationId2);
                        if (!(state2 == null || state2.timeoutExtended())) {
                            InstallParams params3 = state2.getInstallParams();
                            InstallArgs args2 = params3.mArgs;
                            Uri originUri2 = Uri.fromFile(args2.origin.resolvedFile);
                            Slog.i(PackageManagerService.TAG, "Verification timed out for " + originUri2);
                            PackageManagerService.this.mPendingVerification.remove(verificationId2);
                            UserHandle user = args2.getUser();
                            if (PackageManagerService.this.getDefaultVerificationResponse(user) == 1) {
                                Slog.i(PackageManagerService.TAG, "Continuing with installation of " + originUri2);
                                state2.setVerifierResponse(Binder.getCallingUid(), 2);
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, 1, user);
                            } else {
                                PackageManagerService.this.broadcastPackageVerified(verificationId2, originUri2, -1, user);
                                params3.setReturnCode(-22);
                            }
                            Trace.asyncTraceEnd(262144, "verification", verificationId2);
                            params3.handleVerificationFinished();
                            return;
                        }
                        return;
                    case 17:
                        IFVerificationParams params4 = (IFVerificationParams) msg.obj;
                        PackageManagerService.this.verifyIntentFiltersIfNeeded(params4.userId, params4.verifierUid, params4.replacing, params4.pkg);
                        return;
                    case 18:
                        int verificationId3 = msg.arg1;
                        IntentFilterVerificationState state3 = PackageManagerService.this.mIntentFilterVerificationStates.get(verificationId3);
                        if (state3 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid IntentFilter verification token " + verificationId3 + " received");
                            return;
                        }
                        int userId = state3.getUserId();
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Processing IntentFilter verification with token:" + verificationId3 + " and userId:" + userId);
                        }
                        IntentFilterVerificationResponse response2 = (IntentFilterVerificationResponse) msg.obj;
                        state3.setVerifierResponse(response2.callerUid, response2.code);
                        if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " and userId:" + userId + " is settings verifier response with response code:" + response2.code);
                        }
                        if (response2.code == -1 && PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "Domains failing verification: " + response2.getFailedDomainsString());
                        }
                        if (state3.isVerificationComplete()) {
                            PackageManagerService.this.mIntentFilterVerifier.receiveVerificationResponse(verificationId3);
                            return;
                        } else if (PackageManagerService.DEBUG_DOMAIN_VERIFICATION) {
                            Slog.d(PackageManagerService.TAG, "IntentFilter verification with token:" + verificationId3 + " was not said to be complete");
                            return;
                        } else {
                            return;
                        }
                    case 19:
                        Process.setThreadPriority(0);
                        synchronized (PackageManagerService.this.mPackages) {
                            removeMessages(19);
                            PackageManagerService.this.mSettings.writePackageListLPr(msg.arg1);
                        }
                        Process.setThreadPriority(10);
                        return;
                    case 20:
                        InstantAppResolver.doInstantAppResolutionPhaseTwo(PackageManagerService.this.mContext, PackageManagerService.this.mInstantAppResolverConnection, (InstantAppRequest) msg.obj, PackageManagerService.this.mInstantAppInstallerActivity, PackageManagerService.this.mHandler);
                        return;
                    case 21:
                        int enableRollbackToken = msg.arg1;
                        int enableRollbackCode = msg.arg2;
                        InstallParams params5 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken);
                        if (params5 == null) {
                            Slog.w(PackageManagerService.TAG, "Invalid rollback enabled token " + enableRollbackToken + " received");
                            return;
                        }
                        PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken);
                        if (enableRollbackCode != 1) {
                            Uri originUri3 = Uri.fromFile(params5.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Failed to enable rollback for " + originUri3);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri3);
                        }
                        Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken);
                        params5.handleRollbackEnabled();
                        return;
                    case 22:
                        int enableRollbackToken2 = msg.arg1;
                        InstallParams params6 = PackageManagerService.this.mPendingEnableRollback.get(enableRollbackToken2);
                        if (params6 != null) {
                            Uri originUri4 = Uri.fromFile(params6.mArgs.origin.resolvedFile);
                            Slog.w(PackageManagerService.TAG, "Enable rollback timed out for " + originUri4);
                            PackageManagerService.this.mPendingEnableRollback.remove(enableRollbackToken2);
                            Slog.w(PackageManagerService.TAG, "Continuing with installation of " + originUri4);
                            Trace.asyncTraceEnd(262144, "enable_rollback", enableRollbackToken2);
                            params6.handleRollbackEnabled();
                            Intent rollbackTimeoutIntent = new Intent("android.intent.action.CANCEL_ENABLE_ROLLBACK");
                            rollbackTimeoutIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken2);
                            rollbackTimeoutIntent.addFlags(DumpState.DUMP_HANDLE);
                            PackageManagerService.this.mContext.sendBroadcastAsUser(rollbackTimeoutIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT");
                            return;
                        }
                        return;
                    case PackageManagerService.DEFERRED_NO_KILL_POST_DELETE /* 23 */:
                        synchronized (PackageManagerService.this.mInstallLock) {
                            InstallArgs args3 = (InstallArgs) msg.obj;
                            if (args3 != null) {
                                args3.doPostDeleteLI(true);
                            }
                        }
                        return;
                    case PackageManagerService.DEFERRED_NO_KILL_INSTALL_OBSERVER /* 24 */:
                        String packageName = (String) msg.obj;
                        if (packageName != null) {
                            PackageManagerService.this.notifyInstallObserver(packageName);
                            return;
                        }
                        return;
                    default:
                        return;
                }
            } else {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Log.v(PackageManagerService.TAG, "Handling post-install for " + msg.arg1);
                }
                PostInstallData data = PackageManagerService.this.mRunningInstalls.get(msg.arg1);
                boolean didRestore = msg.arg2 != 0;
                PackageManagerService.this.mRunningInstalls.delete(msg.arg1);
                if (data != null && data.mPostInstallRunnable != null) {
                    data.mPostInstallRunnable.run();
                } else if (data != null) {
                    InstallArgs args4 = data.args;
                    PackageInstalledInfo parentRes = data.res;
                    if (parentRes != null) {
                        HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(1, parentRes.uid, 0, parentRes.name, parentRes.installerPackageName);
                    }
                    boolean grantPermissions = (args4.installFlags & 256) != 0;
                    boolean killApp = (args4.installFlags & 4096) == 0;
                    boolean virtualPreload = (args4.installFlags & 65536) != 0;
                    PackageManagerService.mHwPMSEx.addGrantedInstalledPkg(parentRes.pkg, grantPermissions);
                    String[] grantedPermissions = args4.installGrantPermissions;
                    if ((args4.installFlags & 4194304) == 0 || parentRes.pkg == null) {
                        whitelistedRestrictedPermissions = args4.whitelistedRestrictedPermissions;
                    } else {
                        whitelistedRestrictedPermissions = parentRes.pkg.requestedPermissions;
                    }
                    PackageManagerService.this.handlePackagePostInstall(parentRes, grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, didRestore, args4.installerPackageName, args4.observer);
                    if (parentRes.addedChildPackages != null) {
                        childCount = parentRes.addedChildPackages.size();
                    }
                    for (int i5 = 0; i5 < childCount; i5++) {
                        PackageManagerService.this.handlePackagePostInstall(parentRes.addedChildPackages.valueAt(i5), grantPermissions, killApp, virtualPreload, grantedPermissions, whitelistedRestrictedPermissions, false, args4.installerPackageName, args4.observer);
                    }
                    if (!(parentRes.pkg == null || (PackageManagerService.isSystemApp(parentRes.pkg) && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) == 0 && (parentRes.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0))) {
                        PackageManagerService.this.parseInstalledPkgInfo(args4, parentRes);
                    }
                    if (args4.traceMethod != null) {
                        Trace.asyncTraceEnd(262144, args4.traceMethod, args4.traceCookie);
                    }
                } else if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.i(PackageManagerService.TAG, "Nothing to do for post-install token " + msg.arg1);
                }
                Trace.asyncTraceEnd(262144, "postInstall", msg.arg1);
            }
        }
    }

    private void updateDisablePluginsLocked(PackageParser.Package pkg, List<String> removeSplitList) {
        ArrayList<String> disablePlugins;
        String[] installedSplitNames;
        if (pkg != null) {
            try {
                if (pkg.codePath == null) {
                    return;
                }
                if (pkg.codePath.startsWith(sAppInstallDir.getCanonicalPath())) {
                    String packageName = pkg.packageName;
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    if (!(disabledPs == null || disabledPs.pkg == null)) {
                        if ((disabledPs.hw_extra_flags & 1) != 0) {
                            Slog.i(TAG, packageName + " disablePlugins: " + Arrays.toString(disabledPs.disablePlugins));
                            if (disabledPs.disablePlugins == null || disabledPs.disablePlugins.length <= 0) {
                                disablePlugins = new ArrayList<>();
                            } else {
                                disablePlugins = new ArrayList<>(Arrays.asList(disabledPs.disablePlugins));
                            }
                            String[] presetSplitNames = disabledPs.pkg.splitNames;
                            ArrayList<String> presetSplitList = new ArrayList<>(Arrays.asList(presetSplitNames));
                            for (int i = 0; i < presetSplitNames.length; i++) {
                                String splitName = presetSplitNames[i];
                                boolean isPluginPreset = (disabledPs.pkg.splitPrivateFlags[i] & Integer.MIN_VALUE) != 0;
                                boolean isRemoved = removeSplitList != null && removeSplitList.contains(splitName);
                                if (isPluginPreset && isRemoved && !disablePlugins.contains(splitName)) {
                                    disablePlugins.add(splitName);
                                }
                            }
                            for (String str : pkg.splitNames) {
                                disablePlugins.remove(str);
                            }
                            disablePlugins.removeIf(new Predicate(presetSplitList) {
                                /* class com.android.server.pm.$$Lambda$PackageManagerService$hmtzd5G2cJRtfjfGbXf2UQQRcQ */
                                private final /* synthetic */ ArrayList f$0;

                                {
                                    this.f$0 = r1;
                                }

                                @Override // java.util.function.Predicate
                                public final boolean test(Object obj) {
                                    return PackageManagerService.lambda$updateDisablePluginsLocked$0(this.f$0, (String) obj);
                                }
                            });
                            String[] disablePluginNew = (String[]) disablePlugins.toArray(new String[disablePlugins.size()]);
                            Slog.i(TAG, packageName + " disablePlugins change to: " + Arrays.toString(disablePluginNew));
                            if (!Arrays.equals(disablePluginNew, disabledPs.disablePlugins)) {
                                disabledPs.disablePlugins = disablePluginNew;
                            }
                            Slog.i(TAG, packageName + " updateDisablePlugins finish");
                        }
                    }
                }
            } catch (Exception e) {
                Slog.e(TAG, "updateDisablePlugins error " + e.getMessage());
            }
        }
    }

    static /* synthetic */ boolean lambda$updateDisablePluginsLocked$0(ArrayList presetSplitList, String e) {
        return !presetSplitList.contains(e);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x03b5, code lost:
        r0 = th;
     */
    private void handlePackagePostInstall(PackageInstalledInfo res, boolean grantPermissions, boolean killApp, boolean virtualPreload, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions, boolean launchedForRestore, String installerPackage, IPackageInstallObserver2 installObserver) {
        boolean z;
        boolean deferInstallObserver;
        String installerPackageName;
        int[] firstUserIds;
        InstallArgs args;
        String installerPackageName2;
        int packageExternalStorageType;
        int i;
        int[] iArr;
        boolean succeeded = res.returnCode == 1;
        boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        if (succeeded) {
            if (res.removedInfo != null) {
                res.removedInfo.sendPackageRemovedBroadcasts(killApp);
            }
            if (whitelistedRestrictedPermissions != null && !whitelistedRestrictedPermissions.isEmpty()) {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(res.pkg, res.newUsers, whitelistedRestrictedPermissions, Process.myUid(), 2, this.mPermissionCallback);
            }
            boolean isSystemAppGrantByMdmAndNonPreload = isSystemAppGrantByMdmAndNonPreload(res.pkg);
            if (grantPermissions || isSystemAppGrantByMdmAndNonPreload) {
                this.mPermissionManager.grantRequestedRuntimePermissions(res.pkg, res.newUsers, grantedPermissions, Binder.getCallingUid(), this.mPermissionCallback);
            }
            if (isSystemAppGrantByMdmAndNonPreload) {
                mHwPMSEx.updateDozeList(res.pkg.applicationInfo.packageName, true);
            }
            if (res.installerPackageName != null) {
                installerPackageName = res.installerPackageName;
            } else if (res.removedInfo != null) {
                installerPackageName = res.removedInfo.installerPackageName;
            } else {
                installerPackageName = null;
            }
            if (res.pkg.parentPackage != null) {
                this.mPermissionManager.grantRuntimePermissionsGrantedToDisabledPackage(res.pkg, Binder.getCallingUid(), this.mPermissionCallback);
            }
            synchronized (this.mPackages) {
                this.mInstantAppRegistry.onPackageInstalledLPw(res.pkg, res.newUsers);
            }
            String packageName = res.pkg.applicationInfo.packageName;
            int[] firstUserIds2 = EMPTY_INT_ARRAY;
            int[] firstInstantUserIds = EMPTY_INT_ARRAY;
            int[] updateUserIds = EMPTY_INT_ARRAY;
            int[] instantUserIds = EMPTY_INT_ARRAY;
            boolean allNewUsers = res.origUsers == null || res.origUsers.length == 0;
            PackageSetting ps = (PackageSetting) res.pkg.mExtras;
            int[] iArr2 = res.newUsers;
            int length = iArr2.length;
            int[] instantUserIds2 = instantUserIds;
            int[] firstUserIds3 = firstUserIds2;
            int i2 = 0;
            int[] firstInstantUserIds2 = firstInstantUserIds;
            int[] updateUserIds2 = updateUserIds;
            while (i2 < length) {
                int newUser = iArr2[i2];
                boolean isInstantApp = ps.getInstantApp(newUser);
                if (!allNewUsers) {
                    boolean isNew = true;
                    int[] iArr3 = res.origUsers;
                    iArr = iArr2;
                    int length2 = iArr3.length;
                    i = length;
                    int i3 = 0;
                    while (true) {
                        if (i3 >= length2) {
                            break;
                        } else if (iArr3[i3] == newUser) {
                            isNew = false;
                            break;
                        } else {
                            i3++;
                            length2 = length2;
                        }
                    }
                    if (isNew) {
                        if (isInstantApp) {
                            firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                        } else {
                            firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                        }
                    } else if (isInstantApp) {
                        instantUserIds2 = ArrayUtils.appendInt(instantUserIds2, newUser);
                    } else {
                        updateUserIds2 = ArrayUtils.appendInt(updateUserIds2, newUser);
                    }
                } else if (isInstantApp) {
                    firstInstantUserIds2 = ArrayUtils.appendInt(firstInstantUserIds2, newUser);
                    iArr = iArr2;
                    i = length;
                } else {
                    firstUserIds3 = ArrayUtils.appendInt(firstUserIds3, newUser);
                    iArr = iArr2;
                    i = length;
                }
                i2++;
                iArr2 = iArr;
                length = i;
            }
            mHwPMSEx.updatePackageBlackListInfo(packageName);
            if (res.pkg.staticSharedLibName == null) {
                this.mProcessLoggingHandler.invalidateProcessLoggingBaseApkHash(res.pkg.baseCodePath);
                mHwPMSEx.sendIncompatibleNotificationIfNeeded(packageName);
                sendPackageAddedForNewUsers(packageName, res.pkg.applicationInfo.isSystemApp() || virtualPreload, virtualPreload, UserHandle.getAppId(res.uid), firstUserIds3, firstInstantUserIds2);
                Bundle extras = new Bundle(1);
                extras.putInt("android.intent.extra.UID", res.uid);
                if (update) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                args = null;
                sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, updateUserIds2, instantUserIds2);
                if (installerPackageName != null) {
                    installerPackageName2 = installerPackageName;
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, installerPackageName, null, updateUserIds2, instantUserIds2);
                } else {
                    installerPackageName2 = installerPackageName;
                }
                String str = this.mRequiredVerifierPackage;
                boolean notifyVerifier = str != null && !str.equals(installerPackageName2);
                if (notifyVerifier) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds2);
                }
                String str2 = this.mRequiredInstallerPackage;
                if (str2 != null) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, DumpState.DUMP_SERVICE_PERMISSIONS, str2, null, firstUserIds3, instantUserIds2);
                }
                if (update) {
                    sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, null, null, updateUserIds2, instantUserIds2);
                    if (installerPackageName2 != null) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, installerPackageName2, null, updateUserIds2, instantUserIds2);
                    }
                    if (notifyVerifier) {
                        sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", packageName, extras, 0, this.mRequiredVerifierPackage, null, updateUserIds2, instantUserIds2);
                    }
                    sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, packageName, null, updateUserIds2, instantUserIds2);
                    HwPackageManagerServiceUtils.sendUpdateBroadcast(this.mProcessLoggingHandler, 1, this.updatePackageName, "com.huawei.android.launcher", this.mContext);
                    firstUserIds = firstUserIds3;
                    packageName = packageName;
                } else if (!launchedForRestore || isSystemApp(res.pkg)) {
                    firstUserIds = firstUserIds3;
                    packageName = packageName;
                } else {
                    if (DEBUG_BACKUP) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("Post-restore of ");
                        packageName = packageName;
                        sb.append(packageName);
                        sb.append(" sending FIRST_LAUNCH in ");
                        sb.append(Arrays.toString(firstUserIds3));
                        Slog.i(TAG, sb.toString());
                    } else {
                        packageName = packageName;
                    }
                    firstUserIds = firstUserIds3;
                    sendFirstLaunchBroadcast(packageName, installerPackage, firstUserIds, firstInstantUserIds2);
                }
                if (isExternal(res.pkg)) {
                    if (!update && (packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(res.pkg.applicationInfo.storageUuid.toString()), isExternal(res.pkg))) != 0) {
                        StatsLog.write(181, packageExternalStorageType, res.pkg.packageName);
                    }
                    if (DEBUG_INSTALL) {
                        Slog.i(TAG, "upgrading pkg " + res.pkg + " is external");
                    }
                    int[] uidArray = {res.pkg.applicationInfo.uid};
                    ArrayList<String> pkgList = new ArrayList<>(1);
                    pkgList.add(packageName);
                    sendResourcesChangedBroadcast(true, true, pkgList, uidArray, (IIntentReceiver) null);
                }
            } else {
                firstUserIds = firstUserIds3;
                args = null;
            }
            if (firstUserIds != null && firstUserIds.length > 0) {
                for (int userId : firstUserIds) {
                    if (!IS_HW_PREFER_APP_POLICY && packageIsBrowser(packageName, userId)) {
                        synchronized (this.mPackages) {
                            if (this.mSettings.mPackages.get(packageName).getInstallReason(userId) != 2) {
                                args = null;
                                setDefaultBrowserAsyncLPw(null, userId);
                            } else {
                                args = null;
                            }
                        }
                    }
                    this.mPermissionManager.restoreDelayedRuntimePermissions(packageName, UserHandle.of(userId));
                    updateDefaultHomeNotLocked(userId);
                }
            }
            if (!allNewUsers || update) {
                notifyPackageChanged(packageName, res.uid);
            } else {
                notifyPackageAdded(packageName, res.uid);
            }
            EventLog.writeEvent((int) EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
            if (res.removedInfo != null) {
                args = res.removedInfo.args;
            }
            if (args == null) {
                VMRuntime.getRuntime().requestConcurrentGC();
            } else if (!killApp) {
                scheduleDeferredNoKillPostDelete(args);
            } else {
                synchronized (this.mInstallLock) {
                    args.doPostDeleteLI(true);
                }
            }
            for (int userId2 : firstUserIds) {
                PackageInfo info = getPackageInfo(packageName, 0, userId2);
                if (info != null) {
                    this.mDexManager.notifyPackageInstalled(info, userId2);
                }
            }
            deferInstallObserver = false;
            z = true;
        } else {
            deferInstallObserver = false;
            z = true;
            HwPackageManagerServiceUtils.sendUpdateBroadcast(this.mProcessLoggingHandler, 1, this.updatePackageName, "com.huawei.android.launcher", this.mContext);
        }
        if (succeeded && update && !killApp) {
            deferInstallObserver = z;
        }
        if (deferInstallObserver) {
            scheduleDeferredNoKillInstallObserver(res, installObserver);
            return;
        } else {
            notifyInstallObserver(res, installObserver);
            return;
        }
        while (true) {
        }
    }

    public void notifyPackagesReplacedReceived(String[] packages) {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        for (String packageName : packages) {
            PackageSetting setting = this.mSettings.mPackages.get(packageName);
            if (setting != null && filterAppAccessLPr(setting, callingUid, callingUserId)) {
                notifyInstallObserver(packageName);
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void notifyInstallObserver(String packageName) {
        Pair<PackageInstalledInfo, IPackageInstallObserver2> pair = this.mNoKillInstallObservers.remove(packageName);
        if (pair != null) {
            notifyInstallObserver((PackageInstalledInfo) pair.first, (IPackageInstallObserver2) pair.second);
        }
    }

    private void notifyInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 installObserver) {
        if (installObserver != null) {
            try {
                installObserver.onPackageInstalled(info.name, info.returnCode, info.returnMsg, extrasForInstallResult(info));
            } catch (RemoteException e) {
                Slog.i(TAG, "Observer no longer exists.");
            }
        }
    }

    private void scheduleDeferredNoKillPostDelete(InstallArgs args) {
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(DEFERRED_NO_KILL_POST_DELETE, args), BackupAgentTimeoutParameters.DEFAULT_QUOTA_EXCEEDED_TIMEOUT_MILLIS);
    }

    private void scheduleDeferredNoKillInstallObserver(PackageInstalledInfo info, IPackageInstallObserver2 observer) {
        String packageName = info.pkg.packageName;
        this.mNoKillInstallObservers.put(packageName, Pair.create(info, observer));
        this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(DEFERRED_NO_KILL_INSTALL_OBSERVER, packageName), 500);
    }

    private static int getPackageExternalStorageType(VolumeInfo packageVolume, boolean packageIsExternal) {
        DiskInfo disk;
        if (packageVolume == null || (disk = packageVolume.getDisk()) == null) {
            return 0;
        }
        if (disk.isSd()) {
            return 1;
        }
        if (disk.isUsb()) {
            return 2;
        }
        if (packageIsExternal) {
            return 3;
        }
        return 0;
    }

    /* access modifiers changed from: package-private */
    public Bundle extrasForInstallResult(PackageInstalledInfo res) {
        int i = res.returnCode;
        if (i != -112) {
            boolean z = true;
            if (i != 1) {
                return null;
            }
            Bundle extras = new Bundle();
            if (res.removedInfo == null || res.removedInfo.removedPackage == null) {
                z = false;
            }
            extras.putBoolean("android.intent.extra.REPLACING", z);
            return extras;
        }
        Bundle extras2 = new Bundle();
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PERMISSION", res.origPermission);
        extras2.putString("android.content.pm.extra.FAILURE_EXISTING_PACKAGE", res.origPackage);
        return extras2;
    }

    /* access modifiers changed from: package-private */
    public void scheduleWriteSettingsLocked() {
        if (!this.mHandler.hasMessages(13)) {
            this.mHandler.sendEmptyMessageDelayed(13, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageListLocked(int userId) {
        if (!this.mHandler.hasMessages(19)) {
            Message msg = this.mHandler.obtainMessage(19);
            msg.arg1 = userId;
            this.mHandler.sendMessageDelayed(msg, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(UserHandle user) {
        scheduleWritePackageRestrictionsLocked(user == null ? -1 : user.getIdentifier());
    }

    /* access modifiers changed from: package-private */
    public void scheduleWritePackageRestrictionsLocked(int userId) {
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (sUserManager.exists(nextUserId)) {
                this.mDirtyUsers.add(Integer.valueOf(nextUserId));
                if (!this.mHandler.hasMessages(14)) {
                    this.mHandler.sendEmptyMessageDelayed(14, JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
                }
            } else {
                return;
            }
        }
    }

    /* JADX WARN: Type inference failed for: r2v0, types: [com.android.server.pm.PackageManagerService, java.lang.Object, android.os.IBinder] */
    /* JADX WARN: Type inference failed for: r3v1, types: [com.android.server.pm.PackageManagerService$PackageManagerNative, android.os.IBinder] */
    /* JADX WARNING: Unknown variable types count: 2 */
    public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        long startTime = SystemClock.uptimeMillis();
        PackageManagerServiceCompilerMapping.checkProperties();
        ?? huaweiPackageManagerService = HwServiceFactory.getHuaweiPackageManagerService(context, installer, factoryTest, onlyCore);
        huaweiPackageManagerService.enableSystemUserPackages();
        ServiceManager.addService("package", (IBinder) huaweiPackageManagerService);
        Objects.requireNonNull(huaweiPackageManagerService);
        ServiceManager.addService("package_native", (IBinder) new PackageManagerNative());
        HwPackageManagerServiceUtils.timingsEnd(TAG, "PackageManagerService booting timestamp", startTime);
        return huaweiPackageManagerService;
    }

    private void enableSystemUserPackages() {
        if (UserManager.isSplitSystemUser()) {
            AppsQueryHelper queryHelper = new AppsQueryHelper(this);
            Set<String> enableApps = new ArraySet<>();
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_NON_LAUNCHABLE_APPS | AppsQueryHelper.GET_APPS_WITH_INTERACT_ACROSS_USERS_PERM | AppsQueryHelper.GET_IMES, true, UserHandle.SYSTEM));
            enableApps.addAll(SystemConfig.getInstance().getSystemUserWhitelistedApps());
            enableApps.addAll(queryHelper.queryApps(AppsQueryHelper.GET_REQUIRED_FOR_SYSTEM_USER, false, UserHandle.SYSTEM));
            enableApps.removeAll(SystemConfig.getInstance().getSystemUserBlacklistedApps());
            Log.i(TAG, "Applications installed for system user: " + enableApps);
            List<String> allAps = queryHelper.queryApps(0, false, UserHandle.SYSTEM);
            int allAppsSize = allAps.size();
            synchronized (this.mPackages) {
                for (int i = 0; i < allAppsSize; i++) {
                    String pName = allAps.get(i);
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(pName);
                    if (pkgSetting != null) {
                        boolean install = enableApps.contains(pName);
                        if (pkgSetting.getInstalled(0) != install) {
                            StringBuilder sb = new StringBuilder();
                            sb.append(install ? "Installing " : "Uninstalling ");
                            sb.append(pName);
                            sb.append(" for system user");
                            Log.i(TAG, sb.toString());
                            pkgSetting.setInstalled(install, 0);
                        }
                    }
                }
                scheduleWritePackageRestrictionsLocked(0);
            }
        }
    }

    /* access modifiers changed from: private */
    public static void getDefaultDisplayMetrics(Context context, DisplayMetrics metrics) {
        ((DisplayManager) context.getSystemService("display")).getDisplay(0).getMetrics(metrics);
    }

    private static void requestCopyPreoptedFiles() {
        if (SystemProperties.getInt("ro.cp_system_other_odex", 0) == 1) {
            SystemProperties.set("sys.cppreopt", "requested");
            long timeStart = SystemClock.uptimeMillis();
            long timeEnd = 100000 + timeStart;
            long timeNow = timeStart;
            while (true) {
                if (SystemProperties.get("sys.cppreopt").equals("finished")) {
                    break;
                }
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
                timeNow = SystemClock.uptimeMillis();
                if (timeNow > timeEnd) {
                    SystemProperties.set("sys.cppreopt", "timed-out");
                    Slog.wtf(TAG, "cppreopt did not finish!");
                    break;
                }
            }
            Slog.i(TAG, "cppreopts took " + (timeNow - timeStart) + " ms");
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:724:0x1386 */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:564:0x138c */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:214:0x078e */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:650:0x153c */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:727:0x1386 */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r22v3 */
    /* JADX WARN: Type inference failed for: r22v8 */
    /* JADX WARN: Type inference failed for: r40v0 */
    /* JADX WARN: Type inference failed for: r1v231, types: [boolean] */
    /* JADX WARN: Type inference failed for: r1v232, types: [com.android.server.pm.permission.PermissionManagerServiceInternal] */
    /* JADX WARN: Type inference failed for: r6v12, types: [boolean] */
    /* JADX WARN: Type inference failed for: r40v2 */
    /* JADX WARN: Type inference failed for: r40v5 */
    /* JADX WARN: Type inference failed for: r40v7 */
    /* JADX WARN: Type inference failed for: r40v8 */
    /* JADX WARN: Type inference failed for: r6v27 */
    /* JADX WARN: Type inference failed for: r6v28 */
    /* JADX WARN: Type inference failed for: r1v310 */
    /* JADX WARN: Type inference failed for: r1v311 */
    /* JADX WARN: Type inference failed for: r22v12 */
    /* JADX WARN: Type inference failed for: r22v14 */
    /* JADX WARNING: Removed duplicated region for block: B:36:0x02bf  */
    /* JADX WARNING: Removed duplicated region for block: B:45:0x0370  */
    /* JADX WARNING: Removed duplicated region for block: B:48:0x03ad A[SYNTHETIC, Splitter:B:48:0x03ad] */
    /* JADX WARNING: Unknown variable types count: 4 */
    public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
        Throwable th;
        Throwable th2;
        long hwStartTime;
        String separateProcesses;
        Object obj;
        Object obj2;
        Throwable th3;
        Object obj3;
        Throwable th4;
        ArrayMap<String, PackageParser.Package> arrayMap;
        long hwStartTime2;
        ArrayList<File> fileList;
        int builtInLibCount;
        ArrayMap<String, SystemConfig.SharedLibraryEntry> libConfig;
        int i;
        long hwStartTime3;
        File privilegedAppDir;
        Settings.VersionInfo ver;
        long hwStartTime4;
        long j;
        File privilegedVendorAppDir;
        File vendorAppDir;
        File privilegedOdmAppDir;
        File odmAppDir;
        File privilegedProductAppDir;
        File productAppDir;
        File privilegedProductServicesAppDir;
        File productServicesAppDir;
        long hwStartTime5;
        Settings.VersionInfo ver2;
        List<String> stubSystemApps;
        Throwable th5;
        PackageParser.Package r6;
        PackageParser.Package r7;
        ?? r1;
        int storageFlags;
        int i2;
        List<String> deferPackages;
        int storageFlags2;
        ?? r62;
        long hwStartTime6;
        Throwable th6;
        long hwStartTime7;
        String str;
        PackageParser.Package pkg;
        Iterator<PackageParser.Package> it;
        int i3;
        List<String> deferPackages2;
        int i4;
        File oemAppDir;
        File productServicesAppDir2;
        File privilegedProductServicesAppDir2;
        File productAppDir2;
        File privilegedProductAppDir2;
        File vendorAppDir2;
        File privilegedProductAppDir3;
        File odmAppDir2;
        int rescanFlags;
        int reparseFlags;
        File oemAppDir2;
        File systemAppDir;
        int i5;
        List<String> possiblyDeletedUpdatedSystemApps;
        boolean z;
        String packageName;
        String msg;
        PackageSetting ps;
        PackageManagerException e;
        Settings.VersionInfo ver3;
        List<String> stubSystemApps2;
        Iterator<PackageParser.Package> pkgIterator;
        int hwEmuiVersion;
        Boolean bool;
        Throwable e2;
        boolean z2 = true;
        this.mNextInstallToken = 1;
        this.updatePackageName = null;
        this.mPackageUsage = new PackageUsage();
        this.mCompilerStats = new CompilerStats();
        this.mPermissionCallback = new PermissionManagerServiceInternal.PermissionCallback() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass1 */

            public /* synthetic */ void lambda$onGidsChanged$0$PackageManagerService$1(int appId, int userId) {
                PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_GIDS_CHANGED);
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onGidsChanged(int appId, int userId) {
                PackageManagerService.this.mHandler.post(new Runnable(appId, userId) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$1$7o99DenVu604GN9uaO7x0s_Ispw */
                    private final /* synthetic */ int f$1;
                    private final /* synthetic */ int f$2;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.AnonymousClass1.this.lambda$onGidsChanged$0$PackageManagerService$1(this.f$1, this.f$2);
                    }
                });
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionGranted(int uid, int userId) {
                PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionGranted() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionRevoked(int uid, int userId) {
                PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
                }
                int appId = UserHandle.getAppId(uid);
                if (uid != 1001) {
                    PackageManagerService.this.mHandler.post(new Runnable(appId, userId) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$1$UqkVA9qTDjOrKboRoZUSVel9Qek */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        @Override // java.lang.Runnable
                        public final void run() {
                            PackageManagerService.AnonymousClass1.this.lambda$onPermissionRevoked$1$PackageManagerService$1(this.f$1, this.f$2);
                        }
                    });
                } else {
                    Slog.w(PackageManagerService.TAG, "onPermissionRevoked don't kill PHONE_UID processes ");
                }
            }

            public /* synthetic */ void lambda$onPermissionRevoked$1$PackageManagerService$1(int appId, int userId) {
                PackageManagerService.this.killUid(appId, userId, PackageManagerService.KILL_APP_REASON_PERMISSIONS_REVOKED);
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionRevoked() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
                synchronized (PackageManagerService.this.mPackages) {
                    for (int userId : updatedUserIds) {
                        PackageManagerService.this.mSettings.writeRuntimePermissionsForUserLPr(userId, sync);
                    }
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onInstallPermissionUpdated() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionRemoved() {
                synchronized (PackageManagerService.this.mPackages) {
                    PackageManagerService.this.mSettings.writeLPr();
                }
            }

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onOneTimePermissionFlagUpdated(int uid) {
                PackageManagerService.this.mOnPermissionChangeListeners.onPermissionsChanged(uid);
            }
        };
        this.mStorageListener = new StorageEventListener() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass2 */

            public void onVolumeStateChanged(VolumeInfo vol, int oldState, int newState) {
                if (vol.type != 1) {
                    return;
                }
                if (vol.state == 2) {
                    String volumeUuid = vol.getFsUuid();
                    PackageManagerService.sUserManager.reconcileUsers(volumeUuid);
                    PackageManagerService.this.reconcileApps(volumeUuid);
                    PackageManagerService.this.mInstallerService.onPrivateVolumeMounted(volumeUuid);
                    PackageManagerService.this.loadPrivatePackages(vol);
                } else if (vol.state == 5) {
                    PackageManagerService.this.unloadPrivatePackages(vol);
                }
            }

            public void onVolumeForgotten(String fsUuid) {
                if (TextUtils.isEmpty(fsUuid)) {
                    Slog.e(PackageManagerService.TAG, "Forgetting internal storage is probably a mistake; ignoring");
                    return;
                }
                synchronized (PackageManagerService.this.mPackages) {
                    for (PackageSetting ps : PackageManagerService.this.mSettings.getVolumePackagesLPr(fsUuid)) {
                        Slog.d(PackageManagerService.TAG, "Destroying " + ps.name + " because volume was forgotten");
                        PackageManagerService.this.deletePackageVersioned(new VersionedPackage(ps.name, -1), new PackageManager.LegacyPackageDeleteObserver((IPackageDeleteObserver) null).getBinder(), 0, 2);
                        AttributeCache.instance().removePackage(ps.name);
                    }
                    PackageManagerService.this.mSettings.onVolumeForgotten(fsUuid);
                    PackageManagerService.this.mSettings.writeLPr();
                }
            }
        };
        this.isSystemUIScanned = false;
        this.mMediaMounted = false;
        this.mHwInnerService = new HwInnerPackageManagerService(this);
        mHwPMSEx = HwServiceExFactory.getHwPackageManagerServiceEx(this, context);
        HwPackageManagerServiceUtils.initHwPMSEx(mHwPMSEx);
        LockGuard.installLock(this.mPackages, 3);
        Trace.traceBegin(262144, "create package manager");
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());
        Jlog.d(31, "JL_BOOT_PROGRESS_PMS_START");
        if (this.mSdkVersion <= 0) {
            Slog.w(TAG, "**** ro.build.version.sdk not set!");
        }
        this.mContext = context;
        long hwStartTime8 = HwPackageManagerServiceUtils.hwTimingsBegin();
        this.mFactoryTest = factoryTest;
        this.mOnlyCore = onlyCore;
        this.mMetrics = new DisplayMetrics();
        this.mInstaller = installer;
        synchronized (this.mInstallLock) {
            try {
                synchronized (this.mPackages) {
                    try {
                        LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());
                        try {
                            Slog.i(TAG, "UserManagerService");
                            HwServiceFactory.IHwUserManagerService service = HwServiceFactory.getHwUserManagerService();
                            if (service != null) {
                                try {
                                    sUserManager = service.getInstance(context, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                                    hwStartTime = hwStartTime8;
                                } catch (Throwable th7) {
                                    e2 = th7;
                                    hwStartTime = hwStartTime8;
                                    try {
                                        Slog.e(TAG, "UserManagerService error " + e2);
                                        this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                                        this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                                        this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                                        this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                                        this.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.log", LOG_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.se", SE_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.networkstack", NETWORKSTACK_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.ddmp", DDMP_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.dmsdpdevice", DMSDPDEVICE_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("com.huawei.hiaction.share_user", AIENGINE_UID, 1, 8);
                                        this.mSettings.addSharedUserLPw("android.uid.cloudservice", CLOUDSERVICE_UID, 1, 8);
                                        separateProcesses = SystemProperties.get("debug.separate_processes");
                                        if (separateProcesses != null) {
                                        }
                                        this.mDefParseFlags = 0;
                                        this.mSeparateProcesses = null;
                                        this.mPackageDexOptimizer = new PackageDexOptimizer(installer, this.mInstallLock, context, "*dexopt*");
                                        mHwPMSEx.initParallelPackageDexOptimizer(context, this.mPackageDexOptimizer);
                                        this.mDexManager = new DexManager(this.mContext, this, this.mPackageDexOptimizer, installer, this.mInstallLock);
                                        this.mArtManagerService = new ArtManagerService(this.mContext, this, installer, this.mInstallLock);
                                        this.mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());
                                        this.mViewCompiler = new ViewCompiler(this.mInstallLock, this.mInstaller);
                                        this.mOnPermissionChangeListeners = new OnPermissionChangeListeners(FgThread.get().getLooper());
                                        getDefaultDisplayMetrics(context, this.mMetrics);
                                        if (HwFrameworkFactory.getHwApsImpl() != null) {
                                        }
                                        Trace.traceBegin(262144, "get system config");
                                        SystemConfig systemConfig = SystemConfig.getInstance();
                                        this.mAvailableFeatures = systemConfig.getAvailableFeatures();
                                        this.mAvailableHwFeatures = systemConfig.getAvailableHwFeatures();
                                        Trace.traceEnd(262144);
                                        this.mProtectedPackages = new ProtectedPackages(this.mContext);
                                        this.mApexManager = new ApexManager(context);
                                        long hwStartTime9 = hwStartTime;
                                        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "Config Init", hwStartTime9);
                                        obj = this.mInstallLock;
                                        synchronized (obj) {
                                        }
                                    } catch (Throwable th8) {
                                        th2 = th8;
                                        while (true) {
                                            try {
                                                break;
                                            } catch (Throwable th9) {
                                                th = th9;
                                                throw th;
                                            }
                                        }
                                        throw th2;
                                    }
                                }
                                this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                                this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                                this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                                this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                            } else {
                                hwStartTime = hwStartTime8;
                                try {
                                    sUserManager = new UserManagerService(context, this, new UserDataPreparer(this.mInstaller, this.mInstallLock, this.mContext, this.mOnlyCore), this.mPackages);
                                } catch (Throwable th10) {
                                    e2 = th10;
                                }
                                this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                                this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                                this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                                this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                            }
                        } catch (Throwable th11) {
                            hwStartTime = hwStartTime8;
                            e2 = th11;
                            Slog.e(TAG, "UserManagerService error " + e2);
                            this.mComponentResolver = new ComponentResolver(sUserManager, (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class), this.mPackages);
                            this.mPermissionManager = PermissionManagerService.create(context, this.mPackages);
                            this.mDefaultPermissionPolicy = this.mPermissionManager.getDefaultPermissionGrantPolicy();
                            this.mSettings = new Settings(Environment.getDataDirectory(), this.mPermissionManager.getPermissionSettings(), this.mPackages);
                            this.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.log", LOG_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.se", SE_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.networkstack", NETWORKSTACK_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.ddmp", DDMP_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.dmsdpdevice", DMSDPDEVICE_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("com.huawei.hiaction.share_user", AIENGINE_UID, 1, 8);
                            this.mSettings.addSharedUserLPw("android.uid.cloudservice", CLOUDSERVICE_UID, 1, 8);
                            separateProcesses = SystemProperties.get("debug.separate_processes");
                            if (separateProcesses != null) {
                            }
                            this.mDefParseFlags = 0;
                            this.mSeparateProcesses = null;
                            this.mPackageDexOptimizer = new PackageDexOptimizer(installer, this.mInstallLock, context, "*dexopt*");
                            mHwPMSEx.initParallelPackageDexOptimizer(context, this.mPackageDexOptimizer);
                            this.mDexManager = new DexManager(this.mContext, this, this.mPackageDexOptimizer, installer, this.mInstallLock);
                            this.mArtManagerService = new ArtManagerService(this.mContext, this, installer, this.mInstallLock);
                            this.mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());
                            this.mViewCompiler = new ViewCompiler(this.mInstallLock, this.mInstaller);
                            this.mOnPermissionChangeListeners = new OnPermissionChangeListeners(FgThread.get().getLooper());
                            getDefaultDisplayMetrics(context, this.mMetrics);
                            if (HwFrameworkFactory.getHwApsImpl() != null) {
                            }
                            Trace.traceBegin(262144, "get system config");
                            SystemConfig systemConfig2 = SystemConfig.getInstance();
                            this.mAvailableFeatures = systemConfig2.getAvailableFeatures();
                            this.mAvailableHwFeatures = systemConfig2.getAvailableHwFeatures();
                            Trace.traceEnd(262144);
                            this.mProtectedPackages = new ProtectedPackages(this.mContext);
                            this.mApexManager = new ApexManager(context);
                            long hwStartTime92 = hwStartTime;
                            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "Config Init", hwStartTime92);
                            obj = this.mInstallLock;
                            synchronized (obj) {
                            }
                        }
                    } catch (Throwable th12) {
                        th2 = th12;
                        while (true) {
                            break;
                        }
                        throw th2;
                    }
                }
                try {
                } catch (Throwable th13) {
                    th = th13;
                    throw th;
                }
            } catch (Throwable th14) {
                th = th14;
                throw th;
            }
        }
        this.mSettings.addSharedUserLPw("android.uid.system", 1000, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.phone", 1001, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.log", LOG_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.nfc", 1027, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.shell", 2000, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.se", SE_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.networkstack", NETWORKSTACK_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.ddmp", DDMP_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.dmsdpdevice", DMSDPDEVICE_UID, 1, 8);
        this.mSettings.addSharedUserLPw("com.huawei.hiaction.share_user", AIENGINE_UID, 1, 8);
        this.mSettings.addSharedUserLPw("android.uid.cloudservice", CLOUDSERVICE_UID, 1, 8);
        separateProcesses = SystemProperties.get("debug.separate_processes");
        if (separateProcesses != null || separateProcesses.length() <= 0) {
            this.mDefParseFlags = 0;
            this.mSeparateProcesses = null;
        } else if ("*".equals(separateProcesses)) {
            this.mDefParseFlags = 2;
            this.mSeparateProcesses = null;
            Slog.w(TAG, "Running with debug.separate_processes: * (ALL)");
        } else {
            this.mDefParseFlags = 0;
            this.mSeparateProcesses = separateProcesses.split(",");
            Slog.w(TAG, "Running with debug.separate_processes: " + separateProcesses);
        }
        this.mPackageDexOptimizer = new PackageDexOptimizer(installer, this.mInstallLock, context, "*dexopt*");
        mHwPMSEx.initParallelPackageDexOptimizer(context, this.mPackageDexOptimizer);
        this.mDexManager = new DexManager(this.mContext, this, this.mPackageDexOptimizer, installer, this.mInstallLock);
        this.mArtManagerService = new ArtManagerService(this.mContext, this, installer, this.mInstallLock);
        this.mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());
        this.mViewCompiler = new ViewCompiler(this.mInstallLock, this.mInstaller);
        this.mOnPermissionChangeListeners = new OnPermissionChangeListeners(FgThread.get().getLooper());
        getDefaultDisplayMetrics(context, this.mMetrics);
        if (HwFrameworkFactory.getHwApsImpl() != null) {
            HwFrameworkFactory.getHwApsImpl().adjustPmDisplayMetricsInRog(this.mMetrics);
        }
        Trace.traceBegin(262144, "get system config");
        SystemConfig systemConfig22 = SystemConfig.getInstance();
        this.mAvailableFeatures = systemConfig22.getAvailableFeatures();
        this.mAvailableHwFeatures = systemConfig22.getAvailableHwFeatures();
        Trace.traceEnd(262144);
        this.mProtectedPackages = new ProtectedPackages(this.mContext);
        this.mApexManager = new ApexManager(context);
        long hwStartTime922 = hwStartTime;
        HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "Config Init", hwStartTime922);
        obj = this.mInstallLock;
        synchronized (obj) {
            try {
                ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
                synchronized (arrayMap2) {
                    try {
                        this.mHandlerThread = new ServiceThread(TAG, 10, true);
                        this.mHandlerThread.start();
                        this.mHandler = new PackageHandler(this.mHandlerThread.getLooper());
                        this.mProcessLoggingHandler = new ProcessLoggingHandler();
                        Watchdog.getInstance().addThread(this.mHandler, 600000);
                        this.mInstantAppRegistry = new InstantAppRegistry(this);
                        ArrayMap<String, SystemConfig.SharedLibraryEntry> libConfig2 = systemConfig22.getSharedLibraries();
                        int builtInLibCount2 = libConfig2.size();
                        for (int i6 = 0; i6 < builtInLibCount2; i6++) {
                            try {
                                addBuiltInSharedLibraryLocked(libConfig2.valueAt(i6).filename, libConfig2.keyAt(i6));
                            } catch (Throwable th15) {
                                th4 = th15;
                                arrayMap = arrayMap2;
                                obj2 = obj;
                                throw th4;
                            }
                        }
                        int i7 = 0;
                        while (i7 < builtInLibCount2) {
                            try {
                                String name = libConfig2.keyAt(i7);
                                SystemConfig.SharedLibraryEntry entry = libConfig2.valueAt(i7);
                                try {
                                    int dependencyCount = entry.dependencies.length;
                                    int j2 = 0;
                                    while (j2 < dependencyCount) {
                                        SharedLibraryInfo dependency = getSharedLibraryInfoLPr(entry.dependencies[j2], -1);
                                        if (dependency != null) {
                                            bool = z2;
                                            getSharedLibraryInfoLPr(name, -1).addDependency(dependency);
                                        } else {
                                            bool = z2;
                                        }
                                        j2++;
                                        dependencyCount = dependencyCount;
                                        z2 = bool;
                                    }
                                    i7++;
                                    hwStartTime922 = hwStartTime922;
                                } catch (Throwable th16) {
                                    th4 = th16;
                                    arrayMap = arrayMap2;
                                    obj2 = obj;
                                    throw th4;
                                }
                            } catch (Throwable th17) {
                                th4 = th17;
                                arrayMap = arrayMap2;
                                obj2 = obj;
                                throw th4;
                            }
                        }
                        try {
                            SELinuxMMAC.readInstallPolicy();
                            mHwPMSEx.initHwCertificationManager();
                            hwStartTime2 = HwPackageManagerServiceUtils.hwTimingsBegin();
                        } catch (Throwable th18) {
                            arrayMap = arrayMap2;
                            obj2 = obj;
                            th4 = th18;
                            throw th4;
                        }
                        try {
                            Trace.traceBegin(262144, "loadFallbacks");
                            FallbackCategoryProvider.loadFallbacks();
                            Trace.traceEnd(262144);
                            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "loadFallbacks", hwStartTime2);
                            long hwStartTime10 = HwPackageManagerServiceUtils.hwTimingsBegin();
                            Trace.traceBegin(262144, "read user settings");
                            this.mFirstBoot = !this.mSettings.readLPw(sUserManager.getUsers(false));
                            Trace.traceEnd(262144);
                            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.readLPw", hwStartTime10);
                            boolean isSettingsDirty = false;
                            if (MAPLE_ENABLE) {
                                HwMaplePMServiceUtils.init(this.mHandlerThread.getLooper());
                                HwMaplePMServiceUtils.loadDisabledMaplePkgs();
                            } else {
                                HwMaplePMServiceUtils.deleteDisabledMapleFile();
                            }
                            for (int i8 = this.mSettings.mPackages.size() - 1; i8 >= 0; i8--) {
                                PackageSetting ps2 = this.mSettings.mPackages.valueAt(i8);
                                if (!isExternal(ps2) && ((ps2.codePath == null || !ps2.codePath.exists()) && this.mSettings.getDisabledSystemPkgLPr(ps2.name) != null)) {
                                    this.mSettings.mPackages.removeAt(i8);
                                    this.mSettings.enableSystemPackageLPw(ps2.name);
                                }
                            }
                            if (!this.mOnlyCore && this.mFirstBoot) {
                                requestCopyPreoptedFiles();
                            }
                            Resources.getSystem().getString(17039801);
                            String customResolverActivityName = HwFrameworkFactory.getHuaweiResolverActivity(this.mContext);
                            if (!TextUtils.isEmpty(customResolverActivityName)) {
                                this.mCustomResolverComponentName = ComponentName.unflattenFromString(customResolverActivityName);
                            }
                            long startTime = SystemClock.uptimeMillis();
                            EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);
                            String bootClassPath = System.getenv("BOOTCLASSPATH");
                            String systemServerClassPath = System.getenv("SYSTEMSERVERCLASSPATH");
                            if (bootClassPath == null) {
                                Slog.w(TAG, "No BOOTCLASSPATH found!");
                            }
                            if (systemServerClassPath == null) {
                                Slog.w(TAG, "No SYSTEMSERVERCLASSPATH found!");
                            }
                            File frameworkDir = new File(Environment.getRootDirectory(), "framework");
                            Settings.VersionInfo ver4 = this.mSettings.getInternalVersion();
                            this.mIsUpgrade = ver4 != null && (!Build.FINGERPRINT.equals(ver4.fingerprint) || !Build.HWFINGERPRINT.equals(ver4.hwFingerprint) || !Build.FINGERPRINTEX.equals(ver4.fingerprintEx));
                            if (this.mIsUpgrade) {
                                PackageManagerServiceUtils.logCriticalInfo(4, "FINGERPRINT Upgrading from " + ver4.fingerprint + " to " + Build.FINGERPRINT + " and HWFINGERPRINT Upgrading from " + ver4.hwFingerprint + " to " + Build.HWFINGERPRINT + " and FINGERPRINTEX Upgrading from " + ver4.fingerprintEx + " to " + Build.FINGERPRINTEX);
                            }
                            int hwEmuiVersion2 = SystemProperties.getInt("ro.build.hw_emui_api_level", 0);
                            this.mIsEmuiVersionUpgrade = ver4 != null && ver4.emuiVersion < hwEmuiVersion2;
                            if (this.mIsEmuiVersionUpgrade) {
                                PackageManagerServiceUtils.logCriticalInfo(4, "EMUI version upgrading from " + ver4.emuiVersion + " to " + hwEmuiVersion2);
                            }
                            mHwPMSEx.loadCorrectUninstallDelapp();
                            this.mDelPackageList = mHwPMSEx.getDelPackageList();
                            mHwPMSEx.readPersistentConfig();
                            mHwPMSEx.readPreInstallApkList();
                            mHwPMSEx.getUninstallApk();
                            if (IS_AUTO_INSTALL_ENABLE) {
                                mHwPMSEx.loadRemoveUnstallApks();
                            }
                            mHwPMSEx.initCertCompatSettings();
                            this.mPromoteSystemApps = this.mIsUpgrade && ver4.sdkVersion <= 22;
                            this.mIsPreNUpgrade = this.mIsUpgrade && ver4.sdkVersion < DEFERRED_NO_KILL_INSTALL_OBSERVER;
                            this.mIsPreNMR1Upgrade = this.mIsUpgrade && ver4.sdkVersion < 25;
                            this.mIsPreQUpgrade = this.mIsUpgrade && ver4.sdkVersion < 29;
                            this.mIsPrePUpgrade = this.mIsUpgrade && ver4.sdkVersion < 28;
                            int i9 = ver4.sdkVersion;
                            if (this.mPromoteSystemApps) {
                                for (PackageSetting ps3 : this.mSettings.mPackages.values()) {
                                    if (isSystemApp(ps3)) {
                                        hwEmuiVersion = hwEmuiVersion2;
                                        this.mExistingSystemPackages.add(ps3.name);
                                    } else {
                                        hwEmuiVersion = hwEmuiVersion2;
                                    }
                                    hwEmuiVersion2 = hwEmuiVersion;
                                }
                            }
                            this.mCacheDir = preparePackageParserCache(this.mIsUpgrade);
                            int scanFlags = (this.mIsUpgrade || this.mFirstBoot) ? 528 | 8192 : 528;
                            long hwStartTime11 = HwPackageManagerServiceUtils.hwTimingsBegin();
                            try {
                                fileList = HwCfgFilePolicy.getCfgFileList("/overlay", 1);
                            } catch (NoClassDefFoundError er) {
                                fileList = null;
                                Slog.e(TAG, er.getMessage());
                            } catch (Throwable th19) {
                                arrayMap = arrayMap2;
                                obj2 = obj;
                                th4 = th19;
                                throw th4;
                            }
                            if (fileList != null) {
                                try {
                                    Iterator<File> it2 = fileList.iterator();
                                    while (it2.hasNext()) {
                                        arrayMap = arrayMap2;
                                        try {
                                            scanDirTracedLI(it2.next(), this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                                            hwStartTime11 = hwStartTime11;
                                            libConfig2 = libConfig2;
                                            arrayMap2 = arrayMap;
                                            builtInLibCount2 = builtInLibCount2;
                                        } catch (Throwable th20) {
                                            th4 = th20;
                                            obj2 = obj;
                                            throw th4;
                                        }
                                    }
                                    arrayMap = arrayMap2;
                                    libConfig = libConfig2;
                                    builtInLibCount = builtInLibCount2;
                                    i = 0;
                                    obj2 = 1;
                                    hwStartTime3 = hwStartTime11;
                                } catch (Throwable th21) {
                                    arrayMap = arrayMap2;
                                    th4 = th21;
                                    obj2 = obj;
                                    throw th4;
                                }
                            } else {
                                arrayMap = arrayMap2;
                                libConfig = libConfig2;
                                builtInLibCount = builtInLibCount2;
                                i = 0;
                                obj2 = 1;
                                hwStartTime3 = hwStartTime11;
                            }
                            try {
                                scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                                ?? r40 = 2097152;
                                scanDirTracedLI(new File(PRODUCT_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
                                scanDirTracedLI(new File(PRODUCT_SERVICES_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
                                scanDirTracedLI(new File(ODM_OVERLAY_DIR), this.mDefParseFlags | 16, 8388608 | scanFlags | 131072, 0);
                                scanDirTracedLI(new File(OEM_OVERLAY_DIR), this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
                                HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system overlay", hwStartTime3);
                                this.mParallelPackageParserCallback.findStaticOverlayPackages();
                                long hwStartTime12 = HwPackageManagerServiceUtils.hwTimingsBegin();
                                try {
                                    obj2 = obj;
                                    try {
                                        scanDirTracedLI(frameworkDir, this.mDefParseFlags | 16, scanFlags | 1 | 131072 | 262144, 0);
                                        if (this.mPackages.containsKey(PLATFORM_PACKAGE_NAME)) {
                                            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system framework", hwStartTime12);
                                            long hwStartTime13 = HwPackageManagerServiceUtils.hwTimingsBegin();
                                            try {
                                                privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
                                                ver = ver4;
                                                scanDirTracedLI(privilegedAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 262144, 0);
                                                HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system priv-app", hwStartTime13);
                                                hwStartTime4 = HwPackageManagerServiceUtils.hwTimingsBegin();
                                            } catch (Throwable th22) {
                                                th4 = th22;
                                                obj2 = obj2;
                                                throw th4;
                                            }
                                            try {
                                                File systemAppDir2 = new File(Environment.getRootDirectory(), "app");
                                                File systemAppDir3 = systemAppDir2;
                                                scanDirTracedLI(systemAppDir2, this.mDefParseFlags | 16, scanFlags | 131072, 0);
                                                HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "scan system app", hwStartTime4);
                                                File privilegedVendorAppDir2 = new File(Environment.getVendorDirectory(), "priv-app");
                                                try {
                                                    privilegedVendorAppDir = privilegedVendorAppDir2.getCanonicalFile();
                                                } catch (IOException e3) {
                                                    privilegedVendorAppDir = privilegedVendorAppDir2;
                                                }
                                                File vendorAppDir3 = new File(Environment.getVendorDirectory(), "app");
                                                try {
                                                    vendorAppDir = vendorAppDir3.getCanonicalFile();
                                                } catch (IOException e4) {
                                                    vendorAppDir = vendorAppDir3;
                                                }
                                                mHwPMSEx.scanNonSystemPartitionDir(scanFlags);
                                                mHwPMSEx.scanRemovableAppDir(scanFlags);
                                                File privilegedOdmAppDir2 = new File(Environment.getOdmDirectory(), "priv-app");
                                                try {
                                                    privilegedOdmAppDir = privilegedOdmAppDir2.getCanonicalFile();
                                                } catch (IOException e5) {
                                                    privilegedOdmAppDir = privilegedOdmAppDir2;
                                                }
                                                File privilegedOdmAppDir3 = privilegedOdmAppDir;
                                                File privilegedVendorAppDir3 = privilegedVendorAppDir;
                                                File vendorAppDir4 = vendorAppDir;
                                                scanDirTracedLI(privilegedOdmAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576 | 262144, 0);
                                                File odmAppDir3 = new File(Environment.getOdmDirectory(), "app");
                                                try {
                                                    odmAppDir = odmAppDir3.getCanonicalFile();
                                                } catch (IOException e6) {
                                                    odmAppDir = odmAppDir3;
                                                }
                                                File odmAppDir4 = odmAppDir;
                                                scanDirTracedLI(odmAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 1048576, 0);
                                                File oemAppDir3 = new File(Environment.getOemDirectory(), "app");
                                                File oemAppDir4 = oemAppDir3;
                                                scanDirTracedLI(oemAppDir3, this.mDefParseFlags | 16, scanFlags | 131072 | 524288, 0);
                                                File privilegedProductAppDir4 = new File(Environment.getProductDirectory(), "priv-app");
                                                try {
                                                    privilegedProductAppDir = privilegedProductAppDir4.getCanonicalFile();
                                                } catch (IOException e7) {
                                                    privilegedProductAppDir = privilegedProductAppDir4;
                                                }
                                                File privilegedProductAppDir5 = privilegedProductAppDir;
                                                scanDirTracedLI(privilegedProductAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152 | 262144, 0);
                                                File productAppDir3 = new File(Environment.getProductDirectory(), "app");
                                                try {
                                                    productAppDir = productAppDir3.getCanonicalFile();
                                                } catch (IOException e8) {
                                                    productAppDir = productAppDir3;
                                                }
                                                File productAppDir4 = productAppDir;
                                                scanDirTracedLI(productAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 2097152, 0);
                                                File privilegedProductServicesAppDir3 = new File(Environment.getProductServicesDirectory(), "priv-app");
                                                try {
                                                    privilegedProductServicesAppDir = privilegedProductServicesAppDir3.getCanonicalFile();
                                                } catch (IOException e9) {
                                                    privilegedProductServicesAppDir = privilegedProductServicesAppDir3;
                                                }
                                                File privilegedProductServicesAppDir4 = privilegedProductServicesAppDir;
                                                scanDirTracedLI(privilegedProductServicesAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304 | 262144, 0);
                                                File productServicesAppDir3 = new File(Environment.getProductServicesDirectory(), "app");
                                                try {
                                                    productServicesAppDir = productServicesAppDir3.getCanonicalFile();
                                                } catch (IOException e10) {
                                                    productServicesAppDir = productServicesAppDir3;
                                                }
                                                File productServicesAppDir4 = productServicesAppDir;
                                                scanDirTracedLI(productServicesAppDir, this.mDefParseFlags | 16, scanFlags | 131072 | 4194304, 0);
                                                mHwPMSEx.scanNoSysAppInNonSystemPartitionDir(scanFlags);
                                                List<String> possiblyDeletedUpdatedSystemApps2 = new ArrayList<>();
                                                List<String> stubSystemApps3 = new ArrayList<>();
                                                if (!this.mOnlyCore) {
                                                    try {
                                                        Iterator<PackageParser.Package> pkgIterator2 = this.mPackages.values().iterator();
                                                        while (pkgIterator2.hasNext()) {
                                                            try {
                                                                PackageParser.Package pkg2 = pkgIterator2.next();
                                                                if (pkg2.isStub) {
                                                                    stubSystemApps3.add(pkg2.packageName);
                                                                }
                                                                if (mHwPMSEx.isSystemAppGrantByMdm(pkg2.packageName)) {
                                                                    MDM_SYS_APP_PREALOAD_LIST.put(pkg2.packageName, z2);
                                                                }
                                                                if (!isUpgradeAndEmuiVersionUpgrade()) {
                                                                    pkgIterator = pkgIterator2;
                                                                } else if (mHwPMSEx.migrateAppUninstalledState(pkg2.packageName)) {
                                                                    StringBuilder sb = new StringBuilder();
                                                                    pkgIterator = pkgIterator2;
                                                                    sb.append("migrate uninstalled state for renamed package app, newPkgName: ");
                                                                    sb.append(pkg2.packageName);
                                                                    Slog.i(TAG, sb.toString());
                                                                } else {
                                                                    pkgIterator = pkgIterator2;
                                                                }
                                                                pkgIterator2 = pkgIterator;
                                                            } catch (Throwable th23) {
                                                                th4 = th23;
                                                                obj2 = obj2;
                                                                throw th4;
                                                            }
                                                        }
                                                        Iterator<PackageSetting> psit = this.mSettings.mPackages.values().iterator();
                                                        while (psit.hasNext()) {
                                                            PackageSetting ps4 = psit.next();
                                                            if ((ps4.pkgFlags & 1) == 0) {
                                                                stubSystemApps2 = stubSystemApps3;
                                                                ver3 = ver;
                                                                hwStartTime5 = hwStartTime4;
                                                            } else {
                                                                PackageParser.Package scannedPkg = this.mPackages.get(ps4.name);
                                                                stubSystemApps2 = stubSystemApps3;
                                                                boolean isSystemAppGrantByMdm = mHwPMSEx.isSystemAppGrantByMdm(ps4.name);
                                                                if (scannedPkg != null) {
                                                                    ver3 = ver;
                                                                    if (this.mSettings.isDisabledSystemPackageLPr(ps4.name)) {
                                                                        StringBuilder sb2 = new StringBuilder();
                                                                        sb2.append("Expecting better updated system app for ");
                                                                        sb2.append(ps4.name);
                                                                        sb2.append("; removing system app.  Last known codePath=");
                                                                        sb2.append(ps4.codePathString);
                                                                        sb2.append(", versionCode=");
                                                                        hwStartTime5 = hwStartTime4;
                                                                        try {
                                                                            sb2.append(ps4.versionCode);
                                                                            sb2.append("; scanned versionCode=");
                                                                            sb2.append(scannedPkg.getLongVersionCode());
                                                                            PackageManagerServiceUtils.logCriticalInfo(5, sb2.toString());
                                                                            removePackageLI(scannedPkg, true);
                                                                            this.mExpectingBetter.put(ps4.name, ps4.codePath);
                                                                        } catch (Throwable th24) {
                                                                            th4 = th24;
                                                                            obj2 = obj2;
                                                                            throw th4;
                                                                        }
                                                                    } else {
                                                                        hwStartTime5 = hwStartTime4;
                                                                    }
                                                                    setSystemUIScaned(ps4.name);
                                                                } else {
                                                                    ver3 = ver;
                                                                    hwStartTime5 = hwStartTime4;
                                                                    if (this.mSettings.isDisabledSystemPackageLPr(ps4.name)) {
                                                                        PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps4.name);
                                                                        if (disabledPs.codePath != null && disabledPs.codePath.exists()) {
                                                                            if (disabledPs.pkg != null) {
                                                                                if (isSystemAppGrantByMdm) {
                                                                                    MDM_SYS_APP_PREALOAD_LIST.put(ps4.name, z2);
                                                                                }
                                                                                this.mExpectingBetter.put(disabledPs.name, disabledPs.codePath);
                                                                            }
                                                                        }
                                                                        possiblyDeletedUpdatedSystemApps2.add(ps4.name);
                                                                    } else if (!isSystemAppGrantByMdm) {
                                                                        Optional<HwRenamedPackagePolicy> hwRenamedPackagePolicyOptional = mHwPMSEx.getRenamedPackagePolicyByOriginalName(ps4.name);
                                                                        if (!isUpgradeAndEmuiVersionUpgrade() || !hwRenamedPackagePolicyOptional.isPresent()) {
                                                                            psit.remove();
                                                                            setSystemUIScanErr(ps4.name);
                                                                            isSettingsDirty = true;
                                                                        } else {
                                                                            Slog.i(TAG, "PACKAGE_NAME_CHANGE:" + ps4.name + "do not call the psit.remove, keep it to migrate");
                                                                        }
                                                                        PackageManagerServiceUtils.logCriticalInfo(5, "System package " + ps4.name + " no longer exists; it's data will be wiped");
                                                                    }
                                                                    stubSystemApps3 = stubSystemApps2;
                                                                    ver = ver3;
                                                                    hwStartTime4 = hwStartTime5;
                                                                }
                                                            }
                                                            stubSystemApps3 = stubSystemApps2;
                                                            ver = ver3;
                                                            hwStartTime4 = hwStartTime5;
                                                        }
                                                        stubSystemApps = stubSystemApps3;
                                                        ver2 = ver;
                                                        hwStartTime5 = hwStartTime4;
                                                    } catch (Throwable th25) {
                                                        j = hwStartTime4;
                                                        th4 = th25;
                                                        obj2 = obj2;
                                                        throw th4;
                                                    }
                                                } else {
                                                    stubSystemApps = stubSystemApps3;
                                                    ver2 = ver;
                                                    hwStartTime5 = hwStartTime4;
                                                }
                                                try {
                                                    deleteTempPackageFiles();
                                                    int cachedSystemApps = PackageParser.sCachedPackageReadCount.get();
                                                    this.mSettings.pruneSharedUsersLPw();
                                                    long systemScanTime = SystemClock.uptimeMillis() - startTime;
                                                    int systemPackagesCount = this.mPackages.size();
                                                    StringBuilder sb3 = new StringBuilder();
                                                    sb3.append("Finished scanning system apps. Time: ");
                                                    sb3.append(systemScanTime);
                                                    sb3.append(" ms, packageCount: ");
                                                    sb3.append(systemPackagesCount);
                                                    sb3.append(" , timePerPackage: ");
                                                    sb3.append(systemPackagesCount == 0 ? 0 : systemScanTime / ((long) systemPackagesCount));
                                                    sb3.append(" , cached: ");
                                                    sb3.append(cachedSystemApps);
                                                    Slog.i(TAG, sb3.toString());
                                                    if (!this.mIsUpgrade || systemPackagesCount <= 0) {
                                                        r6 = null;
                                                    } else {
                                                        r6 = null;
                                                        MetricsLogger.histogram((Context) null, "ota_package_manager_system_app_avg_scan_time", ((int) systemScanTime) / systemPackagesCount);
                                                    }
                                                    if (!this.mOnlyCore) {
                                                        try {
                                                            EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis());
                                                            mHwPMSEx.rebuildApkBindFile();
                                                            boolean z3 = true;
                                                            List<String> possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps2;
                                                            scanDirTracedLI(sAppInstallDir, 0, this.mSettings.isPackageSettingsError() ? scanFlags : scanFlags | 128, 0);
                                                            int i10 = possiblyDeletedUpdatedSystemApps3.size() - 1;
                                                            while (i10 >= 0) {
                                                                String packageName2 = possiblyDeletedUpdatedSystemApps3.get(i10);
                                                                PackageParser.Package pkg3 = this.mPackages.get(packageName2);
                                                                this.mSettings.removeDisabledSystemPackageLPw(packageName2);
                                                                boolean keepDataForMigrate = false;
                                                                if (pkg3 == null) {
                                                                    packageName = packageName2;
                                                                    i5 = i10;
                                                                    possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                                                                    z = z3;
                                                                    msg = "Updated system package " + packageName2 + " no longer exists; removing its data";
                                                                } else {
                                                                    String msg2 = "Updated system package " + packageName2 + " no longer exists; rescanning package on data";
                                                                    removePackageLI(pkg3, z3);
                                                                    if (!mHwPMSEx.getRenamedPackagePolicyByOriginalName(packageName2).isPresent() || !isUpgradeAndEmuiVersionUpgrade()) {
                                                                        try {
                                                                            i5 = i10;
                                                                            possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                                                                            packageName = packageName2;
                                                                            z = true;
                                                                            try {
                                                                                scanPackageTracedLI(new File(pkg3.applicationInfo.getCodePath()), 0, scanFlags, 0, (UserHandle) null);
                                                                            } catch (PackageManagerException e11) {
                                                                                e = e11;
                                                                            }
                                                                        } catch (PackageManagerException e12) {
                                                                            packageName = packageName2;
                                                                            i5 = i10;
                                                                            possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                                                                            z = true;
                                                                            e = e12;
                                                                            Slog.e(TAG, "Failed to parse updated, ex-system package: " + e.getMessage());
                                                                            msg = msg2;
                                                                            ps = this.mSettings.mPackages.get(packageName);
                                                                            removePackageDataLIF(ps, null, null, 0, false);
                                                                            PackageManagerServiceUtils.logCriticalInfo(5, msg);
                                                                            i10 = i5 - 1;
                                                                            z3 = z;
                                                                            possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
                                                                        }
                                                                        msg = msg2;
                                                                    } else {
                                                                        keepDataForMigrate = true;
                                                                        Slog.i(TAG, "PACKAGE_NAME_CHANGE " + packageName2 + ", do not scaned the package on data");
                                                                        packageName = packageName2;
                                                                        i5 = i10;
                                                                        possiblyDeletedUpdatedSystemApps = possiblyDeletedUpdatedSystemApps3;
                                                                        msg = msg2;
                                                                        z = true;
                                                                    }
                                                                }
                                                                ps = this.mSettings.mPackages.get(packageName);
                                                                if (ps != null && this.mPackages.get(packageName) == null && !keepDataForMigrate) {
                                                                    removePackageDataLIF(ps, null, null, 0, false);
                                                                }
                                                                PackageManagerServiceUtils.logCriticalInfo(5, msg);
                                                                i10 = i5 - 1;
                                                                z3 = z;
                                                                possiblyDeletedUpdatedSystemApps3 = possiblyDeletedUpdatedSystemApps;
                                                            }
                                                            int i11 = 5;
                                                            int i12 = i;
                                                            while (i12 < this.mExpectingBetter.size()) {
                                                                String packageName3 = this.mExpectingBetter.keyAt(i12);
                                                                if (!this.mPackages.containsKey(packageName3)) {
                                                                    File scanFile = this.mExpectingBetter.valueAt(i12);
                                                                    PackageManagerServiceUtils.logCriticalInfo(i11, "Expected better " + packageName3 + " but never showed up; reverting to system");
                                                                    if (FileUtils.contains(privilegedAppDir, scanFile)) {
                                                                        reparseFlags = this.mDefParseFlags | 16;
                                                                        rescanFlags = scanFlags | 131072 | 262144;
                                                                        systemAppDir = systemAppDir3;
                                                                        odmAppDir2 = odmAppDir4;
                                                                        oemAppDir2 = oemAppDir4;
                                                                    } else {
                                                                        systemAppDir = systemAppDir3;
                                                                        if (FileUtils.contains(systemAppDir, scanFile)) {
                                                                            reparseFlags = this.mDefParseFlags | 16;
                                                                            rescanFlags = scanFlags | 131072;
                                                                            odmAppDir2 = odmAppDir4;
                                                                            oemAppDir2 = oemAppDir4;
                                                                        } else {
                                                                            if (FileUtils.contains(privilegedVendorAppDir3, scanFile)) {
                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                odmAppDir2 = odmAppDir4;
                                                                                oemAppDir2 = oemAppDir4;
                                                                            } else if (FileUtils.contains(privilegedOdmAppDir3, scanFile)) {
                                                                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                odmAppDir2 = odmAppDir4;
                                                                                oemAppDir2 = oemAppDir4;
                                                                            } else {
                                                                                if (!FileUtils.contains(vendorAppDir4, scanFile)) {
                                                                                    odmAppDir2 = odmAppDir4;
                                                                                    if (FileUtils.contains(odmAppDir2, scanFile)) {
                                                                                        vendorAppDir4 = vendorAppDir4;
                                                                                        privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                        privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                        oemAppDir2 = oemAppDir4;
                                                                                    } else {
                                                                                        oemAppDir2 = oemAppDir4;
                                                                                        if (FileUtils.contains(oemAppDir2, scanFile)) {
                                                                                            vendorAppDir4 = vendorAppDir4;
                                                                                            privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                            privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                            rescanFlags = scanFlags | 131072 | 524288;
                                                                                            reparseFlags = this.mDefParseFlags | 16;
                                                                                        } else {
                                                                                            vendorAppDir4 = vendorAppDir4;
                                                                                            if (FileUtils.contains(privilegedProductAppDir5, scanFile)) {
                                                                                                privilegedProductAppDir5 = privilegedProductAppDir5;
                                                                                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                rescanFlags = scanFlags | 131072 | 2097152 | 262144;
                                                                                                reparseFlags = this.mDefParseFlags | 16;
                                                                                            } else {
                                                                                                privilegedProductAppDir5 = privilegedProductAppDir5;
                                                                                                if (FileUtils.contains(productAppDir4, scanFile)) {
                                                                                                    productAppDir4 = productAppDir4;
                                                                                                    privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                    privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                    rescanFlags = scanFlags | 131072 | 2097152;
                                                                                                    reparseFlags = this.mDefParseFlags | 16;
                                                                                                } else {
                                                                                                    productAppDir4 = productAppDir4;
                                                                                                    if (FileUtils.contains(privilegedProductServicesAppDir4, scanFile)) {
                                                                                                        privilegedProductServicesAppDir4 = privilegedProductServicesAppDir4;
                                                                                                        privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                        privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                        rescanFlags = scanFlags | 131072 | 4194304 | 262144;
                                                                                                        reparseFlags = this.mDefParseFlags | 16;
                                                                                                    } else {
                                                                                                        privilegedProductServicesAppDir4 = privilegedProductServicesAppDir4;
                                                                                                        if (FileUtils.contains(productServicesAppDir4, scanFile)) {
                                                                                                            productServicesAppDir4 = productServicesAppDir4;
                                                                                                            privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                            privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                            rescanFlags = scanFlags | 131072 | 4194304;
                                                                                                            reparseFlags = this.mDefParseFlags | 16;
                                                                                                        } else {
                                                                                                            productServicesAppDir4 = productServicesAppDir4;
                                                                                                            if (mHwPMSEx != null && mHwPMSEx.isSystemPreApp(scanFile)) {
                                                                                                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                                rescanFlags = scanFlags | 131072;
                                                                                                                reparseFlags = this.mDefParseFlags | 16;
                                                                                                            } else if (mHwPMSEx == null || !mHwPMSEx.isPrivilegedPreApp(scanFile)) {
                                                                                                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                                StringBuilder sb4 = new StringBuilder();
                                                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                                sb4.append("Ignoring unexpected fallback path ");
                                                                                                                sb4.append(scanFile);
                                                                                                                Slog.e(TAG, sb4.toString());
                                                                                                                oemAppDir = oemAppDir2;
                                                                                                                privilegedProductAppDir3 = privilegedProductAppDir5;
                                                                                                                privilegedProductAppDir2 = privilegedProductServicesAppDir4;
                                                                                                                i4 = 5;
                                                                                                                privilegedProductServicesAppDir2 = vendorAppDir4;
                                                                                                                vendorAppDir2 = productAppDir4;
                                                                                                                productAppDir2 = productServicesAppDir4;
                                                                                                                productServicesAppDir2 = systemAppDir;
                                                                                                            } else {
                                                                                                                privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                                                privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                                                rescanFlags = scanFlags | 131072 | 262144;
                                                                                                                reparseFlags = this.mDefParseFlags | 16;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    vendorAppDir4 = vendorAppDir4;
                                                                                    privilegedOdmAppDir3 = privilegedOdmAppDir3;
                                                                                    privilegedVendorAppDir3 = privilegedVendorAppDir3;
                                                                                    odmAppDir2 = odmAppDir4;
                                                                                    oemAppDir2 = oemAppDir4;
                                                                                }
                                                                                reparseFlags = this.mDefParseFlags | 16;
                                                                                rescanFlags = scanFlags | 131072 | 1048576;
                                                                            }
                                                                            reparseFlags = this.mDefParseFlags | 16;
                                                                            rescanFlags = scanFlags | 131072 | 1048576 | 262144;
                                                                        }
                                                                    }
                                                                    this.mSettings.enableSystemPackageLPw(packageName3);
                                                                    isSettingsDirty = true;
                                                                    privilegedProductAppDir3 = privilegedProductAppDir5;
                                                                    privilegedProductAppDir2 = privilegedProductServicesAppDir4;
                                                                    privilegedProductServicesAppDir2 = vendorAppDir4;
                                                                    vendorAppDir2 = productAppDir4;
                                                                    productAppDir2 = productServicesAppDir4;
                                                                    productServicesAppDir2 = systemAppDir;
                                                                    oemAppDir = oemAppDir2;
                                                                    i4 = 5;
                                                                    try {
                                                                        scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, 0, (UserHandle) null);
                                                                    } catch (PackageManagerException e13) {
                                                                        Slog.e(TAG, "Failed to parse original system package: " + e13.getMessage());
                                                                    }
                                                                } else {
                                                                    i4 = i11;
                                                                    odmAppDir2 = odmAppDir4;
                                                                    oemAppDir = oemAppDir4;
                                                                    privilegedProductAppDir3 = privilegedProductAppDir5;
                                                                    privilegedProductAppDir2 = privilegedProductServicesAppDir4;
                                                                    privilegedProductServicesAppDir2 = vendorAppDir4;
                                                                    vendorAppDir2 = productAppDir4;
                                                                    productAppDir2 = productServicesAppDir4;
                                                                    productServicesAppDir2 = systemAppDir3;
                                                                }
                                                                i12++;
                                                                odmAppDir4 = odmAppDir2;
                                                                systemAppDir3 = productServicesAppDir2;
                                                                oemAppDir4 = oemAppDir;
                                                                i11 = i4;
                                                                productServicesAppDir4 = productAppDir2;
                                                                productAppDir4 = vendorAppDir2;
                                                                vendorAppDir4 = privilegedProductServicesAppDir2;
                                                                privilegedProductServicesAppDir4 = privilegedProductAppDir2;
                                                                privilegedProductAppDir5 = privilegedProductAppDir3;
                                                            }
                                                            installSystemStubPackages(stubSystemApps, scanFlags);
                                                            int cachedNonSystemApps = PackageParser.sCachedPackageReadCount.get() - cachedSystemApps;
                                                            long dataScanTime = (SystemClock.uptimeMillis() - systemScanTime) - startTime;
                                                            int dataPackagesCount = this.mPackages.size() - systemPackagesCount;
                                                            StringBuilder sb5 = new StringBuilder();
                                                            sb5.append("Finished scanning non-system apps. Time: ");
                                                            sb5.append(dataScanTime);
                                                            sb5.append(" ms, packageCount: ");
                                                            sb5.append(dataPackagesCount);
                                                            sb5.append(" , timePerPackage: ");
                                                            sb5.append(dataPackagesCount == 0 ? 0 : dataScanTime / ((long) dataPackagesCount));
                                                            sb5.append(" , cached: ");
                                                            sb5.append(cachedNonSystemApps);
                                                            Slog.i(TAG, sb5.toString());
                                                            if (!this.mIsUpgrade || dataPackagesCount <= 0) {
                                                                r7 = null;
                                                            } else {
                                                                r7 = null;
                                                                MetricsLogger.histogram((Context) null, "ota_package_manager_data_app_avg_scan_time", ((int) dataScanTime) / dataPackagesCount);
                                                            }
                                                        } catch (Throwable th26) {
                                                            th5 = th26;
                                                            th4 = th5;
                                                            obj2 = obj2;
                                                            throw th4;
                                                        }
                                                    } else {
                                                        r7 = r6;
                                                    }
                                                    this.mExpectingBetter.clear();
                                                    this.mStorageManagerPackage = getStorageManagerPackageName();
                                                    this.mSetupWizardPackage = getSetupWizardPackageName();
                                                    this.mComponentResolver.fixProtectedFilterPriorities();
                                                    this.mSystemTextClassifierPackage = getSystemTextClassifierPackageName();
                                                    this.mWellbeingPackage = getWellbeingPackageName();
                                                    this.mDocumenterPackage = getDocumenterPackageName();
                                                    this.mConfiguratorPackage = getDeviceConfiguratorPackageName();
                                                    this.mAppPredictionServicePackage = getAppPredictionServicePackageName();
                                                    this.mIncidentReportApproverPackage = getIncidentReportApproverPackageName();
                                                    updateAllSharedLibrariesLocked(r7, Collections.unmodifiableMap(this.mPackages));
                                                    for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
                                                        List<String> changedAbiCodePath = adjustCpuAbisForSharedUserLPw(setting.packages, r7);
                                                        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
                                                            for (int i13 = changedAbiCodePath.size() - 1; i13 >= 0; i13--) {
                                                                try {
                                                                    this.mInstaller.rmdex(changedAbiCodePath.get(i13), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                                                                } catch (Installer.InstallerException e14) {
                                                                }
                                                            }
                                                        }
                                                        setting.fixSeInfoLocked();
                                                    }
                                                    this.mPackageUsage.read(this.mPackages);
                                                    this.mCompilerStats.read();
                                                    EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());
                                                    Slog.i(TAG, "Time to scan packages: " + (((float) (SystemClock.uptimeMillis() - startTime)) / 1000.0f) + " seconds");
                                                    r1 = ver2.sdkVersion != this.mSdkVersion ? 1 : i;
                                                    if (r1 != 0) {
                                                        this.tSdkVersion = ver2.sdkVersion;
                                                        Slog.i(TAG, "Platform changed from " + ver2.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for internal storage");
                                                    }
                                                    this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, r1, this.mPackages.values(), this.mPermissionCallback);
                                                    ver2.sdkVersion = this.mSdkVersion;
                                                    ver2.emuiVersion = SystemProperties.getInt("ro.build.hw_emui_api_level", i);
                                                    if (!onlyCore && (this.mPromoteSystemApps || this.mFirstBoot)) {
                                                        for (UserInfo user : sUserManager.getUsers(true)) {
                                                            this.mSettings.applyDefaultPreferredAppsLPw(user.id);
                                                            primeDomainVerificationsLPw(user.id);
                                                        }
                                                    } else if (onlyCore || !this.mIsUpgrade) {
                                                        Slog.d(TAG, "No need to do anything to prime domain");
                                                    } else {
                                                        for (UserInfo user2 : sUserManager.getUsers(true)) {
                                                            primeDomainVerificationsLPw(user2.id, 1);
                                                        }
                                                    }
                                                    storageFlags = StorageManager.isFileEncryptedNativeOrEmulated() ? 1 : 3;
                                                    i2 = i;
                                                    deferPackages = reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, 0, storageFlags, true, true);
                                                } catch (Throwable th27) {
                                                    th5 = th27;
                                                    th4 = th5;
                                                    obj2 = obj2;
                                                    throw th4;
                                                }
                                                try {
                                                    storageFlags2 = storageFlags;
                                                    this.mPrepareAppDataFuture = SystemServerInitThreadPool.get().submit(new Runnable(deferPackages, storageFlags2) {
                                                        /* class com.android.server.pm.$$Lambda$PackageManagerService$Wjv1QnSJSVGpPDwhJspfZXLK3F0 */
                                                        private final /* synthetic */ List f$1;
                                                        private final /* synthetic */ int f$2;

                                                        {
                                                            this.f$1 = r2;
                                                            this.f$2 = r3;
                                                        }

                                                        @Override // java.lang.Runnable
                                                        public final void run() {
                                                            PackageManagerService.this.lambda$new$1$PackageManagerService(this.f$1, this.f$2);
                                                        }
                                                    }, "prepareAppData");
                                                    if (this.mIsUpgrade && !onlyCore) {
                                                        Slog.i(TAG, "Build fingerprint changed; clearing code caches");
                                                        int i14 = i2;
                                                        while (i14 < this.mSettings.mPackages.size()) {
                                                            PackageSetting ps5 = this.mSettings.mPackages.valueAt(i14);
                                                            if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps5.volumeUuid)) {
                                                                deferPackages2 = deferPackages;
                                                                clearAppDataLIF(ps5.pkg, -1, ((!IS_SUPPORT_RESERVE_PROFILE || r1 != 0) ? i2 : 128) | 39);
                                                            } else {
                                                                deferPackages2 = deferPackages;
                                                            }
                                                            i14++;
                                                            deferPackages = deferPackages2;
                                                        }
                                                        ver2.fingerprint = Build.FINGERPRINT;
                                                        ver2.hwFingerprint = Build.HWFINGERPRINT;
                                                        ver2.fingerprintEx = Build.FINGERPRINTEX;
                                                    }
                                                    if (onlyCore || !this.mIsPreQUpgrade) {
                                                        r62 = i2;
                                                    } else {
                                                        Slog.i(TAG, "Whitelisting all existing apps to hide their icons");
                                                        int size = this.mSettings.mPackages.size();
                                                        int i15 = 0;
                                                        while (i15 < size) {
                                                            PackageSetting ps6 = this.mSettings.mPackages.valueAt(i15);
                                                            if ((ps6.pkgFlags & 1) != 0) {
                                                                i3 = i2;
                                                            } else {
                                                                i3 = i2;
                                                                ps6.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME, i3);
                                                            }
                                                            i15++;
                                                            i2 = i3;
                                                        }
                                                        r62 = i2;
                                                    }
                                                    this.mExistingSystemPackages.clear();
                                                    this.mPromoteSystemApps = r62;
                                                    ver2.databaseVersion = 3;
                                                    if (isSettingsDirty || this.mIsUpgrade || this.mFirstBoot) {
                                                        long hwStartTime14 = HwPackageManagerServiceUtils.hwTimingsBegin();
                                                        try {
                                                            Trace.traceBegin(262144, "write settings");
                                                            this.mSettings.writeLPr();
                                                            Trace.traceEnd(262144);
                                                            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "mSettings.writeLPr", hwStartTime14);
                                                            hwStartTime6 = hwStartTime14;
                                                        } catch (Throwable th28) {
                                                            th4 = th28;
                                                            obj2 = obj2;
                                                            throw th4;
                                                        }
                                                    } else {
                                                        if (!this.mHandler.hasMessages(13)) {
                                                            this.mHandler.sendEmptyMessageDelayed(13, 5000);
                                                        }
                                                        hwStartTime6 = hwStartTime5;
                                                    }
                                                } catch (Throwable th29) {
                                                    th5 = th29;
                                                    th4 = th5;
                                                    obj2 = obj2;
                                                    throw th4;
                                                }
                                            } catch (Throwable th30) {
                                                j = hwStartTime4;
                                                th4 = th30;
                                                obj2 = obj2;
                                                throw th4;
                                            }
                                            try {
                                                mHwPMSEx.writeCertCompatPackages(true);
                                                EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());
                                                Jlog.d(32, "JL_BOOT_PROGRESS_PMS_READY");
                                                if (!this.mOnlyCore) {
                                                    try {
                                                        this.mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr();
                                                        this.mRequiredInstallerPackage = getRequiredInstallerLPr();
                                                        this.mRequiredUninstallerPackage = getRequiredUninstallerLPr();
                                                        this.mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();
                                                        if (this.mIntentFilterVerifierComponent != null) {
                                                            this.mIntentFilterVerifier = new IntentVerifierProxy(this.mContext, this.mIntentFilterVerifierComponent);
                                                        } else {
                                                            this.mIntentFilterVerifier = null;
                                                        }
                                                        this.mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.services", -1);
                                                        this.mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr("android.ext.shared", -1);
                                                    } catch (Throwable th31) {
                                                        th4 = th31;
                                                        obj2 = obj2;
                                                        throw th4;
                                                    }
                                                } else {
                                                    this.mRequiredVerifierPackage = null;
                                                    this.mRequiredInstallerPackage = null;
                                                    this.mRequiredUninstallerPackage = null;
                                                    this.mIntentFilterVerifierComponent = null;
                                                    this.mIntentFilterVerifier = null;
                                                    this.mServicesSystemSharedLibraryPackageName = null;
                                                    this.mSharedSystemSharedLibraryPackageName = null;
                                                }
                                                this.mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();
                                                int[] userIds = UserManagerService.getInstance().getUserIds();
                                                Iterator<PackageParser.Package> it3 = this.mPackages.values().iterator();
                                                while (it3.hasNext()) {
                                                    try {
                                                        PackageParser.Package pkg4 = it3.next();
                                                        if (!pkg4.isSystem()) {
                                                            int length = userIds.length;
                                                            r40 = hwStartTime6;
                                                            int i16 = 0;
                                                            while (i16 < length) {
                                                                int userId = userIds[i16];
                                                                PackageSetting ps7 = (PackageSetting) pkg4.mExtras;
                                                                if (ps7 == null || !ps7.getInstantApp(userId)) {
                                                                    it = it3;
                                                                    pkg = pkg4;
                                                                } else if (!ps7.getInstalled(userId)) {
                                                                    it = it3;
                                                                    pkg = pkg4;
                                                                } else {
                                                                    it = it3;
                                                                    pkg = pkg4;
                                                                    this.mInstantAppRegistry.addInstantAppLPw(userId, ps7.appId);
                                                                }
                                                                i16++;
                                                                it3 = it;
                                                                storageFlags2 = storageFlags2;
                                                                pkg4 = pkg;
                                                            }
                                                            hwStartTime6 = r40;
                                                        }
                                                    } catch (Throwable th32) {
                                                        th = th32;
                                                        hwStartTime7 = r40;
                                                        th4 = th;
                                                        obj2 = obj2;
                                                        throw th4;
                                                    }
                                                }
                                                hwStartTime7 = hwStartTime6;
                                                try {
                                                    this.mInstallerService = new PackageInstallerService(context, this, this.mApexManager);
                                                    Pair<ComponentName, String> instantAppResolverComponent = getInstantAppResolverLPr();
                                                    if (instantAppResolverComponent != null) {
                                                        if (DEBUG_INSTANT) {
                                                            Slog.d(TAG, "Set ephemeral resolver: " + instantAppResolverComponent);
                                                        }
                                                        this.mInstantAppResolverConnection = new InstantAppResolverConnection(this.mContext, (ComponentName) instantAppResolverComponent.first, (String) instantAppResolverComponent.second);
                                                        this.mInstantAppResolverSettingsComponent = getInstantAppResolverSettingsLPr((ComponentName) instantAppResolverComponent.first);
                                                        str = null;
                                                    } else {
                                                        str = null;
                                                        this.mInstantAppResolverConnection = null;
                                                        this.mInstantAppResolverSettingsComponent = null;
                                                    }
                                                    updateInstantAppInstallerLocked(str);
                                                    Map<Integer, List<PackageInfo>> userPackages = new HashMap<>();
                                                    int length2 = userIds.length;
                                                    int i17 = 0;
                                                    while (i17 < length2) {
                                                        int userId2 = userIds[i17];
                                                        userPackages.put(Integer.valueOf(userId2), getInstalledPackages(0, userId2).getList());
                                                        i17++;
                                                        userIds = userIds;
                                                        instantAppResolverComponent = instantAppResolverComponent;
                                                    }
                                                    this.mDexManager.load(userPackages);
                                                    if (this.mIsUpgrade) {
                                                        MetricsLogger.histogram((Context) null, "ota_package_manager_init_time", (int) (SystemClock.uptimeMillis() - startTime));
                                                    }
                                                    this.mSettings.clearReservedUidMap();
                                                } catch (Throwable th33) {
                                                    th = th33;
                                                    th4 = th;
                                                    obj2 = obj2;
                                                    throw th4;
                                                }
                                            } catch (Throwable th34) {
                                                th6 = th34;
                                                th4 = th6;
                                                obj2 = obj2;
                                                throw th4;
                                            }
                                            try {
                                                this.mModuleInfoProvider = new ModuleInfoProvider(this.mContext, (IPackageManager) this);
                                                this.mInstaller.setWarnIfHeld(this.mPackages);
                                                PackageParser.readConfigUseRoundIcon(this.mContext.getResources());
                                                this.mServiceStartWithDelay = SystemClock.uptimeMillis() + 60000;
                                                Trace.traceEnd(262144);
                                            } catch (Throwable th35) {
                                                th3 = th35;
                                                obj3 = obj2;
                                                throw th3;
                                            }
                                        } else {
                                            throw new IllegalStateException("Failed to load frameworks package; check log for warnings");
                                        }
                                    } catch (Throwable th36) {
                                        th4 = th36;
                                        obj2 = obj2;
                                        throw th4;
                                    }
                                } catch (Throwable th37) {
                                    obj2 = obj;
                                    th4 = th37;
                                    throw th4;
                                }
                            } catch (Throwable th38) {
                                obj2 = obj;
                                th4 = th38;
                                throw th4;
                            }
                        } catch (Throwable th39) {
                            arrayMap = arrayMap2;
                            obj2 = obj;
                            th4 = th39;
                            throw th4;
                        }
                    } catch (Throwable th40) {
                        arrayMap = arrayMap2;
                        obj2 = obj;
                        th4 = th40;
                        throw th4;
                    }
                }
            } catch (Throwable th41) {
                th3 = th41;
                obj3 = obj2;
                throw th3;
            }
        }
    }

    public /* synthetic */ void lambda$new$1$PackageManagerService(List deferPackages, int storageFlags) {
        TimingsTraceLog traceLog = new TimingsTraceLog("SystemServerTimingAsync", 262144);
        traceLog.traceBegin("AppDataFixup");
        try {
            this.mInstaller.fixupAppData(StorageManager.UUID_PRIVATE_INTERNAL, 3);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, "Trouble fixing GIDs", e);
        }
        traceLog.traceEnd();
        traceLog.traceBegin("AppDataPrepare");
        if (deferPackages != null && !deferPackages.isEmpty()) {
            int count = 0;
            Iterator it = deferPackages.iterator();
            while (it.hasNext()) {
                String pkgName = (String) it.next();
                PackageParser.Package pkg = null;
                synchronized (this.mPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(pkgName);
                    if (ps != null && ps.getInstalled(0)) {
                        pkg = ps.pkg;
                    }
                }
                if (pkg != null) {
                    synchronized (this.mInstallLock) {
                        prepareAppDataAndMigrateLIF(pkg, 0, storageFlags, true);
                    }
                    count++;
                }
            }
            traceLog.traceEnd();
            Slog.i(TAG, "Deferred reconcileAppsData finished " + count + " packages");
        }
    }

    private boolean isUpgradeAndEmuiVersionUpgrade() {
        return this.mIsUpgrade && this.mIsEmuiVersionUpgrade;
    }

    private boolean isSystemUIScanErr() {
        if (!isRecoverPermissionByPlatform()) {
            return false;
        }
        return "1".equals(SystemProperties.get(SYSTEMUI_SCAN_ERROR, "0"));
    }

    private boolean isRecoverPermissionByPlatform() {
        if ("mt6765".equals(HW_PLATFORM)) {
            return true;
        }
        return false;
    }

    private void resetSystemUIScanErr() {
        if (isSystemUIScanErr() && this.isSystemUIScanned) {
            SystemProperties.set(SYSTEMUI_SCAN_ERROR, "0");
        }
    }

    private void setSystemUIScanErr(String pkgName) {
        if (isRecoverPermissionByPlatform() && !TextUtils.isEmpty(pkgName) && HW_SYSTEMUI_PKGNAME.equals(pkgName)) {
            SystemProperties.set(SYSTEMUI_SCAN_ERROR, "1");
        }
    }

    private void setSystemUIScaned(String pkgName) {
        if (isRecoverPermissionByPlatform() && !TextUtils.isEmpty(pkgName) && HW_SYSTEMUI_PKGNAME.equals(pkgName)) {
            this.isSystemUIScanned = true;
        }
    }

    private void installSystemStubPackages(List<String> systemStubPackageNames, int scanFlags) {
        int i = systemStubPackageNames.size();
        while (true) {
            i--;
            if (i < 0) {
                break;
            }
            String packageName = systemStubPackageNames.get(i);
            if (this.mSettings.isDisabledSystemPackageLPr(packageName)) {
                systemStubPackageNames.remove(i);
            } else {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                if (pkg == null) {
                    systemStubPackageNames.remove(i);
                } else {
                    PackageSetting ps = this.mSettings.mPackages.get(packageName);
                    if (ps == null || ps.getEnabled(0) != 3) {
                        try {
                            installStubPackageLI(pkg, 0, scanFlags);
                            ps.setEnabled(0, 0, PLATFORM_PACKAGE_NAME);
                            systemStubPackageNames.remove(i);
                        } catch (PackageManagerException e) {
                            Slog.e(TAG, "Failed to parse uncompressed system package: " + e.getMessage());
                        }
                    } else {
                        systemStubPackageNames.remove(i);
                    }
                }
            }
        }
        for (int i2 = systemStubPackageNames.size() - 1; i2 >= 0; i2 += -1) {
            String pkgName = systemStubPackageNames.get(i2);
            this.mSettings.mPackages.get(pkgName).setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
            PackageManagerServiceUtils.logCriticalInfo(6, "Stub disabled; pkg: " + pkgName);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0065, code lost:
        r6 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:30:0x0066, code lost:
        if (r4 != null) goto L_0x0068;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:31:0x0068, code lost:
        $closeResource(r5, r4);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:32:0x006b, code lost:
        throw r6;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:65:0x00b6, code lost:
        r7 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:66:0x00b7, code lost:
        if (r6 != null) goto L_0x00b9;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:67:0x00b9, code lost:
        $closeResource(r2, r6);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:68:0x00bc, code lost:
        throw r7;
     */
    private boolean enableCompressedPackage(PackageParser.Package stubPkg) {
        int parseFlags = this.mDefParseFlags | Integer.MIN_VALUE | 64;
        synchronized (this.mInstallLock) {
            try {
                PackageFreezer freezer = freezePackage(stubPkg.packageName, "setEnabledSetting");
                PackageParser.Package pkg = installStubPackageLI(stubPkg, parseFlags, 0);
                synchronized (this.mPackages) {
                    prepareAppDataAfterInstallLIF(pkg);
                    try {
                        updateSharedLibrariesLocked(pkg, null, this.mPackages);
                    } catch (PackageManagerException e) {
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: ", e);
                    }
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    this.mSettings.writeLPr();
                }
                if (freezer != null) {
                    $closeResource(null, freezer);
                }
                clearAppDataLIF(pkg, -1, 39);
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
            } catch (PackageManagerException e2) {
                try {
                    PackageFreezer freezer2 = freezePackage(stubPkg.packageName, "setEnabledSetting");
                    synchronized (this.mPackages) {
                        enableSystemPackageLPw(stubPkg);
                        installPackageFromSystemLIF(stubPkg.codePath, null, null, null, true);
                        if (freezer2 != null) {
                            $closeResource(null, freezer2);
                        }
                        synchronized (this.mPackages) {
                            PackageSetting stubPs = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs != null) {
                                stubPs.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                            return false;
                        }
                    }
                } catch (PackageManagerException pme) {
                    try {
                        Slog.wtf(TAG, "Failed to restore system package:" + stubPkg.packageName, pme);
                        synchronized (this.mPackages) {
                            PackageSetting stubPs2 = this.mSettings.mPackages.get(stubPkg.packageName);
                            if (stubPs2 != null) {
                                stubPs2.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            }
                            this.mSettings.writeLPr();
                        }
                    } catch (Throwable th) {
                        th = th;
                    }
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
        return true;
        throw th;
    }

    private static /* synthetic */ void $closeResource(Throwable x0, AutoCloseable x1) {
        if (x0 != null) {
            try {
                x1.close();
            } catch (Throwable th) {
                x0.addSuppressed(th);
            }
        } else {
            x1.close();
        }
    }

    private PackageParser.Package installStubPackageLI(PackageParser.Package stubPkg, int parseFlags, int scanFlags) throws PackageManagerException {
        if (DEBUG_COMPRESSION) {
            Slog.i(TAG, "Uncompressing system stub; pkg: " + stubPkg.packageName);
        }
        File scanFile = decompressPackage(stubPkg.packageName, stubPkg.codePath);
        if (scanFile != null) {
            synchronized (this.mPackages) {
                this.mSettings.disableSystemPackageLPw(stubPkg.packageName, true);
            }
            removePackageLI(stubPkg, true);
            try {
                return scanPackageTracedLI(scanFile, parseFlags, scanFlags, 0, (UserHandle) null);
            } catch (PackageManagerException e) {
                Slog.w(TAG, "Failed to install compressed system package:" + stubPkg.packageName, e);
                removeCodePathLI(scanFile);
                throw e;
            }
        } else {
            throw new PackageManagerException("Unable to decompress stub at " + stubPkg.codePath);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:19:0x0098  */
    /* JADX WARNING: Removed duplicated region for block: B:32:0x00d0  */
    /* JADX WARNING: Removed duplicated region for block: B:37:0x00db A[RETURN] */
    private File decompressPackage(String packageName, String codePath) {
        int ret;
        ErrnoException e;
        File[] compressedFiles = PackageManagerServiceUtils.getCompressedFiles(codePath);
        if (compressedFiles == null || compressedFiles.length == 0) {
            if (DEBUG_COMPRESSION) {
                Slog.i(TAG, "No files to decompress: " + codePath);
            }
            return null;
        }
        File dstCodePath = getNextCodePath(Environment.getDataAppDirectory(null), packageName);
        try {
            Os.mkdir(dstCodePath.getAbsolutePath(), 493);
            Os.chmod(dstCodePath.getAbsolutePath(), 493);
            int length = compressedFiles.length;
            ret = 1;
            int ret2 = 0;
            while (true) {
                if (ret2 >= length) {
                    break;
                }
                try {
                    File srcFile = compressedFiles[ret2];
                    String srcFileName = srcFile.getName();
                    String dstFileName = srcFileName.substring(0, srcFileName.length() - COMPRESSED_EXTENSION.length());
                    ret = PackageManagerServiceUtils.decompressFile(srcFile, new File(dstCodePath, dstFileName));
                    if (ret != 1) {
                        PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", file: " + dstFileName);
                        break;
                    }
                    ret2++;
                } catch (ErrnoException e2) {
                    e = e2;
                    PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
                    if (ret == 1) {
                    }
                    if (ret == 1) {
                    }
                }
            }
        } catch (ErrnoException e3) {
            e = e3;
            ret = 1;
            PackageManagerServiceUtils.logCriticalInfo(6, "Failed to decompress; pkg: " + packageName + ", err: " + e.errno);
            if (ret == 1) {
            }
            if (ret == 1) {
            }
        }
        if (ret == 1) {
            File libraryRoot = new File(dstCodePath, "lib");
            NativeLibraryHelper.Handle handle = null;
            try {
                handle = NativeLibraryHelper.Handle.create(dstCodePath);
                ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, (String) null);
            } catch (IOException e4) {
                PackageManagerServiceUtils.logCriticalInfo(6, "Failed to extract native libraries; pkg: " + packageName);
                ret = RequestStatus.SYS_ETIMEDOUT;
            } catch (Throwable th) {
                IoUtils.closeQuietly(handle);
                throw th;
            }
            IoUtils.closeQuietly(handle);
        }
        if (ret == 1) {
            return dstCodePath;
        }
        if (!dstCodePath.exists()) {
            return null;
        }
        removeCodePathLI(dstCodePath);
        return null;
    }

    @GuardedBy({"mPackages"})
    private void updateInstantAppInstallerLocked(String modifiedPackage) {
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        if (activityInfo == null || activityInfo.getComponentName().getPackageName().equals(modifiedPackage)) {
            setUpInstantAppInstallerActivityLP(getInstantAppInstallerLPr());
        }
    }

    private static File preparePackageParserCache(boolean isUpgrade) {
        Slog.i(TAG, "preparePackageParserCache, isUpgrade= " + isUpgrade);
        if (Build.IS_ENG) {
            return null;
        }
        if (SystemProperties.getBoolean("pm.boot.disable_package_cache", false)) {
            Slog.i(TAG, "Disabling package parser cache due to system property.");
            return null;
        }
        File cacheBaseDir = Environment.getPackageCacheDirectory();
        if (!FileUtils.createDir(cacheBaseDir)) {
            return null;
        }
        String cacheName = SystemProperties.digestOf(new String[]{"ro.build.fingerprint", "persist.sys.isolated_storage", "sys.isolated_storage_snapshot"});
        File[] listFilesOrEmpty = FileUtils.listFilesOrEmpty(cacheBaseDir);
        for (File cacheDir : listFilesOrEmpty) {
            if (!Objects.equals(cacheName, cacheDir.getName()) || isUpgrade) {
                Slog.d(TAG, "Destroying unknown cache " + cacheDir.getName());
                FileUtils.deleteContentsAndDir(cacheDir);
            } else {
                Slog.d(TAG, "Keeping known cache " + cacheDir.getName());
            }
        }
        File cacheDir2 = FileUtils.createDir(cacheBaseDir, cacheName);
        if (cacheDir2 == null) {
            Slog.wtf(TAG, "Cache directory cannot be created - wiping base dir " + cacheBaseDir);
            FileUtils.deleteContentsAndDir(cacheBaseDir);
            return null;
        } else if (!Build.IS_USERDEBUG || !Build.VERSION.INCREMENTAL.startsWith("eng.")) {
            return cacheDir2;
        } else {
            Slog.w(TAG, "Wiping cache directory because the system partition changed.");
            if (cacheDir2.lastModified() >= new File(Environment.getRootDirectory(), "framework").lastModified()) {
                return cacheDir2;
            }
            FileUtils.deleteContents(cacheBaseDir);
            return FileUtils.createDir(cacheBaseDir, cacheName);
        }
    }

    public boolean isFirstBoot() {
        return this.mFirstBoot;
    }

    public boolean isOnlyCoreApps() {
        return this.mOnlyCore;
    }

    public boolean isDeviceUpgrading() {
        return this.mIsUpgrade || SystemProperties.getBoolean("persist.pm.mock-upgrade", false);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean isUpgrade() {
        return isDeviceUpgrading();
    }

    private String getRequiredButNotReallyRequiredVerifierLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        if (matches.size() == 0) {
            Log.e(TAG, "There should probably be a verifier, but, none were found");
            return null;
        }
        throw new RuntimeException("There must be exactly one verifier; found " + matches);
    }

    private String getRequiredSharedLibraryLPr(String name, int version) {
        String packageName;
        synchronized (this.mPackages) {
            SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(name, (long) version);
            if (libraryInfo != null) {
                packageName = libraryInfo.getPackageName();
                if (packageName == null) {
                    throw new IllegalStateException("Expected a package for shared library " + name);
                }
            } else {
                throw new IllegalStateException("Missing required shared library:" + name);
            }
        }
        return packageName;
    }

    private String getRequiredInstallerLPr() {
        Intent intent = new Intent("android.intent.action.INSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.parse("content://com.example/foo.apk"), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one installer; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The installer must be a privileged app");
        }
    }

    private String getRequiredUninstallerLPr() {
        Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setData(Uri.fromParts("package", "foo.bar", null));
        ResolveInfo resolveInfo = resolveIntent(intent, null, 1835008, 0);
        if (resolveInfo != null && !this.mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) {
            return resolveInfo.getComponentInfo().packageName;
        }
        throw new RuntimeException("There must be exactly one uninstaller; found " + resolveInfo);
    }

    private String getRequiredPermissionControllerLPr() {
        Intent intent = new Intent("android.intent.action.MANAGE_PERMISSIONS");
        intent.addCategory("android.intent.category.DEFAULT");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835008, 0);
        if (matches.size() != 1) {
            throw new RuntimeException("There must be exactly one permissions manager; found " + matches);
        } else if (matches.get(0).activityInfo.applicationInfo.isPrivilegedApp()) {
            return matches.get(0).getComponentInfo().packageName;
        } else {
            throw new RuntimeException("The permissions manager must be a privileged app");
        }
    }

    private ComponentName getIntentFilterVerifierComponentNameLPr() {
        List<ResolveInfo> matches = queryIntentReceiversInternal(new Intent("android.intent.action.INTENT_FILTER_NEEDS_VERIFICATION"), PACKAGE_MIME_TYPE, 1835008, 0, false);
        ResolveInfo best = null;
        int N = matches.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo cur = matches.get(i);
            if (checkPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", cur.getComponentInfo().packageName, 0) == 0 && (best == null || cur.priority > best.priority)) {
                best = cur;
            }
        }
        if (best != null) {
            return best.getComponentInfo().getComponentName();
        }
        Slog.w(TAG, "Intent filter verifier not found");
        return null;
    }

    public ComponentName getInstantAppResolverComponent() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            Pair<ComponentName, String> instantAppResolver = getInstantAppResolverLPr();
            if (instantAppResolver == null) {
                return null;
            }
            return (ComponentName) instantAppResolver.first;
        }
    }

    private Pair<ComponentName, String> getInstantAppResolverLPr() {
        String[] packageArray = this.mContext.getResources().getStringArray(17236020);
        if (packageArray.length != 0 || Build.IS_DEBUGGABLE) {
            List<ResolveInfo> resolvers = queryIntentServicesInternal(new Intent("android.intent.action.RESOLVE_INSTANT_APP_PACKAGE"), null, (!Build.IS_DEBUGGABLE ? 1048576 : 0) | 786432, 0, Binder.getCallingUid(), false);
            int N = resolvers.size();
            if (N == 0) {
                if (DEBUG_INSTANT) {
                    Slog.d(TAG, "Ephemeral resolver NOT found; no matching intent filters");
                }
                return null;
            }
            Set<String> possiblePackages = new ArraySet<>(Arrays.asList(packageArray));
            for (int i = 0; i < N; i++) {
                ResolveInfo info = resolvers.get(i);
                if (info.serviceInfo != null) {
                    String packageName = info.serviceInfo.packageName;
                    if (possiblePackages.contains(packageName) || Build.IS_DEBUGGABLE) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Ephemeral resolver found; pkg: " + packageName + ", info:" + info);
                        }
                        return new Pair<>(new ComponentName(packageName, info.serviceInfo.name), "android.intent.action.RESOLVE_INSTANT_APP_PACKAGE");
                    } else if (DEBUG_INSTANT) {
                        Slog.d(TAG, "Ephemeral resolver not in allowed package list; pkg: " + packageName + ", info:" + info);
                    }
                }
            }
            if (!DEBUG_INSTANT) {
                return null;
            }
            Slog.v(TAG, "Ephemeral resolver NOT found");
            return null;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Ephemeral resolver NOT found; empty package list");
        }
        return null;
    }

    @GuardedBy({"mPackages"})
    private ActivityInfo getInstantAppInstallerLPr() {
        String[] orderedActions;
        if (Build.IS_ENG) {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE_TEST", "android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        } else {
            orderedActions = new String[]{"android.intent.action.INSTALL_INSTANT_APP_PACKAGE"};
        }
        int resolveFlags = 786944 | (!Build.IS_ENG ? 1048576 : 0);
        Intent intent = new Intent();
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(new File("foo.apk")), PACKAGE_MIME_TYPE);
        List<ResolveInfo> matches = null;
        for (String action : orderedActions) {
            intent.setAction(action);
            matches = queryIntentActivitiesInternal(intent, PACKAGE_MIME_TYPE, resolveFlags, 0);
            if (!matches.isEmpty()) {
                break;
            }
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Instant App installer not found with " + action);
            }
        }
        Iterator<ResolveInfo> iter = matches.iterator();
        while (iter.hasNext()) {
            if (checkPermission("android.permission.INSTALL_PACKAGES", iter.next().activityInfo.packageName, 0) != 0 && !Build.IS_ENG) {
                iter.remove();
            }
        }
        if (matches.size() == 0) {
            return null;
        }
        if (matches.size() == 1) {
            return (ActivityInfo) matches.get(0).getComponentInfo();
        }
        throw new RuntimeException("There must be at most one ephemeral installer; found " + matches);
    }

    private ComponentName getInstantAppResolverSettingsLPr(ComponentName resolver) {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.intent.action.INSTANT_APP_RESOLVER_SETTINGS").addCategory("android.intent.category.DEFAULT").setPackage(resolver.getPackageName()), null, 786432, 0);
        if (matches.isEmpty()) {
            return null;
        }
        return matches.get(0).getComponentInfo().getComponentName();
    }

    @GuardedBy({"mPackages"})
    private void primeDomainVerificationsLPw(int userId) {
        primeDomainVerificationsLPw(userId, 0);
    }

    private void primeDomainVerificationsLPw(int userId, int flag) {
        if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "Priming domain verifications in user " + userId);
        }
        Iterator<String> it = SystemConfig.getInstance().getLinkedApps().iterator();
        while (it.hasNext()) {
            String packageName = it.next();
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "Unknown package " + packageName + " in sysconfig <app-link>");
            } else if (!pkg.isSystem()) {
                Slog.w(TAG, "Non-system app '" + packageName + "' in sysconfig <app-link>");
            } else {
                ArraySet<String> domains = null;
                Iterator it2 = pkg.activities.iterator();
                while (it2.hasNext()) {
                    Iterator it3 = ((PackageParser.Activity) it2.next()).intents.iterator();
                    while (it3.hasNext()) {
                        PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it3.next();
                        if (hasValidDomains(filter)) {
                            if (domains == null) {
                                domains = new ArraySet<>();
                            }
                            domains.addAll(filter.getHostsList());
                        }
                    }
                }
                if (domains == null || domains.size() <= 0) {
                    Slog.w(TAG, "Sysconfig <app-link> package '" + packageName + "' does not handle web links");
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "      + " + packageName);
                    }
                    if (this.mIsUpgrade && flag == 1) {
                        updateIntentFilterVerification(packageName, domains, userId);
                    } else if (flag == 0) {
                        IntentFilterVerificationInfo ivi = this.mSettings.createIntentFilterVerificationIfNeededLPw(packageName, domains);
                        if (ivi != null) {
                            ivi.setStatus(0);
                            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
                        } else {
                            return;
                        }
                    } else {
                        Slog.w(TAG, "Unknown flag " + flag + " in sysconfig <app-link>");
                    }
                }
            }
        }
        scheduleWritePackageRestrictionsLocked(userId);
        scheduleWriteSettingsLocked();
    }

    private void updateIntentFilterVerification(String packageName, ArraySet<String> domains, int userId) {
        PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
        if (packageSetting != null && packageSetting.getIntentFilterVerificationInfo() == null) {
            packageSetting.setIntentFilterVerificationInfo(new IntentFilterVerificationInfo(packageName, domains));
            this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, 2, userId);
            Slog.i(TAG, "package " + packageName + " is a new application for hota upgrade, sysconfig app-link");
        }
    }

    private boolean packageIsBrowser(String packageName, int userId) {
        List<ResolveInfo> list = queryIntentActivitiesInternal(sBrowserIntent, null, 131072, userId);
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo info = list.get(i);
            if (info.priority >= 0 && packageName.equals(info.activityInfo.packageName)) {
                return true;
            }
        }
        return false;
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            if (!(e instanceof SecurityException) && !(e instanceof IllegalArgumentException)) {
                Slog.wtf(TAG, "Package Manager Crash", e);
            }
            throw e;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean canViewInstantApps(int callingUid, int userId) {
        if (callingUid < 10000 || this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS") == 0) {
            return true;
        }
        if (this.mContext.checkCallingOrSelfPermission("android.permission.VIEW_INSTANT_APPS") != 0) {
            return false;
        }
        ComponentName homeComponent = getDefaultHomeActivity(userId);
        if (homeComponent != null && isCallerSameApp(homeComponent.getPackageName(), callingUid)) {
            return true;
        }
        String str = this.mAppPredictionServicePackage;
        if (str == null || !isCallerSameApp(str, callingUid)) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInfo generatePackageInfo(PackageSetting ps, int flags, int userId) {
        int flags2;
        Set<String> permissions;
        if (!sUserManager.exists(userId)) {
            Log.i(TAG, "generatePackageInfo error, user not exists:" + userId);
            return null;
        } else if (ps == null) {
            Log.i(TAG, "generatePackageInfo error, empty package setting");
            return null;
        } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
            Log.i(TAG, "generatePackageInfo error, filter instant applications:" + ps.name);
            return null;
        } else {
            if ((flags & 8192) == 0 || !ps.isSystem()) {
                flags2 = flags;
            } else {
                flags2 = flags | 4194304;
            }
            PackageUserState state = ps.readUserState(userId);
            PackageParser.Package p = ps.pkg;
            if (p != null) {
                PermissionsState permissionsState = ps.getPermissionsState();
                int[] gids = (flags2 & 256) == 0 ? EMPTY_INT_ARRAY : permissionsState.computeGids(userId);
                Set<String> permissions2 = (flags2 & 4096) == 0 || ArrayUtils.isEmpty(p.requestedPermissions) ? Collections.emptySet() : permissionsState.getPermissions(userId);
                if (state.instantApp) {
                    Set<String> arraySet = new ArraySet<>(permissions2);
                    arraySet.removeIf(new Predicate(userId, ps) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$In4Em0pvl4vzKsKu3OPFDRbLfvg */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ PackageSetting f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        @Override // java.util.function.Predicate
                        public final boolean test(Object obj) {
                            return PackageManagerService.this.lambda$generatePackageInfo$2$PackageManagerService(this.f$1, this.f$2, (String) obj);
                        }
                    });
                    permissions = arraySet;
                } else {
                    permissions = permissions2;
                }
                PackageInfo packageInfo = PackageParser.generatePackageInfo(p, gids, flags2, ps.firstInstallTime, ps.lastUpdateTime, permissions, state, userId);
                if (packageInfo == null) {
                    Log.i(TAG, "generatePackageInfo error, PackageParser error:" + ps.name);
                    return null;
                }
                ApplicationInfo applicationInfo = packageInfo.applicationInfo;
                String resolveExternalPackageNameLPr = resolveExternalPackageNameLPr(p);
                applicationInfo.packageName = resolveExternalPackageNameLPr;
                packageInfo.packageName = resolveExternalPackageNameLPr;
                return packageInfo;
            } else if ((flags2 & 8192) == 0 || !state.isAvailable(flags2)) {
                Log.i(TAG, "generatePackageInfo error, ps.pkg is null:" + ps.name);
                return null;
            } else {
                PackageInfo pi = new PackageInfo();
                pi.packageName = ps.name;
                pi.setLongVersionCode(ps.versionCode);
                pi.sharedUserId = ps.sharedUser != null ? ps.sharedUser.name : null;
                pi.firstInstallTime = ps.firstInstallTime;
                pi.lastUpdateTime = ps.lastUpdateTime;
                ApplicationInfo ai = new ApplicationInfo();
                ai.packageName = ps.name;
                ai.uid = UserHandle.getUid(userId, ps.appId);
                ai.primaryCpuAbi = ps.primaryCpuAbiString;
                ai.secondaryCpuAbi = ps.secondaryCpuAbiString;
                ai.setVersionCode(ps.versionCode);
                ai.flags = ps.pkgFlags;
                ai.privateFlags = ps.pkgPrivateFlags;
                pi.applicationInfo = PackageParser.generateApplicationInfo(ai, flags2, state, userId);
                if (DEBUG_PACKAGE_INFO) {
                    Log.v(TAG, "ps.pkg is n/a for [" + ps.name + "]. Provides a minimum info.");
                }
                return pi;
            }
        }
    }

    public /* synthetic */ boolean lambda$generatePackageInfo$2$PackageManagerService(int userId, PackageSetting ps, String permissionName) {
        BasePermission permission = this.mPermissionManager.getPermissionTEMP(permissionName);
        if (permission == null) {
            return true;
        }
        if (permission.isInstant()) {
            return false;
        }
        EventLog.writeEvent(1397638484, "140256621", Integer.valueOf(UserHandle.getUid(userId, ps.appId)), permissionName);
        return true;
    }

    public void checkPackageStartable(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            boolean userKeyUnlocked = StorageManager.isUserKeyUnlocked(userId);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new SecurityException("Package " + packageName + " was not found!");
                } else if (ps.getInstalled(userId)) {
                    if (this.mSafeMode) {
                        if (!ps.isSystem()) {
                            throw new SecurityException("Package " + packageName + " not a system app!");
                        }
                    }
                    if (mHwPMSEx != null) {
                        if (mHwPMSEx.isNeedForbidAppAct(PACKAGE_FORBIDDEN, packageName, null, null)) {
                            Slog.i(TAG, "checkPackageStartable isNeedForbidAppAct forbid");
                            throw new SecurityException("Package isNeedForbidAppAct forbid!");
                        }
                    }
                    if (this.mFrozenPackages.contains(packageName)) {
                        throw new SecurityException("Package " + packageName + " is currently frozen!");
                    } else if (!userKeyUnlocked) {
                        if (!ps.pkg.applicationInfo.isEncryptionAware()) {
                            throw new SecurityException("Package " + packageName + " is not encryption aware!");
                        }
                    }
                } else {
                    throw new SecurityException("Package " + packageName + " was not installed for user " + userId + "!");
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isPackageAvailable(String packageName, int userId) {
        PackageUserState state;
        if (!sUserManager.exists(userId)) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "is package available");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                PackageSetting ps = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    return false;
                }
                if (!(ps == null || (state = ps.readUserState(userId)) == null)) {
                    return PackageParser.isAvailable(state);
                }
            }
            return false;
        }
    }

    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        return getPackageInfoInternal(packageName, -1, flags, Binder.getCallingUid(), userId);
    }

    public PackageInfo getPackageInfoVersioned(VersionedPackage versionedPackage, int flags, int userId) {
        return getPackageInfoInternal(versionedPackage.getPackageName(), versionedPackage.getLongVersionCode(), flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInfo getPackageInfoInternal(String packageName, long versionCode, int flags, int filterCallingUid, int userId) {
        Throwable th;
        String packageName2;
        if (DEBUG_GET_PACKAGE && (flags & 268435456) != 0) {
            Log.i(TAG, "getPackageInfoInternal packageName:" + packageName + "," + flags + "," + userId);
        }
        if (!sUserManager.exists(userId)) {
            Log.i(TAG, "generatePackageInfo error, user not exists:" + userId);
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get package info");
        synchronized (this.mPackages) {
            try {
                packageName2 = resolveInternalPackageNameLPr(packageName, versionCode);
                boolean matchFactoryOnly = (2097152 & flags2) != 0;
                if (matchFactoryOnly) {
                    if ((flags2 & 1073741824) != 0) {
                        try {
                            return this.mApexManager.getPackageInfo(packageName2, 2);
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } else {
                        PackageSetting ps = this.mSettings.getDisabledSystemPkgLPr(packageName2);
                        if (ps != null) {
                            if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                                Log.i(TAG, "Package:" + packageName2 + " matchFactoryOnly filtered sharedLib package");
                                return null;
                            } else if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                                Log.i(TAG, "Package:" + packageName2 + " matchFactoryOnly filtered instant applications");
                                return null;
                            } else {
                                return generatePackageInfo(ps, flags2, userId);
                            }
                        }
                    }
                }
                PackageParser.Package p = this.mPackages.get(packageName2);
                if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                    Log.i(TAG, "Package:" + packageName2 + " matchFactoryOnly is not system app");
                    return null;
                } else if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                    Log.i(TAG, "Package:" + packageName2 + "is hideen by cust package manager");
                    return null;
                } else {
                    if (DEBUG_PACKAGE_INFO) {
                        Log.v(TAG, "getPackageInfo " + packageName2 + ": " + p);
                    }
                    if (p != null) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (filterSharedLibPackageLPr(ps2, filterCallingUid, userId, flags2)) {
                            Log.i(TAG, "Package:" + packageName2 + " filtered sharedLib package");
                            return null;
                        } else if (ps2 == null || !filterAppAccessLPr(ps2, filterCallingUid, userId)) {
                            return generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                        } else {
                            Log.i(TAG, "Package:" + packageName2 + " filtered instant applications");
                            return null;
                        }
                    } else if (!matchFactoryOnly && (4202496 & flags2) != 0) {
                        PackageSetting ps3 = this.mSettings.mPackages.get(packageName2);
                        if (ps3 == null) {
                            Log.i(TAG, "Package:" + packageName2 + " matchFactoryOnly ps is empty");
                            return null;
                        } else if (filterSharedLibPackageLPr(ps3, filterCallingUid, userId, flags2)) {
                            Log.i(TAG, "Package:" + packageName2 + " MATCH_KNOWN_PACKAGES filtered sharedLib package");
                            return null;
                        } else if (filterAppAccessLPr(ps3, filterCallingUid, userId)) {
                            Log.i(TAG, "Package:" + packageName2 + " MATCH_KNOWN_PACKAGES filtered instant applications");
                            return null;
                        } else {
                            return generatePackageInfo(ps3, flags2, userId);
                        }
                    } else if (!matchFactoryOnly && (1073741824 & flags2) != 0) {
                        return this.mApexManager.getPackageInfo(packageName2, 1);
                    }
                }
            } catch (Throwable th3) {
                th = th3;
                throw th;
            }
        }
        if (DEBUG_GET_PACKAGE && (flags2 & 268435456) != 0) {
            Log.i(TAG, "Can not find:" + packageName2);
        }
        return null;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component) {
        if (!isComponentVisibleToInstantApp(component, 1) && !isComponentVisibleToInstantApp(component, 3) && !isComponentVisibleToInstantApp(component, 4)) {
            return false;
        }
        return true;
    }

    private boolean isComponentVisibleToInstantApp(ComponentName component, int type) {
        if (type == 1) {
            PackageParser.Activity activity = this.mComponentResolver.getActivity(component);
            if (activity == null) {
                return false;
            }
            return ((1048576 & activity.info.flags) != 0) && ((2097152 & activity.info.flags) == 0);
        } else if (type == 2) {
            PackageParser.Activity activity2 = this.mComponentResolver.getReceiver(component);
            if (activity2 == null) {
                return false;
            }
            return ((1048576 & activity2.info.flags) != 0) && !((2097152 & activity2.info.flags) == 0);
        } else if (type == 3) {
            PackageParser.Service service = this.mComponentResolver.getService(component);
            return (service == null || (1048576 & service.info.flags) == 0) ? false : true;
        } else if (type == 4) {
            PackageParser.Provider provider = this.mComponentResolver.getProvider(component);
            return (provider == null || (1048576 & provider.info.flags) == 0) ? false : true;
        } else if (type == 0) {
            return isComponentVisibleToInstantApp(component);
        } else {
            return false;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, ComponentName component, int componentType, int userId) {
        if (Process.isIsolated(callingUid)) {
            callingUid = this.mIsolatedOwners.get(callingUid);
        }
        boolean callerIsInstantApp = getInstantAppPackageName(callingUid) != null;
        if (ps == null) {
            return callerIsInstantApp;
        }
        if (isCallerSameApp(ps.name, callingUid)) {
            return false;
        }
        if (callerIsInstantApp) {
            if (ps.getInstantApp(userId)) {
                return true;
            }
            if (component == null) {
                return !ps.pkg.visibleToInstantApps;
            }
            PackageParser.Instrumentation instrumentation = this.mInstrumentation.get(component);
            if (instrumentation == null || !isCallerSameApp(instrumentation.info.targetPackage, callingUid)) {
                return !isComponentVisibleToInstantApp(component, componentType);
            }
            return false;
        } else if (!ps.getInstantApp(userId) || canViewInstantApps(callingUid, userId)) {
            return false;
        } else {
            if (component != null) {
                return true;
            }
            return !this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private boolean filterAppAccessLPr(PackageSetting ps, int callingUid, int userId) {
        return filterAppAccessLPr(ps, callingUid, null, 0, userId);
    }

    @GuardedBy({"mPackages"})
    private boolean filterSharedLibPackageLPr(PackageSetting ps, int uid, int userId, int flags) {
        int index;
        if ((flags & DumpState.DUMP_HANDLE) != 0) {
            int appId = UserHandle.getAppId(uid);
            if (appId != 1000 && appId != 2000) {
                if (appId != 0) {
                    if (checkUidPermission("android.permission.INSTALL_PACKAGES", uid) == 0) {
                        return false;
                    }
                }
            }
            return false;
        }
        if (ps != null && ps.pkg != null) {
            if (ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(ps.pkg.staticSharedLibName, ps.pkg.staticSharedLibVersion);
                if (libraryInfo == null) {
                    return false;
                }
                String[] uidPackageNames = getPackagesForUid(UserHandle.getUid(userId, UserHandle.getAppId(uid)));
                if (uidPackageNames == null) {
                    return true;
                }
                for (String uidPackageName : uidPackageNames) {
                    if (ps.name.equals(uidPackageName)) {
                        return false;
                    }
                    PackageSetting uidPs = this.mSettings.getPackageLPr(uidPackageName);
                    if (uidPs != null && (index = ArrayUtils.indexOf(uidPs.usesStaticLibraries, libraryInfo.getName())) >= 0 && uidPs.pkg.usesStaticLibrariesVersions[index] == libraryInfo.getLongVersion()) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }

    public String[] currentToCanonicalPackageNames(String[] names) {
        boolean z;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            for (int i = names.length - 1; i >= 0; i--) {
                PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                boolean translateName = false;
                if (!(ps == null || ps.realName == null)) {
                    if (ps.getInstantApp(callingUserId) && !canViewInstantApps) {
                        if (!this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                            z = false;
                            translateName = z;
                        }
                    }
                    z = true;
                    translateName = z;
                }
                out[i] = translateName ? ps.realName : names[i];
            }
        }
        return out;
    }

    public String[] canonicalToCurrentPackageNames(String[] names) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return names;
        }
        String[] out = new String[names.length];
        synchronized (this.mPackages) {
            int callingUserId = UserHandle.getUserId(callingUid);
            boolean canViewInstantApps = canViewInstantApps(callingUid, callingUserId);
            boolean z = true;
            int i = names.length - 1;
            while (i >= 0) {
                String cur = this.mSettings.getRenamedPackageLPr(names[i]);
                boolean translateName = false;
                if (cur != null) {
                    PackageSetting ps = this.mSettings.mPackages.get(names[i]);
                    boolean z2 = false;
                    if (!((ps == null || !ps.getInstantApp(callingUserId)) ? false : z) || canViewInstantApps || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        z2 = true;
                    }
                    translateName = z2;
                }
                out[i] = translateName ? cur : names[i];
                i--;
                z = true;
            }
        }
        return out;
    }

    public int getPackageUid(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return -1;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageUid");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null || !p.isMatch(flags2)) {
                if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                    return -1;
                }
                return UserHandle.getUid(userId, ps.appId);
            } else if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, userId)) {
                return -1;
            } else {
                return UserHandle.getUid(userId, p.applicationInfo.uid);
            }
        }
    }

    private boolean hasTargetSdkInUidLowerThan(int uid, int higherTargetSDK) {
        int userId = UserHandle.getUserId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
            boolean z = false;
            if (obj == null) {
                return false;
            }
            if (obj instanceof PackageSetting) {
                PackageSetting ps = (PackageSetting) obj;
                if (!ps.getInstalled(userId)) {
                    return false;
                }
                if (ps.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                    z = true;
                }
                return z;
            } else if (!(obj instanceof SharedUserSetting)) {
                return false;
            } else {
                SharedUserSetting sus = (SharedUserSetting) obj;
                int numPkgs = sus.packages.size();
                for (int i = 0; i < numPkgs; i++) {
                    PackageSetting ps2 = sus.packages.valueAt(i);
                    if (ps2.getInstalled(userId)) {
                        if (ps2.pkg.applicationInfo.targetSdkVersion < higherTargetSDK) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
    }

    public int[] getPackageGids(String packageName, int flags, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForPackage(flags, userId, packageName);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getPackageGids");
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null && p.isMatch(flags2)) {
                PackageSetting ps2 = (PackageSetting) p.mExtras;
                if (filterAppAccessLPr(ps2, callingUid, userId)) {
                    return null;
                }
                return ps2.getPermissionsState().computeGids(userId);
            } else if ((4202496 & flags2) == 0 || (ps = this.mSettings.mPackages.get(packageName)) == null || !ps.isMatch(flags2) || filterAppAccessLPr(ps, callingUid, userId)) {
                return null;
            } else {
                return ps.getPermissionsState().computeGids(userId);
            }
        }
    }

    public PermissionInfo getPermissionInfo(String name, String packageName, int flags) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETPERMISSIONINFO);
        return this.mPermissionManager.getPermissionInfo(name, packageName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionInfo> queryPermissionsByGroup(String groupName, int flags) {
        List<PermissionInfo> permissionList = this.mPermissionManager.getPermissionInfoByGroup(groupName, flags, getCallingUid());
        if (permissionList == null) {
            return null;
        }
        return new ParceledListSlice<>(permissionList);
    }

    public PermissionGroupInfo getPermissionGroupInfo(String groupName, int flags) {
        return this.mPermissionManager.getPermissionGroupInfo(groupName, flags, getCallingUid());
    }

    public ParceledListSlice<PermissionGroupInfo> getAllPermissionGroups(int flags) {
        List<PermissionGroupInfo> permissionList = this.mPermissionManager.getAllPermissionGroups(flags, getCallingUid());
        return permissionList == null ? ParceledListSlice.emptyList() : new ParceledListSlice<>(permissionList);
    }

    @GuardedBy({"mPackages"})
    private ApplicationInfo generateApplicationInfoFromSettingsLPw(String packageName, int flags, int filterCallingUid, int userId) {
        PackageSetting ps;
        if (!sUserManager.exists(userId) || (ps = this.mSettings.mPackages.get(packageName)) == null || filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags) || filterAppAccessLPr(ps, filterCallingUid, userId)) {
            return null;
        }
        if (ps.pkg == null) {
            PackageInfo pInfo = generatePackageInfo(ps, flags, userId);
            if (pInfo != null) {
                return pInfo.applicationInfo;
            }
            return null;
        }
        ApplicationInfo ai = PackageParser.generateApplicationInfo(ps.pkg, flags, ps.readUserState(userId), userId);
        if (ai != null) {
            ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
        }
        return ai;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ApplicationInfo getApplicationInfo(String packageName, int flags, int userId) {
        return getApplicationInfoInternal(packageName, flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ApplicationInfo getApplicationInfoInternal(String packageName, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForApplication(flags, userId, packageName);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get application info");
        }
        synchronized (this.mPackages) {
            String packageName2 = resolveInternalPackageNameLPr(packageName, -1);
            PackageParser.Package p = this.mPackages.get(packageName2);
            if (mHwPMSEx.isHwCustHiddenInfoPackage(p)) {
                return null;
            }
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getApplicationInfo " + packageName2 + ": " + p);
            }
            if (p != null) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName2);
                if (ps == null) {
                    return null;
                }
                if (filterSharedLibPackageLPr(ps, filterCallingUid, userId, flags2)) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, userId)) {
                    return null;
                }
                ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags2, ps.readUserState(userId), userId);
                if (ai != null) {
                    ai.packageName = resolveExternalPackageNameLPr(p);
                }
                return ai;
            }
            if (!PLATFORM_PACKAGE_NAME.equals(packageName2)) {
                if (!"system".equals(packageName2)) {
                    if ((4202496 & flags2) == 0) {
                        return null;
                    }
                    return generateApplicationInfoFromSettingsLPw(packageName2, flags2, filterCallingUid, userId);
                }
            }
            return this.mAndroidApplication;
        }
    }

    @GuardedBy({"mPackages"})
    private String normalizePackageNameLPr(String packageName) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        return normalizedPackageName != null ? normalizedPackageName : packageName;
    }

    public void deletePreloadsFileCache() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", "deletePreloadsFileCache");
        File dir = Environment.getDataPreloadsFileCacheDirectory();
        Slog.i(TAG, "Deleting preloaded file cache " + dir);
        FileUtils.deleteContents(dir);
    }

    public void freeStorageAndNotify(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", null);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, observer) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$gaC2olYTl3neR_kQRkLQFmOR9U */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IPackageDataObserver f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$freeStorageAndNotify$3$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorageAndNotify$3$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IPackageDataObserver observer) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted((String) null, success);
            } catch (RemoteException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_CACHE", TAG);
        this.mHandler.post(new Runnable(volumeUuid, freeStorageSize, storageFlags, pi) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$tHiREWkQTFa6JxirXusjITbt91Q */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ long f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ IntentSender f$4;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r5;
                this.f$4 = r6;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$freeStorage$4$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
            }
        });
    }

    public /* synthetic */ void lambda$freeStorage$4$PackageManagerService(String volumeUuid, long freeStorageSize, int storageFlags, IntentSender pi) {
        boolean success = false;
        try {
            freeStorage(volumeUuid, freeStorageSize, storageFlags);
            success = true;
        } catch (IOException e) {
            Slog.w(TAG, e);
        }
        if (pi != null) {
            try {
                pi.sendIntent(null, success ? 1 : 0, null, null, null);
            } catch (IntentSender.SendIntentException e2) {
                Slog.w(TAG, e2);
            }
        }
    }

    public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
        long j;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        File file = storage.findPathForUuid(volumeUuid);
        if (file.getUsableSpace() < bytes) {
            if (ENABLE_FREE_CACHE_V2) {
                boolean internalVolume = Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid);
                boolean aggressive = (storageFlags & 1) != 0;
                long reservedBytes = storage.getStorageCacheBytes(file, storageFlags);
                if (internalVolume && (aggressive || SystemProperties.getBoolean("persist.sys.preloads.file_cache_expired", false))) {
                    deletePreloadsFileCache();
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                if (internalVolume && aggressive) {
                    FileUtils.deleteContents(this.mCacheDir);
                    if (file.getUsableSpace() >= bytes) {
                        return;
                    }
                }
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 256);
                } catch (Installer.InstallerException e) {
                }
                if (file.getUsableSpace() < bytes) {
                    if (internalVolume && pruneUnusedStaticSharedLibraries(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "unused_static_shared_lib_min_cache_period", 7200000))) {
                        return;
                    }
                    if (!internalVolume || !this.mInstantAppRegistry.pruneInstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "installed_instant_app_min_cache_period", UnixCalendar.WEEK_IN_MILLIS))) {
                        try {
                            j = 604800000;
                            try {
                                this.mInstaller.freeCache(volumeUuid, bytes, reservedBytes, 768);
                            } catch (Installer.InstallerException e2) {
                            }
                        } catch (Installer.InstallerException e3) {
                            j = 604800000;
                        }
                        if (file.getUsableSpace() < bytes) {
                            if (internalVolume && this.mInstantAppRegistry.pruneUninstalledInstantApps(bytes, Settings.Global.getLong(this.mContext.getContentResolver(), "uninstalled_instant_app_min_cache_period", j))) {
                                return;
                            }
                        } else {
                            return;
                        }
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            } else {
                try {
                    this.mInstaller.freeCache(volumeUuid, bytes, 0, 0);
                } catch (Installer.InstallerException e4) {
                }
                if (file.getUsableSpace() >= bytes) {
                    return;
                }
            }
            throw new IOException("Failed to free " + bytes + " on storage device at " + file);
        }
    }

    private boolean pruneUnusedStaticSharedLibraries(long neededSpace, long maxCachePeriod) throws IOException {
        Throwable th;
        List<VersionedPackage> packagesToDelete;
        long now;
        int[] allUsers;
        StorageManager storage;
        long now2;
        StorageManager storage2;
        PackageManagerService packageManagerService = this;
        StorageManager storage3 = (StorageManager) packageManagerService.mContext.getSystemService(StorageManager.class);
        File volume = storage3.findPathForUuid(StorageManager.UUID_PRIVATE_INTERNAL);
        long now3 = System.currentTimeMillis();
        synchronized (packageManagerService.mPackages) {
            try {
                int[] allUsers2 = sUserManager.getUserIds();
                int libCount = packageManagerService.mSharedLibraries.size();
                int i = 0;
                packagesToDelete = null;
                while (i < libCount) {
                    try {
                        LongSparseArray<SharedLibraryInfo> versionedLib = packageManagerService.mSharedLibraries.valueAt(i);
                        if (versionedLib != null) {
                            int versionCount = versionedLib.size();
                            int j = 0;
                            while (true) {
                                if (j >= versionCount) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                                if (!libInfo.isStatic()) {
                                    allUsers = allUsers2;
                                    storage = storage3;
                                    now = now3;
                                    break;
                                }
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                String internalPackageName = packageManagerService.resolveInternalPackageNameLPr(declaringPackage.getPackageName(), declaringPackage.getLongVersionCode());
                                PackageSetting ps = packageManagerService.mSettings.getPackageLPr(internalPackageName);
                                if (ps != null) {
                                    storage2 = storage3;
                                    try {
                                        if (now3 - ps.lastUpdateTime < maxCachePeriod) {
                                            now2 = now3;
                                        } else if (ps.pkg.isSystem()) {
                                            now2 = now3;
                                        } else {
                                            if (packagesToDelete == null) {
                                                try {
                                                    packagesToDelete = new ArrayList<>();
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                    while (true) {
                                                        try {
                                                            break;
                                                        } catch (Throwable th3) {
                                                            th = th3;
                                                        }
                                                    }
                                                    throw th;
                                                }
                                            }
                                            now2 = now3;
                                            packagesToDelete.add(new VersionedPackage(internalPackageName, declaringPackage.getLongVersionCode()));
                                        }
                                    } catch (Throwable th4) {
                                        th = th4;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                } else {
                                    storage2 = storage3;
                                    now2 = now3;
                                }
                                j++;
                                packageManagerService = this;
                                storage3 = storage2;
                                allUsers2 = allUsers2;
                                versionedLib = versionedLib;
                                now3 = now2;
                            }
                        } else {
                            allUsers = allUsers2;
                            storage = storage3;
                            now = now3;
                        }
                        i++;
                        packageManagerService = this;
                        storage3 = storage;
                        allUsers2 = allUsers;
                        now3 = now;
                    } catch (Throwable th5) {
                        th = th5;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
            } catch (Throwable th6) {
                th = th6;
                while (true) {
                    break;
                }
                throw th;
            }
        }
        if (packagesToDelete == null) {
            return false;
        }
        int packageCount = packagesToDelete.size();
        for (int i2 = 0; i2 < packageCount; i2++) {
            VersionedPackage pkgToDelete = packagesToDelete.get(i2);
            if (deletePackageX(pkgToDelete.getPackageName(), pkgToDelete.getLongVersionCode(), 0, 2) == 1 && volume.getUsableSpace() >= neededSpace) {
                return true;
            }
        }
        return false;
    }

    private int updateFlags(int flags, int userId) {
        if ((flags & 786432) != 0) {
            return flags;
        }
        if (getUserManagerInternal().isUserUnlockingOrUnlocked(userId)) {
            return flags | 786432;
        }
        return flags | 524288;
    }

    /* access modifiers changed from: package-private */
    public UserManagerInternal getUserManagerInternal() {
        if (this.mUserManagerInternal == null) {
            this.mUserManagerInternal = (UserManagerInternal) LocalServices.getService(UserManagerInternal.class);
        }
        return this.mUserManagerInternal;
    }

    private ActivityManagerInternal getActivityManagerInternal() {
        if (this.mActivityManagerInternal == null) {
            this.mActivityManagerInternal = (ActivityManagerInternal) LocalServices.getService(ActivityManagerInternal.class);
        }
        return this.mActivityManagerInternal;
    }

    private ActivityTaskManagerInternal getActivityTaskManagerInternal() {
        if (this.mActivityTaskManagerInternal == null) {
            this.mActivityTaskManagerInternal = (ActivityTaskManagerInternal) LocalServices.getService(ActivityTaskManagerInternal.class);
        }
        return this.mActivityTaskManagerInternal;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private DeviceIdleController.LocalService getDeviceIdleController() {
        if (this.mDeviceIdleController == null) {
            this.mDeviceIdleController = (DeviceIdleController.LocalService) LocalServices.getService(DeviceIdleController.LocalService.class);
        }
        return this.mDeviceIdleController;
    }

    private StorageManagerInternal getStorageManagerInternal() {
        if (this.mStorageManagerInternal == null) {
            this.mStorageManagerInternal = (StorageManagerInternal) LocalServices.getService(StorageManagerInternal.class);
        }
        return this.mStorageManagerInternal;
    }

    private int updateFlagsForPackage(int flags, int userId, Object cookie) {
        boolean isCallerSystemUser = UserHandle.getCallingUserId() == 0;
        if ((flags & 4194304) != 0) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, !isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId), "MATCH_ANY_USER flag requires INTERACT_ACROSS_USERS permission at " + Debug.getCallers(5));
        } else if ((flags & 8192) != 0 && isCallerSystemUser && sUserManager.hasManagedProfile(0)) {
            flags |= 4194304;
        }
        return updateFlags(flags, userId);
    }

    private int updateFlagsForApplication(int flags, int userId, Object cookie) {
        return updateFlagsForPackage(flags, userId, cookie);
    }

    private int updateFlagsForComponent(int flags, int userId, Object cookie) {
        return updateFlags(flags, userId);
    }

    private Intent updateIntentForResolve(Intent intent) {
        if (intent.getSelector() != null) {
            intent = intent.getSelector();
        }
        if (DEBUG_PREFERRED) {
            intent.addFlags(8);
        }
        return intent;
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, false, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps) {
        return updateFlagsForResolve(flags, userId, intent, callingUid, wantInstantApps, false);
    }

    /* access modifiers changed from: package-private */
    public int updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid, boolean wantInstantApps, boolean onlyExposedExplicitly) {
        int flags2;
        if (this.mSafeMode) {
            flags |= 1048576;
        }
        if (getInstantAppPackageName(callingUid) != null) {
            if (onlyExposedExplicitly) {
                flags |= DumpState.DUMP_APEX;
            }
            flags2 = flags | DumpState.DUMP_SERVICE_PERMISSIONS | 8388608;
        } else {
            boolean allowMatchInstant = true;
            boolean wantMatchInstant = (flags & 8388608) != 0;
            if (!wantInstantApps && (!wantMatchInstant || !canViewInstantApps(callingUid, userId))) {
                allowMatchInstant = false;
            }
            flags2 = flags & -50331649;
            if (!allowMatchInstant) {
                flags2 &= -8388609;
            }
        }
        return updateFlagsForComponent(flags2, userId, intent);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ActivityInfo getActivityInfo(ComponentName component, int flags, int userId) {
        return getActivityInfoInternal(component, flags, Binder.getCallingUid(), userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ActivityInfo getActivityInfoInternal(ComponentName component, int flags, int filterCallingUid, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, component);
        if (!isRecentsAccessingChildProfiles(Binder.getCallingUid(), userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "get activity info");
        }
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getActivityInfo " + component + ": " + a);
            }
            if (a != null && this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
                if (ps == null) {
                    return null;
                }
                if (filterAppAccessLPr(ps, filterCallingUid, component, 1, userId)) {
                    return null;
                }
                return PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
            } else if (!this.mResolveComponentName.equals(component)) {
                return null;
            } else {
                return PackageParser.generateActivityInfo(this.mResolveActivity, flags2, new PackageUserState(), userId);
            }
        }
    }

    private boolean isRecentsAccessingChildProfiles(int callingUid, int targetUserId) {
        if (!getActivityTaskManagerInternal().isCallerRecents(callingUid)) {
            return false;
        }
        long token = Binder.clearCallingIdentity();
        try {
            int callingUserId = UserHandle.getUserId(callingUid);
            if (ActivityManager.getCurrentUser() != callingUserId) {
                return false;
            }
            boolean isSameProfileGroup = sUserManager.isSameProfileGroup(callingUserId, targetUserId);
            Binder.restoreCallingIdentity(token);
            return isSameProfileGroup;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public boolean activitySupportsIntent(ComponentName component, Intent intent, String resolvedType) {
        synchronized (this.mPackages) {
            if (component.equals(this.mResolveComponentName)) {
                return true;
            }
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Activity a = this.mComponentResolver.getActivity(component);
            if (a == null) {
                return false;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return false;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 1, callingUserId)) {
                return false;
            }
            for (int i = 0; i < a.intents.size(); i++) {
                if (((PackageParser.ActivityIntentInfo) a.intents.get(i)).match(intent.getAction(), resolvedType, intent.getScheme(), intent.getData(), intent.getCategories(), TAG) >= 0) {
                    return true;
                }
            }
            return false;
        }
    }

    public ActivityInfo getReceiverInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get receiver info");
        synchronized (this.mPackages) {
            PackageParser.Activity a = this.mComponentResolver.getReceiver(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getReceiverInfo " + component + ": " + a);
            }
            if (a == null || !this.mSettings.isEnabledAndMatchLPr(a.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 2, userId)) {
                return null;
            }
            return PackageParser.generateActivityInfo(a, flags2, ps.readUserState(userId), userId);
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:15:0x0056, code lost:
        if (r30.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES") != 0) goto L_0x005f;
     */
    public ParceledListSlice<SharedLibraryInfo> getSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        ArrayList arrayList;
        if (!sUserManager.exists(userId)) {
            return null;
        }
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int flags2 = updateFlagsForPackage(flags, userId, null);
        int checkCallingOrSelfPermission = this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES");
        boolean canSeeStaticLibraries = false;
        int i = DumpState.DUMP_HANDLE;
        if (checkCallingOrSelfPermission != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_PACKAGES") != 0) {
                if (!canRequestPackageInstallsInternal(packageName, DumpState.DUMP_HANDLE, userId, false)) {
                    if (this.mContext.checkCallingOrSelfPermission("android.permission.REQUEST_DELETE_PACKAGES") != 0) {
                    }
                }
            }
        }
        canSeeStaticLibraries = true;
        synchronized (this.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libCount = this.mSharedLibraries.size();
            int i2 = 0;
            while (i2 < libCount) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i2);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libInfo = versionedLib.valueAt(j);
                        if (!canSeeStaticLibraries && libInfo.isStatic()) {
                            break;
                        }
                        long identity = Binder.clearCallingIdentity();
                        try {
                            if (getPackageInfoVersioned(libInfo.getDeclaringPackage(), flags2 | i, userId) != null) {
                                Binder.restoreCallingIdentity(identity);
                                String path = libInfo.getPath();
                                String packageName2 = libInfo.getPackageName();
                                List allCodePaths = libInfo.getAllCodePaths();
                                String name = libInfo.getName();
                                long longVersion = libInfo.getLongVersion();
                                int type = libInfo.getType();
                                VersionedPackage declaringPackage = libInfo.getDeclaringPackage();
                                List<VersionedPackage> packagesUsingSharedLibraryLPr = getPackagesUsingSharedLibraryLPr(libInfo, flags2, userId);
                                if (libInfo.getDependencies() == null) {
                                    arrayList = null;
                                } else {
                                    arrayList = new ArrayList(libInfo.getDependencies());
                                }
                                SharedLibraryInfo resLibInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage, packagesUsingSharedLibraryLPr, arrayList);
                                if (result2 == null) {
                                    result2 = new ArrayList<>();
                                }
                                result2.add(resLibInfo);
                            }
                            j++;
                            i = DumpState.DUMP_HANDLE;
                        } finally {
                            Binder.restoreCallingIdentity(identity);
                        }
                    }
                    result = result2;
                }
                i2++;
                i = DumpState.DUMP_HANDLE;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    public ParceledListSlice<SharedLibraryInfo> getDeclaredSharedLibraries(String packageName, int flags, int userId) {
        ParceledListSlice<SharedLibraryInfo> parceledListSlice;
        PackageManagerService packageManagerService = this;
        packageManagerService.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_SHARED_LIBRARIES", "getDeclaredSharedLibraries");
        int callingUid = Binder.getCallingUid();
        packageManagerService.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "getDeclaredSharedLibraries");
        Preconditions.checkNotNull(packageName, "packageName cannot be null");
        Preconditions.checkArgumentNonnegative(userId, "userId must be >= 0");
        ArrayList arrayList = null;
        if (!sUserManager.exists(userId) || packageManagerService.getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        synchronized (packageManagerService.mPackages) {
            List<SharedLibraryInfo> result = null;
            int libraryCount = packageManagerService.mSharedLibraries.size();
            int i = 0;
            while (i < libraryCount) {
                LongSparseArray<SharedLibraryInfo> versionedLibrary = packageManagerService.mSharedLibraries.valueAt(i);
                if (versionedLibrary != null) {
                    int versionCount = versionedLibrary.size();
                    int j = 0;
                    List<SharedLibraryInfo> result2 = result;
                    while (j < versionCount) {
                        SharedLibraryInfo libraryInfo = versionedLibrary.valueAt(j);
                        VersionedPackage declaringPackage = libraryInfo.getDeclaringPackage();
                        if (Objects.equals(declaringPackage.getPackageName(), packageName)) {
                            long identity = Binder.clearCallingIdentity();
                            try {
                                if (packageManagerService.getPackageInfoVersioned(declaringPackage, 67108864 | flags, userId) != null) {
                                    Binder.restoreCallingIdentity(identity);
                                    String path = libraryInfo.getPath();
                                    String packageName2 = libraryInfo.getPackageName();
                                    List allCodePaths = libraryInfo.getAllCodePaths();
                                    String name = libraryInfo.getName();
                                    long longVersion = libraryInfo.getLongVersion();
                                    int type = libraryInfo.getType();
                                    VersionedPackage declaringPackage2 = libraryInfo.getDeclaringPackage();
                                    List<VersionedPackage> packagesUsingSharedLibraryLPr = packageManagerService.getPackagesUsingSharedLibraryLPr(libraryInfo, flags, userId);
                                    if (libraryInfo.getDependencies() != null) {
                                        arrayList = new ArrayList(libraryInfo.getDependencies());
                                    }
                                    SharedLibraryInfo resultLibraryInfo = new SharedLibraryInfo(path, packageName2, allCodePaths, name, longVersion, type, declaringPackage2, packagesUsingSharedLibraryLPr, arrayList);
                                    if (result2 == null) {
                                        result2 = new ArrayList<>();
                                    }
                                    result2.add(resultLibraryInfo);
                                }
                            } finally {
                                Binder.restoreCallingIdentity(identity);
                            }
                        }
                        j++;
                        arrayList = null;
                        packageManagerService = this;
                    }
                    result = result2;
                }
                i++;
                arrayList = null;
                packageManagerService = this;
            }
            parceledListSlice = result != null ? new ParceledListSlice<>(result) : null;
        }
        return parceledListSlice;
    }

    @GuardedBy({"mPackages"})
    private List<VersionedPackage> getPackagesUsingSharedLibraryLPr(SharedLibraryInfo libInfo, int flags, int userId) {
        List<VersionedPackage> versionedPackages = null;
        int packageCount = this.mSettings.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            PackageSetting ps = this.mSettings.mPackages.valueAt(i);
            if (ps != null && ps.readUserState(userId).isAvailable(flags)) {
                String libName = libInfo.getName();
                if (libInfo.isStatic()) {
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0 && ps.usesStaticLibrariesVersions[libIdx] == libInfo.getLongVersion()) {
                        if (versionedPackages == null) {
                            versionedPackages = new ArrayList<>();
                        }
                        String dependentPackageName = ps.name;
                        if (ps.pkg != null && ps.pkg.applicationInfo.isStaticSharedLibrary()) {
                            dependentPackageName = ps.pkg.manifestPackageName;
                        }
                        versionedPackages.add(new VersionedPackage(dependentPackageName, ps.versionCode));
                    }
                } else if (ps.pkg != null && (ArrayUtils.contains(ps.pkg.usesLibraries, libName) || ArrayUtils.contains(ps.pkg.usesOptionalLibraries, libName))) {
                    if (versionedPackages == null) {
                        versionedPackages = new ArrayList<>();
                    }
                    versionedPackages.add(new VersionedPackage(ps.name, ps.versionCode));
                }
            }
        }
        return versionedPackages;
    }

    public ServiceInfo getServiceInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get service info");
        synchronized (this.mPackages) {
            PackageParser.Service s = this.mComponentResolver.getService(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getServiceInfo " + component + ": " + s);
            }
            if (s == null || !this.mSettings.isEnabledAndMatchLPr(s.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 3, userId)) {
                return null;
            }
            return PackageParser.generateServiceInfo(s, flags2, ps.readUserState(userId), userId);
        }
    }

    public ProviderInfo getProviderInfo(ComponentName component, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        int flags2 = updateFlagsForComponent(flags, userId, component);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get provider info");
        synchronized (this.mPackages) {
            PackageParser.Provider p = this.mComponentResolver.getProvider(component);
            if (DEBUG_PACKAGE_INFO) {
                Log.v(TAG, "getProviderInfo " + component + ": " + p);
            }
            if (p == null || !this.mSettings.isEnabledAndMatchLPr(p.info, flags2, userId)) {
                return null;
            }
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 4, userId)) {
                return null;
            }
            return PackageParser.generateProviderInfo(p, flags2, ps.readUserState(userId), userId);
        }
    }

    public ModuleInfo getModuleInfo(String packageName, int flags) {
        return this.mModuleInfoProvider.getModuleInfo(packageName, flags);
    }

    public List<ModuleInfo> getInstalledModules(int flags) {
        return this.mModuleInfoProvider.getInstalledModules(flags);
    }

    public String[] getSystemSharedLibraryNames() {
        synchronized (this.mPackages) {
            Set<String> libs = null;
            int libCount = this.mSharedLibraries.size();
            for (int i = 0; i < libCount; i++) {
                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.valueAt(i);
                if (versionedLib != null) {
                    int versionCount = versionedLib.size();
                    int j = 0;
                    while (true) {
                        if (j >= versionCount) {
                            break;
                        }
                        SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                        if (!libraryInfo.isStatic()) {
                            if (libs == null) {
                                libs = new ArraySet<>();
                            }
                            libs.add(libraryInfo.getName());
                        } else {
                            PackageSetting ps = this.mSettings.getPackageLPr(libraryInfo.getPackageName());
                            if (ps == null || filterSharedLibPackageLPr(ps, Binder.getCallingUid(), UserHandle.getUserId(Binder.getCallingUid()), DumpState.DUMP_HANDLE)) {
                                j++;
                            } else {
                                if (libs == null) {
                                    libs = new ArraySet<>();
                                }
                                libs.add(libraryInfo.getName());
                            }
                        }
                    }
                }
            }
            if (libs == null) {
                return null;
            }
            String[] libsArray = new String[libs.size()];
            libs.toArray(libsArray);
            return libsArray;
        }
    }

    public String getServicesSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mServicesSystemSharedLibraryPackageName;
        }
        return str;
    }

    public String getSharedSystemSharedLibraryPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mSharedSystemSharedLibraryPackageName;
        }
        return str;
    }

    @GuardedBy({"mPackages"})
    private void updateSequenceNumberLP(PackageSetting pkgSetting, int[] userList) {
        if (userList == null || userList.length == 0) {
            Slog.i(TAG, "updateSequenceNumberLP fail, userList is null or length = 0");
            return;
        }
        for (int i = userList.length - 1; i >= 0; i--) {
            int userId = userList[i];
            if (!pkgSetting.getInstantApp(userId)) {
                SparseArray<String> changedPackages = this.mChangedPackages.get(userId);
                if (changedPackages == null) {
                    changedPackages = new SparseArray<>();
                    this.mChangedPackages.put(userId, changedPackages);
                }
                Map<String, Integer> sequenceNumbers = this.mChangedPackagesSequenceNumbers.get(userId);
                if (sequenceNumbers == null) {
                    sequenceNumbers = new HashMap();
                    this.mChangedPackagesSequenceNumbers.put(userId, sequenceNumbers);
                }
                Integer sequenceNumber = sequenceNumbers.get(pkgSetting.name);
                if (sequenceNumber != null) {
                    changedPackages.remove(sequenceNumber.intValue());
                }
                changedPackages.put(this.mChangedPackagesSequenceNumber, pkgSetting.name);
                sequenceNumbers.put(pkgSetting.name, Integer.valueOf(this.mChangedPackagesSequenceNumber));
            }
        }
        this.mChangedPackagesSequenceNumber++;
    }

    public ChangedPackages getChangedPackages(int sequenceNumber, int userId) {
        ChangedPackages changedPackages = null;
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            if (sequenceNumber >= this.mChangedPackagesSequenceNumber) {
                return null;
            }
            SparseArray<String> changedPackages2 = this.mChangedPackages.get(userId);
            if (changedPackages2 == null) {
                return null;
            }
            List<String> packageNames = new ArrayList<>(this.mChangedPackagesSequenceNumber - sequenceNumber);
            for (int i = sequenceNumber; i < this.mChangedPackagesSequenceNumber; i++) {
                String packageName = changedPackages2.get(i);
                if (packageName != null) {
                    packageNames.add(packageName);
                }
            }
            if (!packageNames.isEmpty()) {
                changedPackages = new ChangedPackages(this.mChangedPackagesSequenceNumber, packageNames);
            }
            return changedPackages;
        }
    }

    public ParceledListSlice<FeatureInfo> getSystemAvailableFeatures() {
        ArrayList<FeatureInfo> res;
        synchronized (this.mAvailableFeatures) {
            res = new ArrayList<>(this.mAvailableFeatures.size() + 1);
            res.addAll(this.mAvailableFeatures.values());
        }
        FeatureInfo fi = new FeatureInfo();
        fi.reqGlEsVersion = SystemProperties.getInt("ro.opengles.version", 0);
        res.add(fi);
        return new ParceledListSlice<>(res);
    }

    public boolean hasSystemFeature(String name, int version) {
        boolean z = false;
        if (HwPackageManagerServiceUtils.isUnsupportedFeatrue(name)) {
            return false;
        }
        synchronized (this.mAvailableFeatures) {
            FeatureInfo feat = this.mAvailableFeatures.get(name);
            if (feat == null) {
                return false;
            }
            if (feat.version >= version) {
                z = true;
            }
            return z;
        }
    }

    public int checkPermission(String permName, String pkgName, int userId) {
        synchronized (this.mPackages) {
            if (this.mCheckPermissionDelegate == null) {
                return checkPermissionImpl(permName, pkgName, userId);
            }
            return this.mCheckPermissionDelegate.checkPermission(permName, pkgName, userId, new TriFunction() {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$b2Z8hEDt0dbtmX9ytdWFgSa9tc */

                public final Object apply(Object obj, Object obj2, Object obj3) {
                    return Integer.valueOf(PackageManagerService.this.checkPermissionImpl((String) obj, (String) obj2, ((Integer) obj3).intValue()));
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public int checkPermissionImpl(String permName, String pkgName, int userId) {
        return this.mPermissionManager.checkPermission(permName, pkgName, getCallingUid(), userId);
    }

    public int checkUidPermission(String permName, int uid) {
        synchronized (this.mPackages) {
            if (UserHandle.isDuid(uid)) {
                return HwFrameworkSecurityPartsFactory.getInstance().getDPermissionManager().checkDPermission(uid, permName);
            } else if (this.mCheckPermissionDelegate == null) {
                return checkUidPermissionImpl(permName, uid);
            } else {
                return this.mCheckPermissionDelegate.checkUidPermission(permName, uid, new BiFunction() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$XJQWfaGM1EYfvHM2L3JN55XapIQ */

                    @Override // java.util.function.BiFunction
                    public final Object apply(Object obj, Object obj2) {
                        return Integer.valueOf(PackageManagerService.this.checkUidPermissionImpl((String) obj, ((Integer) obj2).intValue()));
                    }
                });
            }
        }
    }

    /* access modifiers changed from: private */
    public int checkUidPermissionImpl(String permName, int uid) {
        int checkUidPermission;
        synchronized (this.mPackages) {
            String[] packageNames = getPackagesForUid(uid);
            PackageParser.Package pkg = null;
            int N = packageNames == null ? 0 : packageNames.length;
            int i = 0;
            while (pkg == null && i < N) {
                pkg = this.mPackages.get(packageNames[i]);
                i++;
            }
            checkUidPermission = this.mPermissionManager.checkUidPermission(permName, pkg, uid, getCallingUid());
        }
        return checkUidPermission;
    }

    public boolean isPermissionRevokedByPolicy(String permission, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "isPermissionRevokedByPolicy for user " + userId);
        }
        boolean z = false;
        if (checkPermission(permission, packageName, userId) == 0) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            if (!isCallerSameApp(packageName, callingUid)) {
                return false;
            }
        } else if (isInstantApp(packageName, userId)) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            if ((getPermissionFlags(permission, packageName, userId) & 4) != 0) {
                z = true;
            }
            return z;
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public String getPermissionControllerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredPermissionControllerPackage;
        }
        return str;
    }

    /* access modifiers changed from: package-private */
    public String getPackageInstallerPackageName() {
        String str;
        synchronized (this.mPackages) {
            str = this.mRequiredInstallerPackage;
        }
        return str;
    }

    private boolean addDynamicPermission(PermissionInfo info, final boolean async) {
        return this.mPermissionManager.addDynamicPermission(info, async, getCallingUid(), new PermissionManagerServiceInternal.PermissionCallback() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass3 */

            @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
            public void onPermissionChanged() {
                if (!async) {
                    PackageManagerService.this.mSettings.writeLPr();
                } else {
                    PackageManagerService.this.scheduleWriteSettingsLocked();
                }
            }
        });
    }

    public boolean addPermission(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, false);
        }
        return addDynamicPermission;
    }

    public boolean addPermissionAsync(PermissionInfo info) {
        boolean addDynamicPermission;
        synchronized (this.mPackages) {
            addDynamicPermission = addDynamicPermission(info, true);
        }
        return addDynamicPermission;
    }

    public void removePermission(String permName) {
        this.mPermissionManager.removeDynamicPermission(permName, getCallingUid(), this.mPermissionCallback);
    }

    public void grantRuntimePermission(String packageName, String permName, int userId) {
        if (!isUpgradeAndEmuiVersionUpgrade() || !mHwPMSEx.getRenamedPackagePolicyByOriginalName(packageName).isPresent()) {
            this.mPermissionManager.grantRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, getCallingUid(), userId, this.mPermissionCallback);
            long start = HwPackageManagerServiceUtils.hwTimingsBeginWithTag(TAG, "notifyUidPermissionChanged for " + packageName);
            HwFrameworkSecurityPartsFactory.getInstance().getDPermissionManager().notifyUidPermissionChanged(getPackageUid(packageName, 0, userId));
            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "notifyUidPermissionChanged for " + packageName, start);
            return;
        }
        Slog.i(TAG, "PACKAGE_NAME_CHANGE " + packageName + ", do not grant runtime permissions");
    }

    public void revokeRuntimePermission(String packageName, String permName, int userId) {
        this.mPermissionManager.revokeRuntimePermission(permName, packageName, checkUidPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", Binder.getCallingUid()) == 0, userId, this.mPermissionCallback);
    }

    public void resetRuntimePermissions() {
        this.mContext.enforceCallingOrSelfPermission("android.permission.REVOKE_RUNTIME_PERMISSIONS", "revokeRuntimePermission");
        int callingUid = Binder.getCallingUid();
        if (!(callingUid == 1000 || callingUid == 0)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "resetRuntimePermissions");
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            int[] userIds = UserManagerService.getInstance().getUserIds();
            for (int userId : userIds) {
                int packageCount = this.mPackages.size();
                for (int i = 0; i < packageCount; i++) {
                    PackageParser.Package pkg = this.mPackages.valueAt(i);
                    if (pkg.mExtras instanceof PackageSetting) {
                        resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
                    }
                }
            }
        }
    }

    public int getPermissionFlags(String permName, String packageName, int userId) {
        return this.mPermissionManager.getPermissionFlags(permName, packageName, getCallingUid(), userId);
    }

    public void updatePermissionFlags(String permName, String packageName, int flagMask, int flagValues, boolean checkAdjustPolicyFlagPermission, int userId) {
        boolean overridePolicy;
        int callingUid = getCallingUid();
        boolean overridePolicy2 = false;
        if (callingUid == 1000 || callingUid == 0) {
            overridePolicy = false;
        } else {
            long callingIdentity = Binder.clearCallingIdentity();
            if ((flagMask & 4) != 0) {
                if (checkAdjustPolicyFlagPermission) {
                    try {
                        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "Need android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY to change policy flags");
                    } catch (Throwable th) {
                        Binder.restoreCallingIdentity(callingIdentity);
                        throw th;
                    }
                } else if (!hasTargetSdkInUidLowerThan(callingUid, 29)) {
                    throw new IllegalArgumentException("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY needs  to be checked for packages targeting 29 or later when changing policy flags");
                }
                overridePolicy2 = true;
            }
            Binder.restoreCallingIdentity(callingIdentity);
            overridePolicy = overridePolicy2;
        }
        this.mPermissionManager.updatePermissionFlags(permName, packageName, flagMask, flagValues, callingUid, userId, overridePolicy, this.mPermissionCallback);
        mHwPMSEx.fixMdmRuntimePermission(packageName, permName, flagValues);
    }

    public void updatePermissionFlagsForAllApps(int flagMask, int flagValues, int userId) {
        synchronized (this.mPackages) {
            if (this.mPermissionManager.updatePermissionFlagsForAllApps(flagMask, flagValues, getCallingUid(), userId, this.mPackages.values(), this.mPermissionCallback)) {
                this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
            }
        }
    }

    public List<String> getWhitelistedRestrictedPermissions(String packageName, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlags, 7);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "getWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return null;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerInstallerOnRecord = false;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            if (installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid())) {
                isCallerInstallerOnRecord = true;
            }
            if ((whitelistFlags & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Querying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlags & 6) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Querying upgrade or installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return null;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                return this.mPermissionManager.getWhitelistedRestrictedPermissions(pkg, whitelistFlags, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public boolean addWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        Preconditions.checkNotNull(permission);
        if (!checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission)) {
            return false;
        }
        List<String> permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId);
        if (permissions == null) {
            permissions = new ArrayList(1);
        }
        if (permissions.indexOf(permission) >= 0) {
            return false;
        }
        permissions.add(permission);
        return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
    }

    private boolean checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(String permission) {
        synchronized (this.mPackages) {
            BasePermission bp = this.mPermissionManager.getPermissionTEMP(permission);
            if (bp == null) {
                Slog.w(TAG, "No such permissions: " + permission);
                return false;
            }
            if (bp.isHardOrSoftRestricted() && bp.isImmutablyRestricted()) {
                if (this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") != 0) {
                    throw new SecurityException("Cannot modify whitelisting of an immutably restricted permission: " + permission);
                }
            }
            return true;
        }
    }

    public boolean removeWhitelistedRestrictedPermission(String packageName, String permission, int whitelistFlags, int userId) {
        List<String> permissions;
        Preconditions.checkNotNull(permission);
        if (checkExistsAndEnforceCannotModifyImmutablyRestrictedPermission(permission) && (permissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlags, userId)) != null && permissions.remove(permission)) {
            return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlags, userId);
        }
        return false;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean setWhitelistedRestrictedPermissionsInner(String packageName, List<String> permissions, int whitelistFlag, int userId) {
        return setWhitelistedRestrictedPermissions(packageName, permissions, whitelistFlag, userId);
    }

    private boolean setWhitelistedRestrictedPermissions(String packageName, List<String> permissions, int whitelistFlag, int userId) {
        Preconditions.checkNotNull(packageName);
        Preconditions.checkFlagsArgument(whitelistFlag, 7);
        Preconditions.checkArgument(Integer.bitCount(whitelistFlag) == 1);
        Preconditions.checkArgumentNonNegative((float) userId, (String) null);
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS", "setWhitelistedRestrictedPermissions for user " + userId);
        }
        synchronized (this.mPackages) {
            PackageSetting packageSetting = this.mSettings.mPackages.get(packageName);
            if (packageSetting == null) {
                Slog.w(TAG, "Unknown package: " + packageName);
                return false;
            }
            PackageParser.Package pkg = packageSetting.pkg;
            boolean isCallerPrivileged = this.mContext.checkCallingOrSelfPermission("android.permission.WHITELIST_RESTRICTED_PERMISSIONS") == 0;
            PackageSetting installerPackageSetting = this.mSettings.mPackages.get(packageSetting.installerPackageName);
            boolean isCallerInstallerOnRecord = installerPackageSetting != null && UserHandle.isSameApp(installerPackageSetting.appId, Binder.getCallingUid());
            if ((whitelistFlag & 1) != 0) {
                if (!isCallerPrivileged) {
                    throw new SecurityException("Modifying system whitelist requires android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if ((whitelistFlag & 4) != 0) {
                if (!isCallerPrivileged) {
                    if (!isCallerInstallerOnRecord) {
                        throw new SecurityException("Modifying upgrade whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                    }
                }
                List<String> whitelistedPermissions = getWhitelistedRestrictedPermissions(packageName, whitelistFlag, userId);
                if (permissions != null) {
                    if (!permissions.isEmpty()) {
                        int permissionCount = permissions.size();
                        for (int i = 0; i < permissionCount; i++) {
                            if ((whitelistedPermissions == null || !whitelistedPermissions.contains(permissions.get(i))) && !isCallerPrivileged) {
                                throw new SecurityException("Adding to upgrade whitelist requiresandroid.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                            }
                        }
                    }
                }
                if (whitelistedPermissions == null || whitelistedPermissions.isEmpty()) {
                    return true;
                }
            }
            if ((whitelistFlag & 2) != 0 && !isCallerPrivileged) {
                if (!isCallerInstallerOnRecord) {
                    throw new SecurityException("Modifying installer whitelist requires being installer on record or android.permission.WHITELIST_RESTRICTED_PERMISSIONS");
                }
            }
            if (filterAppAccessLPr(packageSetting, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            long identity = Binder.clearCallingIdentity();
            try {
                this.mPermissionManager.setWhitelistedRestrictedPermissions(pkg, new int[]{userId}, permissions, Process.myUid(), whitelistFlag, this.mPermissionCallback);
                return true;
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* JADX INFO: finally extract failed */
    public boolean shouldShowRequestPermissionRationale(String permissionName, String packageName, int userId) {
        if (UserHandle.getCallingUserId() != userId) {
            Context context = this.mContext;
            context.enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "canShowRequestPermissionRationale for user " + userId);
        }
        if (UserHandle.getAppId(getCallingUid()) != UserHandle.getAppId(getPackageUid(packageName, 268435456, userId)) || checkPermission(permissionName, packageName, userId) == 0) {
            return false;
        }
        long identity = Binder.clearCallingIdentity();
        try {
            int flags = getPermissionFlags(permissionName, packageName, userId);
            Binder.restoreCallingIdentity(identity);
            if ((flags & 22) == 0 && (flags & 1) != 0) {
                return true;
            }
            return false;
        } catch (Throwable th) {
            Binder.restoreCallingIdentity(identity);
            throw th;
        }
    }

    public void addOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS", "addOnPermissionsChangeListener");
        synchronized (this.mPackages) {
            this.mOnPermissionChangeListeners.addListenerLocked(listener);
        }
    }

    public void removeOnPermissionsChangeListener(IOnPermissionsChangeListener listener) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            synchronized (this.mPackages) {
                this.mOnPermissionChangeListeners.removeListenerLocked(listener);
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    public boolean isProtectedBroadcast(String actionName) {
        synchronized (this.mProtectedBroadcasts) {
            if (this.mProtectedBroadcasts.contains(actionName)) {
                return true;
            }
            if (actionName == null || (!actionName.startsWith("android.net.netmon.lingerExpired") && !actionName.startsWith("com.android.server.sip.SipWakeupTimer") && !actionName.startsWith("com.android.internal.telephony.data-reconnect") && !actionName.startsWith("android.net.netmon.launchCaptivePortalApp"))) {
                return false;
            }
            return true;
        }
    }

    public int checkSignatures(String pkg1, String pkg2) {
        synchronized (this.mPackages) {
            PackageParser.Package p1 = this.mPackages.get(pkg1);
            PackageParser.Package p2 = this.mPackages.get(pkg2);
            if (!(p1 == null || p1.mExtras == null || p2 == null)) {
                if (p2.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    int callingUserId = UserHandle.getUserId(callingUid);
                    PackageSetting ps2 = (PackageSetting) p2.mExtras;
                    if (!filterAppAccessLPr((PackageSetting) p1.mExtras, callingUid, callingUserId)) {
                        if (!filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                            return PackageManagerServiceUtils.compareSignatures(p1.mSigningDetails.signatures, p2.mSigningDetails.signatures);
                        }
                    }
                    return -4;
                }
            }
            return -4;
        }
    }

    public int checkUidSignatures(int uid1, int uid2) {
        Signature[] s1;
        Signature[] s2;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int appId1 = UserHandle.getAppId(uid1);
        int appId2 = UserHandle.getAppId(uid2);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId1);
            if (obj == null) {
                return -4;
            }
            if (obj instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s1 = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
            } else if (!(obj instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return -4;
                }
                s1 = ps.signatures.mSigningDetails.signatures;
            }
            Object obj2 = this.mSettings.getSettingLPr(appId2);
            if (obj2 == null) {
                return -4;
            }
            if (obj2 instanceof SharedUserSetting) {
                if (isCallerInstantApp) {
                    return -4;
                }
                s2 = ((SharedUserSetting) obj2).signatures.mSigningDetails.signatures;
            } else if (!(obj2 instanceof PackageSetting)) {
                return -4;
            } else {
                PackageSetting ps2 = (PackageSetting) obj2;
                if (filterAppAccessLPr(ps2, callingUid, callingUserId)) {
                    return -4;
                }
                s2 = ps2.signatures.mSigningDetails.signatures;
            }
            return PackageManagerServiceUtils.compareSignatures(s1, s2);
        }
    }

    public boolean hasSigningCertificate(String packageName, byte[] certificate, int type) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p != null) {
                if (p.mExtras != null) {
                    int callingUid = Binder.getCallingUid();
                    if (filterAppAccessLPr((PackageSetting) p.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                        return false;
                    }
                    if (type == 0) {
                        return p.mSigningDetails.hasCertificate(certificate);
                    } else if (type != 1) {
                        return false;
                    } else {
                        return p.mSigningDetails.hasSha256Certificate(certificate);
                    }
                }
            }
            return false;
        }
    }

    public boolean hasUidSigningCertificate(int uid, byte[] certificate, int type) {
        PackageParser.SigningDetails signingDetails;
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj == null) {
                return false;
            }
            if (obj instanceof SharedUserSetting) {
                if (getInstantAppPackageName(callingUid) != null) {
                    return false;
                }
                signingDetails = ((SharedUserSetting) obj).signatures.mSigningDetails;
            } else if (!(obj instanceof PackageSetting)) {
                return false;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, callingUserId)) {
                    return false;
                }
                signingDetails = ps.signatures.mSigningDetails;
            }
            if (type == 0) {
                return signingDetails.hasCertificate(certificate);
            } else if (type != 1) {
                return false;
            } else {
                return signingDetails.hasSha256Certificate(certificate);
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void killUid(int appId, int userId, String reason) {
        long identity = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killUid(appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private boolean isCompatSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isCompatSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isCompatSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 2;
    }

    private boolean isRecoverSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        return isRecoverSignatureUpdateNeeded(getSettingsVersionForPackage(scannedPkg));
    }

    private static boolean isRecoverSignatureUpdateNeeded(Settings.VersionInfo ver) {
        return ver.databaseVersion < 3;
    }

    public List<String> getAllPackages() {
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            if (canViewInstantApps(callingUid, callingUserId)) {
                return new ArrayList(this.mPackages.keySet());
            }
            String instantAppPkgName = getInstantAppPackageName(callingUid);
            List<String> result = new ArrayList<>();
            if (instantAppPkgName != null) {
                for (PackageParser.Package pkg : this.mPackages.values()) {
                    if (pkg.visibleToInstantApps) {
                        result.add(pkg.packageName);
                    }
                }
            } else {
                for (PackageParser.Package pkg2 : this.mPackages.values()) {
                    PackageSetting ps = pkg2.mExtras != null ? (PackageSetting) pkg2.mExtras : null;
                    if (ps == null || !ps.getInstantApp(callingUserId) || this.mInstantAppRegistry.isInstantAccessGranted(callingUserId, UserHandle.getAppId(callingUid), ps.appId)) {
                        result.add(pkg2.packageName);
                    }
                }
            }
            return result;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public String[] getPackagesForUid(int uid) {
        return getPackagesForUid_debug(uid, false);
    }

    private String[] getPackagesForUid_debug(int uid, boolean debug) {
        SharedUserSetting sus;
        int callingUid = Binder.getCallingUid();
        int i = 0;
        boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
        int userId = UserHandle.getUserId(uid);
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            try {
                Object obj = this.mSettings.getSettingLPr(appId);
                if (!(obj instanceof SharedUserSetting)) {
                    if (obj instanceof PackageSetting) {
                        PackageSetting ps = (PackageSetting) obj;
                        if (ps.getInstalled(userId) && !filterAppAccessLPr(ps, callingUid, userId)) {
                            return new String[]{ps.name};
                        }
                    }
                    return null;
                } else if (isCallerInstantApp) {
                    return null;
                } else {
                    SharedUserSetting sus2 = (SharedUserSetting) obj;
                    String[] res = new String[sus2.packages.size()];
                    Iterator<PackageSetting> it = sus2.packages.iterator();
                    while (it.hasNext()) {
                        PackageSetting ps2 = it.next();
                        if (debug) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Check shared package; installed? ");
                            sb.append(ps2.getInstalled(userId));
                            sb.append(", shared setting: ");
                            sb.append(ps2);
                            sb.append(", package setting: ");
                            sus = sus2;
                            sb.append(this.mSettings.mPackages.get(ps2.name));
                            Slog.e(TAG, sb.toString());
                        } else {
                            sus = sus2;
                        }
                        if (this.mIsUpgrade) {
                            PackageSetting psNow = this.mSettings.mPackages.get(ps2.name);
                            if (psNow != null && psNow.appId != ps2.appId) {
                                res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                                StringBuilder sbWarn = new StringBuilder();
                                sbWarn.append("getPackagesForUid ");
                                sbWarn.append(uid);
                                sbWarn.append(" warning, found package ");
                                sbWarn.append(ps2.name);
                                sbWarn.append(" was user id ");
                                sbWarn.append(ps2.appId);
                                sbWarn.append(", but mismatch ");
                                sbWarn.append(psNow.appId);
                                sbWarn.append(" now!");
                                Slog.w(TAG, sbWarn.toString());
                                sus2 = sus;
                            }
                        }
                        if (ps2.getInstalled(userId)) {
                            res[i] = ps2.name;
                            i++;
                        } else {
                            res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                        }
                        sus2 = sus;
                    }
                    return res;
                }
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    public String getNameForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                SharedUserSetting sus = (SharedUserSetting) obj;
                return sus.name + ":" + sus.userId;
            } else if (!(obj instanceof PackageSetting)) {
                return null;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return null;
                }
                return ps.name;
            }
        }
    }

    public String[] getNamesForUids(int[] uids) {
        if (uids == null || uids.length == 0) {
            return null;
        }
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return null;
        }
        String[] names = new String[uids.length];
        synchronized (this.mPackages) {
            for (int i = uids.length - 1; i >= 0; i--) {
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uids[i]));
                if (obj instanceof SharedUserSetting) {
                    names[i] = "shared:" + ((SharedUserSetting) obj).name;
                } else if (obj instanceof PackageSetting) {
                    PackageSetting ps = (PackageSetting) obj;
                    if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                        names[i] = null;
                    } else {
                        names[i] = ps.name;
                    }
                } else {
                    names[i] = null;
                }
            }
        }
        return names;
    }

    public int getUidForSharedUser(String sharedUserName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || sharedUserName == null) {
            return -1;
        }
        synchronized (this.mPackages) {
            try {
                SharedUserSetting suid = this.mSettings.getSharedUserLPw(sharedUserName, 0, 0, false);
                if (suid == null) {
                    return -1;
                }
                return suid.userId;
            } catch (PackageManagerException e) {
            } catch (Throwable th) {
                throw th;
            }
        }
    }

    public int getFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgFlags;
            }
        }
    }

    public int getPrivateFlagsForUid(int uid) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                return ((SharedUserSetting) obj).pkgPrivateFlags;
            } else if (!(obj instanceof PackageSetting)) {
                return 0;
            } else {
                PackageSetting ps = (PackageSetting) obj;
                if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return 0;
                }
                return ps.pkgPrivateFlags;
            }
        }
    }

    public boolean isUidPrivileged(int uid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        int appId = UserHandle.getAppId(uid);
        synchronized (this.mPackages) {
            Object obj = this.mSettings.getSettingLPr(appId);
            if (obj instanceof SharedUserSetting) {
                Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
                while (it.hasNext()) {
                    if (it.next().isPrivileged()) {
                        return true;
                    }
                }
            } else if (obj instanceof PackageSetting) {
                return ((PackageSetting) obj).isPrivileged();
            }
            return false;
        }
    }

    public String[] getAppOpPermissionPackages(String permName) {
        return this.mPermissionManager.getAppOpPermissionPackages(permName);
    }

    public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) {
        return resolveIntentInternal(intent, resolvedType, flags, userId, false, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ResolveInfo resolveIntentInternal(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
        Throwable th;
        try {
            Trace.traceBegin(262144, "resolveIntent");
            if (!sUserManager.exists(userId)) {
                Trace.traceEnd(262144);
                return null;
            }
            int callingUid = Binder.getCallingUid();
            int flags2 = updateFlagsForResolve(flags, userId, intent, filterCallingUid, resolveForStart);
            try {
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "resolve intent");
                Trace.traceBegin(262144, "queryIntentActivities");
                List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags2, filterCallingUid, userId, resolveForStart, true);
                Trace.traceEnd(262144);
                ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags2, query, userId);
                Trace.traceEnd(262144);
                return bestChoice;
            } catch (Throwable th2) {
                th = th2;
                Trace.traceEnd(262144);
                throw th;
            }
        } catch (Throwable th3) {
            th = th3;
            Trace.traceEnd(262144);
            throw th;
        }
    }

    public ResolveInfo findPersistentPreferredActivity(Intent intent, int userId) {
        ResolveInfo findPersistentPreferredActivityLP;
        if (!UserHandle.isSameApp(Binder.getCallingUid(), 1000)) {
            throw new SecurityException("findPersistentPreferredActivity can only be run by the system");
        } else if (!sUserManager.exists(userId)) {
            return null;
        } else {
            int callingUid = Binder.getCallingUid();
            Intent intent2 = updateIntentForResolve(intent);
            String resolvedType = intent2.resolveTypeIfNeeded(this.mContext.getContentResolver());
            int flags = updateFlagsForResolve(0, userId, intent2, callingUid, false);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent2, resolvedType, flags, userId);
            synchronized (this.mPackages) {
                findPersistentPreferredActivityLP = findPersistentPreferredActivityLP(intent2, resolvedType, flags, query, false, userId);
            }
            return findPersistentPreferredActivityLP;
        }
    }

    public void setLastChosenActivity(Intent intent, String resolvedType, int flags, IntentFilter filter, int match, ComponentName activity) {
        int userId;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            int userId2 = UserHandle.getCallingUserId();
            if (DEBUG_PREFERRED) {
                Log.v(TAG, "setLastChosenActivity intent=" + intent + " resolvedType=" + resolvedType + " flags=" + flags + " filter=" + filter + " match=" + match + " activity=" + activity);
                filter.dump(new PrintStreamPrinter(System.out), "    ");
            }
            intent.setComponent(null);
            List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId2);
            if (activity == null || "com.huawei.pcassistant".equals(activity.getPackageName())) {
                userId = userId2;
            } else {
                userId = userId2;
                findPreferredActivityNotLocked(intent, resolvedType, flags, query, 0, false, true, false, userId2);
            }
            addPreferredActivityInternal(filter, match, null, activity, false, userId, "Setting last chosen");
        }
    }

    public ResolveInfo getLastChosenActivity(Intent intent, String resolvedType, int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        int userId = UserHandle.getCallingUserId();
        if (DEBUG_PREFERRED) {
            Log.v(TAG, "Querying last chosen activity for " + intent);
        }
        return findPreferredActivityNotLocked(intent, resolvedType, flags, queryIntentActivitiesInternal(intent, resolvedType, flags, userId), 0, false, false, false, userId);
    }

    private boolean areWebInstantAppsDisabled(int userId) {
        return this.mWebInstantAppsDisabled.get(userId);
    }

    private boolean isInstantAppResolutionAllowed(Intent intent, List<ResolveInfo> resolvedActivities, int userId, boolean skipPackageCheck) {
        int status;
        if (this.mInstantAppResolverConnection == null || this.mInstantAppInstallerActivity == null || intent.getComponent() != null || (intent.getFlags() & 512) != 0) {
            return false;
        }
        if (!(skipPackageCheck || intent.getPackage() == null)) {
            return false;
        }
        if (!intent.isWebIntent()) {
            if (!(resolvedActivities == null || resolvedActivities.size() == 0) || (intent.getFlags() & 2048) == 0) {
                return false;
            }
        } else if (intent.getData() == null || TextUtils.isEmpty(intent.getData().getHost()) || areWebInstantAppsDisabled(userId)) {
            return false;
        }
        synchronized (this.mPackages) {
            int count = resolvedActivities == null ? 0 : resolvedActivities.size();
            for (int n = 0; n < count; n++) {
                ResolveInfo info = resolvedActivities.get(n);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps != null) {
                    if (!info.handleAllWebDataURI && ((status = (int) (getDomainVerificationStatusLPr(ps, userId) >> 32)) == 2 || status == 4)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app; pkg: " + packageName + ", status: " + status);
                        }
                        return false;
                    } else if (ps.getInstantApp(userId)) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "DENY instant app installed; pkg: " + packageName);
                        }
                        return false;
                    }
                }
            }
            return true;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(20, new InstantAppRequest(responseObj, origIntent, resolvedType, callingPackage, userId, verificationBundle, false)));
    }

    private ResolveInfo chooseBestActivity(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int userId) {
        String str;
        ResolveInfo ri;
        if (query == null) {
            return null;
        }
        int N = query.size();
        if (N == 1) {
            return query.get(0);
        }
        if (N <= 1) {
            return null;
        }
        boolean debug = (intent.getFlags() & 8) != 0;
        ResolveInfo r0 = query.get(0);
        ResolveInfo r1 = query.get(1);
        if (DEBUG_INTENT_MATCHING || debug) {
            Slog.v(TAG, r0.activityInfo.name + "=" + r0.priority + " vs " + r1.activityInfo.name + "=" + r1.priority);
        }
        if (r0.priority == r1.priority && r0.preferredOrder == r1.preferredOrder) {
            if (r0.isDefault == r1.isDefault) {
                if (mHwPMSEx.isFindPreferredActivityInCache(intent, resolvedType, userId)) {
                    Slog.i(TAG, "find preferred activity in cache for action: " + intent.getAction());
                    ri = mHwPMSEx.findPreferredActivityInCache(intent, resolvedType, flags, query, userId);
                    str = TAG;
                } else {
                    int i = r0.priority;
                    str = TAG;
                    ri = findPreferredActivityNotLocked(intent, resolvedType, flags, query, i, true, false, debug, userId);
                }
                if (ri != null) {
                    if (ri.activityInfo != null) {
                        Slog.i(str, "choose best activity: " + ri.activityInfo.packageName + ", " + ri.activityInfo.name);
                    }
                    return ri;
                }
                for (int i2 = 0; i2 < N; i2++) {
                    ResolveInfo ri2 = query.get(i2);
                    if (ri2.activityInfo == null) {
                        Slog.d(str, "chooseBestActivity activityInfo is Empty");
                    } else if (ri2.activityInfo.applicationInfo.isInstantApp()) {
                        if (((int) (getDomainVerificationStatusLPr(this.mSettings.mPackages.get(ri2.activityInfo.packageName), userId) >> 32)) != 4) {
                            return ri2;
                        }
                    } else {
                        continue;
                    }
                }
                ResolveInfo ri3 = new ResolveInfo(this.mResolveInfo);
                ri3.activityInfo = new ActivityInfo(ri3.activityInfo);
                ri3.activityInfo.labelRes = ResolverActivity.getLabelRes(intent.getAction());
                String intentPackage = intent.getPackage();
                if (!TextUtils.isEmpty(intentPackage) && allHavePackage(query, intentPackage)) {
                    ApplicationInfo appi = query.get(0).activityInfo.applicationInfo;
                    ri3.resolvePackageName = intentPackage;
                    if (userNeedsBadging(userId)) {
                        ri3.noResourceId = true;
                    } else {
                        ri3.icon = appi.icon;
                    }
                    ri3.iconResourceId = appi.icon;
                    ri3.labelRes = appi.labelRes;
                }
                ri3.activityInfo.applicationInfo = new ApplicationInfo(ri3.activityInfo.applicationInfo);
                if (userId != 0) {
                    ri3.activityInfo.applicationInfo.uid = UserHandle.getUid(userId, UserHandle.getAppId(ri3.activityInfo.applicationInfo.uid));
                }
                if (ri3.activityInfo.metaData == null) {
                    ri3.activityInfo.metaData = new Bundle();
                }
                ri3.activityInfo.metaData.putBoolean("android.dock_home", true);
                return ri3;
            }
        }
        return query.get(0);
    }

    private boolean allHavePackage(List<ResolveInfo> list, String packageName) {
        if (ArrayUtils.isEmpty(list)) {
            return false;
        }
        int N = list.size();
        for (int i = 0; i < N; i++) {
            ResolveInfo ri = list.get(i);
            ActivityInfo ai = ri != null ? ri.activityInfo : null;
            if (ai == null || !packageName.equals(ai.packageName)) {
                return false;
            }
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private ResolveInfo findPersistentPreferredActivityLP(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, boolean debug, int userId) {
        List<PersistentPreferredActivity> pprefs;
        PackageManagerService packageManagerService = this;
        int i = flags;
        int N = query.size();
        PersistentPreferredIntentResolver ppir = packageManagerService.mSettings.mPersistentPreferredActivities.get(userId);
        if (DEBUG_PREFERRED || debug) {
            Slog.v(TAG, "Looking for presistent preferred activities...");
        }
        int i2 = 0;
        if (ppir != null) {
            pprefs = ppir.queryIntent(intent, resolvedType, (65536 & i) != 0, userId);
        } else {
            pprefs = null;
        }
        if (pprefs == null || pprefs.size() <= 0) {
            return null;
        }
        int M = pprefs.size();
        int i3 = 0;
        while (i3 < M) {
            PersistentPreferredActivity ppa = pprefs.get(i3);
            if (DEBUG_PREFERRED || debug) {
                StringBuilder sb = new StringBuilder();
                sb.append("Checking PersistentPreferredActivity ds=");
                sb.append(ppa.countDataSchemes() > 0 ? ppa.getDataScheme(i2) : "<none>");
                sb.append("\n  component=");
                sb.append(ppa.mComponent);
                Slog.v(TAG, sb.toString());
                ppa.dump(new LogPrinter(2, TAG, 3), "  ");
            }
            ActivityInfo ai = packageManagerService.getActivityInfo(ppa.mComponent, i | 512, userId);
            if (DEBUG_PREFERRED || debug) {
                Slog.v(TAG, "Found persistent preferred activity:");
                if (ai != null) {
                    ai.dump(new LogPrinter(2, TAG, 3), "  ");
                } else {
                    Slog.v(TAG, "  null");
                }
            }
            if (ai != null) {
                for (int j = 0; j < N; j++) {
                    ResolveInfo ri = query.get(j);
                    if (ri.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName) && ri.activityInfo.name.equals(ai.name)) {
                        if (DEBUG_PREFERRED || debug) {
                            Slog.v(TAG, "Returning persistent preferred activity: " + ri.activityInfo.packageName + SliceClientPermissions.SliceAuthority.DELIMITER + ri.activityInfo.name);
                        }
                        return ri;
                    }
                }
                continue;
            }
            i3++;
            i2 = 0;
            packageManagerService = this;
            i = flags;
        }
        return null;
    }

    private boolean isHomeIntent(Intent intent) {
        return "android.intent.action.MAIN".equals(intent.getAction()) && intent.hasCategory("android.intent.category.HOME") && intent.hasCategory("android.intent.category.DEFAULT");
    }

    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:156:0x02fa, code lost:
        if (r40 == false) goto L_0x0337;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:158:0x0302, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.removeMatchedPreferredActivity(r6, r0, r6) == false) goto L_0x0330;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:159:0x0304, code lost:
        r4 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:162:0x0307, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0328;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:163:0x0309, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Removing match " + r6.mPref.mComponent);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:165:0x032c, code lost:
        r15 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:168:0x033f, code lost:
        if (com.android.server.pm.HwPackageManagerServiceUtils.isSkipPreferredSetCheck(r6) != false) goto L_0x0422;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:169:0x0341, code lost:
        if (r39 == false) goto L_0x0422;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:171:0x0349, code lost:
        if (r6.mPref.sameSet(r37, r0) != false) goto L_0x0422;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:173:0x0351, code lost:
        if (r6.mPref.isSuperset(r37, r0) == false) goto L_0x03ae;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:174:0x0353, code lost:
        if (r0 != false) goto L_0x03a2;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:176:0x0357, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0377;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:177:0x0359, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Result set changed, but PreferredActivity is still valid as only non-preferred components were removed for " + r6 + " type " + r35);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:178:0x0377, code lost:
        r1 = new com.android.server.pm.PreferredActivity(r6, r6.mPref.mMatch, r6.mPref.discardObsoleteComponents(r37), r6.mPref.mComponent, r6.mPref.mAlways);
        r0.removeFilter(r6);
        r0.addFilter(r1);
        r4 = true;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:180:0x03a4, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0422;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:181:0x03a6, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Do not remove preferred activity for launcher during SetupWizard");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:183:0x03b0, code lost:
        if (com.android.server.pm.PackageManagerService.IS_HW_PREFER_APP_POLICY != false) goto L_0x0422;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:184:0x03b2, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Result set changed, dropping preferred activity for " + r6 + " type " + r35);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:185:0x03d2, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x03ee;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:186:0x03d4, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Removing preferred activity since set changed " + r6.mPref.mComponent);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:187:0x03ee, code lost:
        r0.removeFilter(r6);
        r0.addFilter(new com.android.server.pm.PreferredActivity(r6, r6.mPref.mMatch, null, r6.mPref.mComponent, false));
     */
    /* JADX WARNING: Code restructure failed: missing block: B:188:0x040f, code lost:
        if (1 == 0) goto L_0x041f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:191:0x0413, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x041c;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:192:0x0415, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:193:0x041c, code lost:
        scheduleWritePackageRestrictionsLocked(r42);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:195:0x0420, code lost:
        return null;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:196:0x0422, code lost:
        r4 = r36;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:197:0x0424, code lost:
        android.util.Slog.i(com.android.server.pm.PackageManagerService.TAG, "Returning preferred activity: " + r13.activityInfo.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r13.activityInfo.name);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:198:0x044b, code lost:
        if (r4 == false) goto L_0x045b;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:200:0x044f, code lost:
        if (com.android.server.pm.PackageManagerService.DEBUG_PREFERRED == false) goto L_0x0458;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:201:0x0451, code lost:
        android.util.Slog.v(com.android.server.pm.PackageManagerService.TAG, "Preferred activity bookkeeping changed; writing restrictions");
     */
    /* JADX WARNING: Code restructure failed: missing block: B:202:0x0458, code lost:
        scheduleWritePackageRestrictionsLocked(r42);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:204:0x045c, code lost:
        return r13;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:205:0x045d, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:241:0x04ea, code lost:
        r0 = th;
     */
    /* JADX WARNING: Removed duplicated region for block: B:114:0x020a A[Catch:{ all -> 0x0479 }] */
    /* JADX WARNING: Removed duplicated region for block: B:120:0x0237 A[Catch:{ all -> 0x0479 }] */
    /* JADX WARNING: Removed duplicated region for block: B:145:0x02a1 A[Catch:{ all -> 0x0479 }] */
    /* JADX WARNING: Removed duplicated region for block: B:148:0x02cc A[Catch:{ all -> 0x0479 }] */
    /* JADX WARNING: Removed duplicated region for block: B:228:0x04c7  */
    /* JADX WARNING: Removed duplicated region for block: B:244:0x0117 A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x0114 A[Catch:{ all -> 0x011f }] */
    public ResolveInfo findPreferredActivityNotLocked(Intent intent, String resolvedType, int flags, List<ResolveInfo> query, int priority, boolean always, boolean removeMatches, boolean debug, int userId) {
        Throwable th;
        List<PreferredActivity> list;
        Throwable th2;
        PreferredActivity pa;
        boolean changed;
        int M;
        List<PreferredActivity> prefs;
        int callingUid;
        PreferredActivity pa2;
        boolean startupGuideEnabled;
        int match;
        String str;
        ResolveInfo ri;
        boolean changed2;
        ResolveInfo pri;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int callingUid2 = Binder.getCallingUid();
        boolean isDeviceProvisioned = Settings.Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0) == 1;
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        Intent intent2 = updateIntentForResolve(intent);
        synchronized (this.mPackages) {
            try {
                ResolveInfo pri2 = findPersistentPreferredActivityLP(intent2, resolvedType, flags2, query, debug, userId);
                if (pri2 != null) {
                    try {
                        return pri2;
                    } catch (Throwable th3) {
                        th = th3;
                        throw th;
                    }
                } else {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                    if (DEBUG_PREFERRED || debug) {
                        Slog.v(TAG, "Looking for preferred activities...");
                    }
                    if (pir != null) {
                        list = pir.queryIntent(intent2, resolvedType, (65536 & flags2) != 0, userId);
                    } else {
                        list = null;
                    }
                    List<PreferredActivity> prefs2 = list;
                    if (prefs2 != null && prefs2.size() > 0) {
                        boolean changed3 = false;
                        try {
                            if (DEBUG_PREFERRED || debug) {
                                Slog.v(TAG, "Figuring out best match...");
                            }
                            int N = query.size();
                            int j = 0;
                            int match2 = 0;
                            while (j < N) {
                                try {
                                    ri = query.get(j);
                                    if (!DEBUG_PREFERRED) {
                                        if (!debug) {
                                            pri = pri2;
                                            changed2 = changed3;
                                            if (ri.match <= match2) {
                                                match2 = ri.match;
                                            }
                                            j++;
                                            pri2 = pri;
                                            changed3 = changed2;
                                        }
                                    }
                                    pri = pri2;
                                } catch (Throwable th4) {
                                    th2 = th4;
                                    if (changed3) {
                                    }
                                    throw th2;
                                }
                                try {
                                    StringBuilder sb = new StringBuilder();
                                    changed2 = changed3;
                                    try {
                                        sb.append("Match for ");
                                        sb.append(ri.activityInfo);
                                        sb.append(": 0x");
                                        sb.append(Integer.toHexString(match2));
                                        Slog.v(TAG, sb.toString());
                                        if (ri.match <= match2) {
                                        }
                                        j++;
                                        pri2 = pri;
                                        changed3 = changed2;
                                    } catch (Throwable th5) {
                                        th2 = th5;
                                        changed3 = changed2;
                                        if (changed3) {
                                        }
                                        throw th2;
                                    }
                                } catch (Throwable th6) {
                                    th2 = th6;
                                    if (changed3) {
                                    }
                                    throw th2;
                                }
                            }
                            try {
                                if (DEBUG_PREFERRED || debug) {
                                    Slog.v(TAG, "Best match: 0x" + Integer.toHexString(match2));
                                }
                                ComponentName startupGuideComp = new ComponentName("com.huawei.hwstartupguide", "com.huawei.hwstartupguide.LanguageSelectActivity");
                                boolean startupGuideEnabled2 = false;
                                if (isHomeIntent(intent2)) {
                                    try {
                                        startupGuideEnabled2 = this.mSettings.getComponentEnabledSettingLPr(startupGuideComp, userId) == 1;
                                    } catch (IllegalArgumentException e) {
                                        Slog.e(TAG, "setup wizard not exist.");
                                    }
                                }
                                int match3 = 268369920 & match2;
                                int M2 = prefs2.size();
                                int i = 0;
                                boolean changed4 = changed3;
                                while (i < M2) {
                                    try {
                                        pa = prefs2.get(i);
                                        if (!DEBUG_PREFERRED) {
                                            if (!debug) {
                                                prefs = prefs2;
                                                M = M2;
                                                callingUid = callingUid2;
                                                pa2 = pa;
                                                changed = changed4;
                                                if (pa2.mPref.mMatch == match3) {
                                                    if (!DEBUG_PREFERRED) {
                                                        if (debug) {
                                                        }
                                                        match = match3;
                                                        startupGuideEnabled = startupGuideEnabled2;
                                                    }
                                                    Slog.v(TAG, "Skipping bad match " + Integer.toHexString(pa2.mPref.mMatch));
                                                    match = match3;
                                                    startupGuideEnabled = startupGuideEnabled2;
                                                } else if (!always || pa2.mPref.mAlways) {
                                                    ActivityInfo ai = getActivityInfo(pa2.mPref.mComponent, flags2 | 512 | 524288 | 262144, userId);
                                                    if (!DEBUG_PREFERRED) {
                                                        if (!debug) {
                                                            match = match3;
                                                            boolean excludeSetupWizardHomeActivity = !isHomeIntent(intent2) && (!isDeviceProvisioned || startupGuideEnabled2);
                                                            if (ai == null) {
                                                                int j2 = 0;
                                                                while (true) {
                                                                    if (j2 >= N) {
                                                                        startupGuideEnabled = startupGuideEnabled2;
                                                                        break;
                                                                    }
                                                                    ResolveInfo ri2 = query.get(j2);
                                                                    startupGuideEnabled = startupGuideEnabled2;
                                                                    if (ri2.activityInfo.applicationInfo.packageName.equals(ai.applicationInfo.packageName)) {
                                                                        if (ri2.activityInfo.name.equals(ai.name)) {
                                                                            break;
                                                                        }
                                                                    }
                                                                    j2++;
                                                                    startupGuideEnabled2 = startupGuideEnabled;
                                                                }
                                                            } else if (excludeSetupWizardHomeActivity) {
                                                                startupGuideEnabled = startupGuideEnabled2;
                                                            } else {
                                                                Slog.w(TAG, "Removing dangling preferred activity: " + pa2.mPref.mComponent);
                                                                pir.removeFilter(pa2);
                                                                changed4 = true;
                                                                startupGuideEnabled = startupGuideEnabled2;
                                                                i++;
                                                                callingUid2 = callingUid;
                                                                match3 = match;
                                                                startupGuideComp = startupGuideComp;
                                                                prefs2 = prefs;
                                                                M2 = M;
                                                                startupGuideEnabled2 = startupGuideEnabled;
                                                            }
                                                        }
                                                    }
                                                    Slog.v(TAG, "Found preferred activity:");
                                                    if (ai != null) {
                                                        match = match3;
                                                        ai.dump(new LogPrinter(2, TAG, 3), "  ");
                                                    } else {
                                                        match = match3;
                                                        Slog.v(TAG, "  null");
                                                    }
                                                    if (!isHomeIntent(intent2)) {
                                                    }
                                                    if (ai == null) {
                                                    }
                                                } else {
                                                    if (!DEBUG_PREFERRED) {
                                                        if (debug) {
                                                        }
                                                        match = match3;
                                                        startupGuideEnabled = startupGuideEnabled2;
                                                    }
                                                    Slog.v(TAG, "Skipping mAlways=false entry");
                                                    match = match3;
                                                    startupGuideEnabled = startupGuideEnabled2;
                                                }
                                                changed4 = changed;
                                                i++;
                                                callingUid2 = callingUid;
                                                match3 = match;
                                                startupGuideComp = startupGuideComp;
                                                prefs2 = prefs;
                                                M2 = M;
                                                startupGuideEnabled2 = startupGuideEnabled;
                                            }
                                        }
                                        prefs = prefs2;
                                    } catch (Throwable th7) {
                                        th2 = th7;
                                        changed3 = changed4;
                                        if (changed3) {
                                        }
                                        throw th2;
                                    }
                                    try {
                                        StringBuilder sb2 = new StringBuilder();
                                        M = M2;
                                        sb2.append("Checking PreferredActivity ds=");
                                        if (pa.countDataSchemes() > 0) {
                                            pa2 = pa;
                                            callingUid = callingUid2;
                                            try {
                                                str = pa2.getDataScheme(0);
                                            } catch (Throwable th8) {
                                                th2 = th8;
                                                changed3 = changed4;
                                            }
                                        } else {
                                            pa2 = pa;
                                            callingUid = callingUid2;
                                            str = "<none>";
                                        }
                                        try {
                                            sb2.append(str);
                                            sb2.append("\n  component=");
                                            sb2.append(pa2.mPref.mComponent);
                                            Slog.v(TAG, sb2.toString());
                                            changed = changed4;
                                        } catch (Throwable th9) {
                                            th2 = th9;
                                            changed3 = changed4;
                                            if (changed3) {
                                            }
                                            throw th2;
                                        }
                                        try {
                                            pa2.dump(new LogPrinter(2, TAG, 3), "  ");
                                            if (pa2.mPref.mMatch == match3) {
                                            }
                                            changed4 = changed;
                                            i++;
                                            callingUid2 = callingUid;
                                            match3 = match;
                                            startupGuideComp = startupGuideComp;
                                            prefs2 = prefs;
                                            M2 = M;
                                            startupGuideEnabled2 = startupGuideEnabled;
                                        } catch (Throwable th10) {
                                            th2 = th10;
                                            changed3 = changed;
                                            if (changed3) {
                                            }
                                            throw th2;
                                        }
                                    } catch (Throwable th11) {
                                        th2 = th11;
                                        changed3 = changed4;
                                        if (changed3) {
                                            if (DEBUG_PREFERRED) {
                                                Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                            }
                                            scheduleWritePackageRestrictionsLocked(userId);
                                        }
                                        throw th2;
                                    }
                                }
                                if (changed4) {
                                    if (DEBUG_PREFERRED) {
                                        Slog.v(TAG, "Preferred activity bookkeeping changed; writing restrictions");
                                    }
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            } catch (Throwable th12) {
                                th2 = th12;
                                changed3 = changed3;
                                if (changed3) {
                                }
                                throw th2;
                            }
                        } catch (Throwable th13) {
                            th2 = th13;
                            if (changed3) {
                            }
                            throw th2;
                        }
                    }
                    return mHwPMSEx.hwFindPreferredActivity(intent2, query);
                }
            } catch (Throwable th14) {
                th = th14;
                throw th;
            }
        }
    }

    public boolean canForwardTo(Intent intent, String resolvedType, int sourceUserId, int targetUserId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        List<CrossProfileIntentFilter> matches = getMatchingCrossProfileIntentFilters(intent, resolvedType, sourceUserId);
        boolean z = true;
        if (matches != null) {
            int size = matches.size();
            for (int i = 0; i < size; i++) {
                if (matches.get(i).getTargetUserId() == targetUserId) {
                    return true;
                }
            }
        }
        if (intent == null || !intent.hasWebURI()) {
            return false;
        }
        int callingUid = Binder.getCallingUid();
        UserInfo parent = getProfileParent(sourceUserId);
        synchronized (this.mPackages) {
            if (getCrossProfileDomainPreferredLpr(intent, resolvedType, updateFlagsForResolve(0, parent.id, intent, callingUid, false), sourceUserId, parent.id) == null) {
                z = false;
            }
        }
        return z;
    }

    private UserInfo getProfileParent(int userId) {
        long identity = Binder.clearCallingIdentity();
        try {
            return sUserManager.getProfileParent(userId);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private List<CrossProfileIntentFilter> getMatchingCrossProfileIntentFilters(Intent intent, String resolvedType, int userId) {
        CrossProfileIntentResolver resolver = this.mSettings.mCrossProfileIntentResolvers.get(userId);
        if (resolver != null) {
            return resolver.queryIntent(intent, resolvedType, false, userId);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) {
        try {
            Trace.traceBegin(262144, "queryIntentActivities");
            List<ResolveInfo> result = queryIntentActivitiesInternal(intent, resolvedType, flags, userId);
            mHwPMSEx.filterResolveInfo(intent, resolvedType, result);
            return new ParceledListSlice<>(result);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private String getInstantAppPackageName(int callingUid) {
        synchronized (this.mPackages) {
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
            String str = null;
            if (!(obj instanceof PackageSetting)) {
                return null;
            }
            PackageSetting ps = (PackageSetting) obj;
            if (ps.getInstantApp(UserHandle.getUserId(callingUid))) {
                str = ps.pkg.packageName;
            }
            return str;
        }
    }

    /* access modifiers changed from: protected */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) {
        return queryIntentActivitiesInternal(intent, resolvedType, flags, Binder.getCallingUid(), userId, false, true);
    }

    /* JADX INFO: Multiple debug info for r0v22 'pkg'  java.util.List<android.content.pm.ResolveInfo>: [D('xpResolveInfo' android.content.pm.ResolveInfo), D('result' java.util.List<android.content.pm.ResolveInfo>)] */
    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:122:0x020d A[Catch:{ all -> 0x02e1 }] */
    /* JADX WARNING: Removed duplicated region for block: B:165:0x02d4  */
    /* JADX WARNING: Removed duplicated region for block: B:72:0x010a  */
    /* JADX WARNING: Removed duplicated region for block: B:73:0x011b  */
    public List<ResolveInfo> queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId, boolean resolveForStart, boolean allowDynamicSplits) {
        ComponentName comp;
        Intent intent2;
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        String instantAppPkgName;
        Intent intent3;
        List<ResolveInfo> result;
        boolean sortResult;
        CrossProfileDomainInfo xpDomainInfo;
        ResolveInfo xpResolveInfo;
        Intent intent4;
        int i;
        PackageManagerService packageManagerService;
        int flags2;
        Intent intent5;
        boolean isTargetExplicitlyVisibleToInstantApp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        String instantAppPkgName2 = getInstantAppPackageName(filterCallingUid);
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "query intent activities");
        String pkgName = intent.getPackage();
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent6 = intent.getSelector();
            comp = intent6.getComponent();
            intent2 = intent6;
        }
        String forbidPackage = comp == null ? pkgName : comp.getPackageName();
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx == null || !iHwPackageManagerServiceEx.isNeedForbidAppAct(PACKAGE_FORBIDDEN, forbidPackage, null, null)) {
            int flags3 = updateFlagsForResolve(flags, userId, intent2, filterCallingUid, resolveForStart, (comp == null && pkgName == null) ? false : true);
            if (comp != null) {
                List<ResolveInfo> list = new ArrayList<>(1);
                ActivityInfo ai = getActivityInfo(comp, flags3, userId);
                if (ai != null) {
                    boolean matchInstantApp = (8388608 & flags3) != 0;
                    boolean matchVisibleToInstantAppOnly = (16777216 & flags3) != 0;
                    boolean matchExplicitlyVisibleOnly = (33554432 & flags3) != 0;
                    boolean isCallerInstantApp = instantAppPkgName2 != null;
                    boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName2);
                    flags2 = flags3;
                    boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                    intent5 = intent2;
                    boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                    if (isTargetVisibleToInstantApp) {
                        if ((ai.flags & 2097152) == 0) {
                            isTargetExplicitlyVisibleToInstantApp = true;
                            if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                                ResolveInfo ri = new ResolveInfo();
                                ri.activityInfo = ai;
                                list.add(ri);
                            }
                        }
                    }
                    isTargetExplicitlyVisibleToInstantApp = false;
                    if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                    }
                } else {
                    flags2 = flags3;
                    intent5 = intent2;
                }
                return applyPostResolutionFilter(list, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent5);
            }
            int flags4 = flags3;
            boolean xpDomainInfo2 = false;
            boolean addInstant = false;
            ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
            synchronized (arrayMap2) {
                if (pkgName == null) {
                    try {
                        List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent2, resolvedType, userId);
                        ResolveInfo xpResolveInfo2 = querySkipCurrentProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId);
                        if (xpResolveInfo2 != null) {
                            try {
                                List<ResolveInfo> xpResult = new ArrayList<>(1);
                                xpResult.add(xpResolveInfo2);
                                arrayMap = arrayMap2;
                                try {
                                    List<ResolveInfo> applyPostResolutionFilter = applyPostResolutionFilter(filterIfNotSystemUser(xpResult, userId), instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                    return applyPostResolutionFilter;
                                } catch (Throwable th2) {
                                    th = th2;
                                    throw th;
                                }
                            } catch (Throwable th3) {
                                th = th3;
                                arrayMap = arrayMap2;
                                throw th;
                            }
                        } else {
                            arrayMap = arrayMap2;
                            try {
                                try {
                                    List<ResolveInfo> result2 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent2, resolvedType, flags4, userId), userId);
                                    addInstant = isInstantAppResolutionAllowed(intent2, result2, userId, false);
                                    boolean isVisibleToUser = false;
                                    result = result2;
                                    flags4 = flags4;
                                    try {
                                        ResolveInfo xpResolveInfo3 = queryCrossProfileIntents(matchingFilters, intent2, resolvedType, flags4, userId, hasNonNegativePriority(result2));
                                        if (xpResolveInfo3 != null) {
                                            try {
                                                if (isUserEnabled(xpResolveInfo3.targetUserId)) {
                                                    if (filterIfNotSystemUser(Collections.singletonList(xpResolveInfo3), userId).size() > 0) {
                                                        isVisibleToUser = true;
                                                    }
                                                    if (isVisibleToUser) {
                                                        result.add(xpResolveInfo3);
                                                        sortResult = true;
                                                        if (!intent2.hasWebURI()) {
                                                            UserInfo parent = getProfileParent(userId);
                                                            if (parent != null) {
                                                                try {
                                                                    xpResolveInfo = xpResolveInfo3;
                                                                    xpDomainInfo = getCrossProfileDomainPreferredLpr(intent2, resolvedType, flags4, userId, parent.id);
                                                                } catch (Throwable th4) {
                                                                    th = th4;
                                                                    throw th;
                                                                }
                                                            } else {
                                                                xpResolveInfo = xpResolveInfo3;
                                                                xpDomainInfo = null;
                                                            }
                                                            if (xpDomainInfo != null) {
                                                                if (xpResolveInfo != null) {
                                                                    result.remove(xpResolveInfo);
                                                                }
                                                                try {
                                                                    if (result.size() != 0 || addInstant) {
                                                                        intent4 = intent2;
                                                                        instantAppPkgName = instantAppPkgName2;
                                                                        i = userId;
                                                                        packageManagerService = this;
                                                                    } else {
                                                                        result.add(xpDomainInfo.resolveInfo);
                                                                        try {
                                                                            List<ResolveInfo> applyPostResolutionFilter2 = applyPostResolutionFilter(result, instantAppPkgName2, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent2);
                                                                            return applyPostResolutionFilter2;
                                                                        } catch (Throwable th5) {
                                                                            th = th5;
                                                                            throw th;
                                                                        }
                                                                    }
                                                                } catch (Throwable th6) {
                                                                    th = th6;
                                                                    throw th;
                                                                }
                                                            } else {
                                                                intent4 = intent2;
                                                                instantAppPkgName = instantAppPkgName2;
                                                                i = userId;
                                                                packageManagerService = this;
                                                                try {
                                                                    if (result.size() <= 1 && !addInstant) {
                                                                        List<ResolveInfo> applyPostResolutionFilter3 = applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent4);
                                                                        return applyPostResolutionFilter3;
                                                                    }
                                                                } catch (Throwable th7) {
                                                                    th = th7;
                                                                    throw th;
                                                                }
                                                            }
                                                            intent3 = intent4;
                                                            try {
                                                                xpDomainInfo2 = true;
                                                                result = filterCandidatesWithDomainPreferredActivitiesLPr(intent4, flags4, result, xpDomainInfo, userId);
                                                            } catch (Throwable th8) {
                                                                th = th8;
                                                                throw th;
                                                            }
                                                        } else {
                                                            intent3 = intent2;
                                                            instantAppPkgName = instantAppPkgName2;
                                                            xpDomainInfo2 = sortResult;
                                                        }
                                                    }
                                                }
                                            } catch (Throwable th9) {
                                                th = th9;
                                                throw th;
                                            }
                                        }
                                        sortResult = false;
                                    } catch (Throwable th10) {
                                        th = th10;
                                        throw th;
                                    }
                                } catch (Throwable th11) {
                                    th = th11;
                                    throw th;
                                }
                                try {
                                    if (!intent2.hasWebURI()) {
                                    }
                                } catch (Throwable th12) {
                                    th = th12;
                                    throw th;
                                }
                            } catch (Throwable th13) {
                                th = th13;
                                throw th;
                            }
                        }
                    } catch (Throwable th14) {
                        th = th14;
                        arrayMap = arrayMap2;
                        throw th;
                    }
                } else {
                    intent3 = intent2;
                    arrayMap = arrayMap2;
                    instantAppPkgName = instantAppPkgName2;
                    try {
                        PackageParser.Package pkg = this.mPackages.get(pkgName);
                        List<ResolveInfo> result3 = null;
                        if (pkg != null) {
                            try {
                                result3 = filterIfNotSystemUser(this.mComponentResolver.queryActivities(intent3, resolvedType, flags4, pkg.activities, userId), userId);
                            } catch (Throwable th15) {
                                th = th15;
                                throw th;
                            }
                        }
                        if (result3 != null) {
                            if (result3.size() != 0) {
                                result = result3;
                            }
                        }
                        addInstant = isInstantAppResolutionAllowed(intent3, null, userId, true);
                        if (result3 == null) {
                            result = new ArrayList<>();
                        } else {
                            result = result3;
                        }
                    } catch (Throwable th16) {
                        th = th16;
                        throw th;
                    }
                }
                if (addInstant) {
                    result = maybeAddInstantAppInstaller(result, intent3, resolvedType, flags4, userId, resolveForStart);
                }
                if (xpDomainInfo2) {
                    Collections.sort(result, ComponentResolver.RESOLVE_PRIORITY_SORTER);
                }
                return applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, filterCallingUid, resolveForStart, userId, intent3);
            }
        }
        Slog.i(TAG, "queryIntentActivitiesInternal isNeedForbidAppAct forbid");
        return new ArrayList();
    }

    /* JADX WARNING: Removed duplicated region for block: B:27:0x00a6  */
    /* JADX WARNING: Removed duplicated region for block: B:30:0x00e9  */
    /* JADX WARNING: Removed duplicated region for block: B:41:0x0138  */
    /* JADX WARNING: Removed duplicated region for block: B:49:0x016a  */
    private List<ResolveInfo> maybeAddInstantAppInstaller(List<ResolveInfo> result, Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart) {
        ResolveInfo localInstantApp;
        int status;
        InstantAppRequest requestObject;
        PackageSetting ps;
        ResolveInfo ephemeralInstaller;
        if (!((flags & 8388608) != 0)) {
            List<ResolveInfo> instantApps = this.mComponentResolver.queryActivities(intent, resolvedType, 8388608 | flags | 64 | DumpState.DUMP_SERVICE_PERMISSIONS, userId);
            for (int i = instantApps.size() - 1; i >= 0; i--) {
                ResolveInfo info = instantApps.get(i);
                String packageName = info.activityInfo.packageName;
                PackageSetting ps2 = this.mSettings.mPackages.get(packageName);
                if (ps2.getInstantApp(userId)) {
                    if (((int) (getDomainVerificationStatusLPr(ps2, userId) >> 32)) == 3) {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Instant app marked to never run; pkg: " + packageName);
                        }
                        localInstantApp = null;
                        status = 1;
                    } else {
                        if (DEBUG_INSTANT) {
                            Slog.v(TAG, "Found installed instant app; pkg: " + packageName);
                        }
                        localInstantApp = info;
                        status = 0;
                    }
                    if (status == 0) {
                        requestObject = null;
                    } else if (localInstantApp == null) {
                        Trace.traceBegin(262144, "resolveEphemeral");
                        InstantAppRequest auxiliaryResponse = InstantAppResolver.doInstantAppResolutionPhaseOne(this.mInstantAppResolverConnection, new InstantAppRequest((AuxiliaryResolveInfo) null, intent, resolvedType, (String) null, userId, (Bundle) null, resolveForStart));
                        Trace.traceEnd(262144);
                        requestObject = auxiliaryResponse;
                    } else {
                        ApplicationInfo ai = localInstantApp.activityInfo.applicationInfo;
                        requestObject = new AuxiliaryResolveInfo((ComponentName) null, ai.packageName, ai.longVersionCode, (String) null);
                    }
                    if ((!intent.isWebIntent() && requestObject == null) || (ps = this.mSettings.mPackages.get(this.mInstantAppInstallerActivity.packageName)) == null || !ps.readUserState(userId).isEnabled(this.mInstantAppInstallerActivity, 0)) {
                        return result;
                    }
                    ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
                    ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
                    ephemeralInstaller.match = 5799936;
                    ephemeralInstaller.filter = new IntentFilter();
                    if (intent.getAction() != null) {
                        ephemeralInstaller.filter.addAction(intent.getAction());
                    }
                    if (!(intent.getData() == null || intent.getData().getPath() == null)) {
                        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
                    }
                    ephemeralInstaller.isInstantAppAvailable = true;
                    ephemeralInstaller.isDefault = true;
                    ephemeralInstaller.auxiliaryInfo = requestObject;
                    if (DEBUG_INSTANT) {
                        Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                    }
                    result.add(ephemeralInstaller);
                    return result;
                }
            }
        }
        localInstantApp = null;
        status = 0;
        if (status == 0) {
        }
        if (!intent.isWebIntent()) {
        }
        ephemeralInstaller = new ResolveInfo(this.mInstantAppInstallerInfo);
        ephemeralInstaller.activityInfo = PackageParser.generateActivityInfo(this.mInstantAppInstallerActivity, 0, ps.readUserState(userId), userId);
        ephemeralInstaller.match = 5799936;
        ephemeralInstaller.filter = new IntentFilter();
        if (intent.getAction() != null) {
        }
        ephemeralInstaller.filter.addDataPath(intent.getData().getPath(), 0);
        ephemeralInstaller.isInstantAppAvailable = true;
        ephemeralInstaller.isDefault = true;
        ephemeralInstaller.auxiliaryInfo = requestObject;
        if (DEBUG_INSTANT) {
        }
        result.add(ephemeralInstaller);
        return result;
    }

    /* access modifiers changed from: private */
    public static class CrossProfileDomainInfo {
        int bestDomainVerificationStatus;
        ResolveInfo resolveInfo;

        private CrossProfileDomainInfo() {
        }
    }

    private CrossProfileDomainInfo getCrossProfileDomainPreferredLpr(Intent intent, String resolvedType, int flags, int sourceUserId, int parentUserId) {
        List<ResolveInfo> resultTargetUser;
        if (!sUserManager.hasUserRestriction("allow_parent_profile_app_linking", sourceUserId)) {
            return null;
        }
        List<ResolveInfo> resultTargetUser2 = this.mComponentResolver.queryActivities(intent, resolvedType, flags, parentUserId);
        if (resultTargetUser2 == null) {
            return null;
        }
        if (resultTargetUser2.isEmpty()) {
            return null;
        }
        CrossProfileDomainInfo result = null;
        int size = resultTargetUser2.size();
        int i = 0;
        while (i < size) {
            ResolveInfo riTargetUser = resultTargetUser2.get(i);
            if (riTargetUser.handleAllWebDataURI) {
                resultTargetUser = resultTargetUser2;
            } else {
                PackageSetting ps = this.mSettings.mPackages.get(riTargetUser.activityInfo.packageName);
                if (ps == null) {
                    resultTargetUser = resultTargetUser2;
                } else {
                    int status = (int) (getDomainVerificationStatusLPr(ps, parentUserId) >> 32);
                    if (result == null) {
                        resultTargetUser = resultTargetUser2;
                        CrossProfileDomainInfo result2 = new CrossProfileDomainInfo();
                        result2.resolveInfo = createForwardingResolveInfoUnchecked(new IntentFilter(), sourceUserId, parentUserId);
                        result2.bestDomainVerificationStatus = status;
                        result = result2;
                    } else {
                        resultTargetUser = resultTargetUser2;
                        result.bestDomainVerificationStatus = bestDomainVerificationStatus(status, result.bestDomainVerificationStatus);
                    }
                }
            }
            i++;
            resultTargetUser2 = resultTargetUser;
        }
        if (result == null || result.bestDomainVerificationStatus != 3) {
            return result;
        }
        return null;
    }

    private int bestDomainVerificationStatus(int status1, int status2) {
        if (status1 == 3) {
            return status2;
        }
        if (status2 == 3) {
            return status1;
        }
        return (int) MathUtils.max(status1, status2);
    }

    private boolean isUserEnabled(int userId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            return userInfo != null && userInfo.isEnabled();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private List<ResolveInfo> filterIfNotSystemUser(List<ResolveInfo> resolveInfos, int userId) {
        if (userId == 0) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            if ((resolveInfos.get(i).activityInfo.flags & 536870912) != 0) {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private List<ResolveInfo> applyPostResolutionFilter(List<ResolveInfo> resolveInfos, String ephemeralPkgName, boolean allowDynamicSplits, int filterCallingUid, boolean resolveForStart, int userId, Intent intent) {
        boolean blockInstant = intent.isWebIntent() && areWebInstantAppsDisabled(userId);
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            if (!info.isInstantAppAvailable || !blockInstant) {
                if (allowDynamicSplits && info.activityInfo != null && info.activityInfo.splitName != null) {
                    if (!ArrayUtils.contains(info.activityInfo.applicationInfo.splitNames, info.activityInfo.splitName)) {
                        if (this.mInstantAppInstallerActivity == null) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "No installer - not adding it to the ResolveInfo list");
                            }
                            resolveInfos.remove(i);
                        } else if (!blockInstant || !isInstantApp(info.activityInfo.packageName, userId)) {
                            if (DEBUG_INSTALL) {
                                Slog.v(TAG, "Adding installer to the ResolveInfo list");
                            }
                            ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                            installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo(findInstallFailureActivity(info.activityInfo.packageName, filterCallingUid, userId), info.activityInfo.packageName, info.activityInfo.applicationInfo.longVersionCode, info.activityInfo.splitName);
                            installerInfo.filter = new IntentFilter();
                            installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                            installerInfo.labelRes = info.resolveLabelResId();
                            installerInfo.icon = info.resolveIconResId();
                            installerInfo.isInstantAppAvailable = true;
                            resolveInfos.set(i, installerInfo);
                        } else {
                            resolveInfos.remove(i);
                        }
                    }
                }
                if (ephemeralPkgName != null && !ephemeralPkgName.equals(info.activityInfo.packageName) && ((!resolveForStart || !((intent.isWebIntent() || (intent.getFlags() & 2048) != 0) && intent.getPackage() == null && intent.getComponent() == null)) && (info.activityInfo.applicationInfo.isInstantApp() || (info.activityInfo.flags & 1048576) == 0))) {
                    resolveInfos.remove(i);
                }
            } else {
                resolveInfos.remove(i);
            }
        }
        return resolveInfos;
    }

    private ComponentName findInstallFailureActivity(String packageName, int filterCallingUid, int userId) {
        Intent failureActivityIntent = new Intent("android.intent.action.INSTALL_FAILURE");
        failureActivityIntent.setPackage(packageName);
        List<ResolveInfo> result = queryIntentActivitiesInternal(failureActivityIntent, null, 0, filterCallingUid, userId, false, false);
        int NR = result.size();
        if (NR <= 0) {
            return null;
        }
        for (int i = 0; i < NR; i++) {
            ResolveInfo info = result.get(i);
            if (info.activityInfo.splitName == null) {
                return new ComponentName(packageName, info.activityInfo.name);
            }
        }
        return null;
    }

    private boolean hasNonNegativePriority(List<ResolveInfo> resolveInfos) {
        return resolveInfos.size() > 0 && resolveInfos.get(0).priority >= 0;
    }

    private List<ResolveInfo> filterCandidatesWithDomainPreferredActivitiesLPr(Intent intent, int matchFlags, List<ResolveInfo> candidates, CrossProfileDomainInfo xpDomainInfo, int userId) {
        Throwable th;
        int maxMatchPrio;
        PackageManagerService packageManagerService = this;
        List<ResolveInfo> list = candidates;
        int i = userId;
        boolean debug = (intent.getFlags() & 8) != 0;
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            Slog.v(TAG, "Filtering results with preferred activities. Candidates count: " + candidates.size());
        }
        ArrayList<ResolveInfo> result = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysList = new ArrayList<>();
        ArrayList<ResolveInfo> undefinedList = new ArrayList<>();
        ArrayList<ResolveInfo> alwaysAskList = new ArrayList<>();
        ArrayList<ResolveInfo> neverList = new ArrayList<>();
        ArrayList<ResolveInfo> matchAllList = new ArrayList<>();
        synchronized (packageManagerService.mPackages) {
            try {
                int n = 0;
                for (int count = candidates.size(); n < count; count = count) {
                    try {
                        ResolveInfo info = list.get(n);
                        PackageSetting ps = packageManagerService.mSettings.mPackages.get(info.activityInfo.packageName);
                        if (ps != null) {
                            if (info.handleAllWebDataURI) {
                                matchAllList.add(info);
                            } else {
                                long packedStatus = packageManagerService.getDomainVerificationStatusLPr(ps, i);
                                int status = (int) (packedStatus >> 32);
                                int linkGeneration = (int) (packedStatus & -1);
                                if (status == 2) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always: " + info.activityInfo.packageName + " : linkgen=" + linkGeneration);
                                    }
                                    info.preferredOrder = linkGeneration;
                                    alwaysList.add(info);
                                } else if (status == 3) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + never: " + info.activityInfo.packageName);
                                    }
                                    neverList.add(info);
                                } else if (status == 4) {
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + always-ask: " + info.activityInfo.packageName);
                                    }
                                    alwaysAskList.add(info);
                                } else {
                                    if (status != 0) {
                                        if (status != 1) {
                                        }
                                    }
                                    if (DEBUG_DOMAIN_VERIFICATION || debug) {
                                        Slog.i(TAG, "  + ask: " + info.activityInfo.packageName);
                                    }
                                    undefinedList.add(info);
                                }
                            }
                        }
                        n++;
                        packageManagerService = this;
                        list = candidates;
                        i = userId;
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
                boolean includeBrowser = false;
                if (alwaysList.size() > 0) {
                    result.addAll(alwaysList);
                } else {
                    result.addAll(undefinedList);
                    if (!(xpDomainInfo == null || xpDomainInfo.bestDomainVerificationStatus == 3)) {
                        result.add(xpDomainInfo.resolveInfo);
                    }
                    includeBrowser = true;
                }
                if (alwaysAskList.size() > 0) {
                    Iterator<ResolveInfo> it = result.iterator();
                    while (it.hasNext()) {
                        it.next().preferredOrder = 0;
                    }
                    result.addAll(alwaysAskList);
                    includeBrowser = true;
                }
                if (includeBrowser) {
                    if (DEBUG_DOMAIN_VERIFICATION) {
                        Slog.v(TAG, "   ...including browsers in candidate set");
                    }
                    if ((matchFlags & 131072) != 0) {
                        result.addAll(matchAllList);
                    } else {
                        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
                        ResolveInfo defaultBrowserMatch = null;
                        int numCandidates = matchAllList.size();
                        int maxMatchPrio2 = 0;
                        int n2 = 0;
                        while (n2 < numCandidates) {
                            ResolveInfo info2 = matchAllList.get(n2);
                            if (info2.priority > maxMatchPrio2) {
                                maxMatchPrio2 = info2.priority;
                            }
                            if (info2.activityInfo.packageName.equals(defaultBrowserPackageName)) {
                                if (defaultBrowserMatch != null) {
                                    maxMatchPrio = maxMatchPrio2;
                                    if (defaultBrowserMatch.priority >= info2.priority) {
                                    }
                                } else {
                                    maxMatchPrio = maxMatchPrio2;
                                }
                                if (debug) {
                                    Slog.v(TAG, "Considering default browser match " + info2);
                                }
                                defaultBrowserMatch = info2;
                            } else {
                                maxMatchPrio = maxMatchPrio2;
                            }
                            n2++;
                            maxMatchPrio2 = maxMatchPrio;
                        }
                        if (defaultBrowserMatch != null && defaultBrowserMatch.priority >= maxMatchPrio2) {
                            if (!TextUtils.isEmpty(defaultBrowserPackageName)) {
                                try {
                                    if (!mHwPMSEx.isMultiScreenCollaborationEnabled(intent)) {
                                        if (debug) {
                                            Slog.v(TAG, "Default browser match " + defaultBrowserMatch);
                                        }
                                        result.add(defaultBrowserMatch);
                                    }
                                } catch (Throwable th3) {
                                    th = th3;
                                    throw th;
                                }
                            }
                        }
                        result.addAll(matchAllList);
                    }
                    if (result.size() == 0) {
                        result.addAll(candidates);
                        result.removeAll(neverList);
                    }
                }
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
        if (DEBUG_PREFERRED || DEBUG_DOMAIN_VERIFICATION) {
            Slog.v(TAG, "Filtered results with preferred activities. New candidates count: " + result.size());
            Iterator<ResolveInfo> it2 = result.iterator();
            while (it2.hasNext()) {
                Slog.v(TAG, "  + " + it2.next().activityInfo);
            }
        }
        return result;
    }

    private long getDomainVerificationStatusLPr(PackageSetting ps, int userId) {
        long result = ps.getDomainVerificationStatusForUser(userId);
        if ((result >> 32) != 0 || ps.getIntentFilterVerificationInfo() == null) {
            return result;
        }
        return ((long) ps.getIntentFilterVerificationInfo().getStatus()) << 32;
    }

    private ResolveInfo querySkipCurrentProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId) {
        ResolveInfo resolveInfo;
        if (matchingFilters == null) {
            return null;
        }
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            if (!((filter.getFlags() & 2) == 0 || (resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId)) == null)) {
                return resolveInfo;
            }
        }
        return null;
    }

    private ResolveInfo queryCrossProfileIntents(List<CrossProfileIntentFilter> matchingFilters, Intent intent, String resolvedType, int flags, int sourceUserId, boolean matchInCurrentProfile) {
        if (matchingFilters == null) {
            return null;
        }
        SparseBooleanArray alreadyTriedUserIds = new SparseBooleanArray();
        int size = matchingFilters.size();
        for (int i = 0; i < size; i++) {
            CrossProfileIntentFilter filter = matchingFilters.get(i);
            int targetUserId = filter.getTargetUserId();
            boolean skipCurrentProfileIfNoMatchFound = false;
            boolean skipCurrentProfile = (filter.getFlags() & 2) != 0;
            if ((filter.getFlags() & 4) != 0) {
                skipCurrentProfileIfNoMatchFound = true;
            }
            if (!skipCurrentProfile && !alreadyTriedUserIds.get(targetUserId) && (!skipCurrentProfileIfNoMatchFound || !matchInCurrentProfile)) {
                ResolveInfo resolveInfo = createForwardingResolveInfo(filter, intent, resolvedType, flags, sourceUserId);
                if (resolveInfo != null) {
                    return resolveInfo;
                }
                alreadyTriedUserIds.put(targetUserId, true);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfo(CrossProfileIntentFilter filter, Intent intent, String resolvedType, int flags, int sourceUserId) {
        int targetUserId = filter.getTargetUserId();
        List<ResolveInfo> resultTargetUser = this.mComponentResolver.queryActivities(intent, resolvedType, flags, targetUserId);
        if (resultTargetUser == null || !isUserEnabled(targetUserId)) {
            return null;
        }
        for (int i = resultTargetUser.size() - 1; i >= 0; i--) {
            if ((resultTargetUser.get(i).activityInfo.applicationInfo.flags & 1073741824) == 0) {
                return createForwardingResolveInfoUnchecked(filter, sourceUserId, targetUserId);
            }
        }
        return null;
    }

    private ResolveInfo createForwardingResolveInfoUnchecked(IntentFilter filter, int sourceUserId, int targetUserId) {
        String className;
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        long ident = Binder.clearCallingIdentity();
        try {
            boolean targetIsProfile = sUserManager.getUserInfo(targetUserId).isManagedProfile();
            if (targetIsProfile) {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_MANAGED_PROFILE;
            } else {
                className = IntentForwarderActivity.FORWARD_INTENT_TO_PARENT;
            }
            ActivityInfo forwardingActivityInfo = getActivityInfo(new ComponentName(this.mAndroidApplication.packageName, className), 0, sourceUserId);
            if (!targetIsProfile) {
                if (forwardingActivityInfo != null) {
                    forwardingActivityInfo.showUserIcon = targetUserId;
                } else {
                    Slog.i(TAG, "get forwarding Activity Info is null. sourceUserId:" + sourceUserId);
                }
                forwardingResolveInfo.noResourceId = true;
            }
            forwardingResolveInfo.activityInfo = forwardingActivityInfo;
            forwardingResolveInfo.priority = 0;
            forwardingResolveInfo.preferredOrder = 0;
            forwardingResolveInfo.match = 0;
            forwardingResolveInfo.isDefault = true;
            forwardingResolveInfo.filter = filter;
            forwardingResolveInfo.targetUserId = targetUserId;
            return forwardingResolveInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ParceledListSlice<ResolveInfo> queryIntentActivityOptions(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentActivityOptionsInternal(caller, specifics, specificTypes, intent, resolvedType, flags, userId));
    }

    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00e6, code lost:
        if (r10 == null) goto L_0x00e9;
     */
    private List<ResolveInfo> queryIntentActivityOptionsInternal(ComponentName caller, Intent[] specifics, String[] specificTypes, Intent intent, String resolvedType, int flags, int userId) {
        String resultsAction;
        int specificsPos;
        String resultsAction2;
        Iterator<String> it;
        String resultsAction3;
        int specificsPos2;
        String resultsAction4;
        int callingUid;
        String str;
        ActivityInfo ai;
        ResolveInfo ri;
        Intent[] intentArr = specifics;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid2 = Binder.getCallingUid();
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid2, false);
        this.mPermissionManager.enforceCrossUserPermission(callingUid2, userId, false, false, "query intent activity options");
        if (intent == null) {
            return Collections.emptyList();
        }
        String resultsAction5 = intent.getAction();
        List<ResolveInfo> results = queryIntentActivitiesInternal(intent, resolvedType, flags2 | 64, userId);
        String str2 = ": ";
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Query " + intent + str2 + results);
        }
        int specificsPos3 = 0;
        if (intentArr != null) {
            int i = 0;
            while (i < intentArr.length) {
                Intent sintent = intentArr[i];
                if (sintent == null) {
                    resultsAction4 = resultsAction5;
                    callingUid = callingUid2;
                } else {
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + sintent);
                    }
                    String action = sintent.getAction();
                    if (resultsAction5 != null && resultsAction5.equals(action)) {
                        action = null;
                    }
                    ResolveInfo ri2 = null;
                    ComponentName comp = sintent.getComponent();
                    if (comp == null) {
                        ResolveInfo ri3 = resolveIntent(sintent, specificTypes != null ? specificTypes[i] : null, flags2, userId);
                        if (ri3 == null) {
                            resultsAction4 = resultsAction5;
                            callingUid = callingUid2;
                        } else {
                            callingUid = callingUid2;
                            ResolveInfo resolveInfo = this.mResolveInfo;
                            ai = ri3.activityInfo;
                            ri2 = ri3;
                            resultsAction4 = resultsAction5;
                            comp = new ComponentName(ai.applicationInfo.packageName, ai.name);
                        }
                    } else {
                        resultsAction4 = resultsAction5;
                        callingUid = callingUid2;
                        ai = getActivityInfo(comp, flags2, userId);
                    }
                    if (DEBUG_INTENT_MATCHING) {
                        Log.v(TAG, "Specific #" + i + str2 + ai);
                    }
                    int N = results.size();
                    int j = specificsPos3;
                    while (j < N) {
                        ResolveInfo sri = results.get(j);
                        if ((sri.activityInfo.name.equals(comp.getClassName()) && sri.activityInfo.applicationInfo.packageName.equals(comp.getPackageName())) || (action != null && sri.filter.matchAction(action))) {
                            results.remove(j);
                            if (DEBUG_INTENT_MATCHING) {
                                Log.v(TAG, "Removing duplicate item from " + j + " due to specific " + specificsPos3);
                            }
                            if (ri2 == null) {
                                ri2 = sri;
                            }
                            j--;
                            N--;
                        }
                        j++;
                        str2 = str2;
                    }
                    str = str2;
                    if (ri2 == null) {
                        ri = new ResolveInfo();
                        ri.activityInfo = ai;
                    } else {
                        ri = ri2;
                    }
                    results.add(specificsPos3, ri);
                    ri.specificIndex = i;
                    specificsPos3++;
                    i++;
                    intentArr = specifics;
                    str2 = str;
                    callingUid2 = callingUid;
                    resultsAction5 = resultsAction4;
                }
                str = str2;
                i++;
                intentArr = specifics;
                str2 = str;
                callingUid2 = callingUid;
                resultsAction5 = resultsAction4;
            }
            resultsAction = resultsAction5;
        } else {
            resultsAction = resultsAction5;
        }
        int N2 = results.size();
        int i2 = specificsPos3;
        while (i2 < N2 - 1) {
            ResolveInfo rii = results.get(i2);
            if (rii.filter == null || (it = rii.filter.actionsIterator()) == null) {
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
            } else {
                while (it.hasNext()) {
                    String action2 = it.next();
                    if (resultsAction != null) {
                        resultsAction3 = resultsAction;
                        if (resultsAction3.equals(action2)) {
                            resultsAction = resultsAction3;
                        }
                    } else {
                        resultsAction3 = resultsAction;
                    }
                    int j2 = i2 + 1;
                    while (j2 < N2) {
                        ResolveInfo rij = results.get(j2);
                        if (rij.filter == null || !rij.filter.hasAction(action2)) {
                            specificsPos2 = specificsPos3;
                        } else {
                            results.remove(j2);
                            if (DEBUG_INTENT_MATCHING) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Removing duplicate item from ");
                                sb.append(j2);
                                specificsPos2 = specificsPos3;
                                sb.append(" due to action ");
                                sb.append(action2);
                                sb.append(" at ");
                                sb.append(i2);
                                Log.v(TAG, sb.toString());
                            } else {
                                specificsPos2 = specificsPos3;
                            }
                            j2--;
                            N2--;
                        }
                        j2++;
                        specificsPos3 = specificsPos2;
                    }
                    resultsAction = resultsAction3;
                }
                specificsPos = specificsPos3;
                resultsAction2 = resultsAction;
                if ((flags2 & 64) == 0) {
                    rii.filter = null;
                }
            }
            i2++;
            resultsAction = resultsAction2;
            specificsPos3 = specificsPos;
        }
        if (caller != null) {
            int N3 = results.size();
            int i3 = 0;
            while (true) {
                if (i3 >= N3) {
                    break;
                }
                ActivityInfo ainfo = results.get(i3).activityInfo;
                if (caller.getPackageName().equals(ainfo.applicationInfo.packageName) && caller.getClassName().equals(ainfo.name)) {
                    results.remove(i3);
                    break;
                }
                i3++;
            }
        }
        if ((flags2 & 64) == 0) {
            int N4 = results.size();
            for (int i4 = 0; i4 < N4; i4++) {
                results.get(i4).filter = null;
            }
        }
        if (DEBUG_INTENT_MATCHING) {
            Log.v(TAG, "Result: " + results);
        }
        return results;
    }

    public ParceledListSlice<ResolveInfo> queryIntentReceivers(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentReceiversInternal(intent, resolvedType, flags, userId, false));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Removed duplicated region for block: B:70:0x00f8  */
    /* JADX WARNING: Removed duplicated region for block: B:71:0x0109  */
    private List<ResolveInfo> queryIntentReceiversInternal(Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) {
        Intent intent2;
        ComponentName comp;
        boolean isTargetExplicitlyVisibleToInstantApp;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        String forbidPackage = comp == null ? intent2.getPackage() : comp.getPackageName();
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx != null && iHwPackageManagerServiceEx.isNeedForbidAppAct(PACKAGE_FORBIDDEN, forbidPackage, null, null)) {
            Slog.i(TAG, "queryIntentReceiversInternal isNeedForbidAppAct forbid");
            return new ArrayList();
        } else if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ActivityInfo ai = getReceiverInfo(comp, flags2, userId);
            if (ai != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean matchExplicitlyVisibleOnly = (33554432 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                boolean isTargetSameInstantApp = comp.getPackageName().equals(instantAppPkgName);
                boolean isTargetInstantApp = (ai.applicationInfo.privateFlags & 128) != 0;
                boolean isTargetVisibleToInstantApp = (ai.flags & 1048576) != 0;
                if (isTargetVisibleToInstantApp) {
                    if ((ai.flags & 2097152) == 0) {
                        isTargetExplicitlyVisibleToInstantApp = true;
                        if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                            ResolveInfo ri = new ResolveInfo();
                            ri.activityInfo = ai;
                            list.add(ri);
                        }
                    }
                }
                isTargetExplicitlyVisibleToInstantApp = false;
                if (isTargetSameInstantApp && ((!matchInstantApp && !isCallerInstantApp && isTargetInstantApp) || (matchVisibleToInstantAppOnly && isCallerInstantApp && (isTargetVisibleToInstantApp || (matchExplicitlyVisibleOnly && !isTargetExplicitlyVisibleToInstantApp))))) {
                }
            }
            return applyPostResolutionFilter(list, instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
        } else {
            synchronized (this.mPackages) {
                String pkgName = intent2.getPackage();
                if (pkgName == null) {
                    return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
                }
                PackageParser.Package pkg = this.mPackages.get(pkgName);
                if (pkg != null) {
                    return applyPostResolutionFilter(this.mComponentResolver.queryReceivers(intent2, resolvedType, flags2, pkg.receivers, userId), instantAppPkgName, allowDynamicSplits, callingUid, false, userId, intent2);
                }
                return Collections.emptyList();
            }
        }
    }

    public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId) {
        return resolveServiceInternal(intent, resolvedType, flags, userId, Binder.getCallingUid());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ResolveInfo resolveServiceInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
        List<ResolveInfo> query;
        if (sUserManager.exists(userId) && (query = queryIntentServicesInternal(intent, resolvedType, updateFlagsForResolve(flags, userId, intent, callingUid, false), userId, callingUid, false)) != null && query.size() >= 1) {
            return query.get(0);
        }
        return null;
    }

    public ParceledListSlice<ResolveInfo> queryIntentServices(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentServicesInternal(intent, resolvedType, flags, userId, Binder.getCallingUid(), false));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ResolveInfo> queryIntentServicesInternal(Intent intent, String resolvedType, int flags, int userId, int callingUid, boolean includeInstantApps) {
        Intent intent2;
        ComponentName comp;
        Throwable th;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "query intent receivers");
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, includeInstantApps);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        String forbidPackage = comp == null ? intent2.getPackage() : comp.getPackageName();
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx != null && iHwPackageManagerServiceEx.isNeedForbidAppAct(PACKAGE_FORBIDDEN, forbidPackage, null, null)) {
            Slog.i(TAG, "queryIntentServicesInternal isNeedForbidAppAct forbid");
            return new ArrayList();
        } else if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ServiceInfo si = getServiceInfo(comp, flags2, userId);
            if (si != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                if (!(!comp.getPackageName().equals(instantAppPkgName) && ((!matchInstantApp && !isCallerInstantApp && ((si.applicationInfo.privateFlags & 128) != 0)) || (matchVisibleToInstantAppOnly && isCallerInstantApp && ((si.flags & 1048576) == 0))))) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.serviceInfo = si;
                    list.add(ri);
                }
            }
            return list;
        } else {
            synchronized (this.mPackages) {
                try {
                    String pkgName = intent2.getPackage();
                    if (pkgName == null) {
                        try {
                            return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, userId), instantAppPkgName);
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } else {
                        PackageParser.Package pkg = this.mPackages.get(pkgName);
                        if (pkg != null) {
                            return applyPostServiceResolutionFilter(this.mComponentResolver.queryServices(intent2, resolvedType, flags2, pkg.services, userId), instantAppPkgName);
                        }
                        return Collections.emptyList();
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }
    }

    private List<ResolveInfo> applyPostServiceResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.serviceInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.serviceInfo.packageName)) {
                if (isEphemeralApp || (info.serviceInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.serviceInfo.splitName != null && !ArrayUtils.contains(info.serviceInfo.applicationInfo.splitNames, info.serviceInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.serviceInfo.packageName, info.serviceInfo.applicationInfo.longVersionCode, info.serviceInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<ResolveInfo> queryIntentContentProviders(Intent intent, String resolvedType, int flags, int userId) {
        return new ParceledListSlice<>(queryIntentContentProvidersInternal(intent, resolvedType, flags, userId));
    }

    private List<ResolveInfo> queryIntentContentProvidersInternal(Intent intent, String resolvedType, int flags, int userId) {
        Intent intent2;
        ComponentName comp;
        Throwable th;
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        String instantAppPkgName = getInstantAppPackageName(callingUid);
        int flags2 = updateFlagsForResolve(flags, userId, intent, callingUid, false);
        if (intent == null) {
            return Collections.emptyList();
        }
        ComponentName comp2 = intent.getComponent();
        if (comp2 != null || intent.getSelector() == null) {
            intent2 = intent;
            comp = comp2;
        } else {
            Intent intent3 = intent.getSelector();
            comp = intent3.getComponent();
            intent2 = intent3;
        }
        String forbidPackage = comp == null ? intent2.getPackage() : comp.getPackageName();
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx != null && iHwPackageManagerServiceEx.isNeedForbidAppAct(PACKAGE_FORBIDDEN, forbidPackage, null, null)) {
            Slog.i(TAG, "queryIntentContentProvidersInternal isNeedForbidAppAct forbid");
            return new ArrayList();
        } else if (comp != null) {
            List<ResolveInfo> list = new ArrayList<>(1);
            ProviderInfo pi = getProviderInfo(comp, flags2, userId);
            if (pi != null) {
                boolean matchInstantApp = (8388608 & flags2) != 0;
                boolean matchVisibleToInstantAppOnly = (16777216 & flags2) != 0;
                boolean isCallerInstantApp = instantAppPkgName != null;
                if (!(!comp.getPackageName().equals(instantAppPkgName) && ((!matchInstantApp && !isCallerInstantApp && ((pi.applicationInfo.privateFlags & 128) != 0)) || (matchVisibleToInstantAppOnly && isCallerInstantApp && ((pi.flags & 1048576) == 0))))) {
                    ResolveInfo ri = new ResolveInfo();
                    ri.providerInfo = pi;
                    list.add(ri);
                }
            }
            return list;
        } else {
            synchronized (this.mPackages) {
                try {
                    String pkgName = intent2.getPackage();
                    if (pkgName == null) {
                        try {
                            return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, userId), instantAppPkgName);
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } else {
                        PackageParser.Package pkg = this.mPackages.get(pkgName);
                        if (pkg != null) {
                            return applyPostContentProviderResolutionFilter(this.mComponentResolver.queryProviders(intent2, resolvedType, flags2, pkg.providers, userId), instantAppPkgName);
                        }
                        return Collections.emptyList();
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            }
        }
    }

    private List<ResolveInfo> applyPostContentProviderResolutionFilter(List<ResolveInfo> resolveInfos, String instantAppPkgName) {
        if (instantAppPkgName == null) {
            return resolveInfos;
        }
        for (int i = resolveInfos.size() - 1; i >= 0; i--) {
            ResolveInfo info = resolveInfos.get(i);
            boolean isEphemeralApp = info.providerInfo.applicationInfo.isInstantApp();
            if (!isEphemeralApp || !instantAppPkgName.equals(info.providerInfo.packageName)) {
                if (isEphemeralApp || (info.providerInfo.flags & 1048576) == 0) {
                    resolveInfos.remove(i);
                }
            } else if (info.providerInfo.splitName != null && !ArrayUtils.contains(info.providerInfo.applicationInfo.splitNames, info.providerInfo.splitName)) {
                if (DEBUG_INSTANT) {
                    Slog.v(TAG, "Adding ephemeral installer to the ResolveInfo list");
                }
                ResolveInfo installerInfo = new ResolveInfo(this.mInstantAppInstallerInfo);
                installerInfo.auxiliaryInfo = new AuxiliaryResolveInfo((ComponentName) null, info.providerInfo.packageName, info.providerInfo.applicationInfo.longVersionCode, info.providerInfo.splitName);
                installerInfo.filter = new IntentFilter();
                installerInfo.resolvePackageName = info.getComponentInfo().packageName;
                resolveInfos.set(i, installerInfo);
            }
        }
        return resolveInfos;
    }

    public ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId) {
        ArrayList<PackageInfo> list;
        ParceledListSlice<PackageInfo> parceledListSlice;
        long startTime = SystemClock.uptimeMillis();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDPACKAGES);
            if (getInstantAppPackageName(callingUid) != null) {
                return ParceledListSlice.emptyList();
            }
            if (!sUserManager.exists(userId)) {
                ParceledListSlice<PackageInfo> emptyList = ParceledListSlice.emptyList();
                Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return emptyList;
            }
            int flags2 = updateFlagsForPackage(flags, userId, null);
            boolean listFactory = true;
            boolean listUninstalled = (4202496 & flags2) != 0;
            boolean listApex = (1073741824 & flags2) != 0;
            if ((2097152 & flags2) == 0) {
                listFactory = false;
            }
            this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed packages");
            synchronized (this.mPackages) {
                if (listUninstalled) {
                    list = new ArrayList<>(this.mSettings.mPackages.size());
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                            if (!filterAppAccessLPr(ps, callingUid, userId)) {
                                PackageInfo pi = generatePackageInfo(ps, flags2, userId);
                                if (pi != null) {
                                    list.add(pi);
                                }
                            }
                        }
                    }
                } else {
                    list = new ArrayList<>(this.mPackages.size());
                    for (PackageParser.Package p : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (!filterSharedLibPackageLPr(ps2, callingUid, userId, flags2)) {
                            if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                PackageInfo pi2 = generatePackageInfo((PackageSetting) p.mExtras, flags2, userId);
                                if (pi2 != null) {
                                    list.add(pi2);
                                }
                            }
                        }
                    }
                }
                if (listApex) {
                    if (listFactory) {
                        list.addAll(this.mApexManager.getFactoryPackages());
                    } else {
                        list.addAll(this.mApexManager.getActivePackages());
                    }
                    if (listUninstalled) {
                        list.addAll(this.mApexManager.getInactivePackages());
                    }
                }
                parceledListSlice = new ParceledListSlice<>(list);
            }
            Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags2 + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            return parceledListSlice;
        } finally {
            Log.i(TAG, "getInstalledPackages cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
        }
    }

    private void addPackageHoldingPermissions(ArrayList<PackageInfo> list, PackageSetting ps, String[] permissions, boolean[] tmp, int flags, int userId) {
        PackageInfo pi;
        int numMatch = 0;
        for (int i = 0; i < permissions.length; i++) {
            if (checkPermission(permissions[i], ps.name, userId) == 0) {
                tmp[i] = true;
                numMatch++;
            } else {
                tmp[i] = false;
            }
        }
        if (!(numMatch == 0 || (pi = generatePackageInfo(ps, flags, userId)) == null)) {
            if ((flags & 4096) == 0) {
                if (numMatch == permissions.length) {
                    pi.requestedPermissions = permissions;
                } else {
                    pi.requestedPermissions = new String[numMatch];
                    int numMatch2 = 0;
                    for (int i2 = 0; i2 < permissions.length; i2++) {
                        if (tmp[i2]) {
                            pi.requestedPermissions[numMatch2] = permissions[i2];
                            numMatch2++;
                        }
                    }
                }
            }
            list.add(pi);
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:39:0x0096 */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:10:0x0037 */
    /* JADX WARN: Type inference failed for: r4v0 */
    /* JADX WARN: Type inference failed for: r4v1 */
    /* JADX WARN: Type inference failed for: r4v8 */
    public ParceledListSlice<PackageInfo> getPackagesHoldingPermissions(String[] permissions, int flags, int userId) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = updateFlagsForPackage(flags, userId, permissions);
        ArrayMap<String, PackageParser.Package> arrayMap3 = 1;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "get packages holding permissions");
        boolean listUninstalled = (flags2 & 4202496) != 0;
        ArrayMap<String, PackageParser.Package> arrayMap4 = this.mPackages;
        synchronized (arrayMap4) {
            try {
                ArrayList<PackageInfo> list = new ArrayList<>();
                boolean[] tmpBools = new boolean[permissions.length];
                if (listUninstalled) {
                    for (PackageSetting ps : this.mSettings.mPackages.values()) {
                        addPackageHoldingPermissions(list, ps, permissions, tmpBools, flags2, userId);
                    }
                    arrayMap2 = arrayMap4;
                } else {
                    for (PackageParser.Package pkg : this.mPackages.values()) {
                        PackageSetting ps2 = (PackageSetting) pkg.mExtras;
                        if (ps2 != null) {
                            arrayMap3 = arrayMap4;
                            addPackageHoldingPermissions(list, ps2, permissions, tmpBools, flags2, userId);
                        } else {
                            arrayMap3 = arrayMap4;
                        }
                        arrayMap4 = arrayMap3;
                    }
                    arrayMap2 = arrayMap4;
                }
                ParceledListSlice<PackageInfo> parceledListSlice = new ParceledListSlice<>(list);
                return parceledListSlice;
            } catch (Throwable th) {
                th = th;
                arrayMap = arrayMap3;
                throw th;
            }
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ParceledListSlice<ApplicationInfo> getInstalledApplications(int flags, int userId) {
        Throwable th;
        long startTime = SystemClock.uptimeMillis();
        int callingPid = Binder.getCallingPid();
        int callingUid = Binder.getCallingUid();
        try {
            HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_GETINSTALLEDAPPLICATIONS);
            try {
                ParceledListSlice<ApplicationInfo> parceledListSlice = new ParceledListSlice<>(getInstalledApplicationsListInternal(flags, userId, callingUid));
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                return parceledListSlice;
            } catch (Throwable th2) {
                th = th2;
                Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
                throw th;
            }
        } catch (Throwable th3) {
            th = th3;
            Log.i(TAG, "getInstalledApplications cost " + (SystemClock.uptimeMillis() - startTime) + " ms, flags: " + flags + ", userId: " + userId + ", callingUid: " + callingUid + ", callingPid: " + callingPid);
            throw th;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ApplicationInfo> getInstalledApplicationsListInternal(int flags, int userId, int callingUid) {
        ArrayList<ApplicationInfo> list;
        ApplicationInfo ai;
        if (getInstantAppPackageName(callingUid) != null) {
            return Collections.emptyList();
        }
        if (!sUserManager.exists(userId)) {
            return Collections.emptyList();
        }
        int flags2 = updateFlagsForApplication(flags, userId, null);
        boolean listUninstalled = (4202496 & flags2) != 0;
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get installed application info");
        synchronized (this.mPackages) {
            if (listUninstalled) {
                list = new ArrayList<>(this.mSettings.mPackages.size());
                for (PackageSetting ps : this.mSettings.mPackages.values()) {
                    int effectiveFlags = flags2;
                    if (ps.isSystem()) {
                        effectiveFlags |= 4194304;
                    }
                    if (ps.pkg == null) {
                        ai = generateApplicationInfoFromSettingsLPw(ps.name, callingUid, effectiveFlags, userId);
                    } else if (!filterSharedLibPackageLPr(ps, callingUid, userId, flags2)) {
                        if (!filterAppAccessLPr(ps, callingUid, userId)) {
                            ai = PackageParser.generateApplicationInfo(ps.pkg, effectiveFlags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                ai.packageName = resolveExternalPackageNameLPr(ps.pkg);
                            }
                        }
                    }
                    if (ai != null) {
                        list.add(ai);
                    }
                }
            } else {
                list = new ArrayList<>(this.mPackages.size());
                for (PackageParser.Package p : this.mPackages.values()) {
                    if (p.mExtras != null) {
                        PackageSetting ps2 = (PackageSetting) p.mExtras;
                        if (!filterSharedLibPackageLPr(ps2, Binder.getCallingUid(), userId, flags2)) {
                            if (!filterAppAccessLPr(ps2, callingUid, userId)) {
                                ApplicationInfo ai2 = PackageParser.generateApplicationInfo(p, flags2, ps2.readUserState(userId), userId);
                                if (ai2 != null) {
                                    ai2.packageName = resolveExternalPackageNameLPr(p);
                                    list.add(ai2);
                                }
                            }
                        }
                    }
                }
            }
        }
        return list;
    }

    public ParceledListSlice<InstantAppInfo> getInstantApps(int userId) {
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getEphemeralApplications");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getEphemeralApplications");
        synchronized (this.mPackages) {
            List<InstantAppInfo> instantApps = this.mInstantAppRegistry.getInstantAppsLPr(userId);
            if (instantApps == null) {
                return null;
            }
            return new ParceledListSlice<>(instantApps);
        }
    }

    public boolean isInstantApp(String packageName, int userId) {
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "isInstantApp");
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            if (Process.isIsolated(callingUid)) {
                callingUid = this.mIsolatedOwners.get(callingUid);
            }
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            this.mPackages.get(packageName);
            if (!(ps != null && (isCallerSameApp(packageName, callingUid) || canViewInstantApps(callingUid, userId) || this.mInstantAppRegistry.isInstantAccessGranted(userId, UserHandle.getAppId(callingUid), ps.appId)))) {
                return false;
            }
            return ps.getInstantApp(userId);
        }
    }

    public byte[] getInstantAppCookie(String packageName, int userId) {
        byte[] instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.getInstantAppCookieLPw(packageName, userId);
        }
        return instantAppCookieLPw;
    }

    public boolean setInstantAppCookie(String packageName, byte[] cookie, int userId) {
        boolean instantAppCookieLPw;
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, true, "setInstantAppCookie");
        if (!isCallerSameApp(packageName, Binder.getCallingUid())) {
            return false;
        }
        synchronized (this.mPackages) {
            instantAppCookieLPw = this.mInstantAppRegistry.setInstantAppCookieLPw(packageName, cookie, userId);
        }
        return instantAppCookieLPw;
    }

    public Bitmap getInstantAppIcon(String packageName, int userId) {
        Bitmap instantAppIconLPw;
        if (!canViewInstantApps(Binder.getCallingUid(), userId)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppIcon");
        }
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppIcon");
        synchronized (this.mPackages) {
            instantAppIconLPw = this.mInstantAppRegistry.getInstantAppIconLPw(packageName, userId);
        }
        return instantAppIconLPw;
    }

    private boolean isCallerSameApp(String packageName, int uid) {
        PackageParser.Package pkg = this.mPackages.get(packageName);
        return pkg != null && UserHandle.getAppId(uid) == pkg.applicationInfo.uid;
    }

    public ParceledListSlice<ApplicationInfo> getPersistentApplications(int flags) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(getPersistentApplicationsInternal(flags));
    }

    private List<ApplicationInfo> getPersistentApplicationsInternal(int flags) {
        PackageSetting ps;
        ArrayList<ApplicationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            int userId = UserHandle.getCallingUserId();
            for (PackageParser.Package p : this.mPackages.values()) {
                if (p.applicationInfo != null) {
                    boolean matchesAware = true;
                    boolean matchesUnaware = (262144 & flags) != 0 && !p.applicationInfo.isDirectBootAware();
                    if ((524288 & flags) == 0 || !p.applicationInfo.isDirectBootAware()) {
                        matchesAware = false;
                    }
                    if ((p.applicationInfo.flags & 8) != 0 && ((!this.mSafeMode || isSystemApp(p)) && ((matchesUnaware || matchesAware) && (ps = this.mSettings.mPackages.get(p.packageName)) != null))) {
                        boolean isPersistent = getHwPMSEx().isReservePersistentApp(ps);
                        if (!this.mSafeMode || isPersistent) {
                            ApplicationInfo ai = PackageParser.generateApplicationInfo(p, flags, ps.readUserState(userId), userId);
                            if (ai != null) {
                                finalList.add(ai);
                            }
                        }
                    }
                }
            }
        }
        return finalList;
    }

    public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
        return resolveContentProviderInternal(name, flags, userId);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ProviderInfo resolveContentProviderInternal(String name, int flags, int userId) {
        if (!sUserManager.exists(userId)) {
            return null;
        }
        int flags2 = updateFlagsForComponent(flags, userId, name);
        int callingUid = Binder.getCallingUid();
        ProviderInfo providerInfo = this.mComponentResolver.queryProvider(name, flags2, userId);
        if (providerInfo == null || !this.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                return null;
            }
            return providerInfo;
        }
    }

    @Deprecated
    public void querySyncProviders(List<String> outNames, List<ProviderInfo> outInfo) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            this.mComponentResolver.querySyncProviders(outNames, outInfo, this.mSafeMode, UserHandle.getCallingUserId());
        }
    }

    public ParceledListSlice<ProviderInfo> queryContentProviders(String processName, int uid, int flags, String metaDataKey) {
        int userId;
        ArrayList<ProviderInfo> finalList;
        PackageManagerService packageManagerService = this;
        int callingUid = Binder.getCallingUid();
        if (processName != null) {
            userId = UserHandle.getUserId(uid);
        } else {
            userId = UserHandle.getCallingUserId();
        }
        if (!sUserManager.exists(userId)) {
            return ParceledListSlice.emptyList();
        }
        int flags2 = packageManagerService.updateFlagsForComponent(flags, userId, processName);
        List<ProviderInfo> matchList = packageManagerService.mComponentResolver.queryProviders(processName, metaDataKey, uid, flags2, userId);
        int listSize = matchList == null ? 0 : matchList.size();
        synchronized (packageManagerService.mPackages) {
            finalList = null;
            int i = 0;
            while (i < listSize) {
                ProviderInfo providerInfo = matchList.get(i);
                if (packageManagerService.mSettings.isEnabledAndMatchLPr(providerInfo, flags2, userId)) {
                    if (!filterAppAccessLPr(packageManagerService.mSettings.mPackages.get(providerInfo.packageName), callingUid, new ComponentName(providerInfo.packageName, providerInfo.name), 4, userId)) {
                        if (finalList == null) {
                            finalList = new ArrayList<>(listSize - i);
                        }
                        finalList.add(providerInfo);
                    }
                }
                i++;
                packageManagerService = this;
            }
        }
        if (finalList == null) {
            return ParceledListSlice.emptyList();
        }
        finalList.sort(sProviderInitOrderSorter);
        return new ParceledListSlice<>(finalList);
    }

    public InstrumentationInfo getInstrumentationInfo(ComponentName component, int flags) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageSetting ps = this.mSettings.mPackages.get(component.getPackageName());
            if (ps == null) {
                return null;
            }
            if (filterAppAccessLPr(ps, callingUid, component, 0, callingUserId)) {
                return null;
            }
            return PackageParser.generateInstrumentationInfo(this.mInstrumentation.get(component), flags);
        }
    }

    public ParceledListSlice<InstrumentationInfo> queryInstrumentation(String targetPackage, int flags) {
        int callingUid = Binder.getCallingUid();
        if (filterAppAccessLPr(this.mSettings.mPackages.get(targetPackage), callingUid, UserHandle.getUserId(callingUid))) {
            return ParceledListSlice.emptyList();
        }
        return new ParceledListSlice<>(queryInstrumentationInternal(targetPackage, flags));
    }

    private List<InstrumentationInfo> queryInstrumentationInternal(String targetPackage, int flags) {
        InstrumentationInfo ii;
        ArrayList<InstrumentationInfo> finalList = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Instrumentation p : this.mInstrumentation.values()) {
                if ((targetPackage == null || targetPackage.equals(p.info.targetPackage)) && (ii = PackageParser.generateInstrumentationInfo(p, flags)) != null) {
                    finalList.add(ii);
                }
            }
        }
        return finalList;
    }

    private void scanDirTracedLI(File scanDir, int parseFlags, int scanFlags, long currentTime) {
        Trace.traceBegin(262144, "scanDir [" + scanDir.getAbsolutePath() + "]");
        try {
            scanDirLI(scanDir, parseFlags, scanFlags, currentTime);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        scanDirLI(dir, parseFlags, scanFlags, currentTime, 0);
    }

    /* access modifiers changed from: protected */
    public void scanDirLI(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        File[] files = scanDir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, "No files in app dir " + scanDir);
            return;
        }
        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, "Scanning app dir " + scanDir + " scanFlags=" + scanFlags + " flags=0x" + Integer.toHexString(parseFlags) + " hwFlags=0x" + Integer.toHexString(hwFlags));
        }
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:62:0x015c  */
    /* JADX WARNING: Removed duplicated region for block: B:65:0x0181  */
    public void scanPackageFilesLI(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        Throwable th;
        ParallelPackageParser.ParseResult parseResult;
        int errorCode;
        String str;
        PackageManagerException e;
        ParallelPackageParser parallelPackageParser = new ParallelPackageParser(this.mSeparateProcesses, this.mOnlyCore, this.mMetrics, this.mCacheDir, this.mParallelPackageParserCallback);
        try {
            int fileCount = 0;
            for (File file : files) {
                try {
                    if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                        if (!mHwPMSEx.isUninstallApk(file.getPath() + ".apk") || (IS_AUTO_INSTALL_ENABLE && mHwPMSEx.isRemoveUnstallApk(file))) {
                            HwCustEmergDataManager emergDataManager = HwCustEmergDataManager.getDefault();
                            if (emergDataManager == null || emergDataManager.isEmergencyState() || !emergDataManager.getEmergencyPkgName().contains(file.getName())) {
                                parallelPackageParser.submit(file, parseFlags);
                                fileCount++;
                            } else {
                                Log.i(TAG, "dont scan EmergencyData.apk");
                            }
                        }
                    }
                } catch (Throwable th2) {
                    th = th2;
                    try {
                        throw th;
                    } catch (Throwable th3) {
                        $closeResource(th, parallelPackageParser);
                        throw th3;
                    }
                }
            }
            for (int fileCount2 = fileCount; fileCount2 > 0; fileCount2--) {
                ParallelPackageParser.ParseResult parseResult2 = parallelPackageParser.take();
                Throwable throwable = parseResult2.throwable;
                if (throwable == null) {
                    if (parseResult2.pkg.applicationInfo.isStaticSharedLibrary()) {
                        renameStaticSharedLibraryPackage(parseResult2.pkg);
                    }
                    if (this.mDelPackageList == null || !this.mDelPackageList.contains(parseResult2.pkg.packageName)) {
                        try {
                            mHwPMSEx.recordPreasApp(parseResult2.pkg.packageName, parseResult2.pkg.codePath);
                            str = ": ";
                            parseResult = parseResult2;
                            try {
                                scanPackageChildLI(parseResult2.pkg, parseFlags, scanFlags, currentTime, null, hwFlags);
                                errorCode = 1;
                            } catch (PackageManagerException e2) {
                                e = e2;
                                int errorCode2 = e.error;
                                Slog.w(TAG, "Failed to scan " + parseResult.scanFile + str + e.getMessage());
                                errorCode = errorCode2;
                                if ((scanFlags & 131072) == 0) {
                                }
                            }
                        } catch (PackageManagerException e3) {
                            e = e3;
                            str = ": ";
                            parseResult = parseResult2;
                            int errorCode22 = e.error;
                            Slog.w(TAG, "Failed to scan " + parseResult.scanFile + str + e.getMessage());
                            errorCode = errorCode22;
                            if ((scanFlags & 131072) == 0) {
                            }
                        }
                    } else {
                        deletePackageIfUnusedLPr(parseResult2.pkg.packageName);
                    }
                } else {
                    parseResult = parseResult2;
                    if (throwable instanceof PackageParser.PackageParserException) {
                        PackageParser.PackageParserException e4 = (PackageParser.PackageParserException) throwable;
                        int errorCode3 = e4.error;
                        Slog.w(TAG, "Failed to parse " + parseResult.scanFile + ": " + e4.getMessage());
                        errorCode = errorCode3;
                    } else {
                        throw new IllegalStateException("Unexpected exception occurred while parsing " + parseResult.scanFile, throwable);
                    }
                }
                if ((scanFlags & 131072) == 0) {
                    if (errorCode != 1) {
                        reportApkScanError(errorCode, parseResult.scanFile);
                        PackageManagerServiceUtils.logCriticalInfo(5, "Deleting invalid package at " + parseResult.scanFile);
                        removeCodePathLI(parseResult.scanFile);
                    }
                }
            }
            $closeResource(null, parallelPackageParser);
        } catch (Throwable th4) {
            th = th4;
            throw th;
        }
    }

    private void reportApkScanError(int errorCode, File file) {
        long elapsedRealtime = SystemClock.elapsedRealtime();
        Slog.i(TAG, "scan userdata apps error, errorCode:" + errorCode + ", file name:" + file.getName() + ", elapsedRealtime: " + elapsedRealtime);
        HwPackageManagerServiceUtils.reportPmsDeleteDataApp(errorCode, file.getName(), elapsedRealtime);
    }

    public static void reportSettingsProblem(int priority, String msg) {
        PackageManagerServiceUtils.logCriticalInfo(priority, msg);
    }

    private void collectCertificatesLI(PackageSetting ps, PackageParser.Package pkg, boolean forceCollect, boolean skipVerify) throws PackageManagerException {
        long lastModifiedTime = this.mIsPreNMR1Upgrade ? new File(pkg.codePath).lastModified() : PackageManagerServiceUtils.getLastModifiedTime(pkg);
        Settings.VersionInfo settingsVersionForPackage = getSettingsVersionForPackage(pkg);
        if (ps == null || forceCollect || !ps.codePathString.equals(pkg.codePath) || ps.timeStamp != lastModifiedTime || isCompatSignatureUpdateNeeded(settingsVersionForPackage) || isRecoverSignatureUpdateNeeded(settingsVersionForPackage)) {
            StringBuilder sb = new StringBuilder();
            sb.append(pkg.codePath);
            sb.append(" changed; collecting certs");
            sb.append(forceCollect ? " (forced)" : "");
            Slog.i(TAG, sb.toString());
        } else if (ps.signatures.mSigningDetails.signatures == null || ps.signatures.mSigningDetails.signatures.length == 0 || ps.signatures.mSigningDetails.signatureSchemeVersion == 0) {
            Slog.w(TAG, "PackageSetting for " + ps.name + " is missing signatures.  Collecting certs again to recover them.,skipVerify=" + skipVerify);
        } else if (ps.pkg == null || !ps.pkg.mRealSigningDetails.hasSignatures()) {
            pkg.mSigningDetails = new PackageParser.SigningDetails(ps.signatures.mSigningDetails);
            return;
        } else {
            pkg.mSigningDetails = new PackageParser.SigningDetails(ps.pkg.mRealSigningDetails);
            Log.w(TAG, "get signature from mRealSigningDetails");
            return;
        }
        try {
            Trace.traceBegin(262144, "collectCertificates");
            PackageParser.collectCertificates(pkg, skipVerify);
            Trace.traceEnd(262144);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    private void maybeClearProfilesForUpgradesLI(PackageSetting originalPkgSetting, PackageParser.Package currentPkg) {
        if (originalPkgSetting != null && isDeviceUpgrading() && originalPkgSetting.versionCode != ((long) currentPkg.mVersionCode)) {
            clearAppProfilesLIF(currentPkg, -1);
            if (DEBUG_INSTALL) {
                Slog.d(TAG, originalPkgSetting.name + " clear profile due to version change " + originalPkgSetting.versionCode + " != " + currentPkg.mVersionCode);
            }
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageTracedLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    private PackageParser.Package scanPackageTracedLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Trace.traceBegin(262144, "scanPackage [" + scanFile.toString() + "]");
        try {
            return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: protected */
    @GuardedBy({"mInstallLock", "mPackages"})
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* access modifiers changed from: protected */
    public PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx.isUninstallApk(scanFile.getPath() + ".apk") && (!IS_AUTO_INSTALL_ENABLE || !mHwPMSEx.isScanInstallApk(scanFile.getPath()))) {
            return null;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Parsing: " + scanFile);
        }
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(this.mSeparateProcesses);
        pp.setOnlyCoreApps(this.mOnlyCore);
        pp.setDisplayMetrics(this.mMetrics);
        pp.setCallback(this.mPackageParserCallback);
        pp.setCacheDir(this.mCacheDir);
        Trace.traceBegin(262144, "parsePackage");
        try {
            PackageParser.Package pkg = pp.parsePackage(scanFile, parseFlags, true, hwFlags);
            Trace.traceEnd(262144);
            if (pkg.applicationInfo.isStaticSharedLibrary()) {
                renameStaticSharedLibraryPackage(pkg);
            }
            return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, hwFlags);
        } catch (PackageParser.PackageParserException e) {
            throw PackageManagerException.from(e);
        } catch (Throwable pkg2) {
            Trace.traceEnd(262144);
            throw pkg2;
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Removed duplicated region for block: B:11:0x0037  */
    /* JADX WARNING: Removed duplicated region for block: B:12:0x003a  */
    /* JADX WARNING: Removed duplicated region for block: B:21:0x0076 A[RETURN] */
    /* JADX WARNING: Removed duplicated region for block: B:22:0x0078  */
    private PackageParser.Package scanPackageChildLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        int fixedScanFlags;
        int hwFlags2;
        int hwFlags3;
        int scanFlags2;
        ArrayList<PackageParser.Package> arrayList;
        if (!pkg.codePath.startsWith(SYSTEM_ROOT_DIR)) {
            if (locationIsProduct(pkg.codePath)) {
                fixedScanFlags = scanFlags | 2097152;
            } else if (locationIsVendor(pkg.codePath)) {
                fixedScanFlags = scanFlags | 1048576;
            }
            if ((pkg.applicationInfo.hwFlags & 1048576) == 0) {
                hwFlags2 = hwFlags | 1048576;
            } else {
                hwFlags2 = hwFlags;
            }
            pkg.applicationInfo.hwFlags = hwFlags2;
            if (mHwPMSEx.isPreRemovableApp(pkg.codePath) || (hwFlags2 & DumpState.DUMP_APEX) != 0) {
                hwFlags3 = hwFlags2;
            } else {
                int hwFlags4 = hwFlags2 | DumpState.DUMP_APEX;
                pkg.applicationInfo.hwFlags = hwFlags2 | DumpState.DUMP_APEX;
                hwFlags3 = hwFlags4;
            }
            pkg.applicationInfo.forceDarkMode = mHwPMSEx.getForceDarkSetting(pkg.packageName);
            if (!mHwPMSEx.isInMspesForbidInstallPackageList(pkg.packageName)) {
                return null;
            }
            if (mHwPMSEx.isInMultiWinWhiteList(pkg.packageName)) {
                pkg.forceResizeableAllActivity();
            }
            if ((fixedScanFlags & 1024) != 0) {
                scanFlags2 = fixedScanFlags & -1025;
            } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
                scanFlags2 = fixedScanFlags;
            } else {
                scanFlags2 = fixedScanFlags | 1024;
            }
            int childCount = 0;
            boolean isNewInstall = (hwFlags3 & 1073741824) != 0 && !this.mPackages.containsKey(pkg.packageName);
            PackageParser.Package scannedPkg = addForInitLI(pkg, parseFlags, scanFlags2, currentTime, user, hwFlags3);
            if (pkg.childPackages != null) {
                childCount = pkg.childPackages.size();
            }
            for (int i = 0; i < childCount; i++) {
                addForInitLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user, hwFlags3);
            }
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageChildLI(pkg, parseFlags, scanFlags2, currentTime, user, hwFlags3);
            }
            if (!(!this.mCotaFlag || (arrayList = this.mTempPkgList) == null || scannedPkg == null)) {
                arrayList.add(pkg);
            }
            mHwPMSEx.doPostScanInstall(pkg, user, isNewInstall, hwFlags3, scannedPkg);
            return scannedPkg;
        }
        fixedScanFlags = scanFlags;
        if ((pkg.applicationInfo.hwFlags & 1048576) == 0) {
        }
        pkg.applicationInfo.hwFlags = hwFlags2;
        if (mHwPMSEx.isPreRemovableApp(pkg.codePath)) {
        }
        hwFlags3 = hwFlags2;
        pkg.applicationInfo.forceDarkMode = mHwPMSEx.getForceDarkSetting(pkg.packageName);
        if (!mHwPMSEx.isInMspesForbidInstallPackageList(pkg.packageName)) {
        }
    }

    private boolean canSkipForcedPackageVerification(PackageParser.Package pkg) {
        if (!canSkipForcedApkVerification(pkg.baseCodePath)) {
            return false;
        }
        if (ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            return true;
        }
        for (int i = 0; i < pkg.splitCodePaths.length; i++) {
            if (!canSkipForcedApkVerification(pkg.splitCodePaths[i])) {
                return false;
            }
        }
        return true;
    }

    /* JADX WARNING: Code restructure failed: missing block: B:17:0x0021, code lost:
        r1 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:18:0x0022, code lost:
        android.util.Slog.w(com.android.server.pm.PackageManagerService.TAG, "Error in fsverity check. Fallback to full apk verification.", r1);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:19:0x0029, code lost:
        return false;
     */
    /* JADX WARNING: Removed duplicated region for block: B:17:0x0021 A[ExcHandler: InstallerException | IOException | DigestException | NoSuchAlgorithmException (r1v1 'e' java.lang.Exception A[CUSTOM_DECLARE]), Splitter:B:15:0x0020] */
    private boolean canSkipForcedApkVerification(String apkPath) {
        if (!PackageManagerServiceUtils.isLegacyApkVerityEnabled()) {
            return VerityUtils.hasFsverity(apkPath);
        }
        byte[] rootHashObserved = VerityUtils.generateApkVerityRootHash(apkPath);
        if (rootHashObserved == null) {
            return false;
        }
        synchronized (this.mInstallLock) {
            this.mInstaller.assertFsverityRootHashMatches(apkPath, rootHashObserved);
        }
        return true;
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return addForInitLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:369:0x0792, code lost:
        r0 = th;
     */
    /* JADX WARNING: Removed duplicated region for block: B:191:0x0375 A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:247:0x04ab  */
    /* JADX WARNING: Removed duplicated region for block: B:248:0x04ae  */
    /* JADX WARNING: Removed duplicated region for block: B:305:0x0671  */
    /* JADX WARNING: Removed duplicated region for block: B:344:0x0762  */
    private PackageParser.Package addForInitLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        Throwable th;
        boolean pkgAlreadyExists;
        boolean isSystemPkgUpdated;
        SharedUserSetting sharedUserSetting;
        int scanFlags2;
        PackageSetting disabledPkgSetting;
        PackageSetting pkgSetting;
        InstallArgs args;
        int hwFlags2;
        boolean skipVerify;
        boolean isUpdate;
        boolean shouldHideSystemApp;
        boolean isSystemAppGrantByMdm;
        PackageParser.Package r13;
        PackageSetting pkgSetting2;
        ScanResult scanResult;
        PackageSetting pkgSetting3;
        PackageSetting pkgSetting4;
        Throwable th2;
        PackageFreezer freezer;
        IHwPluginPackage pluginPackage;
        int i;
        int scannedChildCount;
        PackageSetting originalPkgSetting;
        boolean scanSystemPartition = (parseFlags & 16) != 0;
        boolean scanSystemPartition2 = (scanSystemPartition || !isSystemApp(pkg) || !isSystemAppGrantByMdmAndNonPreload(pkg.packageName, pkg.codePath, pkg.volumeUuid)) ? scanSystemPartition : true;
        synchronized (this.mPackages) {
            if ((1073741824 & hwFlags) == 0) {
                PackageSetting psTemp = this.mSettings.getPackageLPr(pkg.packageName);
                if (!mHwPMSEx.needInstallRemovablePreApk(pkg, hwFlags)) {
                    mHwPMSEx.addUninstallDataToCache(pkg.packageName, pkg.codePath);
                    if (psTemp == null || !psTemp.isAnyInstalled(sUserManager.getUserIds()) || (this.mSettings.getDisabledSystemPkgLPr(pkg.packageName) == null && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/"))) {
                        Slog.d(TAG, "scan return here for package:" + pkg.packageName);
                        return null;
                    }
                } else if (psTemp != null && pkg.codePath != null && !pkg.codePath.startsWith("/data/app/") && psTemp.codePathString != null && psTemp.codePathString.startsWith("/data/app/") && !scanSystemPartition2 && ((long) pkg.mVersionCode) <= psTemp.versionCode) {
                    Slog.d(TAG, "scan return here for ota nosys package:" + pkg.packageName);
                    mHwPMSEx.recordUninstalledDelapp(pkg.packageName, pkg.codePath.toString());
                    return null;
                }
            }
        }
        pkg.setApplicationVolumeUuid(pkg.volumeUuid);
        pkg.setApplicationInfoCodePath(pkg.codePath);
        pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
        pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
        pkg.setApplicationInfoResourcePath(pkg.codePath);
        pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
        pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
        synchronized (this.mPackages) {
            try {
                String renamedPkgName = this.mSettings.getRenamedPackageLPr(pkg.mRealPackage);
                String realPkgName = getRealPackageName(pkg, renamedPkgName);
                if (realPkgName != null) {
                    ensurePackageRenamed(pkg, renamedPkgName);
                }
                PackageSetting originalPkgSetting2 = getOriginalPackageLocked(pkg, renamedPkgName);
                PackageSetting pkgSetting5 = originalPkgSetting2 == null ? this.mSettings.getPackageLPr(pkg.packageName) : originalPkgSetting2;
                pkgAlreadyExists = pkgSetting5 != null;
                String disabledPkgName = pkgAlreadyExists ? pkgSetting5.name : pkg.packageName;
                if (scanSystemPartition2 && !pkgAlreadyExists && this.mSettings.getDisabledSystemPkgLPr(disabledPkgName) != null) {
                    this.mSettings.removeDisabledSystemPackageLPw(disabledPkgName);
                    Slog.w(TAG, disabledPkgName + " updated but found that the pkg is not already exists, remove updated info!");
                }
                PackageSetting disabledPkgSetting2 = this.mSettings.getDisabledSystemPkgLPr(disabledPkgName);
                isSystemPkgUpdated = disabledPkgSetting2 != null;
                if (DEBUG_INSTALL && isSystemPkgUpdated) {
                    Slog.d(TAG, "updatedPkg = " + disabledPkgSetting2);
                }
                this.mSettings.addReservedUidForSharedUser(pkg.mSharedUserId, pkg.packageName);
                if (pkg.mSharedUserId != null) {
                    sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
                } else {
                    sharedUserSetting = null;
                }
                if (!(!DEBUG_PACKAGE_SCANNING || (Integer.MIN_VALUE & parseFlags) == 0 || sharedUserSetting == null)) {
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + sharedUserSetting.userId + "): packages=" + sharedUserSetting.packages);
                }
                if (!scanSystemPartition2) {
                    i = scanFlags;
                    disabledPkgSetting = disabledPkgSetting2;
                    pkgSetting = pkgSetting5;
                } else if (isSystemPkgUpdated) {
                    int scannedChildCount2 = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                    int disabledChildCount = disabledPkgSetting2.childPackageNames != null ? disabledPkgSetting2.childPackageNames.size() : 0;
                    int i2 = 0;
                    while (i2 < disabledChildCount) {
                        String disabledChildPackageName = (String) disabledPkgSetting2.childPackageNames.get(i2);
                        boolean disabledPackageAvailable = false;
                        int j = 0;
                        while (true) {
                            if (j >= scannedChildCount2) {
                                scannedChildCount = scannedChildCount2;
                                originalPkgSetting = originalPkgSetting2;
                                break;
                            }
                            scannedChildCount = scannedChildCount2;
                            originalPkgSetting = originalPkgSetting2;
                            if (((PackageParser.Package) pkg.childPackages.get(j)).packageName.equals(disabledChildPackageName)) {
                                disabledPackageAvailable = true;
                                break;
                            }
                            j++;
                            scannedChildCount2 = scannedChildCount;
                            originalPkgSetting2 = originalPkgSetting;
                        }
                        if (!disabledPackageAvailable) {
                            this.mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);
                        }
                        i2++;
                        realPkgName = realPkgName;
                        scannedChildCount2 = scannedChildCount;
                        originalPkgSetting2 = originalPkgSetting;
                    }
                    disabledPkgSetting = disabledPkgSetting2;
                    pkgSetting = pkgSetting5;
                    ScanRequest request = new ScanRequest(pkg, sharedUserSetting, null, disabledPkgSetting, null, null, null, parseFlags, scanFlags, pkg == this.mPlatformPackage, user);
                    if (isSystemAppGrantByMdmAndNonPreload(pkg)) {
                        try {
                            scanFlags2 = mHwPMSEx.adjustScanFlagForApk(pkg, scanFlags);
                        } catch (Throwable th3) {
                            th = th3;
                        }
                    } else {
                        scanFlags2 = scanFlags;
                    }
                    try {
                        applyPolicy(pkg, parseFlags, scanFlags2, this.mPlatformPackage, hwFlags);
                        ScanResult scanResult2 = scanPackageOnlyLI(request, this.mFactoryTest, -1);
                        if (scanResult2.existingSettingCopied && scanResult2.request.pkgSetting != null) {
                            scanResult2.request.pkgSetting.updateFrom(scanResult2.pkgSetting);
                        }
                    } catch (Throwable th4) {
                        th = th4;
                        while (true) {
                            try {
                                break;
                            } catch (Throwable th5) {
                                th = th5;
                            }
                        }
                        throw th;
                    }
                } else {
                    i = scanFlags;
                    disabledPkgSetting = disabledPkgSetting2;
                    pkgSetting = pkgSetting5;
                }
                scanFlags2 = i;
            } catch (Throwable th6) {
                th = th6;
                while (true) {
                    break;
                }
                throw th;
            }
        }
        if (pkgAlreadyExists && scanSystemPartition2 && isUpgrade()) {
            boolean hasDataInstalled = pkgSetting.codePathString != null && pkgSetting.codePathString.startsWith("/data/app/");
            boolean hasPlugin = pkg.hasPlugin || (pkgSetting.hw_extra_flags & 1) != 0;
            if (hasDataInstalled && hasPlugin && (pluginPackage = HwServiceExFactory.getHwPluginPackage(this, pkg.packageName)) != null && 1 == pluginPackage.mergePluginCommit(pkg, pkgSetting, disabledPkgSetting)) {
                createInstallArgsForExisting(pkgSetting.codePathString, pkgSetting.resourcePathString, InstructionSets.getAppDexInstructionSets(pkgSetting)).cleanUpResourcesLI();
                Slog.i(TAG, "pluginMerge.renameStage " + pkg.packageName);
                pluginPackage.renameStage();
                args = 1;
                boolean newPkgChangedPaths = !pkgAlreadyExists && !pkgSetting.codePathString.equals(pkg.codePath);
                boolean newPkgVersionGreater = !pkgAlreadyExists && pkg.getLongVersionCode() > pkgSetting.versionCode;
                boolean isSystemPkgBetter = (!scanSystemPartition2 && isSystemPkgUpdated && newPkgChangedPaths && newPkgVersionGreater) || (!this.mIsUpgrade && scanSystemPartition2 && isSystemPkgUpdated && pkgAlreadyExists && mHwPMSEx.isInValidApkPatchFile(pkgSetting.codePath, parseFlags));
                if (isSystemPkgBetter && args == null) {
                    synchronized (this.mPackages) {
                        this.mPackages.remove(pkgSetting.name);
                    }
                    PackageManagerServiceUtils.logCriticalInfo(5, "System package updated; name: " + pkgSetting.name + "; " + pkgSetting.versionCode + " --> " + pkg.getLongVersionCode() + "; " + pkgSetting.codePathString + " --> " + pkg.codePath);
                    createInstallArgsForExisting(pkgSetting.codePathString, pkgSetting.resourcePathString, InstructionSets.getAppDexInstructionSets(pkgSetting)).cleanUpResourcesLI();
                    synchronized (this.mPackages) {
                        this.mSettings.enableSystemPackageLPw(pkgSetting.name);
                    }
                }
                if (!scanSystemPartition2 || !isSystemPkgUpdated || (isSystemPkgBetter && args == null)) {
                    if (!isSystemPkgUpdated || !mHwPMSEx.needAddUpdatedRemoveableAppFlag(pkg.packageName)) {
                        hwFlags2 = hwFlags;
                    } else {
                        hwFlags2 = (hwFlags & -33554433) | DumpState.DUMP_HANDLE;
                    }
                    boolean forceCollect = (this.mIsUpgrade && scanSystemPartition2) || PackageManagerServiceUtils.isApkVerificationForced(disabledPkgSetting);
                    boolean skipVerify2 = scanSystemPartition2 || (forceCollect && canSkipForcedPackageVerification(pkg)) || (hwFlags2 & DumpState.DUMP_APEX) != 0 || this.mIsPrePUpgrade;
                    collectCertificatesLI(pkgSetting, pkg, forceCollect, skipVerify2);
                    if (pkgSetting == null) {
                        skipVerify = skipVerify2;
                    } else if (pkgSetting.codePathString.equals(pkg.codePath)) {
                        skipVerify = skipVerify2;
                        if (pkgSetting.timeStamp == new File(pkg.codePath).lastModified()) {
                            isUpdate = false;
                            mHwPMSEx.checkHwCertification(pkg, isUpdate);
                            mHwPMSEx.replaceSignatureIfNeeded(pkgSetting, pkg, true, isUpdate);
                            maybeClearProfilesForUpgradesLI(pkgSetting, pkg);
                            shouldHideSystemApp = false;
                            if (pkgSetting != null) {
                                isSystemAppGrantByMdm = false;
                            } else {
                                isSystemAppGrantByMdm = isSystemAppGrantByMdmAndNonPreload(pkgSetting.name, pkgSetting.codePathString, pkgSetting.volumeUuid) && !this.mSystemReady;
                            }
                            if (scanSystemPartition2 || isSystemPkgUpdated || !pkgAlreadyExists) {
                                pkgSetting3 = pkgSetting;
                                r13 = pkg;
                            } else if (!pkgSetting.isSystem() || isSystemAppGrantByMdm) {
                                if (pkg.mSigningDetails.checkCapability(pkgSetting.signatures.mSigningDetails, 1)) {
                                    pkgSetting4 = pkgSetting;
                                    r13 = pkg;
                                } else if (!pkgSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, 8)) {
                                    PackageManagerServiceUtils.logCriticalInfo(5, "System package signature mismatch; name: " + pkgSetting.name);
                                    PackageFreezer freezer2 = freezePackage(pkg.packageName, "scanPackageInternalLI");
                                    try {
                                        r13 = pkg;
                                        try {
                                            deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);
                                            if (freezer2 != null) {
                                                $closeResource(null, freezer2);
                                            }
                                            pkgSetting2 = null;
                                            scanResult = scanPackageNewLI(pkg, parseFlags, scanFlags2 | 2, currentTime, user, hwFlags2);
                                            if (scanResult.success) {
                                                synchronized (this.mPackages) {
                                                    try {
                                                        if (pkg.isSystem() || pkg.isUpdatedSystemApp() || !(pkgSetting2 == null || (pkgSetting2.hw_extra_flags & 1048576) == 0)) {
                                                            try {
                                                                setSplitPermission(pkg);
                                                            } catch (PackageParser.PackageParserException e) {
                                                                Slog.e(TAG, "failed to translate permission for " + r13.packageName);
                                                                throw PackageManagerException.from(e);
                                                            }
                                                        }
                                                        String pkgName = scanResult.pkgSetting.name;
                                                        Map<String, ReconciledPackage> reconcileResult = reconcilePackagesLocked(new ReconcileRequest(Collections.singletonMap(pkgName, scanResult), this.mSharedLibraries, this.mPackages, Collections.singletonMap(pkgName, getSettingsVersionForPackage(pkg)), Collections.singletonMap(pkgName, getSharedLibLatestVersionSetting(scanResult))), this.mSettings.mKeySetManagerService);
                                                        if (pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                                                            Optional<HwRenamedPackagePolicy> renamedPackagePolicyOptional = mHwPMSEx.generateRenamedPackagePolicyLocked(r13);
                                                            if (!renamedPackagePolicyOptional.isPresent() || renamedPackagePolicyOptional.get().getAppId() <= 0) {
                                                                optimisticallyRegisterAppId(scanResult);
                                                            } else {
                                                                scanResult.pkgSetting.appId = renamedPackagePolicyOptional.get().getAppId();
                                                                Slog.w(TAG, "rename package " + pkgName + " used appId:" + renamedPackagePolicyOptional.get().getAppId());
                                                            }
                                                        } else {
                                                            optimisticallyRegisterAppId(scanResult);
                                                        }
                                                        commitReconciledScanResultLocked(reconcileResult.get(pkgName));
                                                    } catch (PackageManagerException e2) {
                                                        if (0 != 0) {
                                                            cleanUpAppIdCreation(scanResult);
                                                        }
                                                        throw e2;
                                                    }
                                                }
                                            }
                                            if (shouldHideSystemApp) {
                                                synchronized (this.mPackages) {
                                                    this.mSettings.disableSystemPackageLPw(r13.packageName, true);
                                                }
                                            }
                                            mHwPMSEx.addPreinstalledPkgToList(scanResult.pkgSetting.pkg);
                                            return scanResult.pkgSetting.pkg;
                                        } catch (Throwable th7) {
                                            freezer = freezer2;
                                            th2 = th7;
                                            try {
                                                throw th2;
                                            } catch (Throwable th8) {
                                                if (freezer != null) {
                                                    $closeResource(th2, freezer);
                                                }
                                                throw th8;
                                            }
                                        }
                                    } catch (Throwable th9) {
                                        freezer = freezer2;
                                        th2 = th9;
                                        throw th2;
                                    }
                                } else {
                                    pkgSetting4 = pkgSetting;
                                    r13 = pkg;
                                }
                                if (!newPkgVersionGreater || args != null) {
                                    shouldHideSystemApp = true;
                                    mHwPMSEx.addUpdatedRemoveableAppFlag(r13.codePath, pkgSetting4.name);
                                    PackageManagerServiceUtils.logCriticalInfo(4, "System package disabled; name: " + pkgSetting4.name + "; old: " + pkgSetting4.codePathString + " @ " + pkgSetting4.versionCode + "; new: " + r13.codePath + " @ " + r13.codePath);
                                    pkgSetting2 = pkgSetting4;
                                    scanResult = scanPackageNewLI(pkg, parseFlags, scanFlags2 | 2, currentTime, user, hwFlags2);
                                    if (scanResult.success) {
                                    }
                                    if (shouldHideSystemApp) {
                                    }
                                    mHwPMSEx.addPreinstalledPkgToList(scanResult.pkgSetting.pkg);
                                    return scanResult.pkgSetting.pkg;
                                }
                                StringBuilder sb = new StringBuilder();
                                sb.append("System package enabled; name: ");
                                pkgSetting3 = pkgSetting4;
                                sb.append(pkgSetting3.name);
                                sb.append("; ");
                                sb.append(pkgSetting3.versionCode);
                                sb.append(" --> ");
                                sb.append(pkg.getLongVersionCode());
                                sb.append("; ");
                                sb.append(pkgSetting3.codePathString);
                                sb.append(" --> ");
                                sb.append(r13.codePath);
                                PackageManagerServiceUtils.logCriticalInfo(5, sb.toString());
                                InstallArgs args2 = createInstallArgsForExisting(pkgSetting3.codePathString, pkgSetting3.resourcePathString, InstructionSets.getAppDexInstructionSets(pkgSetting3));
                                synchronized (this.mInstallLock) {
                                    args2.cleanUpResourcesLI();
                                }
                            } else {
                                pkgSetting3 = pkgSetting;
                                r13 = pkg;
                            }
                            pkgSetting2 = pkgSetting3;
                            scanResult = scanPackageNewLI(pkg, parseFlags, scanFlags2 | 2, currentTime, user, hwFlags2);
                            if (scanResult.success) {
                            }
                            if (shouldHideSystemApp) {
                            }
                            mHwPMSEx.addPreinstalledPkgToList(scanResult.pkgSetting.pkg);
                            return scanResult.pkgSetting.pkg;
                        }
                    } else {
                        skipVerify = skipVerify2;
                    }
                    isUpdate = true;
                    mHwPMSEx.checkHwCertification(pkg, isUpdate);
                    mHwPMSEx.replaceSignatureIfNeeded(pkgSetting, pkg, true, isUpdate);
                    maybeClearProfilesForUpgradesLI(pkgSetting, pkg);
                    shouldHideSystemApp = false;
                    if (pkgSetting != null) {
                    }
                    if (scanSystemPartition2) {
                    }
                    pkgSetting3 = pkgSetting;
                    r13 = pkg;
                    pkgSetting2 = pkgSetting3;
                    scanResult = scanPackageNewLI(pkg, parseFlags, scanFlags2 | 2, currentTime, user, hwFlags2);
                    if (scanResult.success) {
                    }
                    if (shouldHideSystemApp) {
                    }
                    mHwPMSEx.addPreinstalledPkgToList(scanResult.pkgSetting.pkg);
                    return scanResult.pkgSetting.pkg;
                }
                mHwPMSEx.addUpdatedRemoveableAppFlag(pkg.codePath, pkg.packageName);
                throw new PackageManagerException(5, "Package " + pkg.packageName + " at " + pkg.codePath + " ignored: updated version " + pkgSetting.versionCode + " better than this " + pkg.getLongVersionCode());
            }
        }
        args = null;
        if (!pkgAlreadyExists) {
        }
        if (!pkgAlreadyExists) {
        }
        if (!scanSystemPartition2) {
        }
        synchronized (this.mPackages) {
        }
        while (true) {
        }
    }

    private void setSplitPermission(PackageParser.Package pkg) throws PackageParser.PackageParserException {
        if (pkg != null && pkg.applicationInfo != null && pkg.hasPermZA) {
            Slog.i(TAG, "setSplitPermission pkg: " + pkg.packageName);
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.hwFlags = applicationInfo.hwFlags | 1048576;
            if (!ArrayUtils.isEmpty(pkg.splitPermissions)) {
                pkg.permissions.addAll(pkg.splitPermissions);
            }
            if (!ArrayUtils.isEmpty(pkg.splitPermissionGroups)) {
                pkg.permissionGroups.addAll(pkg.splitPermissionGroups);
            }
            if (!ArrayUtils.isEmpty(pkg.splitRequestedPermissions)) {
                pkg.requestedPermissions.addAll(pkg.splitRequestedPermissions);
            }
            ZosPermissionAdapter.getInstance().translatePermissionName(pkg);
        }
    }

    private static void renameStaticSharedLibraryPackage(PackageParser.Package pkg) {
        pkg.setPackageName(pkg.packageName + STATIC_SHARED_LIB_DELIMITER + pkg.staticSharedLibVersion);
    }

    static String fixProcessName(String defProcessName, String processName) {
        if (processName == null) {
            return defProcessName;
        }
        return processName;
    }

    private static void enforceSystemOrRoot(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0) {
            throw new SecurityException(message);
        }
    }

    private static void enforceSystemOrRootOrShell(String message) {
        int uid = Binder.getCallingUid();
        if (uid != 1000 && uid != 0 && uid != 2000) {
            throw new SecurityException(message);
        }
    }

    public void performFstrimIfNeeded() {
        boolean dexOptDialogShown;
        enforceSystemOrRoot("Only the system can request fstrim");
        HwThemeManager.applyDefaultHwTheme(false, this.mContext, 0);
        HwThemeManager.linkDataSkinDirAsUser(0);
        try {
            IStorageManager sm = PackageHelper.getStorageManager();
            if (sm != null) {
                boolean doTrim = false;
                long interval = Settings.Global.getLong(this.mContext.getContentResolver(), "fstrim_mandatory_interval", DEFAULT_MANDATORY_FSTRIM_INTERVAL);
                if (interval > 0) {
                    long timeSinceLast = System.currentTimeMillis() - sm.lastMaintenance();
                    if (timeSinceLast > interval) {
                        doTrim = true;
                        Slog.w(TAG, "No disk maintenance in " + timeSinceLast + "; running immediately");
                    }
                }
                if (doTrim) {
                    synchronized (this.mPackages) {
                        dexOptDialogShown = this.mDexOptDialogShown;
                    }
                    if (!isFirstBoot() && dexOptDialogShown) {
                        try {
                            ActivityManager.getService().showBootMessage(this.mContext.getResources().getString(17039595), true);
                        } catch (RemoteException e) {
                        }
                    }
                    sm.runMaintenance();
                    return;
                }
                return;
            }
            Slog.e(TAG, "storageManager service unavailable!");
        } catch (RemoteException e2) {
        }
    }

    public void updatePackagesIfNeeded() {
        List<PackageParser.Package> pkgs;
        enforceSystemOrRoot("Only the system can request package update");
        boolean causeUpgrade = isDeviceUpgrading();
        boolean cacheEnabled = SystemProperties.getBoolean(MAPLE_DECOUPLE_CACHE_ENABLE, true);
        if ((causeUpgrade || isFirstBoot()) && cacheEnabled && mHwPMSEx.isMygoteEnabled()) {
            long startTime = System.nanoTime();
            for (PackageParser.Package pkg : mHwPMSEx.obtainMaplePkgsToGenCache()) {
                Slog.i(TAG, "[DCP] -> generateCachesForMplApps is called " + pkg.baseCodePath);
                int cacheLevel = mHwPMSEx.getCacheLevelForMapleApp(pkg);
                String mapleClassPath = mHwPMSEx.obtainMapleClassPathByPkg(pkg);
                if (!(cacheLevel == -1 || mapleClassPath == null)) {
                    int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
                    synchronized (this.mInstallLock) {
                        mHwPMSEx.callGenMplCacheAtPmsInstaller(pkg.baseCodePath, sharedGid, cacheLevel, mapleClassPath);
                    }
                }
            }
            Slog.i(TAG, "[DCP] -> extra time consumed at hota : " + ((int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime)) + " seconds");
        }
        boolean causeFirstBoot = isFirstBoot() || this.mIsPreNUpgrade;
        boolean causePrunedCache = VMRuntime.didPruneDalvikCache();
        if (!IS_BOPD) {
            if (causeUpgrade || causeFirstBoot || causePrunedCache) {
                synchronized (this.mPackages) {
                    pkgs = PackageManagerServiceUtils.getPackagesForDexopt(this.mPackages.values(), this);
                }
                boolean showDialog = this.mIsPreNUpgrade;
                if (SystemProperties.getBoolean("ro.config.show_dex2oatDialog", true)) {
                    showDialog = this.mIsUpgrade;
                }
                long startTime2 = System.nanoTime();
                int[] stats = performDexOptUpgrade(pkgs, showDialog, causeFirstBoot ? 0 : 1, false);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_dexopted", stats[0]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_skipped", stats[1]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_failed", stats[2]);
                MetricsLogger.histogram(this.mContext, "opt_dialog_num_total", getOptimizablePackages().size());
                MetricsLogger.histogram(this.mContext, "opt_dialog_time_s", (int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime2));
                this.mHandler.post(new Runnable() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$MI6mDhf3D3XDQsqG7XxZy1fGOvU */

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.this.lambda$updatePackagesIfNeeded$5$PackageManagerService();
                    }
                });
            }
        }
    }

    public /* synthetic */ void lambda$updatePackagesIfNeeded$5$PackageManagerService() {
        if (SystemProperties.getInt("ro.logsystem.usertype", 1) == 3) {
            Slog.i(TAG, "HwPackageDynamicCodeLoading enable");
            long endTime = System.currentTimeMillis();
            Iterator<String> it = getOptimizablePackages().iterator();
            while (it.hasNext()) {
                HwServiceExFactory.getHwPackageDynamicCodeLoading().record(it.next(), endTime, 1);
            }
            HwServiceExFactory.getHwPackageDynamicCodeLoading().writeNow();
        }
    }

    private static String getPrebuildProfilePath(PackageParser.Package pkg) {
        return pkg.baseCodePath + ".prof";
    }

    /* access modifiers changed from: package-private */
    public boolean isUseProfileForDexopt(PackageParser.Package pkg) {
        if ((!isFirstBoot() && !isUpgrade()) || !isSystemApp(pkg)) {
            return false;
        }
        File profileFile = new File(getPrebuildProfilePath(pkg));
        if (profileFile.exists()) {
            try {
                if (this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                    return false;
                }
                Log.e(TAG, "Installer failed to copy system profile!");
                return false;
            } catch (Exception e) {
                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e);
                return false;
            }
        } else {
            PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
            if (disabledPs == null || !disabledPs.pkg.isStub) {
                return false;
            }
            File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
            if (!profileFile2.exists()) {
                return false;
            }
            try {
                if (this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                    return true;
                }
                Log.e(TAG, "Failed to copy system profile for stub package!");
                return false;
            } catch (Exception e2) {
                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + " ", e2);
                return false;
            }
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:109:0x022d  */
    /* JADX WARNING: Removed duplicated region for block: B:115:0x0255  */
    /* JADX WARNING: Removed duplicated region for block: B:78:0x017f  */
    /* JADX WARNING: Removed duplicated region for block: B:82:0x01a7  */
    private int[] performDexOptUpgrade(List<PackageParser.Package> pkgs, boolean showDialog, int compilationReason, boolean bootComplete) {
        int numberOfPackagesProfiledOpt;
        int numberOfPackagesOptimized;
        int numberOfPackagesFailed;
        Iterator<PackageParser.Package> it;
        boolean useProfileForDexopt;
        int numberOfPackagesProfiledOpt2;
        int primaryDexOptStaus;
        boolean useProfileForDexopt2;
        Exception e;
        Exception e2;
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().getDexOptNeededCachePrepare(pkgs, compilationReason, bootComplete, this.mDexManager, this, 0);
        }
        boolean z = false;
        boolean isUpdateAtNight = SystemProperties.getBoolean(HOTA_NIGHT_UPDATE, false);
        int numberOfPackagesProfiledOpt3 = 0;
        int maxNumberOfPackagesProfiledOpt = SystemProperties.getInt(HOTA_NIGHT_MAX_PROFILEGUIDED_NUM, 0);
        if (isUpdateAtNight) {
            SystemProperties.set(HOTA_NIGHT_UPDATE, "false");
        }
        int numberOfPackagesVisited = 0;
        int numberOfPackagesOptimized2 = 0;
        int numberOfPackagesSkipped = 0;
        int numberOfPackagesFailed2 = 0;
        int numberOfPackagesToDexopt = pkgs.size();
        Iterator<PackageParser.Package> it2 = pkgs.iterator();
        while (it2.hasNext()) {
            PackageParser.Package pkg = it2.next();
            int numberOfPackagesVisited2 = numberOfPackagesVisited + 1;
            boolean useProfileForDexopt3 = ZygoteInit.sIsMygote ? z : isUseProfileForDexopt(pkg);
            if (!isFirstBoot() && !isDeviceUpgrading()) {
                numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                numberOfPackagesOptimized = numberOfPackagesOptimized2;
                numberOfPackagesFailed = numberOfPackagesFailed2;
                it = it2;
                useProfileForDexopt2 = useProfileForDexopt3;
            } else if (isSystemApp(pkg)) {
                File profileFile = new File(getPrebuildProfilePath(pkg));
                it = it2;
                if (profileFile.exists()) {
                    try {
                        useProfileForDexopt2 = useProfileForDexopt3;
                        try {
                            numberOfPackagesFailed = numberOfPackagesFailed2;
                            try {
                                numberOfPackagesOptimized = numberOfPackagesOptimized2;
                                try {
                                    numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                                } catch (Exception e3) {
                                    e2 = e3;
                                    numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                                    Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                                    useProfileForDexopt = useProfileForDexopt2;
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                            } catch (Exception e4) {
                                e2 = e4;
                                numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                                numberOfPackagesOptimized = numberOfPackagesOptimized2;
                                Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                                useProfileForDexopt = useProfileForDexopt2;
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                        } catch (Exception e5) {
                            e2 = e5;
                            numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                            numberOfPackagesOptimized = numberOfPackagesOptimized2;
                            numberOfPackagesFailed = numberOfPackagesFailed2;
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                            useProfileForDexopt = useProfileForDexopt2;
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                            }
                        }
                        try {
                            if (!this.mInstaller.copySystemProfile(profileFile.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                                Log.e(TAG, "Installer failed to copy system profile!");
                            }
                        } catch (Exception e6) {
                            e2 = e6;
                            Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                            useProfileForDexopt = useProfileForDexopt2;
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                            }
                        }
                    } catch (Exception e7) {
                        e2 = e7;
                        numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                        numberOfPackagesOptimized = numberOfPackagesOptimized2;
                        numberOfPackagesFailed = numberOfPackagesFailed2;
                        useProfileForDexopt2 = useProfileForDexopt3;
                        Log.e(TAG, "Failed to copy profile " + profileFile.getAbsolutePath() + " ", e2);
                        useProfileForDexopt = useProfileForDexopt2;
                        if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                        }
                    }
                } else {
                    numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                    numberOfPackagesOptimized = numberOfPackagesOptimized2;
                    numberOfPackagesFailed = numberOfPackagesFailed2;
                    useProfileForDexopt2 = useProfileForDexopt3;
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                    if (disabledPs != null && disabledPs.pkg.isStub) {
                        File profileFile2 = new File(getPrebuildProfilePath(disabledPs.pkg).replace(STUB_SUFFIX, ""));
                        if (profileFile2.exists()) {
                            try {
                            } catch (Exception e8) {
                                e = e8;
                                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + " ", e);
                                useProfileForDexopt = useProfileForDexopt2;
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                            try {
                                try {
                                    if (!this.mInstaller.copySystemProfile(profileFile2.getAbsolutePath(), pkg.applicationInfo.uid, pkg.packageName, ArtManager.getProfileName((String) null))) {
                                        Log.e(TAG, "Failed to copy system profile for stub package!");
                                        useProfileForDexopt = useProfileForDexopt2;
                                    } else {
                                        useProfileForDexopt = true;
                                    }
                                } catch (Exception e9) {
                                    e = e9;
                                    Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + " ", e);
                                    useProfileForDexopt = useProfileForDexopt2;
                                    if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                    }
                                }
                            } catch (Exception e10) {
                                e = e10;
                                Log.e(TAG, "Failed to copy profile " + profileFile2.getAbsolutePath() + " ", e);
                                useProfileForDexopt = useProfileForDexopt2;
                                if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                }
                            }
                            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
                                if (DEBUG_DEXOPT) {
                                    Log.i(TAG, "Skipping update of of non-optimizable app " + pkg.packageName);
                                }
                                numberOfPackagesSkipped++;
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it2 = it;
                                numberOfPackagesFailed2 = numberOfPackagesFailed;
                                numberOfPackagesOptimized2 = numberOfPackagesOptimized;
                                numberOfPackagesProfiledOpt3 = numberOfPackagesProfiledOpt;
                                z = false;
                            } else {
                                if (DEBUG_DEXOPT) {
                                    Log.i(TAG, "Updating app " + numberOfPackagesVisited2 + " of " + numberOfPackagesToDexopt + ": " + pkg.packageName);
                                }
                                if (showDialog) {
                                    HwPackageManagerServiceUtils.showBootAnimationMessage(numberOfPackagesVisited2, numberOfPackagesToDexopt);
                                }
                                int pkgCompilationReason = compilationReason;
                                if (useProfileForDexopt) {
                                    pkgCompilationReason = 3;
                                }
                                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                                    this.mArtManagerService.compileLayouts(pkg);
                                }
                                int dexoptFlags = bootComplete ? 4 : 0;
                                if (compilationReason == 0) {
                                    dexoptFlags |= 1024;
                                }
                                if (isUpdateAtNight) {
                                    numberOfPackagesProfiledOpt2 = numberOfPackagesProfiledOpt;
                                    if (numberOfPackagesProfiledOpt2 < maxNumberOfPackagesProfiledOpt && !isSystemApp(pkg)) {
                                        numberOfPackagesProfiledOpt2++;
                                        primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, PackageManagerServiceCompilerMapping.getCompilerFilterForReason(3), null, dexoptFlags));
                                        if (primaryDexOptStaus != -1) {
                                            numberOfPackagesFailed2 = numberOfPackagesFailed + 1;
                                        } else if (primaryDexOptStaus == 0) {
                                            numberOfPackagesSkipped++;
                                            numberOfPackagesFailed2 = numberOfPackagesFailed;
                                        } else if (primaryDexOptStaus != 1) {
                                            Log.e(TAG, "Unexpected dexopt return code " + primaryDexOptStaus);
                                            numberOfPackagesFailed2 = numberOfPackagesFailed;
                                        } else {
                                            numberOfPackagesOptimized++;
                                            numberOfPackagesFailed2 = numberOfPackagesFailed;
                                        }
                                        numberOfPackagesProfiledOpt3 = numberOfPackagesProfiledOpt2;
                                        numberOfPackagesVisited = numberOfPackagesVisited2;
                                        it2 = it;
                                        numberOfPackagesOptimized2 = numberOfPackagesOptimized;
                                        z = false;
                                    }
                                } else {
                                    numberOfPackagesProfiledOpt2 = numberOfPackagesProfiledOpt;
                                }
                                primaryDexOptStaus = performDexOptTraced(new DexoptOptions(pkg.packageName, pkgCompilationReason, dexoptFlags));
                                if (primaryDexOptStaus != -1) {
                                }
                                numberOfPackagesProfiledOpt3 = numberOfPackagesProfiledOpt2;
                                numberOfPackagesVisited = numberOfPackagesVisited2;
                                it2 = it;
                                numberOfPackagesOptimized2 = numberOfPackagesOptimized;
                                z = false;
                            }
                        }
                    }
                }
            } else {
                numberOfPackagesProfiledOpt = numberOfPackagesProfiledOpt3;
                numberOfPackagesOptimized = numberOfPackagesOptimized2;
                numberOfPackagesFailed = numberOfPackagesFailed2;
                it = it2;
                useProfileForDexopt2 = useProfileForDexopt3;
            }
            useProfileForDexopt = useProfileForDexopt2;
            if (PackageDexOptimizer.canOptimizePackage(pkg)) {
            }
        }
        HwPackageManagerServiceUtils.stopBootAnimationMessage(this);
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().getDexOptNeededCacheClear();
        }
        return new int[]{numberOfPackagesOptimized2, numberOfPackagesSkipped, numberOfPackagesFailed2};
    }

    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            if (getInstantAppPackageName(callingUid) != null) {
                if (!isCallerSameApp(packageName, callingUid)) {
                    return;
                }
            } else if (isInstantApp(packageName, callingUserId)) {
                return;
            }
            notifyPackageUseLocked(packageName, reason);
        }
    }

    @GuardedBy({"mPackages"})
    public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegateLocked() {
        return this.mCheckPermissionDelegate;
    }

    @GuardedBy({"mPackages"})
    public void setCheckPermissionDelegateLocked(PackageManagerInternal.CheckPermissionDelegate delegate) {
        this.mCheckPermissionDelegate = delegate;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private void notifyPackageUseLocked(String packageName, int reason) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            p.mLastPackageUsageTimeInMills[reason] = System.currentTimeMillis();
        }
    }

    public void notifyDexLoad(String loadingPackageName, List<String> classLoaderNames, List<String> classPaths, String loaderIsa) {
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(loadingPackageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Loading a package that does not exist for the calling user. package=" + loadingPackageName + ", user=" + userId);
            return;
        }
        this.mDexManager.notifyDexLoad(ai, classLoaderNames, classPaths, loaderIsa, userId);
    }

    public void registerDexModule(String packageName, String dexModulePath, boolean isSharedModule, IDexModuleRegisterCallback callback) {
        DexManager.RegisterDexModuleResult result;
        int userId = UserHandle.getCallingUserId();
        ApplicationInfo ai = getApplicationInfo(packageName, 0, userId);
        if (ai == null) {
            Slog.w(TAG, "Registering a dex module for a package that does not exist for the calling user. package=" + packageName + ", user=" + userId);
            result = new DexManager.RegisterDexModuleResult(false, "Package not installed");
        } else {
            result = this.mDexManager.registerDexModule(ai, dexModulePath, isSharedModule, userId);
        }
        if (callback != null) {
            this.mHandler.post(new Runnable(callback, dexModulePath, result) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$01yYDZ5jp11gOeP9aueRSOPPvYc */
                private final /* synthetic */ IDexModuleRegisterCallback f$0;
                private final /* synthetic */ String f$1;
                private final /* synthetic */ DexManager.RegisterDexModuleResult f$2;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                @Override // java.lang.Runnable
                public final void run() {
                    PackageManagerService.lambda$registerDexModule$6(this.f$0, this.f$1, this.f$2);
                }
            });
        }
    }

    static /* synthetic */ void lambda$registerDexModule$6(IDexModuleRegisterCallback callback, String dexModulePath, DexManager.RegisterDexModuleResult result) {
        try {
            callback.onDexModuleRegistered(dexModulePath, result.success, result.message);
        } catch (RemoteException e) {
            Slog.w(TAG, "Failed to callback after module registration " + dexModulePath, e);
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean performDexOptMode(String packageName, boolean checkProfiles, String targetCompilerFilter, boolean force, boolean bootComplete, String splitName) {
        if (mHwPMSEx.isApkDexOpt(targetCompilerFilter)) {
            return mHwPMSEx.hwPerformDexOptMode(packageName, checkProfiles, force, bootComplete, splitName);
        }
        int i = 0;
        int i2 = (force ? 2 : 0) | (checkProfiles ? 1 : 0);
        if (bootComplete) {
            i = 4;
        }
        return performDexOpt(new DexoptOptions(packageName, -1, targetCompilerFilter, splitName, i | i2));
    }

    public boolean performDexOptSecondary(String packageName, String compilerFilter, boolean force) {
        return performDexOpt(new DexoptOptions(packageName, compilerFilter, (force ? 2 : 0) | 13));
    }

    public boolean compileLayouts(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                return false;
            }
            return this.mViewCompiler.compileLayouts(pkg);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean performDexOpt(DexoptOptions options) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null || isInstantApp(options.getPackageName(), UserHandle.getCallingUserId())) {
            return false;
        }
        if (options.isDexoptOnlySecondaryDex()) {
            return this.mDexManager.dexoptSecondaryDex(options);
        }
        if (performDexOptWithStatus(options) != -1) {
            return true;
        }
        return false;
    }

    /* access modifiers changed from: package-private */
    public int performDexOptWithStatus(DexoptOptions options) {
        return performDexOptTraced(options);
    }

    private int performDexOptTraced(DexoptOptions options) {
        Trace.traceBegin(262144, "dexopt");
        try {
            return performDexOptInternal(options);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    private int performDexOptInternal(DexoptOptions options) {
        int performDexOptInternalWithDependenciesLI;
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(options.getPackageName());
            if (p == null) {
                return -1;
            }
            this.mPackageUsage.maybeWriteAsync(this.mPackages);
            this.mCompilerStats.maybeWriteAsync();
            long callingId = Binder.clearCallingIdentity();
            try {
                synchronized (this.mInstallLock) {
                    performDexOptInternalWithDependenciesLI = performDexOptInternalWithDependenciesLI(p, options);
                }
                return performDexOptInternalWithDependenciesLI;
            } finally {
                Binder.restoreCallingIdentity(callingId);
            }
        }
    }

    public ArraySet<String> getOptimizablePackages() {
        ArraySet<String> pkgs = new ArraySet<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p.packageName);
                }
            }
        }
        return pkgs;
    }

    private int performDexOptInternalWithDependenciesLI(PackageParser.Package p, DexoptOptions options) {
        PackageDexOptimizer.ForcedUpdatePackageDexOptimizer pdo;
        Throwable th;
        PackageParser.Package depPackage;
        if (options.isForce()) {
            pdo = new PackageDexOptimizer.ForcedUpdatePackageDexOptimizer(this.mPackageDexOptimizer);
        } else {
            pdo = this.mPackageDexOptimizer;
        }
        Collection<SharedLibraryInfo> deps = findSharedLibraries(p);
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(p.applicationInfo);
        if (!deps.isEmpty()) {
            DexoptOptions libraryOptions = new DexoptOptions(options.getPackageName(), options.getCompilationReason(), options.getCompilerFilter(), options.getSplitName(), options.getFlags() | 64);
            for (SharedLibraryInfo info : deps) {
                synchronized (this.mPackages) {
                    try {
                        depPackage = this.mPackages.get(info.getPackageName());
                        try {
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } catch (Throwable th3) {
                        th = th3;
                        throw th;
                    }
                }
                if (depPackage != null) {
                    pdo.performDexOpt(depPackage, instructionSets, getOrCreateCompilerPackageStats(depPackage), this.mDexManager.getPackageUseInfoOrDefault(depPackage.packageName), libraryOptions);
                }
            }
        }
        return pdo.performDexOpt(p, instructionSets, getOrCreateCompilerPackageStats(p), this.mDexManager.getPackageUseInfoOrDefault(p.packageName), options);
    }

    public void reconcileSecondaryDexFiles(String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && !isInstantApp(packageName, UserHandle.getCallingUserId())) {
            this.mDexManager.reconcileSecondaryDexFiles(packageName);
        }
    }

    /* access modifiers changed from: package-private */
    public DexManager getDexManager() {
        return this.mDexManager;
    }

    public boolean runBackgroundDexoptJob(List<String> packageNames) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return false;
        }
        enforceSystemOrRootOrShell("runBackgroundDexoptJob");
        long identity = Binder.clearCallingIdentity();
        try {
            return BackgroundDexOptService.runIdleOptimizationsNow(this, this.mContext, packageNames);
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    private static List<SharedLibraryInfo> findSharedLibraries(PackageParser.Package p) {
        if (p.usesLibraryInfos == null) {
            return Collections.emptyList();
        }
        ArrayList<SharedLibraryInfo> retValue = new ArrayList<>();
        Set<String> collectedNames = new HashSet<>();
        Iterator it = p.usesLibraryInfos.iterator();
        while (it.hasNext()) {
            findSharedLibrariesRecursive((SharedLibraryInfo) it.next(), retValue, collectedNames);
        }
        return retValue;
    }

    private static void findSharedLibrariesRecursive(SharedLibraryInfo info, ArrayList<SharedLibraryInfo> collected, Set<String> collectedNames) {
        if (!collectedNames.contains(info.getName())) {
            collectedNames.add(info.getName());
            collected.add(info);
            if (info.getDependencies() != null) {
                for (SharedLibraryInfo dep : info.getDependencies()) {
                    findSharedLibrariesRecursive(dep, collected, collectedNames);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> findSharedNonSystemLibraries(PackageParser.Package pkg) {
        List<SharedLibraryInfo> deps = findSharedLibraries(pkg);
        if (deps.isEmpty()) {
            return Collections.emptyList();
        }
        ArrayList<PackageParser.Package> retValue = new ArrayList<>();
        synchronized (this.mPackages) {
            for (SharedLibraryInfo info : deps) {
                PackageParser.Package depPackage = this.mPackages.get(info.getPackageName());
                if (depPackage != null) {
                    retValue.add(depPackage);
                }
            }
        }
        return retValue;
    }

    private SharedLibraryInfo getSharedLibraryInfoLPr(String name, long version) {
        return getSharedLibraryInfo(name, version, this.mSharedLibraries, null);
    }

    private static SharedLibraryInfo getSharedLibraryInfo(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) {
        if (newLibraries != null) {
            LongSparseArray<SharedLibraryInfo> versionedLib = newLibraries.get(name);
            SharedLibraryInfo info = null;
            if (versionedLib != null) {
                info = versionedLib.get(version);
            }
            if (info != null) {
                return info;
            }
        }
        LongSparseArray<SharedLibraryInfo> versionedLib2 = existingLibraries.get(name);
        if (versionedLib2 == null) {
            return null;
        }
        return versionedLib2.get(version);
    }

    private SharedLibraryInfo getLatestSharedLibraVersionLPr(PackageParser.Package pkg) {
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(pkg.staticSharedLibName);
        if (versionedLib == null) {
            return null;
        }
        long previousLibVersion = -1;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            long libVersion = versionedLib.keyAt(i);
            if (libVersion < pkg.staticSharedLibVersion) {
                previousLibVersion = Math.max(previousLibVersion, libVersion);
            }
        }
        if (previousLibVersion >= 0) {
            return versionedLib.get(previousLibVersion);
        }
        return null;
    }

    private PackageSetting getSharedLibLatestVersionSetting(ScanResult scanResult) {
        PackageSetting sharedLibPackage = null;
        synchronized (this.mPackages) {
            SharedLibraryInfo latestSharedLibraVersionLPr = getLatestSharedLibraVersionLPr(scanResult.pkgSetting.pkg);
            if (latestSharedLibraVersionLPr != null) {
                sharedLibPackage = this.mSettings.getPackageLPr(latestSharedLibraVersionLPr.getPackageName());
            }
        }
        return sharedLibPackage;
    }

    public void shutdown() {
        this.mPackageUsage.writeNow(this.mPackages);
        this.mCompilerStats.writeNow();
        this.mDexManager.writePackageDexUsageNow();
        PackageWatchdog.getInstance(this.mContext).writeNow();
        synchronized (this.mPackages) {
            if (this.mHandler.hasMessages(14)) {
                this.mHandler.removeMessages(14);
                Iterator<Integer> it = this.mDirtyUsers.iterator();
                while (it.hasNext()) {
                    this.mSettings.writePackageRestrictionsLPr(it.next().intValue());
                }
                this.mDirtyUsers.clear();
            }
        }
    }

    public void dumpProfiles(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        int callingUid = Binder.getCallingUid();
        if (callingUid == 2000 || callingUid == 0 || callingUid == pkg.applicationInfo.uid) {
            synchronized (this.mInstallLock) {
                Trace.traceBegin(262144, "dump profiles");
                this.mArtManagerService.dumpProfiles(pkg);
                Trace.traceEnd(262144);
            }
            return;
        }
        throw new SecurityException("dumpProfiles");
    }

    public void forceDexOpt(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("forceDexOpt");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        synchronized (this.mInstallLock) {
            Trace.traceBegin(262144, "dexopt");
            int res = performDexOptInternalWithDependenciesLI(pkg, new DexoptOptions(packageName, PackageManagerServiceCompilerMapping.getDefaultCompilerFilter(), 6));
            Trace.traceEnd(262144);
            if (res != 1) {
                throw new IllegalStateException("Failed to dexopt: " + res);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private boolean verifyPackageUpdateLPr(PackageSetting oldPkg, PackageParser.Package newPkg) {
        if ((oldPkg.pkgFlags & 1) == 0) {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package not in system partition");
            return false;
        } else if (this.mPackages.get(oldPkg.name) == null) {
            return true;
        } else {
            Slog.w(TAG, "Unable to update from " + oldPkg.name + " to " + newPkg.packageName + ": old package still exists");
            return false;
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mInstallLock"})
    public void removeCodePathLI(File codePath) {
        if (codePath.isDirectory()) {
            try {
                this.mInstaller.rmPackageDir(codePath.getAbsolutePath());
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, "Failed to remove code path", e);
            }
        } else {
            codePath.delete();
        }
    }

    private int[] resolveUserIds(int userId) {
        return userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
    }

    private void clearAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        clearAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            clearAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
        if ((flags & 128) == 0) {
            clearAppProfilesLIF(pkg, -1);
        }
    }

    private void clearAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.clearAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
        }
    }

    private void destroyAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void destroyAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        int[] resolveUserIds = resolveUserIds(userId);
        for (int realUserId : resolveUserIds) {
            try {
                this.mInstaller.destroyAppData(pkg.volumeUuid, pkg.packageName, realUserId, flags, ps != null ? ps.getCeDataInode(realUserId) : 0);
            } catch (Installer.InstallerException e) {
                Slog.w(TAG, String.valueOf(e));
            }
            this.mDexManager.notifyPackageDataDestroyed(pkg.packageName, userId);
        }
    }

    private void destroyAppProfilesLIF(PackageParser.Package pkg) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        destroyAppProfilesLeafLIF(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            destroyAppProfilesLeafLIF((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void destroyAppProfilesLeafLIF(PackageParser.Package pkg) {
        try {
            this.mInstaller.destroyAppProfiles(pkg.packageName);
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
        }
    }

    private void clearAppProfilesLIF(PackageParser.Package pkg, int userId) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        this.mArtManagerService.clearAppProfiles(pkg);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mArtManagerService.clearAppProfiles((PackageParser.Package) pkg.childPackages.get(i));
        }
    }

    private void setInstallAndUpdateTime(PackageParser.Package pkg, long firstInstallTime, long lastUpdateTime) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            ps.firstInstallTime = firstInstallTime;
            ps.lastUpdateTime = lastUpdateTime;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                ps2.firstInstallTime = firstInstallTime;
                ps2.lastUpdateTime = lastUpdateTime;
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void applyDefiningSharedLibraryUpdateLocked(PackageParser.Package pkg, SharedLibraryInfo libInfo, BiConsumer<SharedLibraryInfo, SharedLibraryInfo> action) {
        if (!pkg.isLibrary()) {
            return;
        }
        if (pkg.staticSharedLibName != null) {
            SharedLibraryInfo definedLibrary = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
            if (definedLibrary != null) {
                action.accept(definedLibrary, libInfo);
                return;
            }
            return;
        }
        Iterator it = pkg.libraryNames.iterator();
        while (it.hasNext()) {
            SharedLibraryInfo definedLibrary2 = getSharedLibraryInfoLPr((String) it.next(), -1);
            if (definedLibrary2 != null) {
                action.accept(definedLibrary2, libInfo);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void addSharedLibraryLPr(PackageParser.Package pkg, Set<String> usesLibraryFiles, SharedLibraryInfo libInfo, PackageParser.Package changingLib) {
        if (libInfo.getPath() != null) {
            usesLibraryFiles.add(libInfo.getPath());
            return;
        }
        PackageParser.Package p = this.mPackages.get(libInfo.getPackageName());
        if (changingLib != null && changingLib.packageName.equals(libInfo.getPackageName()) && (p == null || p.packageName.equals(changingLib.packageName))) {
            p = changingLib;
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
            applyDefiningSharedLibraryUpdateLocked(pkg, libInfo, $$Lambda$PackageManagerService$0uSmqyontvENCPVNP09rputt8co.INSTANCE);
            if (p.usesLibraryFiles != null) {
                Collections.addAll(usesLibraryFiles, p.usesLibraryFiles);
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void updateSharedLibrariesLocked(PackageParser.Package pkg, PackageParser.Package changingLib, Map<String, PackageParser.Package> availablePackages) throws PackageManagerException {
        executeSharedLibrariesUpdateLPr(pkg, changingLib, collectSharedLibraryInfos(pkg, availablePackages, this.mSharedLibraries, null));
    }

    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(PackageParser.Package pkg, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        if (pkg == null) {
            return null;
        }
        ArrayList<SharedLibraryInfo> usesLibraryInfos = null;
        if (pkg.usesLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesLibraries, null, null, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, null, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesStaticLibraries != null) {
            usesLibraryInfos = collectSharedLibraryInfos(pkg.usesStaticLibraries, pkg.usesStaticLibrariesVersions, pkg.usesStaticLibrariesCertDigests, pkg.packageName, true, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        if (pkg.usesOptionalLibraries != null) {
            return collectSharedLibraryInfos(pkg.usesOptionalLibraries, null, null, pkg.packageName, false, pkg.applicationInfo.targetSdkVersion, usesLibraryInfos, availablePackages, existingLibraries, newLibraries);
        }
        return usesLibraryInfos;
    }

    private void executeSharedLibrariesUpdateLPr(PackageParser.Package pkg, PackageParser.Package changingLib, ArrayList<SharedLibraryInfo> usesLibraryInfos) {
        applyDefiningSharedLibraryUpdateLocked(pkg, null, $$Lambda$PackageManagerService$IMzTWqx72Nb0jxIXvoO2RbjKXNU.INSTANCE);
        if (usesLibraryInfos != null) {
            pkg.usesLibraryInfos = usesLibraryInfos;
            Set<String> usesLibraryFiles = new LinkedHashSet<>();
            Iterator<SharedLibraryInfo> it = usesLibraryInfos.iterator();
            while (it.hasNext()) {
                addSharedLibraryLPr(pkg, usesLibraryFiles, it.next(), changingLib);
            }
            pkg.usesLibraryFiles = (String[]) usesLibraryFiles.toArray(new String[usesLibraryFiles.size()]);
            return;
        }
        pkg.usesLibraryInfos = null;
        pkg.usesLibraryFiles = null;
    }

    @GuardedBy({"mPackages"})
    private static ArrayList<SharedLibraryInfo> collectSharedLibraryInfos(List<String> requestedLibraries, long[] requiredVersions, String[][] requiredCertDigests, String packageName, boolean required, int targetSdk, ArrayList<SharedLibraryInfo> outUsedLibraries, Map<String, PackageParser.Package> availablePackages, Map<String, LongSparseArray<SharedLibraryInfo>> existingLibraries, Map<String, LongSparseArray<SharedLibraryInfo>> newLibraries) throws PackageManagerException {
        long libVersion;
        int libCount;
        String[] strArr;
        int libCount2 = requestedLibraries.size();
        int i = 0;
        ArrayList<SharedLibraryInfo> outUsedLibraries2 = outUsedLibraries;
        while (i < libCount2) {
            String libName = requestedLibraries.get(i);
            if (requiredVersions != null) {
                libVersion = requiredVersions[i];
            } else {
                libVersion = -1;
            }
            SharedLibraryInfo libraryInfo = getSharedLibraryInfo(libName, libVersion, existingLibraries, newLibraries);
            if (libraryInfo != null) {
                if (requiredVersions == null || requiredCertDigests == null) {
                    libCount = libCount2;
                } else if (libraryInfo.getLongVersion() == requiredVersions[i]) {
                    PackageParser.Package libPkg = availablePackages.get(libraryInfo.getPackageName());
                    if (libPkg != null) {
                        String[] expectedCertDigests = requiredCertDigests[i];
                        libCount = libCount2;
                        if (expectedCertDigests.length > 1) {
                            if (targetSdk >= 27) {
                                strArr = PackageUtils.computeSignaturesSha256Digests(libPkg.mSigningDetails.signatures);
                            } else {
                                strArr = PackageUtils.computeSignaturesSha256Digests(new Signature[]{libPkg.mSigningDetails.signatures[0]});
                            }
                            String[] libCertDigests = strArr;
                            if (expectedCertDigests.length == libCertDigests.length) {
                                Arrays.sort(libCertDigests);
                                Arrays.sort(expectedCertDigests);
                                int certCount = libCertDigests.length;
                                int j = 0;
                                while (j < certCount) {
                                    if (libCertDigests[j].equalsIgnoreCase(expectedCertDigests[j])) {
                                        j++;
                                        libCertDigests = libCertDigests;
                                    } else {
                                        throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                                    }
                                }
                            } else {
                                throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                            }
                        } else if (!libPkg.mSigningDetails.hasSha256Certificate(ByteStringUtils.fromHexToByteArray(expectedCertDigests[0]))) {
                            throw new PackageManagerException(-9, "Package " + packageName + " requires differently signed static shared library; failing!");
                        }
                    } else {
                        throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library; failing!");
                    }
                } else {
                    throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable static shared library " + libName + " version " + libraryInfo.getLongVersion() + "; failing!");
                }
                if (outUsedLibraries2 == null) {
                    outUsedLibraries2 = new ArrayList<>();
                }
                outUsedLibraries2.add(libraryInfo);
            } else if (!required) {
                if (DEBUG_SHARED_LIBRARIES) {
                    Slog.i(TAG, "Package " + packageName + " desires unavailable shared library " + libName + "; ignoring!");
                }
                libCount = libCount2;
            } else {
                throw new PackageManagerException(-9, "Package " + packageName + " requires unavailable shared library " + libName + "; failing!");
            }
            i++;
            libCount2 = libCount;
        }
        return outUsedLibraries2;
    }

    private static boolean hasString(List<String> list, List<String> which) {
        if (list == null || which == null) {
            return false;
        }
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = which.size() - 1; j >= 0; j--) {
                if (which.get(j).equals(list.get(i))) {
                    return true;
                }
            }
        }
        return false;
    }

    /* access modifiers changed from: protected */
    @GuardedBy({"mPackages"})
    public ArrayList<PackageParser.Package> updateAllSharedLibrariesLocked(PackageParser.Package updatedPkg, Map<String, PackageParser.Package> availablePackages) {
        ArrayList<PackageParser.Package> needsUpdating;
        int i;
        ArrayList<PackageParser.Package> resultList;
        ArraySet<String> descendants;
        ArrayList<PackageParser.Package> resultList2;
        ArrayList<PackageParser.Package> resultList3 = null;
        ArraySet<String> descendants2 = null;
        if (updatedPkg != null) {
            ArrayList<PackageParser.Package> needsUpdating2 = new ArrayList<>(1);
            needsUpdating2.add(updatedPkg);
            needsUpdating = needsUpdating2;
        } else {
            needsUpdating = null;
        }
        do {
            PackageParser.Package changingPkg = needsUpdating == null ? null : needsUpdating.remove(0);
            int i2 = this.mPackages.size() - 1;
            while (i2 >= 0) {
                PackageParser.Package pkg = this.mPackages.valueAt(i2);
                if (changingPkg == null || hasString(pkg.usesLibraries, changingPkg.libraryNames) || hasString(pkg.usesOptionalLibraries, changingPkg.libraryNames) || ArrayUtils.contains(pkg.usesStaticLibraries, changingPkg.staticSharedLibName)) {
                    if (resultList3 == null) {
                        resultList = new ArrayList<>();
                    } else {
                        resultList = resultList3;
                    }
                    if (changingPkg != null && !"com.huawei.androidx".equals(changingPkg.manifestPackageName)) {
                        resultList.add(pkg);
                    }
                    if (changingPkg != null) {
                        if (descendants2 == null) {
                            descendants2 = new ArraySet<>();
                        }
                        if (!descendants2.contains(pkg.packageName)) {
                            descendants2.add(pkg.packageName);
                            needsUpdating.add(pkg);
                        }
                        descendants = descendants2;
                    } else {
                        descendants = descendants2;
                    }
                    try {
                        updateSharedLibrariesLocked(pkg, changingPkg, availablePackages);
                        resultList2 = resultList;
                        i = i2;
                    } catch (PackageManagerException e) {
                        if (!pkg.isSystem() || pkg.isUpdatedSystemApp()) {
                            resultList2 = resultList;
                            i = i2;
                            deletePackageLIF(pkg.packageName, null, true, sUserManager.getUserIds(), pkg.isUpdatedSystemApp() ? 1 : 0, null, true, null);
                        } else {
                            resultList2 = resultList;
                            i = i2;
                        }
                        Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
                    }
                    descendants2 = descendants;
                    resultList3 = resultList2;
                } else {
                    i = i2;
                }
                i2 = i - 1;
            }
            if (needsUpdating == null) {
                break;
            }
        } while (needsUpdating.size() > 0);
        return resultList3;
    }

    /* JADX INFO: finally extract failed */
    @GuardedBy({"mInstallLock", "mPackages"})
    private List<ScanResult> scanPackageTracedLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        int scanFlags2;
        Trace.traceBegin(262144, "scanPackage");
        if ((scanFlags & 1024) != 0) {
            scanFlags2 = scanFlags & -1025;
        } else if (pkg.childPackages == null || pkg.childPackages.size() <= 0) {
            scanFlags2 = scanFlags;
        } else {
            scanFlags2 = scanFlags | 1024;
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        List<ScanResult> scanResults = new ArrayList<>(childCount + 1);
        try {
            scanResults.add(scanPackageNewLI(pkg, parseFlags, scanFlags2, currentTime, user));
            for (int i = 0; i < childCount; i++) {
                scanResults.add(scanPackageNewLI((PackageParser.Package) pkg.childPackages.get(i), parseFlags, scanFlags2, currentTime, user));
            }
            Trace.traceEnd(262144);
            if ((scanFlags2 & 1024) != 0) {
                return scanPackageTracedLI(pkg, parseFlags, scanFlags2, currentTime, user);
            }
            return scanResults;
        } catch (Throwable th) {
            Trace.traceEnd(262144);
            throw th;
        }
    }

    /* access modifiers changed from: private */
    public static class ScanResult {
        public final List<String> changedAbiCodePath;
        public final List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        public final boolean existingSettingCopied;
        public final PackageSetting pkgSetting;
        public final ScanRequest request;
        public final SharedLibraryInfo staticSharedLibraryInfo;
        public final boolean success;

        public ScanResult(ScanRequest request2, boolean success2, PackageSetting pkgSetting2, List<String> changedAbiCodePath2, boolean existingSettingCopied2, SharedLibraryInfo staticSharedLibraryInfo2, List<SharedLibraryInfo> dynamicSharedLibraryInfos2) {
            this.request = request2;
            this.success = success2;
            this.pkgSetting = pkgSetting2;
            this.changedAbiCodePath = changedAbiCodePath2;
            this.existingSettingCopied = existingSettingCopied2;
            this.staticSharedLibraryInfo = staticSharedLibraryInfo2;
            this.dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        }
    }

    /* access modifiers changed from: private */
    public static class ScanRequest {
        public final PackageSetting disabledPkgSetting;
        public final boolean isPlatformPackage;
        public final PackageParser.Package oldPkg;
        public final PackageSetting oldPkgSetting;
        public final PackageSetting originalPkgSetting;
        public final int parseFlags;
        public final PackageParser.Package pkg;
        public final PackageSetting pkgSetting;
        public final String realPkgName;
        public final int scanFlags;
        public final SharedUserSetting sharedUserSetting;
        public final UserHandle user;

        public ScanRequest(PackageParser.Package pkg2, SharedUserSetting sharedUserSetting2, PackageParser.Package oldPkg2, PackageSetting pkgSetting2, PackageSetting disabledPkgSetting2, PackageSetting originalPkgSetting2, String realPkgName2, int parseFlags2, int scanFlags2, boolean isPlatformPackage2, UserHandle user2) {
            this.pkg = pkg2;
            this.oldPkg = oldPkg2;
            this.pkgSetting = pkgSetting2;
            this.sharedUserSetting = sharedUserSetting2;
            this.oldPkgSetting = pkgSetting2 == null ? null : new PackageSetting(pkgSetting2);
            this.disabledPkgSetting = disabledPkgSetting2;
            this.originalPkgSetting = originalPkgSetting2;
            this.realPkgName = realPkgName2;
            this.parseFlags = parseFlags2;
            this.scanFlags = scanFlags2;
            this.isPlatformPackage = isPlatformPackage2;
            this.user = user2;
        }
    }

    private int adjustScanFlags(int scanFlags, PackageSetting pkgSetting, PackageSetting disabledPkgSetting, UserHandle user, PackageParser.Package pkg) {
        PackageSetting systemPkgSetting;
        if ((scanFlags & 4) == 0 || disabledPkgSetting != null || pkgSetting == null || !pkgSetting.isSystem()) {
            systemPkgSetting = disabledPkgSetting;
        } else {
            systemPkgSetting = pkgSetting;
        }
        if (systemPkgSetting != null) {
            scanFlags |= 131072;
            if ((systemPkgSetting.pkgPrivateFlags & 8) != 0) {
                scanFlags |= 262144;
            }
            if ((131072 & systemPkgSetting.pkgPrivateFlags) != 0) {
                scanFlags |= 524288;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 262144) != 0) {
                scanFlags |= 1048576;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 524288) != 0) {
                scanFlags |= 2097152;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 2097152) != 0) {
                scanFlags |= 4194304;
            }
            if ((systemPkgSetting.pkgPrivateFlags & 1073741824) != 0) {
                scanFlags |= 8388608;
            }
        }
        if (pkgSetting != null) {
            int userId = user == null ? 0 : user.getIdentifier();
            if (pkgSetting.getInstantApp(userId)) {
                scanFlags |= 16384;
            }
            if (pkgSetting.getVirtulalPreload(userId)) {
                scanFlags |= 65536;
            }
        }
        boolean skipVendorPrivilegeScan = (1048576 & scanFlags) != 0 && SystemProperties.getInt("ro.vndk.version", 28) < 28;
        if ((scanFlags & 262144) == 0 && !pkg.isPrivileged() && pkg.mSharedUserId != null && !skipVendorPrivilegeScan) {
            SharedUserSetting sharedUserSetting = null;
            try {
                sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
            } catch (PackageManagerException e) {
            }
            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                synchronized (this.mPackages) {
                    if (PackageManagerServiceUtils.compareSignatures(this.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME).signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) != 0) {
                        scanFlags |= 262144;
                    }
                }
            }
        }
        return scanFlags;
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private ScanResult scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        return scanPackageNewLI(pkg, parseFlags, scanFlags, currentTime, user, 0);
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private ScanResult scanPackageNewLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        int scanFlags2;
        SharedUserSetting sharedUserSetting;
        String renamedPkgName = this.mSettings.getRenamedPackageLPr(pkg.mRealPackage);
        String realPkgName = getRealPackageName(pkg, renamedPkgName);
        if (realPkgName != null) {
            ensurePackageRenamed(pkg, renamedPkgName);
        }
        PackageSetting originalPkgSetting = getOriginalPackageLocked(pkg, renamedPkgName);
        PackageSetting pkgSetting = this.mSettings.getPackageLPr(pkg.packageName);
        PackageSetting disabledPkgSetting = this.mSettings.getDisabledSystemPkgLPr(pkg.packageName);
        if (this.mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        int scanFlags3 = adjustScanFlags(scanFlags, pkgSetting, disabledPkgSetting, user, pkg);
        mHwPMSEx.resolvePersistentFlagForPackage(disabledPkgSetting != null ? disabledPkgSetting.pkgFlags : Integer.MIN_VALUE, pkg);
        if (isSystemAppGrantByMdmAndNonPreload(pkg)) {
            scanFlags2 = mHwPMSEx.adjustScanFlagForApk(pkg, scanFlags3);
        } else {
            scanFlags2 = scanFlags3;
        }
        synchronized (this.mPackages) {
            try {
                try {
                    applyPolicy(pkg, parseFlags, scanFlags2, this.mPlatformPackage, hwFlags);
                    String type = HwMaplePMServiceUtils.getMapleAppType(pkg);
                    int hwFlagTemp = hwFlags;
                    if (type != null) {
                        try {
                            if (type.equals("m")) {
                                hwFlagTemp |= DumpState.DUMP_SERVICE_PERMISSIONS;
                                ApplicationInfo applicationInfo = pkg.applicationInfo;
                                applicationInfo.hwFlags = 16777216 | applicationInfo.hwFlags;
                            } else if (type.equals("mo")) {
                                hwFlagTemp |= 20971520;
                                ApplicationInfo applicationInfo2 = pkg.applicationInfo;
                                applicationInfo2.hwFlags = 20971520 | applicationInfo2.hwFlags;
                            } else if (type.equals("z")) {
                                hwFlagTemp |= 8388608;
                                ApplicationInfo applicationInfo3 = pkg.applicationInfo;
                                applicationInfo3.hwFlags = 8388608 | applicationInfo3.hwFlags;
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    }
                    if (HwMaplePMServiceUtils.getDependWebView(pkg)) {
                        hwFlagTemp |= 2097152;
                        ApplicationInfo applicationInfo4 = pkg.applicationInfo;
                        applicationInfo4.hwFlags = 2097152 | applicationInfo4.hwFlags;
                    }
                    if ("com.huawei.webview".equals(pkg.packageName)) {
                        HwMaplePMServiceUtils.setWebViewInfoFlags(hwFlagTemp);
                    }
                    if (HwMaplePMServiceUtils.isMaplePkgGcOnly(pkg)) {
                        hwFlagTemp |= 524288;
                        ApplicationInfo applicationInfo5 = pkg.applicationInfo;
                        applicationInfo5.hwFlags = 524288 | applicationInfo5.hwFlags;
                    }
                    assertPackageIsValid(pkg, parseFlags, scanFlags2);
                    if (pkg.mSharedUserId != null) {
                        sharedUserSetting = this.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
                        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
                            Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + sharedUserSetting.userId + "): packages=" + sharedUserSetting.packages);
                        }
                    } else {
                        sharedUserSetting = null;
                    }
                    if (isSystemApp(pkg) || !HwDeviceManager.disallowOp(19, pkg.packageName)) {
                        PackageParser.Package r8 = pkgSetting == null ? null : pkgSetting.pkg;
                        boolean z = pkg == this.mPlatformPackage;
                        try {
                            return scanPackageOnlyLI(new ScanRequest(pkg, sharedUserSetting, r8, pkgSetting, disabledPkgSetting, originalPkgSetting, realPkgName, parseFlags, scanFlags2, z, user), this.mFactoryTest, currentTime, hwFlagTemp);
                        } catch (Throwable th2) {
                            th = th2;
                            throw th;
                        }
                    } else {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "app is in the installpackage_blacklist");
                    }
                } catch (Throwable th3) {
                    th = th3;
                    throw th;
                }
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
    }

    private boolean optimisticallyRegisterAppId(ScanResult result) throws PackageManagerException {
        if (!result.existingSettingCopied) {
            return this.mSettings.registerAppIdLPw(result.pkgSetting);
        }
        return false;
    }

    private void cleanUpAppIdCreation(ScanResult result) {
        if (result.pkgSetting.appId > 0) {
            this.mSettings.removeAppIdLPw(result.pkgSetting.appId);
        }
    }

    @GuardedBy({"mPackages", "mInstallLock"})
    private void commitReconciledScanResultLocked(ReconciledPackage reconciledPkg) {
        PackageSetting pkgSetting;
        String realPkgName;
        PackageSetting pkgSetting2;
        String realPkgName2;
        PackageSetting pkgSetting3;
        ScanResult result = reconciledPkg.scanResult;
        ScanRequest request = result.request;
        PackageParser.Package pkg = request.pkg;
        PackageParser.Package oldPkg = request.oldPkg;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        PackageSetting oldPkgSetting = request.oldPkgSetting;
        PackageSetting originalPkgSetting = request.originalPkgSetting;
        UserHandle user = request.user;
        String realPkgName3 = request.realPkgName;
        List<String> changedAbiCodePath = result.changedAbiCodePath;
        if (!(request.pkgSetting == null || request.pkgSetting.sharedUser == null || request.pkgSetting.sharedUser == result.pkgSetting.sharedUser)) {
            request.pkgSetting.sharedUser.removePackage(request.pkgSetting);
        }
        if (result.existingSettingCopied) {
            PackageSetting pkgSetting4 = request.pkgSetting;
            pkgSetting4.updateFrom(result.pkgSetting);
            pkg.mExtras = pkgSetting4;
            pkgSetting = pkgSetting4;
        } else {
            PackageSetting pkgSetting5 = result.pkgSetting;
            if (originalPkgSetting != null) {
                pkgSetting3 = pkgSetting5;
                this.mSettings.addRenamedPackageLPw(pkg.packageName, originalPkgSetting.name);
            } else {
                pkgSetting3 = pkgSetting5;
            }
            if (originalPkgSetting != null && (scanFlags & 1024) == 0) {
                this.mTransferedPackages.add(originalPkgSetting.name);
            }
            pkgSetting = pkgSetting3;
        }
        if (pkgSetting.sharedUser != null) {
            pkgSetting.sharedUser.addPackage(pkgSetting);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        this.mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);
        if ((scanFlags & 1024) == 0 && realPkgName3 != null) {
            this.mTransferedPackages.add(pkg.packageName);
        }
        if (reconciledPkg.collectedSharedLibraryInfos != null) {
            executeSharedLibrariesUpdateLPr(pkg, null, reconciledPkg.collectedSharedLibraryInfos);
        }
        KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
        if (reconciledPkg.removeAppKeySetData) {
            ksms.removeAppKeySetDataLPw(pkg.packageName);
        }
        if (reconciledPkg.sharedUserSignaturesChanged) {
            pkgSetting.sharedUser.signaturesChanged = Boolean.TRUE;
            pkgSetting.sharedUser.signatures.mSigningDetails = reconciledPkg.signingDetails;
        }
        pkgSetting.signatures.mSigningDetails = reconciledPkg.signingDetails;
        if ((scanFlags & 1024) != 0 || pkg.mAdoptPermissions == null) {
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        } else {
            int i = pkg.mAdoptPermissions.size() - 1;
            while (i >= 0) {
                String origName = (String) pkg.mAdoptPermissions.get(i);
                PackageSetting orig = this.mSettings.getPackageLPr(origName);
                if (orig == null) {
                    realPkgName2 = realPkgName3;
                } else if (verifyPackageUpdateLPr(orig, pkg)) {
                    StringBuilder sb = new StringBuilder();
                    realPkgName2 = realPkgName3;
                    sb.append("Adopting permissions from ");
                    sb.append(origName);
                    sb.append(" to ");
                    sb.append(pkg.packageName);
                    Slog.i(TAG, sb.toString());
                    this.mSettings.mPermissions.transferPermissions(origName, pkg.packageName);
                } else {
                    realPkgName2 = realPkgName3;
                }
                i--;
                pkgSetting = pkgSetting;
                realPkgName3 = realPkgName2;
            }
            pkgSetting2 = pkgSetting;
            realPkgName = realPkgName3;
        }
        if (changedAbiCodePath != null && changedAbiCodePath.size() > 0) {
            for (int i2 = changedAbiCodePath.size() - 1; i2 >= 0; i2--) {
                try {
                    this.mInstaller.rmdex(changedAbiCodePath.get(i2), InstructionSets.getDexCodeInstructionSet(InstructionSets.getPreferredInstructionSet()));
                } catch (Installer.InstallerException e) {
                }
            }
        }
        if ((scanFlags & 1024) == 0) {
            boolean z = false;
            int userId = user == null ? 0 : user.getIdentifier();
            if ((Integer.MIN_VALUE & parseFlags) != 0) {
                z = true;
            }
            commitPackageSettings(pkg, oldPkg, pkgSetting2, scanFlags, z, reconciledPkg);
            if (pkgSetting2.getInstantApp(userId)) {
                this.mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting2.appId);
            }
        } else if (oldPkgSetting != null) {
            synchronized (this.mPackages) {
                this.mSettings.mPackages.put(oldPkgSetting.name, oldPkgSetting);
            }
        }
    }

    private static String getRealPackageName(PackageParser.Package pkg, String renamedPkgName) {
        if (isPackageRenamed(pkg, renamedPkgName)) {
            return pkg.mRealPackage;
        }
        return null;
    }

    private static boolean isPackageRenamed(PackageParser.Package pkg, String renamedPkgName) {
        return pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPkgName);
    }

    @GuardedBy({"mPackages"})
    private PackageSetting getOriginalPackageLocked(PackageParser.Package pkg, String renamedPkgName) {
        if (!isPackageRenamed(pkg, renamedPkgName)) {
            return null;
        }
        for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
            PackageSetting originalPs = this.mSettings.getPackageLPr((String) pkg.mOriginalPackages.get(i));
            if (originalPs != null && verifyPackageUpdateLPr(originalPs, pkg)) {
                if (originalPs.sharedUser != null) {
                    if (!originalPs.sharedUser.name.equals(pkg.mSharedUserId)) {
                        Slog.w(TAG, "Unable to migrate data from " + originalPs.name + " to " + pkg.packageName + ": old uid " + originalPs.sharedUser.name + " differs from " + pkg.mSharedUserId);
                    }
                } else if (DEBUG_UPGRADE) {
                    Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + originalPs.name);
                }
                return originalPs;
            }
        }
        return null;
    }

    private static void ensurePackageRenamed(PackageParser.Package pkg, String renamedPackageName) {
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(renamedPackageName) && !pkg.packageName.equals(renamedPackageName)) {
            pkg.setPackageName(renamedPackageName);
        }
    }

    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime) throws PackageManagerException {
        return scanPackageOnlyLI(request, isUnderFactoryTest, currentTime, 0);
    }

    @GuardedBy({"mInstallLock"})
    private static ScanResult scanPackageOnlyLI(ScanRequest request, boolean isUnderFactoryTest, long currentTime, int hwFlags) throws PackageManagerException {
        String secondaryCpuAbiFromSettings;
        String primaryCpuAbiFromSettings;
        boolean isPlatformPackage;
        String str;
        String secondaryCpuAbiFromSettings2;
        String str2;
        String primaryCpuAbiFromSettings2;
        PackageSetting pkgSetting;
        UserHandle user;
        String secondaryCpuAbiFromSettings3;
        boolean z;
        String cpuAbiOverride;
        PackageSetting originalPkgSetting;
        List<SharedLibraryInfo> dynamicSharedLibraryInfos;
        String str3;
        String primaryCpuAbiFromSettings3;
        String secondaryCpuAbiFromSettings4;
        String str4;
        String str5;
        PackageParser.Package pkg = request.pkg;
        PackageSetting pkgSetting2 = request.pkgSetting;
        PackageSetting disabledPkgSetting = request.disabledPkgSetting;
        PackageSetting originalPkgSetting2 = request.originalPkgSetting;
        int parseFlags = request.parseFlags;
        int scanFlags = request.scanFlags;
        String realPkgName = request.realPkgName;
        SharedUserSetting sharedUserSetting = request.sharedUserSetting;
        UserHandle user2 = request.user;
        boolean isPlatformPackage2 = request.isPlatformPackage;
        List<String> changedAbiCodePath = null;
        if (DEBUG_PACKAGE_SCANNING && (Integer.MIN_VALUE & parseFlags) != 0) {
            Log.d(TAG, "Scanning package " + pkg.packageName);
        }
        new File(pkg.codePath);
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
        boolean needToDeriveAbi = (scanFlags & 8192) != 0;
        if (needToDeriveAbi) {
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        } else if (pkgSetting2 != null) {
            secondaryCpuAbiFromSettings = pkgSetting2.primaryCpuAbiString;
            primaryCpuAbiFromSettings = pkgSetting2.secondaryCpuAbiString;
        } else {
            needToDeriveAbi = true;
            secondaryCpuAbiFromSettings = null;
            primaryCpuAbiFromSettings = null;
        }
        if (!(pkgSetting2 == null || pkgSetting2.sharedUser == sharedUserSetting)) {
            StringBuilder sb = new StringBuilder();
            sb.append("Package ");
            sb.append(pkg.packageName);
            sb.append(" shared user changed from ");
            if (pkgSetting2.sharedUser != null) {
                str4 = pkgSetting2.sharedUser.name;
            } else {
                str4 = "<nothing>";
            }
            sb.append(str4);
            sb.append(" to ");
            if (sharedUserSetting != null) {
                str5 = sharedUserSetting.name;
            } else {
                str5 = "<nothing>";
            }
            sb.append(str5);
            sb.append("; replacing with new");
            reportSettingsProblem(5, sb.toString());
            pkgSetting2 = null;
        }
        String[] usesStaticLibraries = null;
        if (pkg.usesStaticLibraries != null) {
            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];
            pkg.usesStaticLibraries.toArray(usesStaticLibraries);
        }
        boolean createNewPackage = pkgSetting2 == null;
        if (createNewPackage) {
            String parentPackageName = pkg.parentPackage != null ? pkg.parentPackage.packageName : null;
            boolean instantApp = (scanFlags & 16384) != 0;
            boolean virtualPreload = (65536 & scanFlags) != 0;
            String str6 = pkg.packageName;
            str2 = " to ";
            String str7 = pkg.applicationInfo.nativeLibraryRootDir;
            String str8 = pkg.applicationInfo.primaryCpuAbi;
            String str9 = pkg.applicationInfo.secondaryCpuAbi;
            long j = (long) pkg.mVersionCode;
            int i = pkg.applicationInfo.flags;
            int i2 = pkg.applicationInfo.privateFlags;
            List childPackageNames = pkg.getChildPackageNames();
            UserManagerService instance = UserManagerService.getInstance();
            long[] jArr = pkg.usesStaticLibrariesVersions;
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            pkgSetting = Settings.createNewSetting(str6, originalPkgSetting2, disabledPkgSetting, realPkgName, sharedUserSetting, destCodeFile, destResourceFile, str7, str8, str9, j, i, i2, user2, true, instantApp, virtualPreload, parentPackageName, childPackageNames, instance, usesStaticLibraries, jArr);
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
        } else {
            str2 = " to ";
            secondaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings;
            str = TAG;
            isPlatformPackage = isPlatformPackage2;
            PackageSetting pkgSetting3 = new PackageSetting(pkgSetting2);
            pkgSetting3.pkg = pkg;
            primaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings;
            Settings.updatePackageSetting(pkgSetting3, disabledPkgSetting, sharedUserSetting, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(), UserManagerService.getInstance(), usesStaticLibraries, pkg.usesStaticLibrariesVersions);
            pkgSetting = pkgSetting3;
        }
        pkgSetting.hw_extra_flags = pkg.applicationInfo.hw_extra_flags;
        if (createNewPackage && originalPkgSetting2 != null) {
            pkg.setPackageName(originalPkgSetting2.name);
            reportSettingsProblem(5, "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name);
        }
        int userId = user2 == null ? 0 : user2.getIdentifier();
        if (!createNewPackage) {
            setInstantAppForUser(pkgSetting, userId, (scanFlags & 16384) != 0, (32768 & scanFlags) != 0);
        }
        if (disabledPkgSetting != null || ((scanFlags & 4) != 0 && pkgSetting.isSystem() && !isSystemAppGrantByMdmAndNonPreload(pkg))) {
            pkg.applicationInfo.flags |= 128;
            HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
        }
        pkg.applicationInfo.seInfo = SELinuxMMAC.getSeInfo(pkg, sharedUserSetting != null ? sharedUserSetting.isPrivileged() | pkg.isPrivileged() : pkg.isPrivileged(), pkg.applicationInfo.targetSandboxVersion, (sharedUserSetting == null || sharedUserSetting.packages.size() == 0) ? pkg.applicationInfo.targetSdkVersion : sharedUserSetting.seInfoTargetSdkVersion);
        pkg.applicationInfo.seInfoUser = SELinuxUtil.assignSeinfoUser(pkgSetting.readUserState(userId == -1 ? 0 : userId));
        pkg.mExtras = pkgSetting;
        pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName);
        if (!isPlatformPackage) {
            pkg.applicationInfo.initForUser(0);
        }
        String cpuAbiOverride2 = PackageManagerServiceUtils.deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
        if ((scanFlags & 4) != 0) {
            user = user2;
            secondaryCpuAbiFromSettings3 = str;
            if ((scanFlags & 256) != 0) {
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
                pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
            } else {
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings2;
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        } else if (needToDeriveAbi) {
            user = user2;
            Trace.traceBegin(262144, "derivePackageAbi");
            derivePackageAbi(pkg, cpuAbiOverride2, (pkg.isLibrary() ^ true) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
            Trace.traceEnd(262144);
            if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
                setBundledAppAbisAndRoots(pkg, pkgSetting);
                setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            }
            secondaryCpuAbiFromSettings3 = str;
        } else {
            user = user2;
            if (primaryCpuAbiFromSettings2 != null || ((!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath))) {
                primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings3;
                secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings4;
            } else {
                derivePackageAbi(pkg, cpuAbiOverride2, !pkg.isLibrary() && !HwPackageManagerServiceUtils.isNoSystemPreApp(pkg.codePath));
                if (pkg.applicationInfo.primaryCpuAbi == null) {
                    setBundledAppAbisAndRoots(pkg, pkgSetting);
                    primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                    secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                } else {
                    primaryCpuAbiFromSettings3 = primaryCpuAbiFromSettings2;
                    secondaryCpuAbiFromSettings4 = secondaryCpuAbiFromSettings2;
                }
            }
            setNativeLibraryPaths(pkg, sAppLib32InstallDir);
            if (DEBUG_ABI_SELECTION) {
                StringBuilder sb2 = new StringBuilder();
                secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings4;
                sb2.append("Using ABIS and native lib paths from settings : ");
                sb2.append(pkg.packageName);
                sb2.append(" ");
                sb2.append(pkg.applicationInfo.primaryCpuAbi);
                sb2.append(", ");
                sb2.append(pkg.applicationInfo.secondaryCpuAbi);
                secondaryCpuAbiFromSettings3 = str;
                Slog.i(secondaryCpuAbiFromSettings3, sb2.toString());
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings3;
            } else {
                secondaryCpuAbiFromSettings2 = secondaryCpuAbiFromSettings4;
                secondaryCpuAbiFromSettings3 = str;
                primaryCpuAbiFromSettings2 = primaryCpuAbiFromSettings3;
            }
        }
        if (isPlatformPackage) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            if (VMRuntime.getRuntime().is64Bit()) {
                z = false;
                str3 = Build.SUPPORTED_64_BIT_ABIS[0];
            } else {
                z = false;
                str3 = Build.SUPPORTED_32_BIT_ABIS[0];
            }
            applicationInfo.primaryCpuAbi = str3;
        } else {
            z = false;
        }
        if ((scanFlags & 1) == 0 && (scanFlags & 4) != 0 && cpuAbiOverride2 == null && pkg.packageName != null) {
            Slog.w(secondaryCpuAbiFromSettings3, "Ignoring persisted ABI override " + cpuAbiOverride2 + " for package " + pkg.packageName);
        }
        pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
        pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        pkgSetting.cpuAbiOverrideString = cpuAbiOverride2;
        pkg.cpuAbiOverride = cpuAbiOverride2;
        if (DEBUG_ABI_SELECTION) {
            Slog.d(secondaryCpuAbiFromSettings3, "Resolved nativeLibraryRoot for " + pkg.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
        }
        pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
        if (DEBUG_ABI_SELECTION) {
            Log.d(secondaryCpuAbiFromSettings3, "Abis for package[" + pkg.packageName + "] are primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
        }
        if ((scanFlags & 16) == 0 && pkgSetting.sharedUser != null) {
            changedAbiCodePath = adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);
        }
        if (isUnderFactoryTest && pkg.requestedPermissions.contains("android.permission.FACTORY_TEST")) {
            pkg.applicationInfo.flags |= 16;
        }
        if (isSystemApp(pkg)) {
            pkgSetting.isOrphaned = true;
        }
        long scanFileTime = PackageManagerServiceUtils.getLastModifiedTime(pkg);
        if (currentTime != 0) {
            cpuAbiOverride = cpuAbiOverride2;
            originalPkgSetting = originalPkgSetting2;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = currentTime;
                pkgSetting.firstInstallTime = currentTime;
            } else if ((scanFlags & 8) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else {
            cpuAbiOverride = cpuAbiOverride2;
            originalPkgSetting = originalPkgSetting2;
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.lastUpdateTime = scanFileTime;
                pkgSetting.firstInstallTime = scanFileTime;
            } else if ((parseFlags & 16) != 0) {
                if (scanFileTime != pkgSetting.timeStamp) {
                    pkgSetting.lastUpdateTime = scanFileTime;
                }
                if ((pkg.applicationInfo.hwFlags & 8388608) != 0) {
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(pkg.packageName)) {
                        HwMaplePMServiceUtils.setMapleEnableFlag(pkg.packageName, true);
                    }
                }
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        pkgSetting.pkg = pkg;
        pkgSetting.pkgFlags = pkg.applicationInfo.flags;
        if (pkg.getLongVersionCode() != pkgSetting.versionCode) {
            pkgSetting.versionCode = pkg.getLongVersionCode();
        }
        String volumeUuid = pkg.applicationInfo.volumeUuid;
        if (!Objects.equals(volumeUuid, pkgSetting.volumeUuid)) {
            StringBuilder sb3 = new StringBuilder();
            sb3.append("Update");
            sb3.append(pkgSetting.isSystem() ? " system" : "");
            sb3.append(" package ");
            sb3.append(pkg.packageName);
            sb3.append(" volume from ");
            sb3.append(pkgSetting.volumeUuid);
            sb3.append(str2);
            sb3.append(volumeUuid);
            Slog.i(secondaryCpuAbiFromSettings3, sb3.toString());
            pkgSetting.volumeUuid = volumeUuid;
        }
        SharedLibraryInfo staticSharedLibraryInfo = !TextUtils.isEmpty(pkg.staticSharedLibName) ? SharedLibraryInfo.createForStatic(pkg) : null;
        if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
            List<SharedLibraryInfo> dynamicSharedLibraryInfos2 = new ArrayList<>(pkg.libraryNames.size());
            for (Iterator it = pkg.libraryNames.iterator(); it.hasNext(); it = it) {
                dynamicSharedLibraryInfos2.add(SharedLibraryInfo.createForDynamic(pkg, (String) it.next()));
            }
            dynamicSharedLibraryInfos = dynamicSharedLibraryInfos2;
        } else {
            dynamicSharedLibraryInfos = null;
        }
        if (!createNewPackage) {
            z = true;
        }
        return new ScanResult(request, true, pkgSetting, changedAbiCodePath, z, staticSharedLibraryInfo, dynamicSharedLibraryInfos);
    }

    private static boolean apkHasCode(String fileName) {
        StrictJarFile jarFile = null;
        boolean z = false;
        try {
            jarFile = new StrictJarFile(fileName, false, false);
            if (jarFile.findEntry("classes.dex") != null) {
                z = true;
            }
            try {
                jarFile.close();
            } catch (IOException e) {
            }
            return z;
        } catch (IOException e2) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e3) {
                }
            }
            return false;
        } catch (Throwable th) {
            if (jarFile != null) {
                try {
                    jarFile.close();
                } catch (IOException e4) {
                }
            }
            throw th;
        }
    }

    private static void assertCodePolicy(PackageParser.Package pkg) throws PackageManagerException {
        boolean shouldHaveCode = (pkg.applicationInfo.flags & 4) != 0;
        boolean isMapleOnlySupport = (pkg.applicationInfo.hwFlags & 4194304) != 0 && MAPLE_ENABLE;
        if (shouldHaveCode && !apkHasCode(pkg.baseCodePath) && !isMapleOnlySupport) {
            throw new PackageManagerException(-2, "Package " + pkg.baseCodePath + " code is missing");
        } else if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
            for (int i = 0; i < pkg.splitCodePaths.length; i++) {
                if (((pkg.splitFlags[i] & 4) != 0) && !apkHasCode(pkg.splitCodePaths[i]) && !isMapleOnlySupport) {
                    throw new PackageManagerException(-2, "Package " + pkg.splitCodePaths[i] + " code is missing");
                }
            }
        }
    }

    private static void applyPolicy(PackageParser.Package pkg, int parseFlags, int scanFlags, PackageParser.Package platformPkg, int hwFlags) {
        if ((scanFlags & 131072) != 0) {
            pkg.applicationInfo.flags |= 1;
            if (pkg.applicationInfo.isDirectBootAware()) {
                Iterator it = pkg.services.iterator();
                while (it.hasNext()) {
                    PackageParser.Service s = (PackageParser.Service) it.next();
                    ServiceInfo serviceInfo = s.info;
                    s.info.directBootAware = true;
                    serviceInfo.encryptionAware = true;
                }
                Iterator it2 = pkg.providers.iterator();
                while (it2.hasNext()) {
                    PackageParser.Provider p = (PackageParser.Provider) it2.next();
                    ProviderInfo providerInfo = p.info;
                    p.info.directBootAware = true;
                    providerInfo.encryptionAware = true;
                }
                Iterator it3 = pkg.activities.iterator();
                while (it3.hasNext()) {
                    PackageParser.Activity a = (PackageParser.Activity) it3.next();
                    ActivityInfo activityInfo = a.info;
                    a.info.directBootAware = true;
                    activityInfo.encryptionAware = true;
                }
                Iterator it4 = pkg.receivers.iterator();
                while (it4.hasNext()) {
                    PackageParser.Activity r = (PackageParser.Activity) it4.next();
                    ActivityInfo activityInfo2 = r.info;
                    r.info.directBootAware = true;
                    activityInfo2.encryptionAware = true;
                }
            }
            if (PackageManagerServiceUtils.compressedFileExists(pkg.codePath)) {
                pkg.isStub = true;
            }
        } else {
            pkg.coreApp = false;
            pkg.applicationInfo.flags &= -9;
            pkg.applicationInfo.privateFlags &= -33;
            pkg.applicationInfo.privateFlags &= -65;
            pkg.protectedBroadcasts = null;
            if (pkg.permissionGroups != null && pkg.permissionGroups.size() > 0) {
                for (int i = pkg.permissionGroups.size() - 1; i >= 0; i--) {
                    ((PackageParser.PermissionGroup) pkg.permissionGroups.get(i)).info.priority = 0;
                }
            }
        }
        if ((scanFlags & 262144) == 0) {
            if (pkg.receivers != null) {
                for (int i2 = pkg.receivers.size() - 1; i2 >= 0; i2--) {
                    PackageParser.Activity receiver = (PackageParser.Activity) pkg.receivers.get(i2);
                    if ((receiver.info.flags & 1073741824) != 0) {
                        receiver.info.exported = false;
                    }
                }
            }
            if (pkg.services != null) {
                for (int i3 = pkg.services.size() - 1; i3 >= 0; i3--) {
                    PackageParser.Service service = (PackageParser.Service) pkg.services.get(i3);
                    if ((service.info.flags & 1073741824) != 0) {
                        service.info.exported = false;
                    }
                }
            }
            if (pkg.providers != null) {
                for (int i4 = pkg.providers.size() - 1; i4 >= 0; i4--) {
                    PackageParser.Provider provider = (PackageParser.Provider) pkg.providers.get(i4);
                    if ((provider.info.flags & 1073741824) != 0) {
                        provider.info.exported = false;
                    }
                }
            }
        }
        if ((scanFlags & 262144) != 0) {
            pkg.applicationInfo.privateFlags |= 8;
        }
        if ((scanFlags & 524288) != 0) {
            ApplicationInfo applicationInfo = pkg.applicationInfo;
            applicationInfo.privateFlags = 131072 | applicationInfo.privateFlags;
        }
        if ((scanFlags & 1048576) != 0) {
            ApplicationInfo applicationInfo2 = pkg.applicationInfo;
            applicationInfo2.privateFlags = 262144 | applicationInfo2.privateFlags;
        }
        if ((scanFlags & 2097152) != 0) {
            ApplicationInfo applicationInfo3 = pkg.applicationInfo;
            applicationInfo3.privateFlags = 524288 | applicationInfo3.privateFlags;
        }
        if ((4194304 & scanFlags) != 0) {
            ApplicationInfo applicationInfo4 = pkg.applicationInfo;
            applicationInfo4.privateFlags = 2097152 | applicationInfo4.privateFlags;
        }
        if ((8388608 & scanFlags) != 0) {
            pkg.applicationInfo.privateFlags |= 1073741824;
        }
        if (PLATFORM_PACKAGE_NAME.equals(pkg.packageName) || (platformPkg != null && PackageManagerServiceUtils.compareSignatures(platformPkg.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
            ApplicationInfo applicationInfo5 = pkg.applicationInfo;
            applicationInfo5.privateFlags = 1048576 | applicationInfo5.privateFlags;
        }
        if (!isSystemApp(pkg)) {
            pkg.mOriginalPackages = null;
            pkg.mRealPackage = null;
            pkg.mAdoptPermissions = null;
        }
        PackageBackwardCompatibility.modifySharedLibraries(pkg);
        HwPackageManagerServiceUtils.addFlagsForRemovablePreApk(pkg, hwFlags);
        HwPackageManagerServiceUtils.addFlagsForUpdatedRemovablePreApk(pkg, hwFlags);
    }

    private static <T> T assertNotNull(T object, String message) throws PackageManagerException {
        if (object != null) {
            return object;
        }
        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, message);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags) throws PackageManagerException {
        assertPackageIsValid(pkg, parseFlags, scanFlags, 0);
    }

    private void assertPackageIsValid(PackageParser.Package pkg, int parseFlags, int scanFlags, int hwFlags) throws PackageManagerException {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        PackageManagerService packageManagerService;
        PackageSetting targetPkgSetting;
        LongSparseArray<SharedLibraryInfo> versionedLib;
        KeySetManagerService ksms;
        PackageManagerService packageManagerService2 = this;
        if ((parseFlags & 64) != 0) {
            assertCodePolicy(pkg);
        }
        if (pkg.applicationInfo.getCodePath() != null) {
            if (pkg.applicationInfo.getResourcePath() != null) {
                boolean isFirstBootOrUpgrade = true;
                boolean isUserInstall = (scanFlags & 16) == 0;
                if ((scanFlags & 8192) == 0) {
                    isFirstBootOrUpgrade = false;
                }
                if ((isUserInstall || isFirstBootOrUpgrade) && packageManagerService2.mApexManager.isApexPackage(pkg.packageName)) {
                    throw new PackageManagerException(-5, pkg.packageName + " is an APEX package and can't be installed as an APK.");
                }
                KeySetManagerService ksms2 = packageManagerService2.mSettings.mKeySetManagerService;
                ksms2.assertScannedPackageValid(pkg);
                ArrayMap<String, PackageParser.Package> arrayMap2 = packageManagerService2.mPackages;
                synchronized (arrayMap2) {
                    try {
                        if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
                            try {
                                if (packageManagerService2.mAndroidApplication != null) {
                                    Slog.w(TAG, "*************************************************");
                                    Slog.w(TAG, "Core android package being redefined.  Skipping.");
                                    Slog.w(TAG, " codePath=" + pkg.codePath);
                                    Slog.w(TAG, "*************************************************");
                                    throw new PackageManagerException(-5, "Core android package being redefined.  Skipping.");
                                }
                            } catch (Throwable th2) {
                                th = th2;
                                arrayMap = arrayMap2;
                                throw th;
                            }
                        }
                        if ((scanFlags & 4) == 0) {
                            if (packageManagerService2.mPackages.containsKey(pkg.packageName)) {
                                throw new PackageManagerException(-5, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
                            }
                        }
                        if (!pkg.applicationInfo.isStaticSharedLibrary()) {
                            arrayMap = arrayMap2;
                        } else if ((scanFlags & 4) != 0 || !packageManagerService2.mPackages.containsKey(pkg.manifestPackageName)) {
                            try {
                                if (pkg.applicationInfo.targetSdkVersion < 26) {
                                    throw new PackageManagerException("Packages declaring static-shared libs must target O SDK or higher");
                                } else if ((scanFlags & 16384) != 0) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot be instant apps");
                                } else if (!ArrayUtils.isEmpty(pkg.mOriginalPackages)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot be renamed");
                                } else if (!ArrayUtils.isEmpty(pkg.childPackages)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot have child packages");
                                } else if (!ArrayUtils.isEmpty(pkg.libraryNames)) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare dynamic libs");
                                } else if (pkg.mSharedUserId != null) {
                                    throw new PackageManagerException("Packages declaring static-shared libs cannot declare shared users");
                                } else if (!pkg.activities.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare activities");
                                } else if (!pkg.services.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare services");
                                } else if (!pkg.providers.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare content providers");
                                } else if (!pkg.receivers.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare broadcast receivers");
                                } else if (!pkg.permissionGroups.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare permission groups");
                                } else if (!pkg.permissions.isEmpty()) {
                                    throw new PackageManagerException("Static shared libs cannot declare permissions");
                                } else if (pkg.protectedBroadcasts != null) {
                                    throw new PackageManagerException("Static shared libs cannot declare protected broadcasts");
                                } else if (pkg.mOverlayTarget == null) {
                                    long minVersionCode = Long.MIN_VALUE;
                                    long maxVersionCode = JobStatus.NO_LATEST_RUNTIME;
                                    LongSparseArray<SharedLibraryInfo> versionedLib2 = packageManagerService2.mSharedLibraries.get(pkg.staticSharedLibName);
                                    if (versionedLib2 != null) {
                                        int versionCount = versionedLib2.size();
                                        int i = 0;
                                        while (true) {
                                            if (i >= versionCount) {
                                                arrayMap = arrayMap2;
                                                break;
                                            }
                                            SharedLibraryInfo libInfo = versionedLib2.valueAt(i);
                                            long libVersionCode = libInfo.getDeclaringPackage().getLongVersionCode();
                                            try {
                                                if (libInfo.getLongVersion() >= pkg.staticSharedLibVersion) {
                                                    ksms = ksms2;
                                                    arrayMap = arrayMap2;
                                                    versionedLib = versionedLib2;
                                                    if (libInfo.getLongVersion() <= pkg.staticSharedLibVersion) {
                                                        if (!"com.huawei.androidx".equals(pkg.manifestPackageName)) {
                                                            maxVersionCode = libVersionCode;
                                                            minVersionCode = libVersionCode;
                                                            break;
                                                        }
                                                        minVersionCode = Math.max(minVersionCode, libVersionCode);
                                                    } else {
                                                        maxVersionCode = Math.min(maxVersionCode, libVersionCode - 1);
                                                    }
                                                } else {
                                                    ksms = ksms2;
                                                    arrayMap = arrayMap2;
                                                    try {
                                                        versionedLib = versionedLib2;
                                                        minVersionCode = Math.max(minVersionCode, libVersionCode + 1);
                                                    } catch (Throwable th3) {
                                                        th = th3;
                                                        throw th;
                                                    }
                                                }
                                                i++;
                                                packageManagerService2 = this;
                                                ksms2 = ksms;
                                                arrayMap2 = arrayMap;
                                                isUserInstall = isUserInstall;
                                                versionedLib2 = versionedLib;
                                            } catch (Throwable th4) {
                                                th = th4;
                                                throw th;
                                            }
                                        }
                                    } else {
                                        arrayMap = arrayMap2;
                                    }
                                    if (pkg.getLongVersionCode() < minVersionCode || pkg.getLongVersionCode() > maxVersionCode) {
                                        throw new PackageManagerException("Static shared lib version codes must be ordered as lib versions");
                                    }
                                } else {
                                    throw new PackageManagerException("Static shared libs cannot be overlay targets");
                                }
                            } catch (Throwable th5) {
                                th = th5;
                                arrayMap = arrayMap2;
                                throw th;
                            }
                        } else {
                            throw new PackageManagerException("Duplicate static shared lib provider package");
                        }
                        if (pkg.childPackages == null || pkg.childPackages.isEmpty()) {
                            packageManagerService = this;
                        } else if ((262144 & scanFlags) != 0) {
                            int childCount = pkg.childPackages.size();
                            for (int i2 = 0; i2 < childCount; i2++) {
                                try {
                                    if (this.mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName, ((PackageParser.Package) pkg.childPackages.get(i2)).packageName)) {
                                        throw new PackageManagerException("Can't override child of another disabled app. Ignoring package " + pkg.packageName);
                                    }
                                } catch (Throwable th6) {
                                    th = th6;
                                    throw th;
                                }
                            }
                            packageManagerService = this;
                        } else {
                            throw new PackageManagerException("Only privileged apps can add child packages. Ignoring package " + pkg.packageName);
                        }
                        if ((scanFlags & 128) != 0) {
                            if (!packageManagerService.mExpectingBetter.containsKey(pkg.packageName)) {
                                if (!isSystemAppGrantByMdmAndNonPreload(pkg)) {
                                    PackageSetting known = packageManagerService.mSettings.getPackageLPr(pkg.packageName);
                                    if (known != null) {
                                        if (DEBUG_PACKAGE_SCANNING) {
                                            Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                                        }
                                        if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                                            throw new PackageManagerException(-23, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                                        }
                                    } else {
                                        throw new PackageManagerException(-19, "Application package " + pkg.packageName + " not found; ignoring.");
                                    }
                                }
                            }
                            PackageManagerServiceUtils.logCriticalInfo(5, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
                        }
                        if ((scanFlags & 4) != 0) {
                            packageManagerService.mComponentResolver.assertProvidersNotDefined(pkg);
                        }
                        if (!pkg.isPrivileged() && pkg.mSharedUserId != null) {
                            SharedUserSetting sharedUserSetting = null;
                            try {
                                sharedUserSetting = packageManagerService.mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, false);
                            } catch (PackageManagerException e) {
                            }
                            if (sharedUserSetting != null && sharedUserSetting.isPrivileged()) {
                                PackageSetting platformPkgSetting = packageManagerService.mSettings.mPackages.get(PLATFORM_PACKAGE_NAME);
                                if (!(platformPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                    throw new PackageManagerException("Apps that share a user with a privileged app must themselves be marked as privileged. " + pkg.packageName + " shares privileged user " + pkg.mSharedUserId + ".");
                                }
                            }
                        }
                        if (pkg.mOverlayTarget != null) {
                            if ((131072 & scanFlags) != 0) {
                                if ((parseFlags & 16) == 0) {
                                    PackageSetting previousPkg = (PackageSetting) assertNotNull(packageManagerService.mSettings.getPackageLPr(pkg.packageName), "previous package state not present");
                                    PackageParser.Package ppkg = previousPkg.pkg;
                                    if (ppkg == null) {
                                        try {
                                            ppkg = new PackageParser().parsePackage(previousPkg.codePath, parseFlags | 16);
                                        } catch (PackageParser.PackageParserException e2) {
                                            Slog.w(TAG, "failed to parse " + previousPkg.codePath, e2);
                                        }
                                    }
                                    if (ppkg != null && ppkg.mOverlayIsStatic) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " is static and cannot be upgraded.");
                                    } else if (pkg.mOverlayIsStatic) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " cannot be upgraded into a static overlay.");
                                    }
                                }
                            } else if (!pkg.mOverlayIsStatic) {
                                if (pkg.applicationInfo.targetSdkVersion < 29) {
                                    PackageSetting platformPkgSetting2 = packageManagerService.mSettings.getPackageLPr(PLATFORM_PACKAGE_NAME);
                                    if (!(platformPkgSetting2.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(platformPkgSetting2.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                        throw new PackageManagerException("Overlay " + pkg.packageName + " must target Q or later, or be signed with the platform certificate");
                                    }
                                }
                                if (!(pkg.mOverlayTargetName != null || (targetPkgSetting = packageManagerService.mSettings.getPackageLPr(pkg.mOverlayTarget)) == null || targetPkgSetting.signatures.mSigningDetails == PackageParser.SigningDetails.UNKNOWN || PackageManagerServiceUtils.compareSignatures(targetPkgSetting.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures) == 0)) {
                                    throw new PackageManagerException("Overlay " + pkg.packageName + " and target " + pkg.mOverlayTarget + " signed with different certificates, and the overlay lacks <overlay android:targetName>");
                                }
                            } else {
                                throw new PackageManagerException("Overlay " + pkg.packageName + " is static but not pre-installed.");
                            }
                        }
                        return;
                    } catch (Throwable th7) {
                        th = th7;
                        arrayMap = arrayMap2;
                        throw th;
                    }
                }
            }
        }
        throw new PackageManagerException(-2, "Code and resource paths haven't been set correctly");
    }

    @GuardedBy({"mPackages"})
    private boolean addBuiltInSharedLibraryLocked(String path, String name) {
        if (nonStaticSharedLibExistsLocked(name)) {
            return false;
        }
        commitSharedLibraryInfoLocked(new SharedLibraryInfo(path, null, null, name, -1, 0, new VersionedPackage(PLATFORM_PACKAGE_NAME, 0L), null, null));
        return true;
    }

    @GuardedBy({"mPackages"})
    private boolean nonStaticSharedLibExistsLocked(String name) {
        return sharedLibExists(name, -1, this.mSharedLibraries);
    }

    private static boolean sharedLibExists(String name, long version, Map<String, LongSparseArray<SharedLibraryInfo>> librarySource) {
        LongSparseArray<SharedLibraryInfo> versionedLib = librarySource.get(name);
        if (versionedLib == null || versionedLib.indexOfKey(version) < 0) {
            return false;
        }
        return true;
    }

    @GuardedBy({"mPackages"})
    private void commitSharedLibraryInfoLocked(SharedLibraryInfo libraryInfo) {
        String name = libraryInfo.getName();
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null) {
            versionedLib = new LongSparseArray<>();
            this.mSharedLibraries.put(name, versionedLib);
        }
        String declaringPackageName = libraryInfo.getDeclaringPackage().getPackageName();
        if (libraryInfo.getType() == 2) {
            this.mStaticLibsByDeclaringPackage.put(declaringPackageName, versionedLib);
        }
        versionedLib.put(libraryInfo.getLongVersion(), libraryInfo);
    }

    private boolean removeSharedLibraryLPw(String name, long version) {
        int libIdx;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(name);
        if (versionedLib == null || (libIdx = versionedLib.indexOfKey(version)) < 0) {
            return false;
        }
        SharedLibraryInfo libraryInfo = versionedLib.valueAt(libIdx);
        versionedLib.remove(version);
        if (versionedLib.size() > 0) {
            return true;
        }
        this.mSharedLibraries.remove(name);
        if (libraryInfo.getType() != 2) {
            return true;
        }
        this.mStaticLibsByDeclaringPackage.remove(libraryInfo.getDeclaringPackage().getPackageName());
        return true;
    }

    private void commitPackageSettings(PackageParser.Package pkg, PackageParser.Package oldPkg, PackageSetting pkgSetting, int scanFlags, boolean chatty, ReconciledPackage reconciledPkg) {
        if ((pkg.applicationInfo.hwFlags & 1048576) != 0) {
            Slog.i(TAG, "Restrict Permissions for Z.");
            pkgSetting.hw_extra_flags |= 1048576;
            ZosPermissionAdapter.getInstance().restrictPermissions(pkg);
        }
        String pkgName = pkg.packageName;
        ComponentName componentName = this.mCustomResolverComponentName;
        if (componentName != null && componentName.getPackageName().equals(pkg.packageName)) {
            getHwPMSEx().setUpCustomResolverActivity(pkg);
        }
        if (pkg.packageName.equals(PLATFORM_PACKAGE_NAME)) {
            synchronized (this.mPackages) {
                if ((scanFlags & 1024) == 0) {
                    this.mPlatformPackage = pkg;
                    pkg.mVersionCode = this.mSdkVersion;
                    pkg.mVersionCodeMajor = 0;
                    this.mAndroidApplication = pkg.applicationInfo;
                    if (!this.mResolverReplaced) {
                        this.mResolveActivity.applicationInfo = this.mAndroidApplication;
                        this.mResolveActivity.name = ResolverActivity.class.getName();
                        this.mResolveActivity.packageName = this.mAndroidApplication.packageName;
                        this.mResolveActivity.processName = "system:ui";
                        this.mResolveActivity.launchMode = 0;
                        this.mResolveActivity.documentLaunchMode = 3;
                        this.mResolveActivity.flags = 32;
                        this.mResolveActivity.theme = 16974374;
                        this.mResolveActivity.exported = true;
                        this.mResolveActivity.enabled = true;
                        this.mResolveActivity.resizeMode = 2;
                        this.mResolveActivity.configChanges = 3504;
                        this.mResolveInfo.activityInfo = this.mResolveActivity;
                        this.mResolveInfo.priority = 0;
                        this.mResolveInfo.preferredOrder = 0;
                        this.mResolveInfo.match = 0;
                        this.mResolveComponentName = new ComponentName(this.mAndroidApplication.packageName, this.mResolveActivity.name);
                    }
                }
            }
        }
        ArrayList<PackageParser.Package> clientLibPkgs = null;
        synchronized (this.mPackages) {
            if (!ArrayUtils.isEmpty(reconciledPkg.allowedSharedLibraryInfos)) {
                for (SharedLibraryInfo info : reconciledPkg.allowedSharedLibraryInfos) {
                    commitSharedLibraryInfoLocked(info);
                }
                Map<String, PackageParser.Package> combinedPackages = reconciledPkg.getCombinedPackages();
                try {
                    updateSharedLibrariesLocked(pkg, null, combinedPackages);
                } catch (PackageManagerException e) {
                    Slog.e(TAG, "updateSharedLibrariesLPr failed: ", e);
                }
                if ((scanFlags & 16) == 0) {
                    clientLibPkgs = updateAllSharedLibrariesLocked(pkg, combinedPackages);
                }
            }
        }
        if ((scanFlags & 16) == 0 && (scanFlags & 2048) == 0 && (scanFlags & 4096) == 0) {
            checkPackageFrozen(pkgName);
        }
        if (clientLibPkgs != null) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
            }
        }
        Trace.traceBegin(262144, "updateSettings");
        synchronized (this.mPackages) {
            this.mSettings.insertPackageSettingLPw(pkgSetting, pkg);
            mHwPMSEx.updateCertCompatPackage(pkg, pkgSetting);
            this.mPackages.put(pkg.applicationInfo.packageName, pkg);
            this.mSettings.mKeySetManagerService.addScannedPackageLPw(pkg);
            this.mComponentResolver.addAllComponents(pkg, chatty);
            if ((scanFlags & 16384) != 0) {
                Slog.w(TAG, "Permission groups from package " + pkg.packageName + " ignored: instant apps cannot define new permission groups.");
            } else {
                this.mPermissionManager.addAllPermissionGroups(pkg, chatty);
            }
            if ((scanFlags & 16384) != 0) {
                Slog.w(TAG, "Permissions from package " + pkg.packageName + " ignored: instant apps cannot define new permissions.");
            } else {
                this.mPermissionManager.addAllPermissions(pkg, chatty);
            }
            StringBuilder r = null;
            int i2 = 0;
            for (int collectionSize = pkg.instrumentation.size(); i2 < collectionSize; collectionSize = collectionSize) {
                PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i2);
                a.info.packageName = pkg.applicationInfo.packageName;
                a.info.sourceDir = pkg.applicationInfo.sourceDir;
                a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
                a.info.splitNames = pkg.splitNames;
                a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
                a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
                a.info.splitDependencies = pkg.applicationInfo.splitDependencies;
                a.info.dataDir = pkg.applicationInfo.dataDir;
                a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir;
                a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir;
                a.info.primaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                a.info.secondaryCpuAbi = pkg.applicationInfo.secondaryCpuAbi;
                a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
                a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir;
                this.mInstrumentation.put(a.getComponentName(), a);
                if (chatty) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(a.info.name);
                }
                i2++;
            }
            if (r != null && DEBUG_PACKAGE_SCANNING) {
                Log.d(TAG, "  Instrumentation: " + ((Object) r));
            }
            if (pkg.protectedBroadcasts != null) {
                int collectionSize2 = pkg.protectedBroadcasts.size();
                synchronized (this.mProtectedBroadcasts) {
                    for (int i3 = 0; i3 < collectionSize2; i3++) {
                        this.mProtectedBroadcasts.add((String) pkg.protectedBroadcasts.get(i3));
                    }
                }
            }
            if (oldPkg != null) {
                AsyncTask.execute(new Runnable(pkg, oldPkg, new ArrayList<>(this.mPackages.keySet())) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$x94KJKQ00H9XukL13EekRT4IkI */
                    private final /* synthetic */ PackageParser.Package f$1;
                    private final /* synthetic */ PackageParser.Package f$2;
                    private final /* synthetic */ ArrayList f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.this.lambda$commitPackageSettings$9$PackageManagerService(this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
        Trace.traceEnd(262144);
    }

    public /* synthetic */ void lambda$commitPackageSettings$9$PackageManagerService(PackageParser.Package pkg, PackageParser.Package oldPkg, ArrayList allPackageNames) {
        this.mPermissionManager.revokeRuntimePermissionsIfGroupChanged(pkg, oldPkg, allPackageNames, this.mPermissionCallback);
    }

    private static void derivePackageAbi(PackageParser.Package pkg, String cpuAbiOverride, boolean extractLibs) throws PackageManagerException {
        boolean extractLibs2;
        int copyRet;
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
        if (!isSystemApp(pkg) || pkg.isUpdatedSystemApp()) {
            extractLibs2 = extractLibs;
        } else {
            extractLibs2 = false;
        }
        String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
        boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;
        NativeLibraryHelper.Handle handle = null;
        try {
            handle = NativeLibraryHelper.Handle.create(pkg);
            File nativeLibraryRoot = new File(nativeLibraryRootStr);
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
            if (HwMaplePMServiceUtils.isNeedToCopyMapleSo(pkg)) {
                Slog.i(TAG, "Is need to cp mp so " + pkg.packageName);
                int copyRet2 = NativeLibraryHelper.copyNativeMapleBinaries(handle, new File(nativeLibraryRoot.getParent(), "maple"));
                if (copyRet2 < 0 && copyRet2 != -114) {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Error unpackaging native libs for app, errorCode=" + copyRet2);
                }
            }
            if (isMultiArch(pkg.applicationInfo)) {
                if (pkg.cpuAbiOverride != null && !"-".equals(pkg.cpuAbiOverride)) {
                    Slog.w(TAG, "Ignoring abiOverride for multi arch application.");
                }
                int abi32 = -114;
                int abi64 = -114;
                if (Build.SUPPORTED_32_BIT_ABIS.length > 0) {
                    if (extractLibs2) {
                        Trace.traceBegin(262144, "copyNativeBinaries");
                        abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS, useIsaSpecificSubdirs);
                    } else {
                        Trace.traceBegin(262144, "findSupportedAbi");
                        abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                    }
                    Trace.traceEnd(262144);
                }
                if (abi32 < 0 || !pkg.isLibrary() || !extractLibs2) {
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 32 bit native libs for multiarch app.", abi32);
                    if (Build.SUPPORTED_64_BIT_ABIS.length > 0) {
                        if (extractLibs2) {
                            Trace.traceBegin(262144, "copyNativeBinaries");
                            abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS, useIsaSpecificSubdirs);
                        } else {
                            Trace.traceBegin(262144, "findSupportedAbi");
                            abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                        }
                        Trace.traceEnd(262144);
                    }
                    maybeThrowExceptionForMultiArchCopy("Error unpackaging 64 bit native libs for multiarch app.", abi64);
                    if (abi64 >= 0) {
                        if (!extractLibs2 || !pkg.isLibrary()) {
                            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
                        } else {
                            throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                        }
                    }
                    if (abi32 >= 0) {
                        String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                        if (abi64 < 0) {
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else if (pkg.use32bitAbi) {
                            pkg.applicationInfo.secondaryCpuAbi = pkg.applicationInfo.primaryCpuAbi;
                            pkg.applicationInfo.primaryCpuAbi = abi;
                        } else {
                            pkg.applicationInfo.secondaryCpuAbi = abi;
                        }
                    }
                } else {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library native lib extraction not supported");
                }
            } else {
                String[] abiList = cpuAbiOverride != null ? new String[]{cpuAbiOverride} : Build.SUPPORTED_ABIS;
                boolean needsRenderScriptOverride = false;
                if (Build.SUPPORTED_64_BIT_ABIS.length > 0 && cpuAbiOverride == null && NativeLibraryHelper.hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                    needsRenderScriptOverride = true;
                }
                if (extractLibs2) {
                    Trace.traceBegin(262144, "copyNativeBinaries");
                    copyRet = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle, nativeLibraryRoot, abiList, useIsaSpecificSubdirs);
                } else {
                    Trace.traceBegin(262144, "findSupportedAbi");
                    copyRet = NativeLibraryHelper.findSupportedAbi(handle, abiList);
                }
                Trace.traceEnd(262144);
                if (copyRet < 0 && copyRet != -114) {
                    throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Error unpackaging native libs for app, errorCode=" + copyRet);
                } else if (copyRet >= 0) {
                    if (!pkg.isLibrary()) {
                        pkg.applicationInfo.primaryCpuAbi = abiList[copyRet];
                    } else {
                        throw new PackageManagerException(RequestStatus.SYS_ETIMEDOUT, "Shared library with native libs must be multiarch");
                    }
                } else if (copyRet == -114 && cpuAbiOverride != null) {
                    pkg.applicationInfo.primaryCpuAbi = cpuAbiOverride;
                } else if (needsRenderScriptOverride) {
                    pkg.applicationInfo.primaryCpuAbi = abiList[0];
                }
            }
        } catch (IOException ioe) {
            Slog.e(TAG, "Unable to get canonical file " + ioe.toString());
        } catch (Throwable th) {
            IoUtils.closeQuietly(handle);
            throw th;
        }
        IoUtils.closeQuietly(handle);
        setNativeLibraryPaths(pkg, sAppLib32InstallDir);
    }

    private static List<String> adjustCpuAbisForSharedUserLPw(Set<PackageSetting> packagesForUser, PackageParser.Package scannedPackage) {
        String adjustedAbi;
        List<String> changedAbiCodePath = null;
        String requiredInstructionSet = null;
        if (!(scannedPackage == null || scannedPackage.applicationInfo.primaryCpuAbi == null)) {
            requiredInstructionSet = VMRuntime.getInstructionSet(scannedPackage.applicationInfo.primaryCpuAbi);
        }
        PackageSetting requirer = null;
        for (PackageSetting ps : packagesForUser) {
            if ((scannedPackage == null || !scannedPackage.packageName.equals(ps.name)) && ps.primaryCpuAbiString != null) {
                String instructionSet = VMRuntime.getInstructionSet(ps.primaryCpuAbiString);
                if (requiredInstructionSet != null && !instructionSet.equals(requiredInstructionSet)) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Instruction set mismatch, ");
                    sb.append(requirer == null ? "[caller]" : requirer);
                    sb.append(" requires ");
                    sb.append(requiredInstructionSet);
                    sb.append(" whereas ");
                    sb.append(ps);
                    sb.append(" requires ");
                    sb.append(instructionSet);
                    Slog.w(TAG, sb.toString());
                }
                if (requiredInstructionSet == null) {
                    requiredInstructionSet = instructionSet;
                    requirer = ps;
                }
            }
        }
        if (requiredInstructionSet != null) {
            if (requirer != null) {
                adjustedAbi = requirer.primaryCpuAbiString;
                if (scannedPackage != null && (!ZygoteInit.sIsMygote || (scannedPackage.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) == 0)) {
                    scannedPackage.applicationInfo.primaryCpuAbi = adjustedAbi;
                }
            } else {
                adjustedAbi = scannedPackage.applicationInfo.primaryCpuAbi;
            }
            for (PackageSetting ps2 : packagesForUser) {
                if ((scannedPackage == null || !scannedPackage.packageName.equals(ps2.name)) && ps2.primaryCpuAbiString == null) {
                    if (SystemProperties.get("persist.sys.shareduid_abi_check", "1").equals("0")) {
                        ps2.primaryCpuAbiString = adjustedAbi;
                    }
                    if (!(ps2.pkg == null || ps2.pkg.applicationInfo == null || TextUtils.equals(adjustedAbi, ps2.pkg.applicationInfo.primaryCpuAbi))) {
                        if (SystemProperties.get("persist.sys.shareduid_abi_check", "1").equals("0")) {
                            ps2.pkg.applicationInfo.primaryCpuAbi = adjustedAbi;
                        }
                        if (DEBUG_ABI_SELECTION) {
                            StringBuilder sb2 = new StringBuilder();
                            sb2.append("Adjusting ABI for ");
                            sb2.append(ps2.name);
                            sb2.append(" to ");
                            sb2.append(adjustedAbi);
                            sb2.append(" (requirer=");
                            PackageParser.Package r8 = "null";
                            sb2.append(requirer != null ? requirer.pkg : r8);
                            sb2.append(", scannedPackage=");
                            if (scannedPackage != null) {
                                r8 = scannedPackage;
                            }
                            sb2.append(r8);
                            sb2.append(")");
                            Slog.i(TAG, sb2.toString());
                        }
                        if (changedAbiCodePath == null) {
                            changedAbiCodePath = new ArrayList<>();
                        }
                        changedAbiCodePath.add(ps2.codePathString);
                    }
                }
            }
        }
        return changedAbiCodePath;
    }

    private void setUpCustomResolverActivity(PackageParser.Package pkg) {
        synchronized (this.mPackages) {
            this.mResolverReplaced = true;
            this.mResolveActivity.applicationInfo = pkg.applicationInfo;
            this.mResolveActivity.name = this.mCustomResolverComponentName.getClassName();
            this.mResolveActivity.packageName = pkg.applicationInfo.packageName;
            this.mResolveActivity.processName = pkg.applicationInfo.packageName;
            this.mResolveActivity.launchMode = 0;
            this.mResolveActivity.flags = 288;
            this.mResolveActivity.theme = 0;
            this.mResolveActivity.exported = true;
            this.mResolveActivity.enabled = true;
            this.mResolveInfo.activityInfo = this.mResolveActivity;
            this.mResolveInfo.priority = 0;
            this.mResolveInfo.preferredOrder = 0;
            this.mResolveInfo.match = 0;
            this.mResolveComponentName = this.mCustomResolverComponentName;
            Slog.i(TAG, "Replacing default ResolverActivity with custom activity: " + this.mResolveComponentName);
        }
    }

    private void setUpInstantAppInstallerActivityLP(ActivityInfo installerActivity) {
        if (installerActivity == null) {
            if (DEBUG_INSTANT) {
                Slog.d(TAG, "Clear ephemeral installer activity");
            }
            this.mInstantAppInstallerActivity = null;
            return;
        }
        if (DEBUG_INSTANT) {
            Slog.d(TAG, "Set ephemeral installer activity: " + installerActivity.getComponentName());
        }
        this.mInstantAppInstallerActivity = installerActivity;
        this.mInstantAppInstallerActivity.flags |= 288;
        ActivityInfo activityInfo = this.mInstantAppInstallerActivity;
        activityInfo.exported = true;
        activityInfo.enabled = true;
        ResolveInfo resolveInfo = this.mInstantAppInstallerInfo;
        resolveInfo.activityInfo = activityInfo;
        resolveInfo.priority = 1;
        resolveInfo.preferredOrder = 1;
        resolveInfo.isDefault = true;
        resolveInfo.match = 5799936;
    }

    private static String calculateBundledApkRoot(String codePathString) {
        File codeRoot;
        File codePath = new File(codePathString);
        if (FileUtils.contains(Environment.getRootDirectory(), codePath)) {
            codeRoot = Environment.getRootDirectory();
        } else if (FileUtils.contains(Environment.getOemDirectory(), codePath)) {
            codeRoot = Environment.getOemDirectory();
        } else if (FileUtils.contains(Environment.getVendorDirectory(), codePath)) {
            codeRoot = Environment.getVendorDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else if (FileUtils.contains(Environment.getProductDirectory(), codePath)) {
            codeRoot = Environment.getProductDirectory();
        } else if (FileUtils.contains(Environment.getProductServicesDirectory(), codePath)) {
            codeRoot = Environment.getProductServicesDirectory();
        } else if (FileUtils.contains(Environment.getOdmDirectory(), codePath)) {
            codeRoot = Environment.getOdmDirectory();
        } else {
            try {
                File f = codePath.getCanonicalFile();
                File parent = f.getParentFile();
                while (true) {
                    File tmp = parent.getParentFile();
                    if (tmp == null) {
                        break;
                    }
                    f = parent;
                    parent = tmp;
                }
                Slog.w(TAG, "Unrecognized code path " + codePath + " - using " + f);
                codeRoot = f;
            } catch (IOException e) {
                Slog.w(TAG, "Can't canonicalize code path " + codePath);
                return Environment.getRootDirectory().getPath();
            }
        }
        return codeRoot.getPath();
    }

    protected static void setNativeLibraryPaths(PackageParser.Package pkg, File appLib32InstallDir) {
        ApplicationInfo info = pkg.applicationInfo;
        String codePath = pkg.codePath;
        File codeFile = new File(codePath);
        boolean bundledApp = info.isSystemApp() && !info.isUpdatedSystemApp();
        info.nativeLibraryRootDir = null;
        info.nativeLibraryRootRequiresIsa = false;
        info.nativeLibraryDir = null;
        info.secondaryNativeLibraryDir = null;
        String secondaryLibDir = "lib";
        if (PackageParser.isApkFile(codeFile)) {
            if (bundledApp) {
                String apkRoot = calculateBundledApkRoot(info.sourceDir);
                boolean is64Bit = VMRuntime.is64BitInstructionSet(InstructionSets.getPrimaryInstructionSet(info));
                String apkName = deriveCodePathName(codePath);
                info.nativeLibraryRootDir = Environment.buildPath(new File(apkRoot), new String[]{is64Bit ? "lib64" : secondaryLibDir, apkName}).getAbsolutePath();
                if (info.secondaryCpuAbi != null) {
                    if (!is64Bit) {
                        secondaryLibDir = "lib64";
                    }
                    info.secondaryNativeLibraryDir = Environment.buildPath(new File(apkRoot), new String[]{secondaryLibDir, apkName}).getAbsolutePath();
                }
            } else {
                info.nativeLibraryRootDir = new File(appLib32InstallDir, deriveCodePathName(codePath)).getAbsolutePath();
            }
            info.nativeLibraryRootRequiresIsa = false;
            info.nativeLibraryDir = info.nativeLibraryRootDir;
            return;
        }
        info.nativeLibraryRootDir = new File(codeFile, secondaryLibDir).getAbsolutePath();
        info.nativeLibraryRootRequiresIsa = true;
        info.nativeLibraryDir = new File(info.nativeLibraryRootDir, InstructionSets.getPrimaryInstructionSet(info)).getAbsolutePath();
        if (info.secondaryCpuAbi != null) {
            info.secondaryNativeLibraryDir = new File(info.nativeLibraryRootDir, VMRuntime.getInstructionSet(info.secondaryCpuAbi)).getAbsolutePath();
        }
    }

    private static void setBundledAppAbisAndRoots(PackageParser.Package pkg, PackageSetting pkgSetting) {
        setBundledAppAbi(pkg, calculateBundledApkRoot(pkg.applicationInfo.sourceDir), deriveCodePathName(pkg.applicationInfo.getCodePath()));
        if (pkgSetting != null) {
            pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
            pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
        }
    }

    /* JADX INFO: Multiple debug info for r4v20 boolean: [D('isa' java.lang.String), D('has32BitLibs' boolean)] */
    private static void setBundledAppAbi(PackageParser.Package pkg, String apkRoot, String apkName) {
        boolean has64BitLibs;
        boolean has64BitLibs2;
        File codeFile = new File(pkg.codePath);
        if (PackageParser.isApkFile(codeFile)) {
            has64BitLibs = new File(apkRoot, new File("lib64", apkName).getPath()).exists();
            has64BitLibs2 = new File(apkRoot, new File("lib", apkName).getPath()).exists();
        } else {
            File rootDir = new File(codeFile, "lib");
            if (ArrayUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_64_BIT_ABIS[0])) {
                has64BitLibs = false;
            } else {
                has64BitLibs = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_64_BIT_ABIS[0])).exists();
            }
            if (ArrayUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS) || TextUtils.isEmpty(Build.SUPPORTED_32_BIT_ABIS[0])) {
                has64BitLibs2 = false;
            } else {
                has64BitLibs2 = new File(rootDir, VMRuntime.getInstructionSet(Build.SUPPORTED_32_BIT_ABIS[0])).exists();
            }
        }
        if (has64BitLibs && !has64BitLibs2) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (has64BitLibs2 && !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else if (!has64BitLibs2 || !has64BitLibs) {
            pkg.applicationInfo.primaryCpuAbi = null;
            pkg.applicationInfo.secondaryCpuAbi = null;
        } else {
            if ((pkg.applicationInfo.flags & Integer.MIN_VALUE) == 0) {
                Slog.e(TAG, "Package " + pkg + " has multiple bundled libs, but is not multiarch.");
            }
            if (VMRuntime.is64BitInstructionSet(InstructionSets.getPreferredInstructionSet())) {
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
                pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
                return;
            }
            pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_32_BIT_ABIS[0];
            pkg.applicationInfo.secondaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[0];
        }
    }

    private void killApplication(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, -1, reason);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void killApplication(String pkgName, int appId, int userId, String reason) {
        long token = Binder.clearCallingIdentity();
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                try {
                    am.killApplication(pkgName, appId, userId, reason);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    private void removePackageLI(PackageParser.Package pkg, boolean chatty) {
        PackageSetting ps = (PackageSetting) pkg.mExtras;
        if (ps != null) {
            removePackageLI(ps.name, chatty);
        } else if (DEBUG_REMOVE && chatty) {
            Log.d(TAG, "Not removing package " + pkg.packageName + "; mExtras == null");
        }
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageSetting ps2 = (PackageSetting) ((PackageParser.Package) pkg.childPackages.get(i)).mExtras;
            if (ps2 != null) {
                removePackageLI(ps2.name, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removePackageLI(String packageName, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + packageName);
        }
        synchronized (this.mPackages) {
            PackageParser.Package removedPackage = this.mPackages.remove(packageName);
            if (removedPackage != null) {
                cleanPackageDataStructuresLILPw(removedPackage, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void removeInstalledPackageLI(PackageParser.Package pkg, boolean chatty) {
        if (DEBUG_INSTALL && chatty) {
            Log.d(TAG, "Removing package " + pkg.applicationInfo.packageName);
        }
        synchronized (this.mPackages) {
            this.mPackages.remove(pkg.applicationInfo.packageName);
            cleanPackageDataStructuresLILPw(pkg, chatty);
            int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
            for (int i = 0; i < childCount; i++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i);
                this.mPackages.remove(childPkg.applicationInfo.packageName);
                cleanPackageDataStructuresLILPw(childPkg, chatty);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void cleanPackageDataStructuresLILPw(PackageParser.Package pkg, boolean chatty) {
        this.mComponentResolver.removeAllComponents(pkg, chatty);
        this.mPermissionManager.removeAllPermissions(pkg, chatty);
        int instrumentationSize = pkg.instrumentation.size();
        StringBuilder r = null;
        for (int i = 0; i < instrumentationSize; i++) {
            PackageParser.Instrumentation a = (PackageParser.Instrumentation) pkg.instrumentation.get(i);
            this.mInstrumentation.remove(a.getComponentName());
            if (DEBUG_REMOVE && chatty) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Instrumentation: " + ((Object) r));
        }
        StringBuilder r2 = null;
        if (!((pkg.applicationInfo.flags & 1) == 0 || pkg.libraryNames == null)) {
            int libraryNamesSize = pkg.libraryNames.size();
            for (int i2 = 0; i2 < libraryNamesSize; i2++) {
                String name = (String) pkg.libraryNames.get(i2);
                if (removeSharedLibraryLPw(name, 0) && DEBUG_REMOVE && chatty) {
                    if (r2 == null) {
                        r2 = new StringBuilder(256);
                    } else {
                        r2.append(' ');
                    }
                    r2.append(name);
                }
            }
        }
        StringBuilder r3 = null;
        if (pkg.staticSharedLibName != null && removeSharedLibraryLPw(pkg.staticSharedLibName, pkg.staticSharedLibVersion) && DEBUG_REMOVE && chatty) {
            if (0 == 0) {
                r3 = new StringBuilder(256);
            } else {
                r3.append(' ');
            }
            r3.append(pkg.staticSharedLibName);
        }
        if (r3 != null && DEBUG_REMOVE) {
            Log.d(TAG, "  Libraries: " + ((Object) r3));
        }
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageBroadcast(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        mHwPMSEx.preSendPackageBroadcast(action, pkg, targetPkg);
        this.mHandler.post(new Runnable(userIds, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$MvVzTGv2D_Cv5xbMQxkG6UyAp_A */
            private final /* synthetic */ int[] f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ String f$3;
            private final /* synthetic */ Bundle f$4;
            private final /* synthetic */ int f$5;
            private final /* synthetic */ String f$6;
            private final /* synthetic */ IIntentReceiver f$7;
            private final /* synthetic */ int[] f$8;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
                this.f$7 = r8;
                this.f$8 = r9;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$sendPackageBroadcast$10$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8);
            }
        });
    }

    public /* synthetic */ void lambda$sendPackageBroadcast$10$PackageManagerService(int[] userIds, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] instantUserIds) {
        int[] resolvedUserIds;
        try {
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                if (userIds == null) {
                    resolvedUserIds = am.getRunningUserIds();
                } else {
                    resolvedUserIds = userIds;
                }
                doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, resolvedUserIds, false);
                if (instantUserIds != null && instantUserIds != EMPTY_INT_ARRAY) {
                    doSendBroadcast(am, action, pkg, extras, flags, targetPkg, finishedReceiver, instantUserIds, true);
                }
            }
        } catch (RemoteException e) {
        }
    }

    @Override // com.android.server.pm.PackageSender
    public void notifyPackageAdded(String packageName, int uid) {
        PackageManagerInternal.PackageListObserver[] observers;
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            } else {
                return;
            }
        }
        for (int i = observers.length - 1; i >= 0; i--) {
            observers[i].onPackageAdded(packageName, uid);
        }
    }

    @Override // com.android.server.pm.PackageSender
    public void notifyPackageChanged(String packageName, int uid) {
        PackageManagerInternal.PackageListObserver[] observers;
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            } else {
                return;
            }
        }
        for (int i = observers.length - 1; i >= 0; i--) {
            observers[i].onPackageChanged(packageName, uid);
        }
    }

    static /* synthetic */ int lambda$static$11(ProviderInfo p1, ProviderInfo p2) {
        int v1 = p1.initOrder;
        int v2 = p2.initOrder;
        if (v1 > v2) {
            return -1;
        }
        return v1 < v2 ? 1 : 0;
    }

    @Override // com.android.server.pm.PackageSender
    public void notifyPackageRemoved(String packageName, int uid) {
        PackageManagerInternal.PackageListObserver[] observers;
        synchronized (this.mPackages) {
            if (this.mPackageListObservers.size() != 0) {
                observers = (PackageManagerInternal.PackageListObserver[]) this.mPackageListObservers.toArray(new PackageManagerInternal.PackageListObserver[this.mPackageListObservers.size()]);
            } else {
                return;
            }
        }
        for (int i = observers.length - 1; i >= 0; i--) {
            observers[i].onPackageRemoved(packageName, uid);
        }
    }

    private void doSendBroadcast(IActivityManager am, String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, boolean isInstantApp) throws RemoteException {
        for (int id : userIds) {
            Intent intent = new Intent(action, pkg != null ? Uri.fromParts("package", pkg, null) : null);
            String[] requiredPermissions = isInstantApp ? INSTANT_APP_BROADCAST_PERMISSION : null;
            if (extras != null) {
                intent.putExtras(extras);
            }
            if (targetPkg != null) {
                intent.setPackage(targetPkg);
            }
            int uid = intent.getIntExtra("android.intent.extra.UID", -1);
            if (uid > 0 && UserHandle.getUserId(uid) != id) {
                intent.putExtra("android.intent.extra.UID", UserHandle.getUid(id, UserHandle.getAppId(uid)));
            }
            intent.putExtra("android.intent.extra.user_handle", id);
            intent.addFlags(flags | DumpState.DUMP_HANDLE);
            if (DEBUG_BROADCASTS) {
                RuntimeException here = new RuntimeException("here");
                here.fillInStackTrace();
                Slog.d(TAG, "Sending to user " + id + ": " + intent.toShortString(false, true, false, false) + " " + intent.getExtras(), here);
            }
            am.broadcastIntent((IApplicationThread) null, intent, (String) null, finishedReceiver, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, finishedReceiver != null, false, id);
        }
    }

    private boolean isExternalMediaAvailable() {
        return this.mMediaMounted || Environment.isExternalStorageEmulated();
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private int fixUpInstallReason(String installerPackageName, int installerUid, int installReason) {
        if (checkUidPermission("android.permission.INSTALL_PACKAGES", installerUid) == 0) {
            return installReason;
        }
        String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(UserHandle.getUserId(installerUid));
        if (ownerPackage != null && ownerPackage.equals(installerPackageName)) {
            return 1;
        }
        if (installReason == 1) {
            return 0;
        }
        return installReason;
    }

    /* access modifiers changed from: package-private */
    public void installStage(ActiveInstallSession activeInstallSession) {
        if (DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
            Slog.d(TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
        }
        if (activeInstallSession == null || !GMS_CORE_NAME.equals(activeInstallSession.getPackageName())) {
            this.callingSessionUid = -1;
        } else {
            this.callingSessionUid = activeInstallSession.getInstallerUid();
            if (DEBUG_GUNSTALL) {
                Slog.i(TAG, "installStage: installerUid=" + this.callingSessionUid);
            }
        }
        Message msg = this.mHandler.obtainMessage(5);
        InstallParams params = new InstallParams(activeInstallSession);
        params.setTraceMethod("installStage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    /* access modifiers changed from: package-private */
    public void installStage(List<ActiveInstallSession> children) throws PackageManagerException {
        Message msg = this.mHandler.obtainMessage(5);
        MultiPackageInstallParams params = new MultiPackageInstallParams(UserHandle.ALL, children);
        params.setTraceMethod("installStageMultiPackage").setTraceCookie(System.identityHashCode(params));
        msg.obj = params;
        Trace.asyncTraceBegin(262144, "installStageMultiPackage", System.identityHashCode(msg.obj));
        Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
        this.mHandler.sendMessage(msg);
    }

    private void sendPackageAddedForUser(String packageName, PackageSetting pkgSetting, int userId) {
        boolean isSystem = isSystemApp(pkgSetting) || isUpdatedSystemApp(pkgSetting);
        boolean isInstantApp = pkgSetting.getInstantApp(userId);
        sendPackageAddedForNewUsers(packageName, isSystem, false, pkgSetting.appId, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
        PackageInstaller.SessionInfo info = new PackageInstaller.SessionInfo();
        info.installReason = pkgSetting.getInstallReason(userId);
        info.appPackageName = packageName;
        sendSessionCommitBroadcast(info, userId);
    }

    @Override // com.android.server.pm.PackageSender
    public void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds) {
        if (!ArrayUtils.isEmpty(userIds) || !ArrayUtils.isEmpty(instantUserIds)) {
            Bundle extras = new Bundle(1);
            extras.putInt("android.intent.extra.UID", UserHandle.getUid(ArrayUtils.isEmpty(userIds) ? instantUserIds[0] : userIds[0], appId));
            sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", packageName, extras, 0, null, null, userIds, instantUserIds);
            if (sendBootCompleted && !ArrayUtils.isEmpty(userIds)) {
                this.mHandler.post(new Runnable(userIds, packageName, includeStopped) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$xmtSrOleoKr1YUMkKwdtQnmXYaI */
                    private final /* synthetic */ int[] f$1;
                    private final /* synthetic */ String f$2;
                    private final /* synthetic */ boolean f$3;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.this.lambda$sendPackageAddedForNewUsers$12$PackageManagerService(this.f$1, this.f$2, this.f$3);
                    }
                });
            }
        }
    }

    public /* synthetic */ void lambda$sendPackageAddedForNewUsers$12$PackageManagerService(int[] userIds, String packageName, boolean includeStopped) {
        for (int userId : userIds) {
            sendBootCompletedBroadcastToSystemApp(packageName, includeStopped, userId);
        }
    }

    private void sendBootCompletedBroadcastToSystemApp(String packageName, boolean includeStopped, int userId) {
        RemoteException e;
        if (this.mUserManagerInternal.isUserRunning(userId)) {
            IActivityManager am = ActivityManager.getService();
            try {
                Intent lockedBcIntent = new Intent("android.intent.action.LOCKED_BOOT_COMPLETED").setPackage(packageName);
                if (includeStopped) {
                    lockedBcIntent.addFlags(32);
                }
                String[] requiredPermissions = {"android.permission.RECEIVE_BOOT_COMPLETED"};
                try {
                    am.broadcastIntent((IApplicationThread) null, lockedBcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                    try {
                        if (this.mUserManagerInternal.isUserUnlockingOrUnlocked(userId)) {
                            Intent bcIntent = new Intent("android.intent.action.BOOT_COMPLETED").setPackage(packageName);
                            if (includeStopped) {
                                bcIntent.addFlags(32);
                            }
                            am.broadcastIntent((IApplicationThread) null, bcIntent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, requiredPermissions, -1, (Bundle) null, false, false, userId);
                        }
                    } catch (RemoteException e2) {
                        e = e2;
                        throw e.rethrowFromSystemServer();
                    }
                } catch (RemoteException e3) {
                    e = e3;
                    throw e.rethrowFromSystemServer();
                }
            } catch (RemoteException e4) {
                e = e4;
                throw e.rethrowFromSystemServer();
            }
        }
    }

    public boolean setApplicationHiddenSettingAsUser(String packageName, boolean hidden, int userId) {
        PackageSetting pkgSetting;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        if (!hidden || (iHwPackageManagerServiceEx = mHwPMSEx) == null || !iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName)) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
            int callingUid = Binder.getCallingUid();
            PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
            permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, true, "setApplicationHiddenSetting for user " + userId);
            if (!hidden || !isPackageDeviceAdmin(packageName, userId)) {
                long callingId = Binder.clearCallingIdentity();
                boolean sendAdded = false;
                boolean sendRemoved = false;
                try {
                    synchronized (this.mPackages) {
                        pkgSetting = this.mSettings.mPackages.get(packageName);
                        if (pkgSetting == null) {
                            return false;
                        }
                        if (hidden && HwPackageManagerServiceUtils.isInAntiFillingWhiteList(packageName, hasSystemFeature("android.software.home_screen", 0))) {
                            Slog.w(TAG, "Not hiding package " + packageName + ": limited by anti-filling");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if ((pkgSetting.pkgFlags & 1) != 0 && (GMS_CORE_NAME.equals(packageName) || "com.google.android.gsf".equals(packageName))) {
                            Slog.w(TAG, "Not hiding package " + packageName + ": limited because it's gms app");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                            Slog.w(TAG, "Cannot hide package: android");
                            Binder.restoreCallingIdentity(callingId);
                            return false;
                        } else {
                            PackageParser.Package pkg = this.mPackages.get(packageName);
                            if (pkg != null && pkg.staticSharedLibName != null) {
                                Slog.w(TAG, "Cannot hide package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            } else if (hidden && !UserHandle.isSameApp(callingUid, pkgSetting.appId) && this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                                Slog.w(TAG, "Not hiding protected package: " + packageName);
                                Binder.restoreCallingIdentity(callingId);
                                return false;
                            } else if (pkgSetting.getHidden(userId) != hidden) {
                                pkgSetting.setHidden(hidden, userId);
                                this.mSettings.writePackageRestrictionsLPr(userId);
                                if (hidden) {
                                    sendRemoved = true;
                                } else {
                                    sendAdded = true;
                                }
                            }
                        }
                    }
                    if (sendAdded) {
                        sendPackageAddedForUser(packageName, pkgSetting, userId);
                        Binder.restoreCallingIdentity(callingId);
                        return true;
                    } else if (sendRemoved) {
                        killApplication(packageName, UserHandle.getUid(userId, pkgSetting.appId), "hiding pkg");
                        sendApplicationHiddenForUser(packageName, pkgSetting, userId);
                        Binder.restoreCallingIdentity(callingId);
                        return true;
                    } else {
                        Binder.restoreCallingIdentity(callingId);
                        return false;
                    }
                } finally {
                    Binder.restoreCallingIdentity(callingId);
                }
            } else {
                Slog.w(TAG, "Not hiding package " + packageName + ": has active device admin");
                return false;
            }
        } else {
            Slog.i(TAG, "hidePackage NeedForbidShellFunc, " + packageName + " won't be hidden");
            return false;
        }
    }

    public void setSystemAppHiddenUntilInstalled(String packageName, boolean hidden) {
        enforceSystemOrPhoneCaller("setSystemAppHiddenUntilInstalled");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    PackageParser.Package pkg = pkgSetting.pkg;
                    if (!(pkg == null || pkg.applicationInfo == null)) {
                        pkg.applicationInfo.hiddenUntilInstalled = hidden;
                    }
                    PackageSetting disabledPs = this.mSettings.getDisabledSystemPkgLPr(packageName);
                    if (disabledPs != null) {
                        PackageParser.Package pkg2 = disabledPs.pkg;
                        if (!(pkg2 == null || pkg2.applicationInfo == null)) {
                            pkg2.applicationInfo.hiddenUntilInstalled = hidden;
                        }
                    }
                }
            }
        }
    }

    public boolean setSystemAppInstallState(String packageName, boolean installed, int userId) {
        enforceSystemOrPhoneCaller("setSystemAppInstallState");
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                if (pkgSetting.isSystem()) {
                    if (pkgSetting.getInstalled(userId) == installed) {
                        return false;
                    }
                }
            }
            return false;
        }
        long callingId = Binder.clearCallingIdentity();
        if (installed) {
            try {
                installExistingPackageAsUser(packageName, userId, 4194304, 3, null);
                return true;
            } finally {
                Binder.restoreCallingIdentity(callingId);
            }
        } else {
            deletePackageVersioned(new VersionedPackage(packageName, -1), new PackageManager.LegacyPackageDeleteObserver((IPackageDeleteObserver) null).getBinder(), userId, 4);
            Binder.restoreCallingIdentity(callingId);
            return true;
        }
    }

    private void sendApplicationHiddenForUser(String packageName, PackageSetting pkgSetting, int userId) {
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        info.removedPackage = packageName;
        info.installerPackageName = pkgSetting.installerPackageName;
        info.removedUsers = new int[]{userId};
        info.broadcastUsers = new int[]{userId};
        info.uid = UserHandle.getUid(userId, pkgSetting.appId);
        info.sendPackageRemovedBroadcasts(true);
    }

    private void sendDistractingPackagesChanged(String[] pkgList, int[] uidList, int userId, int distractionFlags) {
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        extras.putInt("android.intent.extra.distraction_restrictions", distractionFlags);
        sendPackageBroadcast("android.intent.action.DISTRACTING_PACKAGES_CHANGED", null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    private void sendPackagesSuspendedForUser(String[] pkgList, int[] uidList, int userId, boolean suspended, PersistableBundle launcherExtras) {
        String str;
        Bundle extras = new Bundle(3);
        extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
        extras.putIntArray("android.intent.extra.changed_uid_list", uidList);
        if (launcherExtras != null) {
            extras.putBundle("android.intent.extra.LAUNCHER_EXTRAS", new Bundle(launcherExtras.deepCopy()));
        }
        if (suspended) {
            str = "android.intent.action.PACKAGES_SUSPENDED";
        } else {
            str = "android.intent.action.PACKAGES_UNSUSPENDED";
        }
        sendPackageBroadcast(str, null, extras, 1073741824, null, null, new int[]{userId}, null);
    }

    public boolean getApplicationHiddenSettingAsUser(String packageName, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MANAGE_USERS", null);
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "getApplicationHidden for user " + userId);
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    return true;
                }
                if (filterAppAccessLPr(ps, callingUid, userId)) {
                    Binder.restoreCallingIdentity(callingId);
                    return true;
                }
                boolean hidden = ps.getHidden(userId);
                Binder.restoreCallingIdentity(callingId);
                return hidden;
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions) {
        return installExistingPackageAsUser(packageName, userId, installFlags, installReason, whiteListedPermissions, null);
    }

    /* access modifiers changed from: package-private */
    public int installExistingPackageAsUser(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions, IntentSender intentSender) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "installExistingPackageAsUser package=" + packageName + " userId=" + userId + " installFlags=" + installFlags + " installReason=" + installReason + " whiteListedPermissions=" + whiteListedPermissions);
        }
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") == 0 || this.mContext.checkCallingOrSelfPermission("com.android.permission.INSTALL_EXISTING_PACKAGES") == 0) {
            return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason, whiteListedPermissions, intentSender);
        }
        throw new SecurityException("Neither user " + callingUid + " nor current process has android.permission.INSTALL_PACKAGES.");
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Code restructure failed: missing block: B:83:0x0132, code lost:
        r0 = th;
     */
    /* JADX WARNING: Removed duplicated region for block: B:58:0x00e5 A[Catch:{ all -> 0x0134 }] */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x00f8  */
    public int installExistingPackageAsUserInternal(String packageName, int userId, int installFlags, int installReason, List<String> whiteListedPermissions, IntentSender intentSender) {
        Throwable th;
        Throwable th2;
        PackageSetting pkgSetting;
        List<String> whiteListedPermissions2;
        PostInstallData postInstallData;
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "installExistingPackage for user " + userId);
        if (isUserRestricted(userId, "no_install_apps")) {
            return -111;
        }
        long callingId = Binder.clearCallingIdentity();
        boolean installed = false;
        boolean instantApp = (installFlags & 2048) != 0;
        boolean fullApp = (installFlags & 16384) != 0;
        try {
            synchronized (this.mPackages) {
                try {
                    pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting == null) {
                        Binder.restoreCallingIdentity(callingId);
                        return -3;
                    }
                    if (!canViewInstantApps(callingUid, UserHandle.getUserId(callingUid))) {
                        int[] userIds = sUserManager.getUserIds();
                        int length = userIds.length;
                        boolean installAllowed = false;
                        int i = 0;
                        while (i < length) {
                            installAllowed = !pkgSetting.getInstantApp(userIds[i]);
                            if (installAllowed) {
                                break;
                            }
                            i++;
                            userIds = userIds;
                        }
                        if (!installAllowed) {
                            Binder.restoreCallingIdentity(callingId);
                            return -3;
                        }
                    }
                    if (!pkgSetting.getInstalled(userId)) {
                        pkgSetting.setInstalled(true, userId);
                        pkgSetting.setHidden(false, userId);
                        try {
                            pkgSetting.setInstallReason(installReason, userId);
                            this.mSettings.writePackageRestrictionsLPr(userId);
                            this.mSettings.writeKernelMappingLPr(pkgSetting);
                            installed = true;
                        } catch (Throwable th3) {
                            th2 = th3;
                            throw th2;
                        }
                    } else if (fullApp && pkgSetting.getInstantApp(userId)) {
                        installed = true;
                    }
                    try {
                        setInstantAppForUser(pkgSetting, userId, instantApp, fullApp);
                    } catch (Throwable th4) {
                        th2 = th4;
                        throw th2;
                    }
                } catch (Throwable th5) {
                    th2 = th5;
                    throw th2;
                }
            }
            if (installed) {
                if ((4194304 & installFlags) != 0) {
                    try {
                        if (pkgSetting.pkg != null) {
                            whiteListedPermissions2 = pkgSetting.pkg.requestedPermissions;
                            setWhitelistedRestrictedPermissions(packageName, whiteListedPermissions2, 2, userId);
                            if (pkgSetting.pkg != null) {
                                synchronized (this.mInstallLock) {
                                    prepareAppDataAfterInstallLIF(pkgSetting.pkg);
                                }
                            }
                            sendPackageAddedForUser(packageName, pkgSetting, userId);
                            synchronized (this.mPackages) {
                                updateSequenceNumberLP(pkgSetting, new int[]{userId});
                            }
                            PackageInstalledInfo res = createPackageInstalledInfo(1);
                            res.pkg = pkgSetting.pkg;
                            res.newUsers = new int[]{userId};
                            if (intentSender == null) {
                                postInstallData = null;
                            } else {
                                postInstallData = new PostInstallData(null, res, new Runnable(res, intentSender) {
                                    /* class com.android.server.pm.$$Lambda$PackageManagerService$5hT3Do2mLOkOzeEpiIJBbt6lRYA */
                                    private final /* synthetic */ PackageManagerService.PackageInstalledInfo f$1;
                                    private final /* synthetic */ IntentSender f$2;

                                    {
                                        this.f$1 = r2;
                                        this.f$2 = r3;
                                    }

                                    @Override // java.lang.Runnable
                                    public final void run() {
                                        PackageManagerService.this.lambda$installExistingPackageAsUserInternal$13$PackageManagerService(this.f$1, this.f$2);
                                    }
                                });
                            }
                            restoreAndPostInstall(userId, res, postInstallData);
                        }
                    } catch (Throwable th6) {
                        th = th6;
                        Binder.restoreCallingIdentity(callingId);
                        throw th;
                    }
                }
                whiteListedPermissions2 = whiteListedPermissions;
                try {
                    setWhitelistedRestrictedPermissions(packageName, whiteListedPermissions2, 2, userId);
                    if (pkgSetting.pkg != null) {
                    }
                    sendPackageAddedForUser(packageName, pkgSetting, userId);
                    synchronized (this.mPackages) {
                    }
                } catch (Throwable th7) {
                    th = th7;
                    Binder.restoreCallingIdentity(callingId);
                    throw th;
                }
            }
            Binder.restoreCallingIdentity(callingId);
            return 1;
        } catch (Throwable th8) {
            th = th8;
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
        while (true) {
        }
    }

    public /* synthetic */ void lambda$installExistingPackageAsUserInternal$13$PackageManagerService(PackageInstalledInfo res, IntentSender intentSender) {
        onRestoreComplete(res.returnCode, this.mContext, intentSender);
    }

    static void onRestoreComplete(int returnCode, Context context, IntentSender target) {
        Intent fillIn = new Intent();
        fillIn.putExtra("android.content.pm.extra.STATUS", PackageManager.installStatusToPublicStatus(returnCode));
        try {
            target.sendIntent(context, 0, fillIn, null, null);
        } catch (IntentSender.SendIntentException e) {
        }
    }

    static void setInstantAppForUser(PackageSetting pkgSetting, int userId, boolean instantApp, boolean fullApp) {
        if (!(instantApp || fullApp)) {
            return;
        }
        if (userId == -1) {
            int[] userIds = sUserManager.getUserIds();
            for (int currentUserId : userIds) {
                if (instantApp && !pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(true, currentUserId);
                } else if (fullApp && pkgSetting.getInstantApp(currentUserId)) {
                    pkgSetting.setInstantApp(false, currentUserId);
                }
            }
        } else if (instantApp && !pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(true, userId);
        } else if (fullApp && pkgSetting.getInstantApp(userId)) {
            pkgSetting.setInstantApp(false, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isUserRestricted(int userId, String restrictionKey) {
        if (!sUserManager.getUserRestrictions(userId).getBoolean(restrictionKey, false)) {
            return false;
        }
        Log.w(TAG, "User is restricted: " + restrictionKey);
        return true;
    }

    public String[] setDistractingPackageRestrictionsAsUser(String[] packageNames, int restrictionFlags, int userId) {
        boolean[] canRestrict;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "setDistractingPackageRestrictionsAsUser");
        int callingUid = Binder.getCallingUid();
        if (callingUid == 0 || callingUid == 1000 || UserHandle.getUserId(callingUid) == userId) {
            Preconditions.checkNotNull(packageNames, "packageNames cannot be null");
            List<String> changedPackagesList = new ArrayList<>(packageNames.length);
            IntArray changedUids = new IntArray(packageNames.length);
            List<String> unactionedPackages = new ArrayList<>(packageNames.length);
            if (restrictionFlags != 0) {
                canRestrict = canSuspendPackageForUserInternal(packageNames, userId);
            } else {
                canRestrict = null;
            }
            for (int i = 0; i < packageNames.length; i++) {
                String packageName = packageNames[i];
                synchronized (this.mPackages) {
                    PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
                    if (pkgSetting != null) {
                        if (!filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                            if (canRestrict == null || canRestrict[i]) {
                                synchronized (this.mPackages) {
                                    if (restrictionFlags != pkgSetting.getDistractionFlags(userId)) {
                                        pkgSetting.setDistractionFlags(restrictionFlags, userId);
                                        changedPackagesList.add(packageName);
                                        changedUids.add(UserHandle.getUid(userId, pkgSetting.appId));
                                    }
                                }
                            } else {
                                unactionedPackages.add(packageName);
                            }
                        }
                    }
                    Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping...");
                    unactionedPackages.add(packageName);
                }
            }
            if (!changedPackagesList.isEmpty()) {
                sendDistractingPackagesChanged((String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]), changedUids.toArray(), userId, restrictionFlags);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
            return (String[]) unactionedPackages.toArray(new String[0]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot call for user " + userId);
    }

    private void enforceCanSetPackagesSuspendedAsUser(String callingPackage, int callingUid, int userId, String callingMethod) {
        if (callingUid != 0 && callingUid != 1000) {
            String ownerPackage = this.mProtectedPackages.getDeviceOwnerOrProfileOwnerPackage(userId);
            boolean allowedShell = false;
            if (ownerPackage == null) {
                this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", callingMethod);
                int packageUid = getPackageUid(callingPackage, 0, userId);
                boolean allowedPackageUid = packageUid == callingUid;
                if (callingUid == 2000 && UserHandle.isSameApp(packageUid, callingUid)) {
                    allowedShell = true;
                }
                if (!allowedShell && !allowedPackageUid) {
                    throw new SecurityException("Calling package " + callingPackage + " in user " + userId + " does not belong to calling uid " + callingUid);
                }
            } else if (getPackageUid(ownerPackage, 0, userId) != callingUid) {
                throw new UnsupportedOperationException("Cannot suspend/unsuspend packages. User " + userId + " has an active DO or PO");
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:33:0x00ce, code lost:
        if (r0 == null) goto L_0x00dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:35:0x00d2, code lost:
        if (r0[r14] != false) goto L_0x00dd;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:36:0x00d4, code lost:
        r15.add(r13);
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:37:0x00dd, code lost:
        r11 = r20.mPackages;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:38:0x00df, code lost:
        monitor-enter(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:39:0x00e0, code lost:
        r18 = r3;
        r19 = r14;
        r8 = r15;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:41:?, code lost:
        r0.setSuspended(r22, r26, r25, r23, r24, r27);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:42:0x00f9, code lost:
        monitor-exit(r11);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:43:0x00fa, code lost:
        r0.add(r13);
        r0.add(android.os.UserHandle.getUid(r27, r0.appId));
     */
    public String[] setPackagesSuspendedAsUser(String[] packageNames, boolean suspended, PersistableBundle appExtras, PersistableBundle launcherExtras, SuspendDialogInfo dialogInfo, String callingPackage, int userId) {
        boolean[] canSuspend;
        int i;
        int callingUid;
        List<String> unactionedPackages;
        String packageName;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        String[] strArr = packageNames;
        String str = callingPackage;
        int callingUid2 = Binder.getCallingUid();
        enforceCanSetPackagesSuspendedAsUser(str, callingUid2, userId, "setPackagesSuspendedAsUser");
        if (ArrayUtils.isEmpty(packageNames)) {
            return strArr;
        }
        List<String> changedPackagesList = new ArrayList<>(strArr.length);
        IntArray changedUids = new IntArray(strArr.length);
        List<String> unactionedPackages2 = new ArrayList<>(strArr.length);
        if (suspended) {
            canSuspend = canSuspendPackageForUserInternal(strArr, userId);
        } else {
            canSuspend = null;
        }
        int i2 = 0;
        while (i2 < strArr.length) {
            String packageName2 = strArr[i2];
            if (suspended && (iHwPackageManagerServiceEx = mHwPMSEx) != null && iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName2)) {
                unactionedPackages2.add(packageName2);
                Slog.i(TAG, "suspendPackage NeedForbidShellFunc, " + packageName2 + " won't be suspend");
                callingUid = callingUid2;
                i = i2;
                unactionedPackages = unactionedPackages2;
            } else if (str.equals(packageName2)) {
                StringBuilder sb = new StringBuilder();
                sb.append("Calling package: ");
                sb.append(str);
                sb.append(" trying to ");
                sb.append(suspended ? "" : "un");
                sb.append("suspend itself. Ignoring");
                Slog.w(TAG, sb.toString());
                unactionedPackages2.add(packageName2);
                callingUid = callingUid2;
                i = i2;
                unactionedPackages = unactionedPackages2;
            } else {
                synchronized (this.mPackages) {
                    try {
                        PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName2);
                        if (pkgSetting == null) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        } else if (filterAppAccessLPr(pkgSetting, callingUid2, userId)) {
                            callingUid = callingUid2;
                            packageName = packageName2;
                            i = i2;
                            unactionedPackages = unactionedPackages2;
                        }
                        Slog.w(TAG, "Could not find package setting for package: " + packageName + ". Skipping suspending/un-suspending.");
                        unactionedPackages.add(packageName);
                    } catch (Throwable th) {
                        th = th;
                        throw th;
                    }
                }
            }
            i2 = i + 1;
            str = callingPackage;
            unactionedPackages2 = unactionedPackages;
            callingUid2 = callingUid;
            strArr = packageNames;
        }
        if (!changedPackagesList.isEmpty()) {
            String[] changedPackages = (String[]) changedPackagesList.toArray(new String[changedPackagesList.size()]);
            sendPackagesSuspendedForUser(changedPackages, changedUids.toArray(), userId, suspended, launcherExtras);
            sendMyPackageSuspendedOrUnsuspended(changedPackages, suspended, appExtras, userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        }
        return (String[]) unactionedPackages2.toArray(new String[unactionedPackages2.size()]);
    }

    public PersistableBundle getSuspendedPackageAppExtras(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (getPackageUid(packageName, 0, userId) == callingUid) {
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                    throw new IllegalArgumentException("Unknown target package: " + packageName);
                }
                PackageUserState packageUserState = ps.readUserState(userId);
                if (!packageUserState.suspended) {
                    return null;
                }
                return packageUserState.suspendedAppExtras;
            }
        }
        throw new SecurityException("Calling package " + packageName + " does not belong to calling uid " + callingUid);
    }

    private void sendMyPackageSuspendedOrUnsuspended(String[] affectedPackages, boolean suspended, PersistableBundle appExtras, int userId) {
        String action;
        Bundle intentExtras = new Bundle();
        if (suspended) {
            if (appExtras != null) {
                intentExtras.putBundle("android.intent.extra.SUSPENDED_PACKAGE_EXTRAS", new Bundle(appExtras.deepCopy()));
            }
            action = "android.intent.action.MY_PACKAGE_SUSPENDED";
        } else {
            action = "android.intent.action.MY_PACKAGE_UNSUSPENDED";
        }
        this.mHandler.post(new Runnable(suspended, userId, affectedPackages, action, intentExtras) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$HK_t4UP5DBwt6SE50jDkVWIaNwU */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String[] f$3;
            private final /* synthetic */ String f$4;
            private final /* synthetic */ Bundle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$sendMyPackageSuspendedOrUnsuspended$14$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
    }

    public /* synthetic */ void lambda$sendMyPackageSuspendedOrUnsuspended$14$PackageManagerService(boolean suspended, int userId, String[] affectedPackages, String action, Bundle intentExtras) {
        try {
            IActivityManager am = ActivityManager.getService();
            if (am == null) {
                StringBuilder sb = new StringBuilder();
                sb.append("IActivityManager null. Cannot send MY_PACKAGE_ ");
                sb.append(suspended ? "" : "UN");
                sb.append("SUSPENDED broadcasts");
                Slog.wtf(TAG, sb.toString());
                return;
            }
            int[] targetUserIds = {userId};
            for (String packageName : affectedPackages) {
                doSendBroadcast(am, action, null, intentExtras, DumpState.DUMP_SERVICE_PERMISSIONS, packageName, null, targetUserIds, false);
            }
        } catch (RemoteException e) {
        }
    }

    public boolean isPackageSuspendedForUser(String packageName, int userId) {
        boolean suspended;
        int callingUid = Binder.getCallingUid();
        PermissionManagerServiceInternal permissionManagerServiceInternal = this.mPermissionManager;
        permissionManagerServiceInternal.enforceCrossUserPermission(callingUid, userId, true, false, "isPackageSuspendedForUser for user " + userId);
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null || filterAppAccessLPr(ps, callingUid, userId)) {
                throw new IllegalArgumentException("Unknown target package: " + packageName);
            }
            suspended = ps.getSuspended(userId);
        }
        return suspended;
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForSuspendingPackage(String packageName, int affectedUser) {
        int[] userIds = affectedUser == -1 ? sUserManager.getUserIds() : new int[]{affectedUser};
        for (int userId : userIds) {
            Objects.requireNonNull(packageName);
            unsuspendForSuspendingPackages(new Predicate(packageName) {
                /* class com.android.server.pm.$$Lambda$S4BXTl5Ly3EHhXAReFCtlz2B8eo */
                private final /* synthetic */ String f$0;

                {
                    this.f$0 = r1;
                }

                @Override // java.util.function.Predicate
                public final boolean test(Object obj) {
                    return this.f$0.equals((String) obj);
                }
            }, userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void unsuspendForNonSystemSuspendingPackages(ArraySet<Integer> userIds) {
        int sz = userIds.size();
        for (int i = 0; i < sz; i++) {
            unsuspendForSuspendingPackages($$Lambda$PackageManagerService$BLKFkCe_A0qn0wGueDNTdKJLGTg.INSTANCE, userIds.valueAt(i).intValue());
        }
    }

    static /* synthetic */ boolean lambda$unsuspendForNonSystemSuspendingPackages$15(String suspendingPackage) {
        return !PLATFORM_PACKAGE_NAME.equals(suspendingPackage);
    }

    private void unsuspendForSuspendingPackages(Predicate<String> packagePredicate, int userId) {
        List<String> affectedPackages = new ArrayList<>();
        IntArray affectedUids = new IntArray();
        synchronized (this.mPackages) {
            for (PackageSetting ps : this.mSettings.mPackages.values()) {
                PackageUserState pus = ps.readUserState(userId);
                if (pus.suspended && packagePredicate.test(pus.suspendingPackage)) {
                    ps.setSuspended(false, null, null, null, null, userId);
                    affectedPackages.add(ps.name);
                    affectedUids.add(UserHandle.getUid(userId, ps.getAppId()));
                }
            }
        }
        if (!affectedPackages.isEmpty()) {
            String[] packageArray = (String[]) affectedPackages.toArray(new String[affectedPackages.size()]);
            sendMyPackageSuspendedOrUnsuspended(packageArray, false, null, userId);
            sendPackagesSuspendedForUser(packageArray, affectedUids.toArray(), userId, false, null);
            this.mSettings.writePackageRestrictionsLPr(userId);
        }
    }

    public String[] getUnsuspendablePackagesForUser(String[] packageNames, int userId) {
        Preconditions.checkNotNull("packageNames cannot be null", packageNames);
        this.mContext.enforceCallingOrSelfPermission("android.permission.SUSPEND_APPS", "getUnsuspendablePackagesForUser");
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) == userId) {
            ArraySet<String> unactionablePackages = new ArraySet<>();
            boolean[] canSuspend = canSuspendPackageForUserInternal(packageNames, userId);
            for (int i = 0; i < packageNames.length; i++) {
                if (!canSuspend[i]) {
                    unactionablePackages.add(packageNames[i]);
                }
            }
            return (String[]) unactionablePackages.toArray(new String[unactionablePackages.size()]);
        }
        throw new SecurityException("Calling uid " + callingUid + " cannot query getUnsuspendablePackagesForUser for user " + userId);
    }

    private boolean[] canSuspendPackageForUserInternal(String[] packageNames, int userId) {
        boolean[] canSuspend = new boolean[packageNames.length];
        long callingId = Binder.clearCallingIdentity();
        try {
            String activeLauncherPackageName = getActiveLauncherPackageName(userId);
            String dialerPackageName = getDefaultDialerPackageName(userId);
            for (int i = 0; i < packageNames.length; i++) {
                canSuspend[i] = false;
                String packageName = packageNames[i];
                if (isPackageDeviceAdmin(packageName, userId)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": has an active device admin");
                } else if (packageName.equals(activeLauncherPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": contains the active launcher");
                } else if (packageName.equals(this.mRequiredInstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package installation");
                } else if (packageName.equals(this.mRequiredUninstallerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package uninstallation");
                } else if (packageName.equals(this.mRequiredVerifierPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for package verification");
                } else if (packageName.equals(dialerPackageName)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": is the default dialer");
                } else if (packageName.equals(this.mRequiredPermissionControllerPackage)) {
                    Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": required for permissions management");
                } else {
                    synchronized (this.mPackages) {
                        if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                            Slog.w(TAG, "Cannot suspend package \"" + packageName + "\": protected package");
                        } else {
                            PackageParser.Package pkg = this.mPackages.get(packageName);
                            if (pkg != null && pkg.applicationInfo.isStaticSharedLibrary()) {
                                Slog.w(TAG, "Cannot suspend package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
                            } else if (PLATFORM_PACKAGE_NAME.equals(packageName)) {
                                Slog.w(TAG, "Cannot suspend the platform package: " + packageName);
                            } else {
                                canSuspend[i] = true;
                            }
                        }
                    }
                }
            }
            return canSuspend;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private String getActiveLauncherPackageName(int userId) {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        ResolveInfo resolveInfo = resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 65536, userId);
        if (resolveInfo == null) {
            return null;
        }
        return resolveInfo.activityInfo.packageName;
    }

    private String getDefaultDialerPackageName(int userId) {
        PackageManagerInternal.DefaultDialerProvider provider;
        synchronized (this.mPackages) {
            provider = this.mDefaultDialerProvider;
        }
        if (provider != null) {
            return provider.getDefaultDialer(userId);
        }
        Slog.e(TAG, "mDefaultDialerProvider is null");
        return null;
    }

    public void verifyPendingInstall(int id, int verificationCode) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(15);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCode, Binder.getCallingUid());
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public void extendVerificationTimeout(int id, int verificationCodeAtTimeout, long millisecondsToDelay) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can extend verification timeouts");
        PackageVerificationState state = this.mPendingVerification.get(id);
        PackageVerificationResponse response = new PackageVerificationResponse(verificationCodeAtTimeout, Binder.getCallingUid());
        if (millisecondsToDelay > AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT) {
            millisecondsToDelay = AppStandbyController.SettingsObserver.DEFAULT_STRONG_USAGE_TIMEOUT;
        }
        if (millisecondsToDelay < 0) {
            millisecondsToDelay = 0;
        }
        if (!(verificationCodeAtTimeout == 1 || verificationCodeAtTimeout == -1)) {
        }
        if (state != null && !state.timeoutExtended()) {
            state.extendTimeout();
            Message msg = this.mHandler.obtainMessage(15);
            msg.arg1 = id;
            msg.obj = response;
            this.mHandler.sendMessageDelayed(msg, millisecondsToDelay);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void broadcastPackageVerified(int verificationId, Uri packageUri, int verificationCode, UserHandle user) {
        Intent intent = new Intent("android.intent.action.PACKAGE_VERIFIED");
        intent.setDataAndType(packageUri, PACKAGE_MIME_TYPE);
        intent.addFlags(1);
        intent.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
        intent.putExtra("android.content.pm.extra.VERIFICATION_RESULT", verificationCode);
        this.mContext.sendBroadcastAsUser(intent, user, "android.permission.PACKAGE_VERIFICATION_AGENT");
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ComponentName matchComponentForVerifier(String packageName, List<ResolveInfo> receivers) {
        ActivityInfo targetReceiver = null;
        int NR = receivers.size();
        int i = 0;
        while (true) {
            if (i >= NR) {
                break;
            }
            ResolveInfo info = receivers.get(i);
            if (info.activityInfo != null && packageName.equals(info.activityInfo.packageName)) {
                targetReceiver = info.activityInfo;
                break;
            }
            i++;
        }
        if (targetReceiver == null) {
            return null;
        }
        return new ComponentName(targetReceiver.packageName, targetReceiver.name);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private List<ComponentName> matchVerifiers(PackageInfoLite pkgInfo, List<ResolveInfo> receivers, PackageVerificationState verificationState) {
        int verifierUid;
        if (pkgInfo.verifiers.length == 0) {
            return null;
        }
        int N = pkgInfo.verifiers.length;
        List<ComponentName> sufficientVerifiers = new ArrayList<>(N + 1);
        for (int i = 0; i < N; i++) {
            VerifierInfo verifierInfo = pkgInfo.verifiers[i];
            ComponentName comp = matchComponentForVerifier(verifierInfo.packageName, receivers);
            if (!(comp == null || (verifierUid = getUidForVerifier(verifierInfo)) == -1)) {
                if (DEBUG_VERIFY) {
                    Slog.d(TAG, "Added sufficient verifier " + verifierInfo.packageName + " with the correct signature");
                }
                sufficientVerifiers.add(comp);
                verificationState.addSufficientVerifier(verifierUid);
            }
        }
        return sufficientVerifiers;
    }

    private int getUidForVerifier(VerifierInfo verifierInfo) {
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(verifierInfo.packageName);
            if (pkg == null) {
                return -1;
            }
            if (pkg.mSigningDetails.signatures.length != 1) {
                Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " has more than one signature; ignoring");
                return -1;
            }
            try {
                if (!Arrays.equals(verifierInfo.publicKey.getEncoded(), pkg.mSigningDetails.signatures[0].getPublicKey().getEncoded())) {
                    Slog.i(TAG, "Verifier package " + verifierInfo.packageName + " does not have the expected public key; ignoring");
                    return -1;
                }
                return pkg.applicationInfo.uid;
            } catch (CertificateException e) {
                return -1;
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void setEnableRollbackCode(int token, int enableRollbackCode) {
        Message msg = this.mHandler.obtainMessage(21);
        msg.arg1 = token;
        msg.arg2 = enableRollbackCode;
        this.mHandler.sendMessage(msg);
    }

    public void finishPackageInstall(int token, boolean didLaunch) {
        enforceSystemOrRoot("Only the system is allowed to finish installs");
        if (DEBUG_INSTALL) {
            Slog.v(TAG, "BM finishing package install for " + token);
        }
        Trace.asyncTraceEnd(262144, "restore", token);
        this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, didLaunch ? 1 : 0));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private long getVerificationTimeout() {
        return Settings.Global.getLong(this.mContext.getContentResolver(), "verifier_timeout", JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private int getDefaultVerificationResponse(UserHandle user) {
        if (sUserManager.hasUserRestriction("ensure_verify_apps", user.getIdentifier())) {
            return -1;
        }
        return Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_default_response", 1);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean isVerificationEnabled(int userId, int installFlags, int installerUid) {
        ActivityInfo activityInfo;
        if ((524288 & installFlags) != 0) {
            return false;
        }
        boolean ensureVerifyAppsEnabled = isUserRestricted(userId, "ensure_verify_apps");
        if ((installFlags & 32) != 0) {
            if (ActivityManager.isRunningInTestHarness()) {
                return false;
            }
            if (ensureVerifyAppsEnabled) {
                return true;
            }
            if (Settings.Global.getInt(this.mContext.getContentResolver(), "verifier_verify_adb_installs", 1) == 0) {
                return false;
            }
        } else if (!((installFlags & 2048) == 0 || (activityInfo = this.mInstantAppInstallerActivity) == null || !activityInfo.packageName.equals(this.mRequiredVerifierPackage))) {
            try {
                ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(installerUid, this.mRequiredVerifierPackage);
                if (DEBUG_VERIFY) {
                    Slog.i(TAG, "disable verification for instant app");
                }
                return false;
            } catch (SecurityException e) {
            }
        }
        if (ensureVerifyAppsEnabled) {
            return true;
        }
        if (Settings.Global.getInt(this.mContext.getContentResolver(), "package_verifier_enable", 1) == 1) {
            return true;
        }
        return false;
    }

    public void verifyIntentFilter(int id, int verificationCode, List<String> failedDomains) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTENT_FILTER_VERIFICATION_AGENT", "Only intentfilter verification agents can verify applications");
        Message msg = this.mHandler.obtainMessage(18);
        IntentFilterVerificationResponse response = new IntentFilterVerificationResponse(Binder.getCallingUid(), verificationCode, failedDomains);
        msg.arg1 = id;
        msg.obj = response;
        this.mHandler.sendMessage(msg);
    }

    public int getIntentVerificationStatus(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        if (UserHandle.getUserId(callingUid) != userId) {
            Context context = this.mContext;
            context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getIntentVerificationStatus" + userId);
        }
        if (getInstantAppPackageName(callingUid) != null) {
            return 0;
        }
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                }
            }
            return 0;
        }
    }

    public boolean updateIntentVerificationStatus(String packageName, int status, int userId) {
        boolean result;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                return false;
            }
            result = this.mSettings.updateIntentFilterVerificationStatusLPw(packageName, status, userId);
        }
        if (result) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
        return result;
    }

    public ParceledListSlice<IntentFilterVerificationInfo> getIntentFilterVerifications(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null) {
            return ParceledListSlice.emptyList();
        }
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, UserHandle.getUserId(callingUid))) {
                return ParceledListSlice.emptyList();
            }
            return new ParceledListSlice<>(this.mSettings.getIntentFilterVerificationsLPr(packageName));
        }
    }

    public ParceledListSlice<IntentFilter> getAllIntentFilters(String packageName) {
        if (TextUtils.isEmpty(packageName)) {
            return ParceledListSlice.emptyList();
        }
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg != null) {
                if (pkg.activities != null) {
                    if (pkg.mExtras == null) {
                        return ParceledListSlice.emptyList();
                    } else if (filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                        return ParceledListSlice.emptyList();
                    } else {
                        int count = pkg.activities.size();
                        ArrayList<IntentFilter> result = new ArrayList<>();
                        for (int n = 0; n < count; n++) {
                            PackageParser.Activity activity = (PackageParser.Activity) pkg.activities.get(n);
                            if (activity.intents != null && activity.intents.size() > 0) {
                                result.addAll(activity.intents);
                            }
                        }
                        return new ParceledListSlice<>(result);
                    }
                }
            }
            return ParceledListSlice.emptyList();
        }
    }

    public boolean setDefaultBrowserPackageName(String packageName, int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (userId == -1) {
            return false;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultBrowserProvider is null");
            return false;
        } else if (!provider.setDefaultBrowser(packageName, userId)) {
            return false;
        } else {
            if (packageName == null) {
                return true;
            }
            synchronized (this.mPackages) {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
            }
            return true;
        }
    }

    private void setDefaultBrowserAsyncLPw(String packageName, int userId) {
        if (userId != -1) {
            PackageManagerInternal.DefaultBrowserProvider defaultBrowserProvider = this.mDefaultBrowserProvider;
            if (defaultBrowserProvider == null) {
                Slog.e(TAG, "mDefaultBrowserProvider is null");
                return;
            }
            defaultBrowserProvider.setDefaultBrowserAsync(packageName, userId);
            if (packageName != null) {
                synchronized (this.mPackages) {
                    this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultBrowser(packageName, userId);
                }
            }
        }
    }

    public String getDefaultBrowserPackageName(int userId) {
        PackageManagerInternal.DefaultBrowserProvider provider;
        if (UserHandle.getCallingUserId() != userId) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        }
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultBrowserProvider;
        }
        if (provider != null) {
            return provider.getDefaultBrowser(userId);
        }
        Slog.e(TAG, "mDefaultBrowserProvider is null");
        return null;
    }

    private int getUnknownSourcesSettings() {
        return Settings.Secure.getInt(this.mContext.getContentResolver(), "install_non_market_apps", -1);
    }

    public void setInstallerPackageName(String targetPackage, String installerPackageName) {
        PackageSetting installerPackageSetting;
        Signature[] callerSignature;
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                PackageSetting targetPackageSetting = this.mSettings.mPackages.get(targetPackage);
                if (targetPackageSetting == null || filterAppAccessLPr(targetPackageSetting, callingUid, UserHandle.getUserId(callingUid))) {
                    throw new IllegalArgumentException("Unknown target package: " + targetPackage);
                }
                PackageSetting targetInstallerPkgSetting = null;
                if (installerPackageName != null) {
                    installerPackageSetting = this.mSettings.mPackages.get(installerPackageName);
                    if (installerPackageSetting == null) {
                        throw new IllegalArgumentException("Unknown installer package: " + installerPackageName);
                    }
                } else {
                    installerPackageSetting = null;
                }
                Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(callingUid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        callerSignature = ((SharedUserSetting) obj).signatures.mSigningDetails.signatures;
                    } else if (obj instanceof PackageSetting) {
                        callerSignature = ((PackageSetting) obj).signatures.mSigningDetails.signatures;
                    } else {
                        throw new SecurityException("Bad object " + obj + " for uid " + callingUid);
                    }
                    if (installerPackageSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, installerPackageSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as new installer package " + installerPackageName);
                        }
                    }
                    String targetInstallerPackageName = targetPackageSetting.installerPackageName;
                    if (targetInstallerPackageName != null) {
                        targetInstallerPkgSetting = this.mSettings.mPackages.get(targetInstallerPackageName);
                    }
                    if (targetInstallerPkgSetting != null) {
                        if (PackageManagerServiceUtils.compareSignatures(callerSignature, targetInstallerPkgSetting.signatures.mSigningDetails.signatures) != 0) {
                            throw new SecurityException("Caller does not have same cert as old installer package " + targetInstallerPackageName);
                        }
                    } else if (this.mContext.checkCallingOrSelfPermission("android.permission.INSTALL_PACKAGES") != 0) {
                        EventLog.writeEvent(1397638484, "150857253", Integer.valueOf(callingUid), "");
                        if (getUidTargetSdkVersionLockedLPr(callingUid) > 29) {
                            throw new SecurityException("Neither user " + callingUid + " nor current process has android.permission.INSTALL_PACKAGES");
                        }
                        return;
                    }
                    targetPackageSetting.installerPackageName = installerPackageName;
                    if (installerPackageName != null) {
                        this.mSettings.mInstallerPackages.add(installerPackageName);
                    }
                    scheduleWriteSettingsLocked();
                    return;
                }
                throw new SecurityException("Unknown calling UID: " + callingUid);
            }
        }
    }

    public void setApplicationCategoryHint(String packageName, int categoryHint, String callerPackageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ((AppOpsManager) this.mContext.getSystemService(AppOpsManager.class)).checkPackage(Binder.getCallingUid(), callerPackageName);
            synchronized (this.mPackages) {
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (ps == null) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (filterAppAccessLPr(ps, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                    throw new IllegalArgumentException("Unknown target package " + packageName);
                } else if (!Objects.equals(callerPackageName, ps.installerPackageName)) {
                    throw new IllegalArgumentException("Calling package " + callerPackageName + " is not installer for " + packageName);
                } else if (ps.categoryHint != categoryHint) {
                    ps.categoryHint = categoryHint;
                    scheduleWriteSettingsLocked();
                }
            }
            return;
        }
        throw new SecurityException("Instant applications don't have access to this method");
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void processPendingInstall(InstallArgs args, int currentStatus) {
        if (args.mMultiPackageInstallParams != null) {
            args.mMultiPackageInstallParams.tryProcessInstallRequest(args, currentStatus);
            return;
        }
        PackageInstalledInfo res = createPackageInstalledInfo(currentStatus);
        boolean z = true;
        if (res.returnCode != 1) {
            z = false;
        }
        processInstallRequestsAsync(z, Collections.singletonList(new InstallRequest(args, res)));
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void processInstallRequestsAsync(boolean success, List<InstallRequest> installRequests) {
        this.mHandler.post(new Runnable(success, installRequests) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$WqNCdP_LawZV2AkvAC3Z3Q7VYo0 */
            private final /* synthetic */ boolean f$1;
            private final /* synthetic */ List f$2;

            {
                this.f$1 = r2;
                this.f$2 = r3;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$processInstallRequestsAsync$16$PackageManagerService(this.f$1, this.f$2);
            }
        });
    }

    public /* synthetic */ void lambda$processInstallRequestsAsync$16$PackageManagerService(boolean success, List installRequests) {
        if (success) {
            long installBeginTime = SystemClock.elapsedRealtime();
            Iterator it = installRequests.iterator();
            while (it.hasNext()) {
                InstallRequest request = (InstallRequest) it.next();
                request.args.doPreInstall(request.installResult.returnCode);
            }
            synchronized (this.mInstallLock) {
                installPackagesTracedLI(installRequests);
            }
            Iterator it2 = installRequests.iterator();
            while (it2.hasNext()) {
                InstallRequest request2 = (InstallRequest) it2.next();
                PackageParser.Package pkg = request2.installResult.pkg;
                String pkgName = null;
                if (pkg != null) {
                    pkgName = pkg.packageName;
                }
                if (pkgName != null) {
                    InstallerMgr.getInstance().installPackage(1, request2.args.installerPackageName, pkgName);
                }
            }
            Iterator it3 = installRequests.iterator();
            while (it3.hasNext()) {
                InstallRequest request3 = (InstallRequest) it3.next();
                request3.args.doPostInstall(request3.installResult.returnCode, request3.installResult.uid);
                if (request3.installResult.returnCode == 1) {
                    PackageParser.Package pkg2 = request3.installResult.pkg;
                    String pkgName2 = null;
                    if (pkg2 != null) {
                        pkgName2 = pkg2.packageName;
                    }
                    if (pkgName2 != null) {
                        mHwPMSEx.recordInstallAppInfo(pkgName2, installBeginTime, 0);
                    }
                }
            }
        }
        Iterator it4 = installRequests.iterator();
        while (it4.hasNext()) {
            InstallRequest request4 = (InstallRequest) it4.next();
            restoreAndPostInstall(request4.args.user.getIdentifier(), request4.installResult, new PostInstallData(request4.args, request4.installResult, null));
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private PackageInstalledInfo createPackageInstalledInfo(int currentStatus) {
        PackageInstalledInfo res = new PackageInstalledInfo();
        res.setReturnCode(currentStatus);
        res.uid = -1;
        res.pkg = null;
        res.removedInfo = null;
        return res;
    }

    private void restoreAndPostInstall(int userId, PackageInstalledInfo res, PostInstallData data) {
        int userId2;
        long j;
        Throwable th;
        long ceDataInode;
        int appId;
        int[] installedUsers;
        int userId3;
        if (!(!DEBUG_INSTALL || res == null || res.pkg == null)) {
            Log.v(TAG, "restoreAndPostInstall userId=" + userId + " package=" + res.pkg.packageName);
        }
        boolean update = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
        boolean doRestore = !update && (32768 & (res.pkg == null ? 0 : res.pkg.applicationInfo.flags)) != 0;
        if (this.mNextInstallToken < 0) {
            this.mNextInstallToken = 1;
        }
        int token = this.mNextInstallToken;
        this.mNextInstallToken = token + 1;
        if (data != null) {
            this.mRunningInstalls.put(token, data);
        } else if (DEBUG_INSTALL) {
            Log.v(TAG, "No post-install required for " + token);
        }
        if (DEBUG_INSTALL) {
            Log.v(TAG, "+ starting restore round-trip " + token);
        }
        if (res.returnCode != 1 || !doRestore) {
            userId2 = userId;
        } else {
            IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
            if (bm != null) {
                if (userId == -1) {
                    userId3 = 0;
                } else {
                    userId3 = userId;
                }
                if (DEBUG_INSTALL) {
                    Log.v(TAG, "token " + token + " to BM for possible restore for user " + userId3);
                }
                Trace.asyncTraceBegin(262144, "restore", token);
                try {
                    if (bm.isBackupServiceActive(userId3)) {
                        bm.restoreAtInstallForUser(userId3, res.pkg.applicationInfo.packageName, token);
                    } else {
                        doRestore = false;
                    }
                } catch (RemoteException e) {
                } catch (Exception e2) {
                    Slog.e(TAG, "Exception trying to enqueue restore", e2);
                    doRestore = false;
                }
                userId2 = userId3;
            } else {
                Slog.e(TAG, "Backup Manager not found!");
                doRestore = false;
                userId2 = userId;
            }
        }
        if (res.returnCode != 1 || doRestore || !update) {
            j = 262144;
        } else {
            IRollbackManager rm = IRollbackManager.Stub.asInterface(ServiceManager.getService("rollback"));
            String packageName = res.pkg.applicationInfo.packageName;
            String seInfo = res.pkg.applicationInfo.seInfo;
            int[] allUsers = sUserManager.getUserIds();
            synchronized (this.mSettings) {
                try {
                    PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                    if (ps != null) {
                        try {
                            appId = ps.appId;
                            ceDataInode = ps.getCeDataInode(userId2);
                        } catch (Throwable th2) {
                            th = th2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                            throw th;
                        }
                    } else {
                        appId = -1;
                        ceDataInode = -1;
                    }
                    try {
                        installedUsers = ps.queryInstalledUsers(allUsers, true);
                        try {
                        } catch (Throwable th4) {
                            th = th4;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } catch (Throwable th5) {
                        th = th5;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                } catch (Throwable th6) {
                    th = th6;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
            j = 262144;
            try {
                rm.snapshotAndRestoreUserData(packageName, installedUsers, appId, ceDataInode, seInfo, token);
            } catch (RemoteException e3) {
            }
            doRestore = true;
        }
        if (!doRestore) {
            if (DEBUG_INSTALL) {
                Log.v(TAG, "No restore - queue post-install for " + token);
            }
            Trace.asyncTraceBegin(j, "postInstall", token);
            this.mHandler.sendMessage(this.mHandler.obtainMessage(9, token, 0));
        }
    }

    /* access modifiers changed from: package-private */
    public void notifyFirstLaunch(String packageName, String installerPackage, int userId) {
        this.mHandler.post(new Runnable(packageName, userId, installerPackage) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$LCewegvIGIYPuh6ueP6h4bqmSos */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ String f$3;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$notifyFirstLaunch$17$PackageManagerService(this.f$1, this.f$2, this.f$3);
            }
        });
    }

    public /* synthetic */ void lambda$notifyFirstLaunch$17$PackageManagerService(String packageName, int userId, String installerPackage) {
        for (int i = 0; i < this.mRunningInstalls.size(); i++) {
            PostInstallData data = this.mRunningInstalls.valueAt(i);
            if (data.res.returnCode == 1 && packageName.equals(data.res.pkg.applicationInfo.packageName)) {
                for (int uIndex = 0; uIndex < data.res.newUsers.length; uIndex++) {
                    if (userId == data.res.newUsers[uIndex]) {
                        if (DEBUG_BACKUP) {
                            Slog.i(TAG, "Package " + packageName + " being restored so deferring FIRST_LAUNCH");
                            return;
                        } else {
                            return;
                        }
                    }
                }
                continue;
            }
        }
        if (DEBUG_BACKUP) {
            Slog.i(TAG, "Package " + packageName + " sending normal FIRST_LAUNCH");
        }
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendFirstLaunchBroadcast(packageName, installerPackage, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    private void sendFirstLaunchBroadcast(String pkgName, String installerPkg, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast("android.intent.action.PACKAGE_FIRST_LAUNCH", pkgName, null, 0, installerPkg, null, userIds, instantUserIds);
    }

    /* access modifiers changed from: private */
    public abstract class HandlerParams {
        private final UserHandle mUser;
        int traceCookie;
        String traceMethod;

        /* access modifiers changed from: package-private */
        public abstract void handleReturnCode();

        /* access modifiers changed from: package-private */
        public abstract void handleStartCopy();

        HandlerParams(UserHandle user) {
            this.mUser = user;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getRollbackUser() {
            if (this.mUser == UserHandle.ALL) {
                return UserHandle.SYSTEM;
            }
            return this.mUser;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceMethod(String traceMethod2) {
            this.traceMethod = traceMethod2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public HandlerParams setTraceCookie(int traceCookie2) {
            this.traceCookie = traceCookie2;
            return this;
        }

        /* access modifiers changed from: package-private */
        public final void startCopy() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.i(PackageManagerService.TAG, "startCopy " + this.mUser + ": " + this);
            }
            handleStartCopy();
            handleReturnCode();
        }
    }

    /* access modifiers changed from: package-private */
    public static class OriginInfo {
        final boolean existing;
        final File file;
        final File resolvedFile;
        final String resolvedPath;
        final boolean staged;

        static OriginInfo fromNothing() {
            return new OriginInfo(null, false, false);
        }

        static OriginInfo fromUntrustedFile(File file2) {
            return new OriginInfo(file2, false, false);
        }

        static OriginInfo fromExistingFile(File file2) {
            return new OriginInfo(file2, false, true);
        }

        static OriginInfo fromStagedFile(File file2) {
            return new OriginInfo(file2, true, false);
        }

        private OriginInfo(File file2, boolean staged2, boolean existing2) {
            this.file = file2;
            this.staged = staged2;
            this.existing = existing2;
            if (file2 != null) {
                this.resolvedPath = file2.getAbsolutePath();
                this.resolvedFile = file2;
                return;
            }
            this.resolvedPath = null;
            this.resolvedFile = null;
        }
    }

    /* access modifiers changed from: package-private */
    public static class MoveInfo {
        final int appId;
        final String dataAppName;
        final String fromUuid;
        final int moveId;
        final String packageName;
        final String seinfo;
        final int targetSdkVersion;
        final String toUuid;

        public MoveInfo(int moveId2, String fromUuid2, String toUuid2, String packageName2, String dataAppName2, int appId2, String seinfo2, int targetSdkVersion2) {
            this.moveId = moveId2;
            this.fromUuid = fromUuid2;
            this.toUuid = toUuid2;
            this.packageName = packageName2;
            this.dataAppName = dataAppName2;
            this.appId = appId2;
            this.seinfo = seinfo2;
            this.targetSdkVersion = targetSdkVersion2;
        }
    }

    /* access modifiers changed from: package-private */
    public static class VerificationInfo {
        public static final int NO_UID = -1;
        final int installerUid;
        final int originatingUid;
        final Uri originatingUri;
        final Uri referrer;

        VerificationInfo(Uri originatingUri2, Uri referrer2, int originatingUid2, int installerUid2) {
            this.originatingUri = originatingUri2;
            this.referrer = referrer2;
            this.originatingUid = originatingUid2;
            this.installerUid = installerUid2;
        }
    }

    /* access modifiers changed from: package-private */
    public class MultiPackageInstallParams extends HandlerParams {
        private final ArrayList<InstallParams> mChildParams;
        private final Map<InstallArgs, Integer> mCurrentState;
        private int mRet = 1;

        MultiPackageInstallParams(UserHandle user, List<ActiveInstallSession> activeInstallSessions) throws PackageManagerException {
            super(user);
            if (activeInstallSessions.size() != 0) {
                this.mChildParams = new ArrayList<>(activeInstallSessions.size());
                for (int i = 0; i < activeInstallSessions.size(); i++) {
                    InstallParams childParams = new InstallParams(activeInstallSessions.get(i));
                    childParams.mParentInstallParams = this;
                    this.mChildParams.add(childParams);
                }
                this.mCurrentState = new ArrayMap(this.mChildParams.size());
                return;
            }
            throw new PackageManagerException("No child sessions found!");
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleStartCopy();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            Iterator<InstallParams> it = this.mChildParams.iterator();
            while (it.hasNext()) {
                InstallParams params = it.next();
                params.handleReturnCode();
                if (params.mRet != 1) {
                    this.mRet = params.mRet;
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void tryProcessInstallRequest(InstallArgs args, int currentStatus) {
            boolean z;
            this.mCurrentState.put(args, Integer.valueOf(currentStatus));
            if (this.mCurrentState.size() == this.mChildParams.size()) {
                int completeStatus = 1;
                Iterator<Integer> it = this.mCurrentState.values().iterator();
                while (true) {
                    z = true;
                    if (!it.hasNext()) {
                        break;
                    }
                    Integer status = it.next();
                    if (status.intValue() != 0) {
                        if (status.intValue() != 1) {
                            completeStatus = status.intValue();
                            break;
                        }
                    } else {
                        return;
                    }
                }
                List<InstallRequest> installRequests = new ArrayList<>(this.mCurrentState.size());
                for (Map.Entry<InstallArgs, Integer> entry : this.mCurrentState.entrySet()) {
                    installRequests.add(new InstallRequest(entry.getKey(), PackageManagerService.this.createPackageInstalledInfo(completeStatus)));
                }
                PackageManagerService packageManagerService = PackageManagerService.this;
                if (completeStatus != 1) {
                    z = false;
                }
                packageManagerService.processInstallRequestsAsync(z, installRequests);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public class InstallParams extends HandlerParams {
        final List<String> addSplitList;
        final int dexOptPolicy;
        final String[] grantedRuntimePermissions;
        final int hwInstallFlags;
        int installFlags;
        final int installReason;
        final String installerPackageName;
        private InstallArgs mArgs;
        private boolean mEnableRollbackCompleted;
        MultiPackageInstallParams mParentInstallParams;
        int mRet;
        private boolean mVerificationCompleted;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        final String packageAbiOverride;
        final List<String> removeSplitList;
        final long requiredInstalledVersionCode;
        final PackageParser.SigningDetails signingDetails;
        final VerificationInfo verificationInfo;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        InstallParams(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, VerificationInfo verificationInfo2, UserHandle user, String packageAbiOverride2, String[] grantedPermissions, List<String> whitelistedRestrictedPermissions2, PackageParser.SigningDetails signingDetails2, int installReason2, long requiredInstalledVersionCode2) {
            super(user);
            this.origin = origin2;
            this.move = move2;
            this.observer = observer2;
            this.installFlags = installFlags2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.verificationInfo = verificationInfo2;
            this.packageAbiOverride = packageAbiOverride2;
            this.grantedRuntimePermissions = grantedPermissions;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.requiredInstalledVersionCode = requiredInstalledVersionCode2;
            this.removeSplitList = null;
            this.addSplitList = null;
            this.hwInstallFlags = 0;
            this.dexOptPolicy = 0;
        }

        InstallParams(ActiveInstallSession activeInstallSession) {
            super(activeInstallSession.getUser());
            if (PackageManagerService.DEBUG_INSTANT && (activeInstallSession.getSessionParams().installFlags & 2048) != 0) {
                Slog.d(PackageManagerService.TAG, "Ephemeral install of " + activeInstallSession.getPackageName());
            }
            this.verificationInfo = new VerificationInfo(activeInstallSession.getSessionParams().originatingUri, activeInstallSession.getSessionParams().referrerUri, activeInstallSession.getSessionParams().originatingUid, activeInstallSession.getInstallerUid());
            this.origin = OriginInfo.fromStagedFile(activeInstallSession.getStagedDir());
            this.move = null;
            this.installReason = PackageManagerService.this.fixUpInstallReason(activeInstallSession.getInstallerPackageName(), activeInstallSession.getInstallerUid(), activeInstallSession.getSessionParams().installReason);
            this.observer = activeInstallSession.getObserver();
            this.installFlags = activeInstallSession.getSessionParams().installFlags;
            this.installerPackageName = activeInstallSession.getInstallerPackageName();
            this.volumeUuid = activeInstallSession.getSessionParams().volumeUuid;
            this.packageAbiOverride = activeInstallSession.getSessionParams().abiOverride;
            this.grantedRuntimePermissions = activeInstallSession.getSessionParams().grantedRuntimePermissions;
            this.whitelistedRestrictedPermissions = activeInstallSession.getSessionParams().whitelistedRestrictedPermissions;
            this.signingDetails = activeInstallSession.getSigningDetails();
            this.requiredInstalledVersionCode = activeInstallSession.getSessionParams().requiredInstalledVersionCode;
            this.removeSplitList = activeInstallSession.getSessionParams().removeSplitList;
            this.addSplitList = activeInstallSession.getSessionParams().addSplitList;
            this.hwInstallFlags = activeInstallSession.getSessionParams().hwInstallFlags;
            this.dexOptPolicy = activeInstallSession.getSessionParams().dexOptPolicy;
        }

        public String toString() {
            return "InstallParams{" + Integer.toHexString(System.identityHashCode(this)) + " file=" + this.origin.file + "}";
        }

        private int installLocationPolicy(PackageInfoLite pkgLite) {
            PackageSetting ps;
            String packageName = pkgLite.packageName;
            int installLocation = pkgLite.installLocation;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package installedPkg = PackageManagerService.this.mPackages.get(packageName);
                PackageParser.Package dataOwnerPkg = installedPkg;
                if (dataOwnerPkg == null && (ps = PackageManagerService.this.mSettings.mPackages.get(packageName)) != null) {
                    dataOwnerPkg = ps.pkg;
                }
                if (this.requiredInstalledVersionCode != -1) {
                    if (dataOwnerPkg == null) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but package is not installed");
                        return -8;
                    } else if (dataOwnerPkg.getLongVersionCode() != this.requiredInstalledVersionCode) {
                        Slog.w(PackageManagerService.TAG, "Required installed version code was " + this.requiredInstalledVersionCode + " but actual installed version is " + dataOwnerPkg.getLongVersionCode());
                        return -8;
                    }
                }
                if (dataOwnerPkg != null && !PackageManagerServiceUtils.isDowngradePermitted(this.installFlags, dataOwnerPkg.applicationInfo.flags)) {
                    try {
                        PackageManagerService.checkDowngrade(dataOwnerPkg, pkgLite);
                    } catch (PackageManagerException e) {
                        Slog.w(PackageManagerService.TAG, "Downgrade detected: " + e.getMessage());
                        return -7;
                    }
                }
                if (installedPkg != null) {
                    if ((this.installFlags & 2) == 0) {
                        return -4;
                    }
                    if ((installedPkg.applicationInfo.flags & 1) != 0) {
                        return 1;
                    }
                    if (installLocation == 1) {
                        return 1;
                    }
                    if (installLocation != 2) {
                        if (PackageManagerService.isExternal(installedPkg)) {
                            return 2;
                        }
                        return 1;
                    }
                }
                return pkgLite.recommendedInstallLocation;
            }
        }

        /* JADX WARNING: Removed duplicated region for block: B:137:0x03c2  */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleStartCopy() {
            UserHandle verifierUser;
            int requiredUid;
            int[] installedUsers;
            int ret;
            int ret2 = 1;
            if (this.origin.staged) {
                if (this.origin.file != null) {
                    this.installFlags |= 16;
                } else {
                    throw new IllegalStateException("Invalid stage location");
                }
            }
            boolean onInt = (this.installFlags & 16) != 0;
            boolean ephemeral = (this.installFlags & 2048) != 0;
            PackageInfoLite pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
            if (PackageManagerService.DEBUG_INSTANT && ephemeral) {
                Slog.v(PackageManagerService.TAG, "pkgLite for install: " + pkgLite);
            }
            if (!this.origin.staged && pkgLite.recommendedInstallLocation == -1) {
                long lowThreshold = StorageManager.from(PackageManagerService.this.mContext).getStorageLowBytes(Environment.getDataDirectory());
                long sizeBytes = PackageManagerServiceUtils.calculateInstalledSize(this.origin.resolvedPath, this.packageAbiOverride);
                if (sizeBytes >= 0) {
                    try {
                        PackageManagerService.this.mInstaller.freeCache(null, sizeBytes + lowThreshold, 0, 0);
                        pkgLite = PackageManagerServiceUtils.getMinimalPackageInfo(PackageManagerService.this.mContext, this.origin.resolvedPath, this.installFlags, this.packageAbiOverride);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, "Failed to free cache", e);
                    }
                }
                if (pkgLite.recommendedInstallLocation == -6) {
                    pkgLite.recommendedInstallLocation = -1;
                }
            }
            if (PackageManagerService.mHwPMSEx.isOldPackageNameCanNotInstall(pkgLite.packageName)) {
                Slog.i(PackageManagerService.TAG, pkgLite.packageName + " is the old package name and can not install.");
                ret2 = -5;
            }
            if (ret2 == 1) {
                int loc = pkgLite.recommendedInstallLocation;
                if (loc == -3) {
                    ret2 = -19;
                } else if (loc == -4) {
                    ret2 = -1;
                } else if (loc == -1) {
                    ret2 = -4;
                } else if (loc == -2) {
                    ret2 = -2;
                } else if (loc == -6) {
                    ret2 = -3;
                } else if (loc == -5) {
                    ret2 = -20;
                } else {
                    int loc2 = installLocationPolicy(pkgLite);
                    if (loc2 == -7) {
                        ret2 = -25;
                    } else if (loc2 == -8) {
                        ret2 = -121;
                    } else if (!onInt) {
                        if (loc2 == 2) {
                            this.installFlags &= -17;
                        } else if (loc2 == 3) {
                            if (PackageManagerService.DEBUG_INSTANT) {
                                Slog.v(PackageManagerService.TAG, "...setting INSTALL_EPHEMERAL install flag");
                            }
                            this.installFlags |= 2048;
                            this.installFlags &= -17;
                        } else {
                            this.installFlags |= 16;
                        }
                    }
                }
            }
            InstallArgs args = PackageManagerService.this.createInstallArgs(this);
            this.mVerificationCompleted = true;
            this.mEnableRollbackCompleted = true;
            this.mArgs = args;
            PackageManagerService.mHwPMSEx.verifyPackageSecurityPolicy(pkgLite.packageName, this.origin.file);
            if (ret2 == 1) {
                UserHandle verifierUser2 = getUser();
                if (verifierUser2.equals(UserHandle.ALL)) {
                    verifierUser = UserHandle.SYSTEM;
                } else {
                    verifierUser = verifierUser2;
                }
                if (PackageManagerService.this.mRequiredVerifierPackage == null) {
                    requiredUid = -1;
                } else {
                    PackageManagerService packageManagerService = PackageManagerService.this;
                    requiredUid = packageManagerService.getPackageUid(packageManagerService.mRequiredVerifierPackage, 268435456, verifierUser.getIdentifier());
                }
                VerificationInfo verificationInfo2 = this.verificationInfo;
                int installerUid = verificationInfo2 == null ? -1 : verificationInfo2.installerUid;
                Slog.d(PackageManagerService.TAG, "VerifierPackage requiredUid:" + requiredUid);
                boolean isDisableAppVerify = (this.mArgs.hwInstallFlags & 4) != 0;
                if (isDisableAppVerify) {
                    Slog.i(PackageManagerService.TAG, "package:" + pkgLite.packageName + ",install disable app verify");
                }
                if (this.origin.existing || requiredUid == -1 || isDisableAppVerify) {
                    ret = ret2;
                } else if (PackageManagerService.this.isVerificationEnabled(verifierUser.getIdentifier(), this.installFlags, installerUid)) {
                    Intent verification = new Intent("android.intent.action.PACKAGE_NEEDS_VERIFICATION");
                    verification.addFlags(268435456);
                    verification.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                    verification.addFlags(1);
                    List<ResolveInfo> receivers = PackageManagerService.this.queryIntentReceiversInternal(verification, PackageManagerService.PACKAGE_MIME_TYPE, 0, verifierUser.getIdentifier(), false);
                    if (PackageManagerService.DEBUG_VERIFY) {
                        Slog.d(PackageManagerService.TAG, "Found " + receivers.size() + " verifiers for intent " + verification.toString() + " with " + pkgLite.verifiers.length + " optional verifiers");
                    }
                    final int verificationId = PackageManagerService.access$3408(PackageManagerService.this);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_ID", verificationId);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_PACKAGE", this.installerPackageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALL_FLAGS", this.installFlags);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_PACKAGE_NAME", pkgLite.packageName);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_VERSION_CODE", pkgLite.versionCode);
                    verification.putExtra("android.content.pm.extra.VERIFICATION_LONG_VERSION_CODE", pkgLite.getLongVersionCode());
                    VerificationInfo verificationInfo3 = this.verificationInfo;
                    if (verificationInfo3 != null) {
                        if (verificationInfo3.originatingUri != null) {
                            verification.putExtra("android.intent.extra.ORIGINATING_URI", this.verificationInfo.originatingUri);
                        }
                        if (this.verificationInfo.referrer != null) {
                            verification.putExtra("android.intent.extra.REFERRER", this.verificationInfo.referrer);
                        }
                        if (this.verificationInfo.originatingUid >= 0) {
                            verification.putExtra("android.intent.extra.ORIGINATING_UID", this.verificationInfo.originatingUid);
                        }
                        if (this.verificationInfo.installerUid >= 0) {
                            verification.putExtra("android.content.pm.extra.VERIFICATION_INSTALLER_UID", this.verificationInfo.installerUid);
                        }
                    }
                    PackageVerificationState verificationState = new PackageVerificationState(requiredUid, this);
                    PackageManagerService.this.mPendingVerification.append(verificationId, verificationState);
                    List<ComponentName> sufficientVerifiers = PackageManagerService.this.matchVerifiers(pkgLite, receivers, verificationState);
                    DeviceIdleController.LocalService idleController = PackageManagerService.this.getDeviceIdleController();
                    long idleDuration = PackageManagerService.this.getVerificationTimeout();
                    if (sufficientVerifiers != null) {
                        int N = sufficientVerifiers.size();
                        if (N == 0) {
                            Slog.i(PackageManagerService.TAG, "Additional verifiers required, but none installed.");
                            ret2 = -22;
                            PackageManagerService packageManagerService2 = PackageManagerService.this;
                            ComponentName requiredVerifierComponent = packageManagerService2.matchComponentForVerifier(packageManagerService2.mRequiredVerifierPackage, receivers);
                            if (ret2 != 1 && PackageManagerService.this.mRequiredVerifierPackage != null) {
                                Trace.asyncTraceBegin(262144, "verification", verificationId);
                                verification.setComponent(requiredVerifierComponent);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), PackageManagerService.this.mRequiredVerifierPackage, idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(verification, verifierUser, "android.permission.PACKAGE_VERIFICATION_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass1 */

                                    @Override // android.content.BroadcastReceiver
                                    public void onReceive(Context context, Intent intent) {
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(16);
                                        msg.arg1 = verificationId;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, PackageManagerService.this.getVerificationTimeout());
                                    }
                                }, null, 0, null, null);
                                this.mVerificationCompleted = false;
                            }
                            if ((this.installFlags & 262144) != 0) {
                                final int enableRollbackToken = PackageManagerService.access$3708(PackageManagerService.this);
                                Trace.asyncTraceBegin(262144, "enable_rollback", enableRollbackToken);
                                PackageManagerService.this.mPendingEnableRollback.append(enableRollbackToken, this);
                                synchronized (PackageManagerService.this.mPackages) {
                                    PackageSetting ps = PackageManagerService.this.mSettings.getPackageLPr(pkgLite.packageName);
                                    if (ps != null) {
                                        installedUsers = ps.queryInstalledUsers(PackageManagerService.sUserManager.getUserIds(), true);
                                    } else {
                                        installedUsers = new int[0];
                                    }
                                }
                                Intent enableRollbackIntent = new Intent("android.intent.action.PACKAGE_ENABLE_ROLLBACK");
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_TOKEN", enableRollbackToken);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALL_FLAGS", this.installFlags);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_INSTALLED_USERS", installedUsers);
                                enableRollbackIntent.putExtra("android.content.pm.extra.ENABLE_ROLLBACK_USER", getRollbackUser().getIdentifier());
                                enableRollbackIntent.setDataAndType(Uri.fromFile(new File(this.origin.resolvedPath)), PackageManagerService.PACKAGE_MIME_TYPE);
                                enableRollbackIntent.addFlags(1);
                                enableRollbackIntent.addFlags(DumpState.DUMP_HANDLE);
                                PackageManagerService.this.mContext.sendOrderedBroadcastAsUser(enableRollbackIntent, UserHandle.SYSTEM, "android.permission.PACKAGE_ROLLBACK_AGENT", new BroadcastReceiver() {
                                    /* class com.android.server.pm.PackageManagerService.InstallParams.AnonymousClass2 */

                                    @Override // android.content.BroadcastReceiver
                                    public void onReceive(Context context, Intent intent) {
                                        long rollbackTimeout = DeviceConfig.getLong("rollback", PackageManagerService.PROPERTY_ENABLE_ROLLBACK_TIMEOUT_MILLIS, (long) JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
                                        if (rollbackTimeout < 0) {
                                            rollbackTimeout = JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY;
                                        }
                                        Message msg = PackageManagerService.this.mHandler.obtainMessage(22);
                                        msg.arg1 = enableRollbackToken;
                                        PackageManagerService.this.mHandler.sendMessageDelayed(msg, rollbackTimeout);
                                    }
                                }, null, 0, null, null);
                                this.mEnableRollbackCompleted = false;
                            }
                        } else {
                            int i = 0;
                            while (i < N) {
                                ComponentName verifierComponent = sufficientVerifiers.get(i);
                                idleController.addPowerSaveTempWhitelistApp(Process.myUid(), verifierComponent.getPackageName(), idleDuration, verifierUser.getIdentifier(), false, "package verifier");
                                Intent sufficientIntent = new Intent(verification);
                                sufficientIntent.setComponent(verifierComponent);
                                PackageManagerService.this.mContext.sendBroadcastAsUser(sufficientIntent, verifierUser);
                                i++;
                                N = N;
                            }
                        }
                    }
                    ret2 = ret2;
                    PackageManagerService packageManagerService22 = PackageManagerService.this;
                    ComponentName requiredVerifierComponent2 = packageManagerService22.matchComponentForVerifier(packageManagerService22.mRequiredVerifierPackage, receivers);
                    if (ret2 != 1) {
                    }
                    if ((this.installFlags & 262144) != 0) {
                    }
                } else {
                    ret = ret2;
                }
                ret2 = ret;
                if ((this.installFlags & 262144) != 0) {
                }
            }
            this.mRet = ret2;
        }

        /* access modifiers changed from: package-private */
        public void setReturnCode(int ret) {
            if (this.mRet == 1) {
                this.mRet = ret;
            }
        }

        /* access modifiers changed from: package-private */
        public void handleVerificationFinished() {
            this.mVerificationCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        public void handleRollbackEnabled() {
            this.mEnableRollbackCompleted = true;
            handleReturnCode();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.HandlerParams
        public void handleReturnCode() {
            if (this.mVerificationCompleted && this.mEnableRollbackCompleted) {
                if ((this.installFlags & 8388608) != 0) {
                    String packageName = "";
                    try {
                        new PackageParser();
                        packageName = PackageParser.parsePackageLite(this.origin.file, 0).packageName;
                    } catch (PackageParser.PackageParserException e) {
                        Slog.e(PackageManagerService.TAG, "Can't parse package at " + this.origin.file.getAbsolutePath(), e);
                    }
                    try {
                        this.observer.onPackageInstalled(packageName, this.mRet, "Dry run", new Bundle());
                    } catch (RemoteException e2) {
                        Slog.i(PackageManagerService.TAG, "Observer no longer exists.");
                    }
                } else {
                    if (this.mRet == 1) {
                        this.mRet = this.mArgs.copyApk();
                    }
                    PackageManagerService.this.processPendingInstall(this.mArgs, this.mRet);
                }
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private InstallArgs createInstallArgs(InstallParams params) {
        if (params.move != null) {
            return new MoveInstallArgs(params);
        }
        return new FileInstallArgs(params);
    }

    private InstallArgs createInstallArgsForExisting(String codePath, String resourcePath, String[] instructionSets) {
        return new FileInstallArgs(codePath, resourcePath, instructionSets);
    }

    /* access modifiers changed from: package-private */
    public static abstract class InstallArgs {
        final String abiOverride;
        List<String> addSplitList;
        int dexOptPolicy;
        int hwInstallFlags;
        final int installFlags;
        final String[] installGrantPermissions;
        final int installReason;
        final String installerPackageName;
        String[] instructionSets;
        final MultiPackageInstallParams mMultiPackageInstallParams;
        final MoveInfo move;
        final IPackageInstallObserver2 observer;
        final OriginInfo origin;
        String packageName;
        int packageVersion;
        List<String> removeSplitList;
        final PackageParser.SigningDetails signingDetails;
        final int traceCookie;
        final String traceMethod;
        final UserHandle user;
        final String volumeUuid;
        final List<String> whitelistedRestrictedPermissions;

        /* access modifiers changed from: package-private */
        public abstract void cleanUpResourcesLI();

        /* access modifiers changed from: package-private */
        public abstract int copyApk();

        /* access modifiers changed from: package-private */
        public abstract boolean doPostDeleteLI(boolean z);

        /* access modifiers changed from: package-private */
        public abstract int doPostInstall(int i, int i2);

        /* access modifiers changed from: package-private */
        public abstract int doPreInstall(int i);

        /* access modifiers changed from: package-private */
        public abstract boolean doRename(int i, PackageParser.Package v);

        /* access modifiers changed from: package-private */
        public abstract String getCodePath();

        /* access modifiers changed from: package-private */
        public abstract String getResourcePath();

        InstallArgs(OriginInfo origin2, MoveInfo move2, IPackageInstallObserver2 observer2, int installFlags2, String installerPackageName2, String volumeUuid2, UserHandle user2, String[] instructionSets2, String abiOverride2, String[] installGrantPermissions2, List<String> whitelistedRestrictedPermissions2, String traceMethod2, int traceCookie2, PackageParser.SigningDetails signingDetails2, int installReason2, MultiPackageInstallParams multiPackageInstallParams) {
            this.origin = origin2;
            this.move = move2;
            this.installFlags = installFlags2;
            this.observer = observer2;
            this.installerPackageName = installerPackageName2;
            this.volumeUuid = volumeUuid2;
            this.user = user2;
            this.instructionSets = instructionSets2;
            this.abiOverride = abiOverride2;
            this.installGrantPermissions = installGrantPermissions2;
            this.whitelistedRestrictedPermissions = whitelistedRestrictedPermissions2;
            this.traceMethod = traceMethod2;
            this.traceCookie = traceCookie2;
            this.signingDetails = signingDetails2;
            this.installReason = installReason2;
            this.mMultiPackageInstallParams = multiPackageInstallParams;
        }

        /* access modifiers changed from: package-private */
        public int doPreCopy() {
            return 1;
        }

        /* access modifiers changed from: package-private */
        public int doPostCopy(int uid) {
            return 1;
        }

        /* access modifiers changed from: protected */
        public boolean isEphemeral() {
            return (this.installFlags & 2048) != 0;
        }

        /* access modifiers changed from: package-private */
        public UserHandle getUser() {
            return this.user;
        }
    }

    /* access modifiers changed from: package-private */
    public void removeDexFiles(List<String> allCodePaths, String[] instructionSets) {
        if (allCodePaths.isEmpty()) {
            return;
        }
        if (instructionSets != null) {
            String[] dexCodeInstructionSets = InstructionSets.getDexCodeInstructionSets(instructionSets);
            for (String codePath : allCodePaths) {
                for (String dexCodeInstructionSet : dexCodeInstructionSets) {
                    try {
                        this.mInstaller.rmdex(codePath, dexCodeInstructionSet);
                    } catch (Installer.InstallerException e) {
                    }
                }
            }
            return;
        }
        throw new IllegalStateException("instructionSet == null");
    }

    /* access modifiers changed from: package-private */
    public class FileInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        FileInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
            this.removeSplitList = params.removeSplitList;
            this.addSplitList = params.addSplitList;
            this.hwInstallFlags = params.hwInstallFlags;
            this.dexOptPolicy = params.dexOptPolicy;
        }

        FileInstallArgs(String codePath, String resourcePath, String[] instructionSets) {
            super(OriginInfo.fromNothing(), null, null, 0, null, null, null, instructionSets, null, null, null, null, 0, PackageParser.SigningDetails.UNKNOWN, 0, null);
            File file = null;
            this.codeFile = codePath != null ? new File(codePath) : null;
            this.resourceFile = resourcePath != null ? new File(resourcePath) : file;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            Trace.traceBegin(262144, "copyApk");
            try {
                return doCopyApk();
            } finally {
                Trace.traceEnd(262144);
            }
        }

        private int doCopyApk() {
            int ret;
            if (this.origin.staged) {
                if (PackageManagerService.DEBUG_INSTALL) {
                    Slog.d(PackageManagerService.TAG, this.origin.file + " already staged; skipping copy");
                }
                this.codeFile = this.origin.file;
                this.resourceFile = this.origin.file;
                return 1;
            }
            try {
                File tempDir = PackageManagerService.this.mInstallerService.allocateStageDirLegacy(this.volumeUuid, (this.installFlags & 2048) != 0);
                this.codeFile = tempDir;
                this.resourceFile = tempDir;
                int ret2 = PackageManagerServiceUtils.copyPackage(this.origin.file.getAbsolutePath(), this.codeFile);
                if (ret2 != 1) {
                    Slog.e(PackageManagerService.TAG, "Failed to copy package");
                    return ret2;
                }
                File libraryRoot = new File(this.codeFile, "lib");
                NativeLibraryHelper.Handle handle = null;
                try {
                    handle = NativeLibraryHelper.Handle.create(this.codeFile);
                    ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot, this.abiOverride);
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Copying native libraries failed", e);
                    ret = RequestStatus.SYS_ETIMEDOUT;
                } catch (Throwable th) {
                    IoUtils.closeQuietly(handle);
                    throw th;
                }
                IoUtils.closeQuietly(handle);
                return ret;
            } catch (IOException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to create copy file: " + e2);
                return -4;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp();
                return false;
            }
            File targetDir = this.codeFile.getParentFile();
            File beforeCodeFile = this.codeFile;
            File afterCodeFile = PackageManagerService.this.getNextCodePath(targetDir, pkg.packageName);
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Renaming " + beforeCodeFile + " to " + afterCodeFile);
            }
            try {
                Os.rename(beforeCodeFile.getAbsolutePath(), afterCodeFile.getAbsolutePath());
                if (!SELinux.restoreconRecursive(afterCodeFile)) {
                    Slog.i(PackageManagerService.TAG, "ignore restoreconRecursive error, pkg:" + pkg.packageName + ",hasPlugin:" + pkg.hasPlugin);
                }
                this.codeFile = afterCodeFile;
                this.resourceFile = afterCodeFile;
                try {
                    pkg.setCodePath(afterCodeFile.getCanonicalPath());
                    pkg.setBaseCodePath(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.baseCodePath));
                    pkg.setSplitCodePaths(FileUtils.rewriteAfterRename(beforeCodeFile, afterCodeFile, pkg.splitCodePaths));
                    pkg.setApplicationVolumeUuid(pkg.volumeUuid);
                    pkg.setApplicationInfoCodePath(pkg.codePath);
                    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
                    pkg.setApplicationInfoResourcePath(pkg.codePath);
                    pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
                    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
                    return true;
                } catch (IOException e) {
                    Slog.e(PackageManagerService.TAG, "Failed to get path: " + afterCodeFile, e);
                    return false;
                }
            } catch (ErrnoException e2) {
                Slog.w(PackageManagerService.TAG, "Failed to rename", e2);
                return false;
            }
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status != 1) {
                cleanUp();
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp() {
            File file = this.codeFile;
            if (file == null || !file.exists()) {
                return false;
            }
            PackageManagerService.this.removeCodePathLI(this.codeFile);
            File file2 = this.resourceFile;
            if (file2 == null || FileUtils.contains(this.codeFile, file2)) {
                return true;
            }
            this.resourceFile.delete();
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            List<String> allCodePaths = Collections.EMPTY_LIST;
            File file = this.codeFile;
            if (file != null && file.exists()) {
                try {
                    allCodePaths = PackageParser.parsePackageLite(this.codeFile, 0).getAllCodePaths();
                } catch (PackageParser.PackageParserException e) {
                }
            }
            cleanUp();
            PackageManagerService.this.removeDexFiles(allCodePaths, this.instructionSets);
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            cleanUpResourcesLI();
            return true;
        }
    }

    private static void maybeThrowExceptionForMultiArchCopy(String message, int copyRet) throws PackageManagerException {
        if (copyRet < 0 && copyRet != -114 && copyRet != -113) {
            throw new PackageManagerException(copyRet, message);
        }
    }

    /* access modifiers changed from: package-private */
    public class MoveInstallArgs extends InstallArgs {
        private File codeFile;
        private File resourceFile;

        MoveInstallArgs(InstallParams params) {
            super(params.origin, params.move, params.observer, params.installFlags, params.installerPackageName, params.volumeUuid, params.getUser(), null, params.packageAbiOverride, params.grantedRuntimePermissions, params.whitelistedRestrictedPermissions, params.traceMethod, params.traceCookie, params.signingDetails, params.installReason, params.mParentInstallParams);
            this.removeSplitList = params.removeSplitList;
            this.addSplitList = params.addSplitList;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int copyApk() {
            if (PackageManagerService.DEBUG_INSTALL) {
                Slog.d(PackageManagerService.TAG, "Moving " + this.move.packageName + " from " + this.move.fromUuid + " to " + this.move.toUuid);
            }
            synchronized (PackageManagerService.this.mInstaller) {
                try {
                    PackageManagerService.this.mInstaller.moveCompleteApp(this.move.fromUuid, this.move.toUuid, this.move.packageName, this.move.dataAppName, this.move.appId, this.move.seinfo, this.move.targetSdkVersion);
                } catch (Installer.InstallerException e) {
                    Slog.w(PackageManagerService.TAG, "Failed to move app", e);
                    return RequestStatus.SYS_ETIMEDOUT;
                }
            }
            this.codeFile = new File(Environment.getDataAppDirectory(this.move.toUuid), this.move.dataAppName);
            this.resourceFile = this.codeFile;
            if (!PackageManagerService.DEBUG_INSTALL) {
                return 1;
            }
            Slog.d(PackageManagerService.TAG, "codeFile after move is " + this.codeFile);
            return 1;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPreInstall(int status) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doRename(int status, PackageParser.Package pkg) {
            if (status != 1) {
                cleanUp(this.move.toUuid);
                return false;
            }
            pkg.setApplicationVolumeUuid(pkg.volumeUuid);
            pkg.setApplicationInfoCodePath(pkg.codePath);
            pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);
            pkg.setApplicationInfoResourcePath(pkg.codePath);
            pkg.setApplicationInfoBaseResourcePath(pkg.baseCodePath);
            pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public int doPostInstall(int status, int uid) {
            if (status == 1) {
                cleanUp(this.move.fromUuid);
            } else {
                PackageManagerService.mHwPMSEx.cleanUpHwCert();
                cleanUp(this.move.toUuid);
            }
            return status;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getCodePath() {
            File file = this.codeFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public String getResourcePath() {
            File file = this.resourceFile;
            if (file != null) {
                return file.getAbsolutePath();
            }
            return null;
        }

        private boolean cleanUp(String volumeUuid) {
            File codeFile2 = new File(Environment.getDataAppDirectory(volumeUuid), this.move.dataAppName);
            Slog.d(PackageManagerService.TAG, "Cleaning up " + this.move.packageName + " on " + volumeUuid);
            int[] userIds = PackageManagerService.sUserManager.getUserIds();
            synchronized (PackageManagerService.this.mInstallLock) {
                for (int userId : userIds) {
                    try {
                        PackageManagerService.this.mInstaller.destroyAppData(volumeUuid, this.move.packageName, userId, 3, 0);
                    } catch (Installer.InstallerException e) {
                        Slog.w(PackageManagerService.TAG, String.valueOf(e));
                    }
                }
                PackageManagerService.this.removeCodePathLI(codeFile2);
            }
            return true;
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public void cleanUpResourcesLI() {
            throw new UnsupportedOperationException();
        }

        /* access modifiers changed from: package-private */
        @Override // com.android.server.pm.PackageManagerService.InstallArgs
        public boolean doPostDeleteLI(boolean delete) {
            throw new UnsupportedOperationException();
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private File getNextCodePath(File targetDir, String packageName) {
        File result;
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[16];
        do {
            random.nextBytes(bytes);
            String suffix = Base64.encodeToString(bytes, 10);
            result = new File(targetDir, packageName + "-" + suffix);
        } while (result.exists());
        return result;
    }

    static String deriveCodePathName(String codePath) {
        if (codePath == null) {
            return null;
        }
        File codeFile = new File(codePath);
        String name = codeFile.getName();
        if (codeFile.isDirectory()) {
            return name;
        }
        if (name.endsWith(".apk") || name.endsWith(".tmp")) {
            return name.substring(0, name.lastIndexOf(46));
        }
        Slog.w(TAG, "Odd, " + codePath + " doesn't look like an APK");
        return null;
    }

    /* access modifiers changed from: package-private */
    public static class PackageInstalledInfo {
        ArrayMap<String, PackageInstalledInfo> addedChildPackages;
        String installerPackageName;
        String name;
        int[] newUsers;
        String origPackage;
        String origPermission;
        int[] origUsers;
        PackageParser.Package pkg;
        PackageRemovedInfo removedInfo;
        int returnCode;
        String returnMsg;
        int uid;

        PackageInstalledInfo() {
        }

        public void setError(int code, String msg) {
            setReturnCode(code);
            setReturnMessage(msg);
            Slog.w(PackageManagerService.TAG, msg);
        }

        public void setError(String msg, PackageParser.PackageParserException e) {
            setReturnCode(e.error);
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setError(String msg, PackageManagerException e) {
            this.returnCode = e.error;
            setReturnMessage(ExceptionUtils.getCompleteMessage(msg, e));
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).setError(msg, e);
            }
            Slog.w(PackageManagerService.TAG, msg, e);
        }

        public void setReturnCode(int returnCode2) {
            this.returnCode = returnCode2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnCode = returnCode2;
            }
        }

        private void setReturnMessage(String returnMsg2) {
            this.returnMsg = returnMsg2;
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.addedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.addedChildPackages.valueAt(i).returnMsg = returnMsg2;
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:10:0x0019, code lost:
        r2 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:11:0x001a, code lost:
        $closeResource(r1, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:12:0x001d, code lost:
        throw r2;
     */
    private static void updateDigest(MessageDigest digest, File file) throws IOException {
        DigestInputStream digestStream = new DigestInputStream(new FileInputStream(file), digest);
        do {
        } while (digestStream.read() != -1);
        $closeResource(null, digestStream);
    }

    private String getParentOrChildPackageChangedSharedUser(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        if (!Objects.equals(oldPkg.mSharedUserId, newPkg.mSharedUserId)) {
            return newPkg.packageName;
        }
        int newChildCount = 0;
        int oldChildCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        if (newPkg.childPackages != null) {
            newChildCount = newPkg.childPackages.size();
        }
        for (int i = 0; i < newChildCount; i++) {
            PackageParser.Package newChildPkg = (PackageParser.Package) newPkg.childPackages.get(i);
            for (int j = 0; j < oldChildCount; j++) {
                PackageParser.Package oldChildPkg = (PackageParser.Package) oldPkg.childPackages.get(j);
                if (newChildPkg.packageName.equals(oldChildPkg.packageName) && !Objects.equals(newChildPkg.mSharedUserId, oldChildPkg.mSharedUserId)) {
                    return newChildPkg.packageName;
                }
            }
        }
        return null;
    }

    private void removeNativeBinariesLI(PackageSetting ps) {
        PackageSetting childPs;
        if (ps != null) {
            NativeLibraryHelper.removeNativeBinariesLI(ps.legacyNativeLibraryPathString);
            int childCount = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
            for (int i = 0; i < childCount; i++) {
                synchronized (this.mPackages) {
                    childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i));
                }
                if (childPs != null) {
                    NativeLibraryHelper.removeNativeBinariesLI(childPs.legacyNativeLibraryPathString);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void enableSystemPackageLPw(PackageParser.Package pkg) {
        this.mSettings.enableSystemPackageLPw(pkg.packageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.enableSystemPackageLPw(((PackageParser.Package) pkg.childPackages.get(i)).packageName);
        }
    }

    @GuardedBy({"mPackages"})
    private boolean disableSystemPackageLPw(PackageParser.Package oldPkg, PackageParser.Package newPkg) {
        boolean disabled = this.mSettings.disableSystemPackageLPw(oldPkg.packageName, true);
        int childCount = oldPkg.childPackages != null ? oldPkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPkg = (PackageParser.Package) oldPkg.childPackages.get(i);
            disabled |= this.mSettings.disableSystemPackageLPw(childPkg.packageName, newPkg.hasChildPackage(childPkg.packageName));
        }
        return disabled;
    }

    @GuardedBy({"mPackages"})
    private void setInstallerPackageNameLPw(PackageParser.Package pkg, String installerPackageName) {
        this.mSettings.setInstallerPackageName(pkg.packageName, installerPackageName);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            this.mSettings.setInstallerPackageName(((PackageParser.Package) pkg.childPackages.get(i)).packageName, installerPackageName);
        }
    }

    /* access modifiers changed from: protected */
    public void updateSettingsLI(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsInternalLI(newPackage, installerPackageName, allUsers, res.origUsers, res, user, installReason);
        int childCount = newPackage.childPackages != null ? newPackage.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            PackageParser.Package childPackage = (PackageParser.Package) newPackage.childPackages.get(i);
            PackageInstalledInfo childRes = res.addedChildPackages.get(childPackage.packageName);
            updateSettingsInternalLI(childPackage, installerPackageName, allUsers, childRes.origUsers, childRes, user, installReason);
        }
    }

    private void updateSettingsInternalLI(PackageParser.Package pkg, String installerPackageName, int[] allUsers, int[] installedForUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        int i;
        boolean isUpdate;
        int origUserId;
        Trace.traceBegin(262144, "updateSettings");
        String pkgName = pkg.packageName;
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "New package installed in " + pkg.codePath);
        }
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                arrayMap = arrayMap2;
                try {
                    this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                    PackageSetting ps = this.mSettings.mPackages.get(pkgName);
                    boolean isUpdate2 = (res.removedInfo == null || res.removedInfo.removedPackage == null) ? false : true;
                    if (!isUpdate2 && ps != null) {
                        mHwPMSEx.updateUseSideMode(pkgName, ps);
                        mHwPMSEx.updateForceDarkMode(pkgName, ps);
                    }
                    if (!(ps == null || ps.pkg == null || ps.pkg.applicationInfo == null)) {
                        ps.pkg.applicationInfo.forceDarkMode = ps.forceDarkMode;
                        Slog.i(TAG, "applicationInfo.forceDarkMode of pkgName: " + pkgName + " is " + ps.pkg.applicationInfo.forceDarkMode);
                    }
                    HwPackageManagerServiceUtils.updateFlagsForMarketSystemApp(pkg);
                    int userId = user.getIdentifier();
                    if (ps != null) {
                        int i2 = -1;
                        if (isSystemApp(pkg)) {
                            if (DEBUG_INSTALL) {
                                Slog.d(TAG, "Implicitly enabling system package on upgrade: " + pkgName);
                            }
                            if (res.origUsers != null) {
                                int[] iArr = res.origUsers;
                                int length = iArr.length;
                                int i3 = 0;
                                while (i3 < length) {
                                    int origUserId2 = iArr[i3];
                                    if (userId != i2) {
                                        origUserId = origUserId2;
                                        if (userId != origUserId) {
                                            i3++;
                                            i2 = -1;
                                        }
                                    } else {
                                        origUserId = origUserId2;
                                    }
                                    ps.setEnabled(0, origUserId, installerPackageName);
                                    i3++;
                                    i2 = -1;
                                }
                            }
                            if (allUsers != null && installedForUsers != null) {
                                int length2 = allUsers.length;
                                int i4 = 0;
                                while (i4 < length2) {
                                    int currentUserId = allUsers[i4];
                                    boolean installed = ArrayUtils.contains(installedForUsers, currentUserId);
                                    if (DEBUG_INSTALL) {
                                        isUpdate = isUpdate2;
                                        StringBuilder sb = new StringBuilder();
                                        i = length2;
                                        sb.append("    user ");
                                        sb.append(currentUserId);
                                        sb.append(" => ");
                                        sb.append(installed);
                                        Slog.d(TAG, sb.toString());
                                    } else {
                                        isUpdate = isUpdate2;
                                        i = length2;
                                    }
                                    ps.setInstalled(installed, currentUserId);
                                    i4++;
                                    isUpdate2 = isUpdate;
                                    length2 = i;
                                }
                            }
                        }
                        if (userId != -1) {
                            ps.setInstalled(true, userId);
                            ps.setEnabled(0, userId, installerPackageName);
                        }
                        Set<Integer> previousUserIds = new ArraySet<>();
                        if (!(res.removedInfo == null || res.removedInfo.installReasons == null)) {
                            int installReasonCount = res.removedInfo.installReasons.size();
                            for (int i5 = 0; i5 < installReasonCount; i5++) {
                                int previousUserId = res.removedInfo.installReasons.keyAt(i5);
                                ps.setInstallReason(res.removedInfo.installReasons.valueAt(i5).intValue(), previousUserId);
                                previousUserIds.add(Integer.valueOf(previousUserId));
                            }
                        }
                        if (userId == -1) {
                            int[] userIds = sUserManager.getUserIds();
                            for (int currentUserId2 : userIds) {
                                if (!previousUserIds.contains(Integer.valueOf(currentUserId2))) {
                                    ps.setInstallReason(installReason, currentUserId2);
                                }
                            }
                        } else if (!previousUserIds.contains(Integer.valueOf(userId))) {
                            ps.setInstallReason(installReason, userId);
                        }
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                    res.name = pkgName;
                    res.uid = pkg.applicationInfo.uid;
                    res.pkg = pkg;
                    this.mSettings.setInstallerPackageName(pkgName, installerPackageName);
                    res.setReturnCode(1);
                    Trace.traceBegin(262144, "writeSettings");
                    this.mSettings.writeLPr();
                    Trace.traceEnd(262144);
                    Trace.traceEnd(262144);
                } catch (Throwable th2) {
                    th = th2;
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
                arrayMap = arrayMap2;
                throw th;
            }
        }
    }

    /* access modifiers changed from: private */
    public static class InstallRequest {
        public final InstallArgs args;
        public final PackageInstalledInfo installResult;

        private InstallRequest(InstallArgs args2, PackageInstalledInfo res) {
            this.args = args2;
            this.installResult = res;
        }
    }

    @GuardedBy({"mInstallLock", "mPackages"})
    private void installPackagesTracedLI(List<InstallRequest> requests) {
        try {
            Trace.traceBegin(262144, "installPackages");
            installPackagesLI(requests);
        } finally {
            Trace.traceEnd(262144);
        }
    }

    /* access modifiers changed from: private */
    public static class CommitRequest {
        final int[] mAllUsers;
        final Map<String, ReconciledPackage> reconciledPackages;

        private CommitRequest(Map<String, ReconciledPackage> reconciledPackages2, int[] allUsers) {
            this.reconciledPackages = reconciledPackages2;
            this.mAllUsers = allUsers;
        }
    }

    /* access modifiers changed from: private */
    public static class ReconcileRequest {
        public final Map<String, PackageParser.Package> allPackages;
        public final Map<String, InstallArgs> installArgs;
        public final Map<String, PackageInstalledInfo> installResults;
        public final Map<String, PackageSetting> lastStaticSharedLibSettings;
        public final Map<String, PrepareResult> preparedPackages;
        public final Map<String, ScanResult> scannedPackages;
        public final Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource;
        public final Map<String, Settings.VersionInfo> versionInfos;

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, InstallArgs> installArgs2, Map<String, PackageInstalledInfo> installResults2, Map<String, PrepareResult> preparedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this.scannedPackages = scannedPackages2;
            this.installArgs = installArgs2;
            this.installResults = installResults2;
            this.preparedPackages = preparedPackages2;
            this.sharedLibrarySource = sharedLibrarySource2;
            this.allPackages = allPackages2;
            this.versionInfos = versionInfos2;
            this.lastStaticSharedLibSettings = lastStaticSharedLibSettings2;
        }

        private ReconcileRequest(Map<String, ScanResult> scannedPackages2, Map<String, LongSparseArray<SharedLibraryInfo>> sharedLibrarySource2, Map<String, PackageParser.Package> allPackages2, Map<String, Settings.VersionInfo> versionInfos2, Map<String, PackageSetting> lastStaticSharedLibSettings2) {
            this(scannedPackages2, Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), sharedLibrarySource2, allPackages2, versionInfos2, lastStaticSharedLibSettings2);
        }
    }

    /* access modifiers changed from: private */
    public static class ReconcileFailure extends PackageManagerException {
        ReconcileFailure(String message) {
            super("Reconcile failed: " + message);
        }

        ReconcileFailure(int reason, String message) {
            super(reason, "Reconcile failed: " + message);
        }

        ReconcileFailure(PackageManagerException e) {
            this(e.error, e.getMessage());
        }
    }

    /* access modifiers changed from: private */
    public static class ReconciledPackage {
        public final List<SharedLibraryInfo> allowedSharedLibraryInfos;
        public ArrayList<SharedLibraryInfo> collectedSharedLibraryInfos;
        public final DeletePackageAction deletePackageAction;
        public final InstallArgs installArgs;
        public final PackageInstalledInfo installResult;
        public final PackageSetting pkgSetting;
        public final PrepareResult prepareResult;
        public final boolean removeAppKeySetData;
        public final ReconcileRequest request;
        public final ScanResult scanResult;
        public final boolean sharedUserSignaturesChanged;
        public final PackageParser.SigningDetails signingDetails;

        private ReconciledPackage(ReconcileRequest request2, InstallArgs installArgs2, PackageSetting pkgSetting2, PackageInstalledInfo installResult2, PrepareResult prepareResult2, ScanResult scanResult2, DeletePackageAction deletePackageAction2, List<SharedLibraryInfo> allowedSharedLibraryInfos2, PackageParser.SigningDetails signingDetails2, boolean sharedUserSignaturesChanged2, boolean removeAppKeySetData2) {
            this.request = request2;
            this.installArgs = installArgs2;
            this.pkgSetting = pkgSetting2;
            this.installResult = installResult2;
            this.prepareResult = prepareResult2;
            this.scanResult = scanResult2;
            this.deletePackageAction = deletePackageAction2;
            this.allowedSharedLibraryInfos = allowedSharedLibraryInfos2;
            this.signingDetails = signingDetails2;
            this.sharedUserSignaturesChanged = sharedUserSignaturesChanged2;
            this.removeAppKeySetData = removeAppKeySetData2;
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private Map<String, PackageParser.Package> getCombinedPackages() {
            ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(this.request.allPackages.size() + this.request.scannedPackages.size());
            combinedPackages.putAll(this.request.allPackages);
            for (ScanResult scanResult2 : this.request.scannedPackages.values()) {
                combinedPackages.put(scanResult2.pkgSetting.name, scanResult2.request.pkg);
            }
            return combinedPackages;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:131:0x032b A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:88:0x0245  */
    @GuardedBy({"mPackages"})
    private static Map<String, ReconciledPackage> reconcilePackagesLocked(ReconcileRequest request, KeySetManagerService ksms) throws ReconcileFailure {
        PackageManagerException e;
        DeletePackageAction deletePackageAction;
        PackageSetting signatureCheckPs;
        PackageSetting disabledPkgSetting;
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries;
        PackageParser.SigningDetails signingDetails;
        PackageManagerException e2;
        IllegalArgumentException e3;
        KeySetManagerService keySetManagerService = ksms;
        Map<String, ScanResult> scannedPackages = request.scannedPackages;
        Map<String, ReconciledPackage> result = new ArrayMap<>(scannedPackages.size());
        ArrayMap<String, PackageParser.Package> combinedPackages = new ArrayMap<>(request.allPackages.size() + scannedPackages.size());
        combinedPackages.putAll(request.allPackages);
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries2 = new ArrayMap<>();
        for (String installPackageName : scannedPackages.keySet()) {
            ScanResult scanResult = scannedPackages.get(installPackageName);
            combinedPackages.put(scanResult.pkgSetting.name, scanResult.request.pkg);
            List<SharedLibraryInfo> allowedSharedLibInfos = getAllowedSharedLibInfos(scanResult, request.sharedLibrarySource);
            SharedLibraryInfo staticLib = scanResult.staticSharedLibraryInfo;
            if (allowedSharedLibInfos != null) {
                for (SharedLibraryInfo info : allowedSharedLibInfos) {
                    if (!addSharedLibraryToPackageVersionMap(incomingSharedLibraries2, info)) {
                        throw new ReconcileFailure("Static Shared Library " + staticLib.getName() + " is being installed twice in this set!");
                    }
                }
            }
            InstallArgs installArgs = request.installArgs.get(installPackageName);
            PackageInstalledInfo res = request.installResults.get(installPackageName);
            PrepareResult prepareResult = request.preparedPackages.get(installPackageName);
            boolean isInstall = installArgs != null;
            if (!isInstall || !(res == null || prepareResult == null)) {
                if (!isInstall || !prepareResult.replace || prepareResult.system) {
                    deletePackageAction = null;
                } else {
                    DeletePackageAction deletePackageAction2 = mayDeletePackageLocked(res.removedInfo, prepareResult.originalPs, prepareResult.disabledPs, prepareResult.childPackageSettings, 1 | ((scanResult.request.scanFlags & 2048) == 0 ? 0 : 8), null);
                    if (deletePackageAction2 != null) {
                        deletePackageAction = deletePackageAction2;
                    } else {
                        throw new ReconcileFailure(-10, "May not delete " + installPackageName + " to replace");
                    }
                }
                int scanFlags = scanResult.request.scanFlags;
                int parseFlags = scanResult.request.parseFlags;
                PackageParser.Package pkg = scanResult.request.pkg;
                PackageSetting disabledPkgSetting2 = scanResult.request.disabledPkgSetting;
                PackageSetting lastStaticSharedLibSetting = request.lastStaticSharedLibSettings.get(installPackageName);
                if (prepareResult == null || lastStaticSharedLibSetting == null) {
                    signatureCheckPs = scanResult.pkgSetting;
                } else {
                    signatureCheckPs = lastStaticSharedLibSetting;
                }
                boolean removeAppKeySetData = false;
                boolean sharedUserSignaturesChanged = false;
                if (keySetManagerService.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags)) {
                    if (!keySetManagerService.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                        if ((parseFlags & 16) != 0) {
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                        } else {
                            throw new ReconcileFailure(-7, "Package " + pkg.packageName + " upgrade keys do not match the previously installed version");
                        }
                    }
                    signingDetails = pkg.mSigningDetails;
                    disabledPkgSetting = disabledPkgSetting2;
                    incomingSharedLibraries = incomingSharedLibraries2;
                } else {
                    try {
                        Settings.VersionInfo versionInfo = request.versionInfos.get(installPackageName);
                        incomingSharedLibraries = incomingSharedLibraries2;
                        try {
                            if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, disabledPkgSetting2, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(versionInfo), isRecoverSignatureUpdateNeeded(versionInfo))) {
                                removeAppKeySetData = true;
                            }
                            signingDetails = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                disabledPkgSetting = disabledPkgSetting2;
                                try {
                                    if (pkg.mSigningDetails.hasAncestor(signatureCheckPs.sharedUser.signatures.mSigningDetails)) {
                                        signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    }
                                    if (signatureCheckPs.sharedUser.signaturesChanged == null) {
                                        signatureCheckPs.sharedUser.signaturesChanged = Boolean.FALSE;
                                    }
                                } catch (PackageManagerException e4) {
                                    e2 = e4;
                                    if ((parseFlags & 16) != 0) {
                                    }
                                } catch (IllegalArgumentException e5) {
                                    e3 = e5;
                                    throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                                }
                            } else {
                                disabledPkgSetting = disabledPkgSetting2;
                            }
                        } catch (PackageManagerException e6) {
                            e2 = e6;
                            disabledPkgSetting = disabledPkgSetting2;
                            if ((parseFlags & 16) != 0) {
                            }
                        } catch (IllegalArgumentException e7) {
                            e3 = e7;
                            throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                        }
                    } catch (PackageManagerException e8) {
                        e2 = e8;
                        disabledPkgSetting = disabledPkgSetting2;
                        incomingSharedLibraries = incomingSharedLibraries2;
                        if ((parseFlags & 16) != 0) {
                            PackageParser.SigningDetails signingDetails2 = pkg.mSigningDetails;
                            if (signatureCheckPs.sharedUser != null) {
                                Signature[] sharedUserSignatures = signatureCheckPs.sharedUser.signatures.mSigningDetails.signatures;
                                if (signatureCheckPs.sharedUser.signaturesChanged == null || PackageManagerServiceUtils.compareSignatures(sharedUserSignatures, pkg.mSigningDetails.signatures) == 0) {
                                    sharedUserSignaturesChanged = true;
                                    signingDetails = signingDetails2;
                                    signatureCheckPs.sharedUser.signatures.mSigningDetails = pkg.mSigningDetails;
                                    signatureCheckPs.sharedUser.signaturesChanged = Boolean.TRUE;
                                } else if (SystemProperties.getInt("ro.product.first_api_level", 0) <= 29) {
                                    throw new ReconcileFailure(-104, "Signature mismatch for shared user: " + scanResult.pkgSetting.sharedUser);
                                } else {
                                    throw new IllegalStateException("Signature mismatch on system package " + pkg.packageName + " for shared user " + scanResult.pkgSetting.sharedUser);
                                }
                            } else {
                                signingDetails = signingDetails2;
                            }
                            reportSettingsProblem(5, "System package " + pkg.packageName + " signature changed; retaining data.");
                            result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                            result = result;
                            scannedPackages = scannedPackages;
                            incomingSharedLibraries2 = incomingSharedLibraries;
                            combinedPackages = combinedPackages;
                            keySetManagerService = ksms;
                        } else {
                            throw new ReconcileFailure(e2);
                        }
                    } catch (IllegalArgumentException e9) {
                        e3 = e9;
                        throw new RuntimeException("Signing certificates comparison made on incomparable signing details but somehow passed verifySignatures!", e3);
                    }
                }
                result.put(installPackageName, new ReconciledPackage(request, installArgs, scanResult.pkgSetting, res, request.preparedPackages.get(installPackageName), scanResult, deletePackageAction, allowedSharedLibInfos, signingDetails, sharedUserSignaturesChanged, removeAppKeySetData));
                result = result;
                scannedPackages = scannedPackages;
                incomingSharedLibraries2 = incomingSharedLibraries;
                combinedPackages = combinedPackages;
                keySetManagerService = ksms;
            } else {
                throw new ReconcileFailure("Reconcile arguments are not balanced for " + installPackageName + "!");
            }
        }
        Map<String, LongSparseArray<SharedLibraryInfo>> incomingSharedLibraries3 = incomingSharedLibraries2;
        ArrayMap<String, PackageParser.Package> combinedPackages2 = combinedPackages;
        Map<String, ScanResult> scannedPackages2 = scannedPackages;
        for (String installPackageName2 : scannedPackages2.keySet()) {
            ScanResult scanResult2 = scannedPackages2.get(installPackageName2);
            if ((scanResult2.request.scanFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else if ((scanResult2.request.parseFlags & 16) != 0) {
                scannedPackages2 = scannedPackages2;
            } else {
                try {
                    try {
                        result.get(installPackageName2).collectedSharedLibraryInfos = collectSharedLibraryInfos(scanResult2.request.pkg, combinedPackages2, request.sharedLibrarySource, incomingSharedLibraries3);
                        scannedPackages2 = scannedPackages2;
                        combinedPackages2 = combinedPackages2;
                        incomingSharedLibraries3 = incomingSharedLibraries3;
                    } catch (PackageManagerException e10) {
                        e = e10;
                        throw new ReconcileFailure(e.error, e.getMessage());
                    }
                } catch (PackageManagerException e11) {
                    e = e11;
                    throw new ReconcileFailure(e.error, e.getMessage());
                }
            }
        }
        return result;
    }

    private static List<SharedLibraryInfo> getAllowedSharedLibInfos(ScanResult scanResult, Map<String, LongSparseArray<SharedLibraryInfo>> existingSharedLibraries) {
        PackageSetting updatedSystemPs;
        PackageParser.Package pkg = scanResult.request.pkg;
        if (scanResult.staticSharedLibraryInfo == null && scanResult.dynamicSharedLibraryInfos == null) {
            return null;
        }
        if (scanResult.staticSharedLibraryInfo != null) {
            return Collections.singletonList(scanResult.staticSharedLibraryInfo);
        }
        boolean hasDynamicLibraries = true;
        if (((pkg.applicationInfo.flags & 1) == 0 && !isSystemAppGrantByMdmAndNonPreload(pkg)) || scanResult.dynamicSharedLibraryInfos == null) {
            hasDynamicLibraries = false;
        }
        if (!hasDynamicLibraries) {
            return null;
        }
        boolean isUpdatedSystemApp = pkg.isUpdatedSystemApp();
        if (!isUpdatedSystemApp) {
            updatedSystemPs = null;
        } else if (scanResult.request.disabledPkgSetting == null) {
            updatedSystemPs = scanResult.request.oldPkgSetting;
        } else {
            updatedSystemPs = scanResult.request.disabledPkgSetting;
        }
        if (!isUpdatedSystemApp || !(updatedSystemPs == null || updatedSystemPs.pkg == null || updatedSystemPs.pkg.libraryNames == null)) {
            ArrayList<SharedLibraryInfo> infos = new ArrayList<>(scanResult.dynamicSharedLibraryInfos.size());
            for (SharedLibraryInfo info : scanResult.dynamicSharedLibraryInfos) {
                String name = info.getName();
                if (isUpdatedSystemApp && !updatedSystemPs.pkg.libraryNames.contains(name)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that is not declared on system image; skipping");
                } else if (sharedLibExists(name, -1, existingSharedLibraries)) {
                    Slog.w(TAG, "Package " + pkg.packageName + " declares library " + name + " that already exists; skipping");
                } else {
                    infos.add(info);
                }
            }
            return infos;
        }
        Slog.w(TAG, "Package " + pkg.packageName + " declares libraries that are not declared on the system image; skipping");
        return null;
    }

    private static boolean addSharedLibraryToPackageVersionMap(Map<String, LongSparseArray<SharedLibraryInfo>> target, SharedLibraryInfo library) {
        String name = library.getName();
        if (!target.containsKey(name)) {
            target.put(name, new LongSparseArray<>());
        } else if (library.getType() != 2 || target.get(name).indexOfKey(library.getLongVersion()) >= 0) {
            return false;
        }
        target.get(name).put(library.getLongVersion(), library);
        return true;
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r1v3 */
    /* JADX WARN: Type inference failed for: r1v70 */
    /* JADX WARNING: Removed duplicated region for block: B:103:0x025e  */
    /* JADX WARNING: Removed duplicated region for block: B:106:0x0264  */
    /* JADX WARNING: Removed duplicated region for block: B:111:0x028e  */
    /* JADX WARNING: Removed duplicated region for block: B:131:0x02f6  */
    /* JADX WARNING: Removed duplicated region for block: B:137:0x030b  */
    /* JADX WARNING: Removed duplicated region for block: B:140:0x0336  */
    /* JADX WARNING: Removed duplicated region for block: B:141:0x0348  */
    /* JADX WARNING: Removed duplicated region for block: B:144:0x034e  */
    /* JADX WARNING: Removed duplicated region for block: B:147:0x0357  */
    /* JADX WARNING: Removed duplicated region for block: B:150:0x0361  */
    /* JADX WARNING: Removed duplicated region for block: B:156:0x0392  */
    /* JADX WARNING: Removed duplicated region for block: B:162:0x039a A[SYNTHETIC] */
    /* JADX WARNING: Removed duplicated region for block: B:93:0x01e7  */
    /* JADX WARNING: Removed duplicated region for block: B:97:0x023a  */
    @GuardedBy({"mPackages"})
    private void commitPackagesLocked(CommitRequest request) {
        PackageParser.Package r20;
        PackageInstalledInfo res;
        PackageSetting ps;
        int i;
        boolean z;
        int childCount;
        int i2;
        PackageInstalledInfo res2;
        Set set;
        PackageSetting ps1;
        SystemDeleteException e;
        Throwable th;
        int deletedChildCount;
        boolean childPackageDeleted;
        int i3;
        PackageSetting deletePackageSetting;
        for (PackageParser.Package oldPackage = request.reconciledPackages.values().iterator(); oldPackage.hasNext(); oldPackage = r20) {
            ReconciledPackage reconciledPkg = oldPackage.next();
            PackageParser.Package pkg = reconciledPkg.scanResult.request.pkg;
            String packageName = pkg.packageName;
            PackageInstalledInfo res3 = reconciledPkg.installResult;
            if (reconciledPkg.prepareResult.replace) {
                PackageParser.Package oldPackage2 = this.mPackages.get(packageName);
                r20 = oldPackage;
                setInstallAndUpdateTime(pkg, ((PackageSetting) oldPackage2.mExtras).firstInstallTime, System.currentTimeMillis());
                PackageSetting deletePackageSetting2 = this.mSettings.mPackages.get(oldPackage2.packageName);
                if (reconciledPkg.prepareResult.system) {
                    removePackageLI(oldPackage2, true);
                    if (!disableSystemPackageLPw(oldPackage2, pkg)) {
                        res3.removedInfo.args = createInstallArgsForExisting(oldPackage2.applicationInfo.getCodePath(), oldPackage2.applicationInfo.getResourcePath(), InstructionSets.getAppDexInstructionSets(oldPackage2.applicationInfo));
                    } else {
                        res3.removedInfo.args = null;
                    }
                    synchronized (this.mPackages) {
                        try {
                            String disableSysPath = this.mSettings.getDisabledSysPackagesPath(packageName);
                            PackageSetting disableSysSetting = this.mSettings.getDisabledSystemPkgLPr(packageName);
                            boolean disableSysPathInDel = false;
                            boolean disableSysInData = false;
                            if (disableSysPath != null) {
                                try {
                                    if (mHwPMSEx.containDelPath(disableSysPath) || mHwPMSEx.isPreRemovableApp(disableSysPath)) {
                                        disableSysPathInDel = true;
                                    }
                                } catch (Throwable th2) {
                                    th = th2;
                                    while (true) {
                                        try {
                                            break;
                                        } catch (Throwable th3) {
                                            th = th3;
                                        }
                                    }
                                    throw th;
                                }
                            }
                            if (disableSysSetting != null && mHwPMSEx.isDelappInData(disableSysSetting)) {
                                disableSysInData = true;
                            }
                            if (mHwPMSEx.containDelPath(oldPackage2.applicationInfo.sourceDir) || mHwPMSEx.isPreRemovableApp(oldPackage2.applicationInfo.sourceDir) || mHwPMSEx.isDelappInData(deletePackageSetting2) || disableSysPathInDel || disableSysInData) {
                                pkg.applicationInfo.hwFlags |= DumpState.DUMP_HANDLE;
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    }
                    int deletedChildCount2 = oldPackage2.childPackages != null ? oldPackage2.childPackages.size() : 0;
                    int newChildCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
                    int i4 = 0;
                    while (i4 < deletedChildCount2) {
                        PackageParser.Package deletedChildPkg = (PackageParser.Package) oldPackage2.childPackages.get(i4);
                        boolean childPackageDeleted2 = true;
                        int j = 0;
                        while (true) {
                            if (j >= newChildCount) {
                                deletedChildCount = deletedChildCount2;
                                childPackageDeleted = childPackageDeleted2;
                                break;
                            }
                            deletedChildCount = deletedChildCount2;
                            if (deletedChildPkg.packageName.equals(((PackageParser.Package) pkg.childPackages.get(j)).packageName)) {
                                childPackageDeleted = false;
                                break;
                            }
                            j++;
                            deletedChildCount2 = deletedChildCount;
                            childPackageDeleted2 = childPackageDeleted2;
                        }
                        if (childPackageDeleted) {
                            PackageSetting ps12 = this.mSettings.getDisabledSystemPkgLPr(deletedChildPkg.packageName);
                            if (ps12 == null || res3.removedInfo.removedChildPackages == null) {
                                i3 = i4;
                                deletePackageSetting = deletePackageSetting2;
                            } else {
                                PackageRemovedInfo removedChildRes = res3.removedInfo.removedChildPackages.get(deletedChildPkg.packageName);
                                i3 = i4;
                                deletePackageSetting = deletePackageSetting2;
                                removePackageDataLIF(ps12, request.mAllUsers, removedChildRes, 0, false);
                                removedChildRes.removedForAllUsers = this.mPackages.get(ps12.name) == null;
                            }
                        } else {
                            i3 = i4;
                            deletePackageSetting = deletePackageSetting2;
                        }
                        i4 = i3 + 1;
                        deletedChildCount2 = deletedChildCount;
                        deletePackageSetting2 = deletePackageSetting;
                    }
                    res = res3;
                } else {
                    try {
                        set = null;
                        res2 = res3;
                        try {
                            executeDeletePackageLIF(reconciledPkg.deletePackageAction, packageName, true, request.mAllUsers, true, pkg);
                        } catch (SystemDeleteException e2) {
                            e = e2;
                        }
                    } catch (SystemDeleteException e3) {
                        e = e3;
                        set = null;
                        res2 = res3;
                        if (Build.IS_ENG) {
                            throw new RuntimeException("Unexpected failure", e);
                        }
                        if (DEBUG_INSTALL) {
                        }
                        int[] uidArray = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList = new ArrayList<>(1);
                        pkgList.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList, uidArray, (IIntentReceiver) null);
                        ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                        if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        }
                        if (ps1.childPackageNames != null) {
                        }
                        if (reconciledPkg.installResult.returnCode != 1) {
                        }
                        if (res.returnCode == 1) {
                        }
                        commitReconciledScanResultLocked(reconciledPkg);
                        updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
                        ps = this.mSettings.mPackages.get(packageName);
                        if (ps == null) {
                        }
                        if (res.returnCode == i) {
                        }
                        childCount = z;
                        if (pkg.childPackages != null) {
                        }
                        while (i2 < childCount) {
                        }
                        if (res.returnCode != 1) {
                        }
                    }
                    if (oldPackage2.isForwardLocked() || isExternal(oldPackage2)) {
                        if (DEBUG_INSTALL) {
                            Slog.i(TAG, "upgrading pkg " + oldPackage2 + " is ASEC-hosted -> UNAVAILABLE");
                        }
                        int[] uidArray2 = {oldPackage2.applicationInfo.uid};
                        ArrayList<String> pkgList2 = new ArrayList<>(1);
                        pkgList2.add(oldPackage2.applicationInfo.packageName);
                        sendResourcesChangedBroadcast(false, true, pkgList2, uidArray2, (IIntentReceiver) null);
                    }
                    ps1 = this.mSettings.mPackages.get(reconciledPkg.prepareResult.existingPackage.packageName);
                    if ((reconciledPkg.installArgs.installFlags & 1) != 0) {
                        if (ps1.mOldCodePaths == null) {
                            ps1.mOldCodePaths = new ArraySet();
                        }
                        Collections.addAll(ps1.mOldCodePaths, oldPackage2.baseCodePath);
                        if (oldPackage2.splitCodePaths != null) {
                            Collections.addAll(ps1.mOldCodePaths, oldPackage2.splitCodePaths);
                        }
                    } else {
                        ps1.mOldCodePaths = set;
                    }
                    if (ps1.childPackageNames != null) {
                        for (int i5 = ps1.childPackageNames.size() - 1; i5 >= 0; i5--) {
                            this.mSettings.mPackages.get((String) ps1.childPackageNames.get(i5)).mOldCodePaths = ps1.mOldCodePaths;
                        }
                    }
                    if (reconciledPkg.installResult.returnCode != 1) {
                        PackageSetting ps2 = this.mSettings.getPackageLPr(pkg.packageName);
                        if (ps2 != null) {
                            res = res2;
                            res.removedInfo.removedForAllUsers = this.mPackages.get(ps2.name) == null;
                            if (res.removedInfo.removedChildPackages != null) {
                                for (int i6 = res.removedInfo.removedChildPackages.size() - 1; i6 >= 0; i6--) {
                                    if (res.addedChildPackages.containsKey(res.removedInfo.removedChildPackages.keyAt(i6))) {
                                        res.removedInfo.removedChildPackages.removeAt(i6);
                                    } else {
                                        PackageRemovedInfo childInfo = res.removedInfo.removedChildPackages.valueAt(i6);
                                        childInfo.removedForAllUsers = this.mPackages.get(childInfo.removedPackage) == null;
                                    }
                                }
                            }
                        } else {
                            res = res2;
                        }
                    } else {
                        res = res2;
                    }
                }
            } else {
                r20 = oldPackage;
                res = res3;
            }
            if (res.returnCode == 1) {
                updateDisablePluginsLocked(pkg, reconciledPkg.installArgs.removeSplitList);
            }
            commitReconciledScanResultLocked(reconciledPkg);
            updateSettingsLI(pkg, reconciledPkg.installArgs.installerPackageName, request.mAllUsers, res, reconciledPkg.installArgs.user, reconciledPkg.installArgs.installReason);
            ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                i = 1;
                res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                z = false;
                ps.setUpdateAvailable(false);
            } else {
                z = false;
                i = 1;
            }
            if (res.returnCode == i) {
                mHwPMSEx.writeCertCompatPackages(z);
            }
            childCount = z;
            if (pkg.childPackages != null) {
                childCount = pkg.childPackages.size();
            }
            for (i2 = 0; i2 < childCount; i2++) {
                PackageParser.Package childPkg = (PackageParser.Package) pkg.childPackages.get(i2);
                PackageInstalledInfo childRes = res.addedChildPackages.get(childPkg.packageName);
                PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                if (childPs != null) {
                    childRes.newUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                }
            }
            if (res.returnCode != 1) {
                updateSequenceNumberLP(ps, res.newUsers);
                updateInstantAppInstallerLocked(packageName);
            }
        }
    }

    /* JADX INFO: Multiple debug info for r11v4 'createdAppId'  java.util.Map<java.lang.String, java.lang.Boolean>: [D('createdAppId' java.util.Map<java.lang.String, java.lang.Boolean>), D('suwFrpState' int)] */
    /* JADX INFO: Multiple debug info for r9v31 'request'  com.android.server.pm.PackageManagerService$InstallRequest: [D('request' com.android.server.pm.PackageManagerService$InstallRequest), D('createdAppId' java.util.Map<java.lang.String, java.lang.Boolean>)] */
    /* JADX INFO: Multiple debug info for r14v18 java.util.Map<java.lang.String, com.android.server.pm.Settings$VersionInfo>: [D('installArgs' java.util.Map<java.lang.String, com.android.server.pm.PackageManagerService$InstallArgs>), D('versionInfos' java.util.Map<java.lang.String, com.android.server.pm.Settings$VersionInfo>)] */
    /* JADX WARNING: Code restructure failed: missing block: B:121:0x0351, code lost:
        r0 = th;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:122:0x0352, code lost:
        r30 = r5;
        r11 = r16;
        r4 = r0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:123:0x0367, code lost:
        r0 = e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:124:0x0368, code lost:
        r19 = r14;
        r30 = r5;
        r28 = 262144;
        r14 = r6;
        r11 = r16;
        r9 = r1;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:293:0x0721, code lost:
        r1 = r4.values().iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:295:0x072d, code lost:
        if (r1.hasNext() != false) goto L_0x072f;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:296:0x072f, code lost:
        r5 = (com.android.server.pm.PackageManagerService.ScanResult) r1.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:297:0x0745, code lost:
        if (r11.getOrDefault(r5.request.pkg.packageName, false).booleanValue() != false) goto L_0x0747;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:298:0x0747, code lost:
        cleanUpAppIdCreation(r5);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:299:0x074b, code lost:
        r1 = r34.iterator();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:301:0x0753, code lost:
        if (r1.hasNext() != false) goto L_0x0755;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:302:0x0755, code lost:
        r5 = r1.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:303:0x0760, code lost:
        if (r5.installResult.returnCode == 1) goto L_0x0762;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:304:0x0762, code lost:
        r5.installResult.returnCode = 0;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:309:0x0778, code lost:
        r5 = r1.next();
     */
    /* JADX WARNING: Code restructure failed: missing block: B:310:0x0780, code lost:
        if (r5.freezer != null) goto L_0x0782;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:311:0x0782, code lost:
        r5.freezer.close();
     */
    /* JADX WARNING: Failed to process nested try/catch */
    /* JADX WARNING: Removed duplicated region for block: B:121:0x0351 A[ExcHandler: all (th java.lang.Throwable), Splitter:B:78:0x0207] */
    /* JADX WARNING: Removed duplicated region for block: B:130:0x03a1  */
    /* JADX WARNING: Removed duplicated region for block: B:145:0x03f6  */
    /* JADX WARNING: Removed duplicated region for block: B:169:0x04c5  */
    /* JADX WARNING: Removed duplicated region for block: B:184:0x051a  */
    /* JADX WARNING: Removed duplicated region for block: B:293:0x0721  */
    /* JADX WARNING: Removed duplicated region for block: B:309:0x0778  */
    @GuardedBy({"mInstallLock"})
    private void installPackagesLI(List<InstallRequest> requests) {
        Map<String, PrepareResult> prepareResults;
        Map<String, Boolean> createdAppId;
        Map<String, PackageSetting> lastStaticSharedLibSettings;
        PackageManagerException e;
        Iterator<PrepareResult> it;
        CommitRequest commitRequest;
        long j;
        PrepareFailure prepareFailure;
        Map<String, PrepareResult> prepareResults2;
        PrepareFailure prepareFailure2;
        long j2;
        Map<String, Settings.VersionInfo> installArgs;
        Map<String, Settings.VersionInfo> versionInfos;
        InstallRequest request;
        PackageManagerException e2;
        PackageSetting sharedLibLatestVersionSetting;
        int suwFrpState = Settings.Secure.getInt(this.mContext.getContentResolver(), SUW_FRP_STATE, 0);
        int childModeOobeStatus = Settings.Secure.getInt(this.mContext.getContentResolver(), CHILDMODE_STATE_OOBE, 0);
        int deviceProvisionedState = Settings.Global.getInt(this.mContext.getContentResolver(), "device_provisioned", 0);
        Map<String, PackageSetting> preparedScans = new ArrayMap<>(requests.size());
        Map<String, Settings.VersionInfo> versionInfos2 = new ArrayMap<>(requests.size());
        Map<String, PackageInstalledInfo> installResults = new ArrayMap<>(requests.size());
        Map<String, PrepareResult> prepareResults3 = new ArrayMap<>(requests.size());
        Map<String, Settings.VersionInfo> versionInfos3 = new ArrayMap<>(requests.size());
        Map<String, PackageSetting> lastStaticSharedLibSettings2 = new ArrayMap<>(requests.size());
        Map<String, Boolean> createdAppId2 = new ArrayMap<>(requests.size());
        long j3 = 262144;
        try {
            Trace.traceBegin(262144, "installPackagesLI");
            Iterator<InstallRequest> it2 = requests.iterator();
            while (it2.hasNext()) {
                try {
                    InstallRequest request2 = it2.next();
                    if (HwActivityTaskManager.isInBopdModeAndKoBackUpApp("")) {
                        try {
                            request2.installResult.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
                            Log.w("BOPD", "can not install packages in bopd!!");
                            if (0 == 0) {
                                Iterator<PackageSetting> it3 = preparedScans.values().iterator();
                                while (it3.hasNext()) {
                                    ScanResult result = (ScanResult) it3.next();
                                    if (createdAppId2.getOrDefault(result.request.pkg.packageName, false).booleanValue()) {
                                        cleanUpAppIdCreation(result);
                                    }
                                    createdAppId2 = createdAppId2;
                                }
                                for (InstallRequest request3 : requests) {
                                    if (request3.installResult.returnCode == 1) {
                                        request3.installResult.returnCode = 0;
                                    }
                                }
                            }
                            for (PrepareResult result2 : prepareResults3.values()) {
                                if (result2.freezer != null) {
                                    result2.freezer.close();
                                }
                            }
                            Trace.traceEnd(262144);
                            return;
                        } catch (Throwable th) {
                            e = th;
                            prepareResults = prepareResults3;
                            createdAppId = createdAppId2;
                            lastStaticSharedLibSettings = preparedScans;
                            if (0 == 0) {
                            }
                            it = prepareResults.values().iterator();
                            while (it.hasNext()) {
                            }
                            Trace.traceEnd(262144);
                            throw e;
                        }
                    } else if ((suwFrpState == 1 || childModeOobeStatus == 1) && deviceProvisionedState != 1) {
                        try {
                            request2.installResult.setReturnCode(RequestStatus.SYS_ETIMEDOUT);
                            Log.w(TAG, "can not install packages before FRP unlock or studentmodeOobe");
                            if (0 == 0) {
                                Iterator<PackageSetting> it4 = preparedScans.values().iterator();
                                while (it4.hasNext()) {
                                    ScanResult result3 = (ScanResult) it4.next();
                                    if (createdAppId2.getOrDefault(result3.request.pkg.packageName, false).booleanValue()) {
                                        cleanUpAppIdCreation(result3);
                                    }
                                }
                                for (InstallRequest request4 : requests) {
                                    if (request4.installResult.returnCode == 1) {
                                        request4.installResult.returnCode = 0;
                                    }
                                }
                            }
                            for (PrepareResult result4 : prepareResults3.values()) {
                                if (result4.freezer != null) {
                                    result4.freezer.close();
                                }
                            }
                            Trace.traceEnd(262144);
                            return;
                        } catch (Throwable th2) {
                            e = th2;
                            prepareResults = prepareResults3;
                            createdAppId = createdAppId2;
                            lastStaticSharedLibSettings = preparedScans;
                            if (0 == 0) {
                            }
                            it = prepareResults.values().iterator();
                            while (it.hasNext()) {
                            }
                            Trace.traceEnd(262144);
                            throw e;
                        }
                    } else {
                        try {
                            Trace.traceBegin(262144, "preparePackage");
                            try {
                                PrepareResult prepareResult = preparePackageLI(request2.args, request2.installResult);
                                try {
                                    Trace.traceEnd(262144);
                                    try {
                                        request2.installResult.setReturnCode(1);
                                        request2.installResult.installerPackageName = request2.args.installerPackageName;
                                        String packageName = prepareResult.packageToScan.packageName;
                                        prepareResults3.put(packageName, prepareResult);
                                        installResults.put(packageName, request2.installResult);
                                        versionInfos2.put(packageName, request2.args);
                                        try {
                                            try {
                                                request = request2;
                                                j2 = 262144;
                                                createdAppId = createdAppId2;
                                                installArgs = versionInfos2;
                                                prepareResults = prepareResults3;
                                                versionInfos = versionInfos3;
                                                try {
                                                    for (ScanResult result5 : scanPackageTracedLI(prepareResult.packageToScan, prepareResult.parseFlags, prepareResult.scanFlags, System.currentTimeMillis(), request2.args.user)) {
                                                        if (preparedScans.put(result5.pkgSetting.pkg.packageName, result5) != null) {
                                                            request.installResult.setError(-5, "Duplicate package " + result5.pkgSetting.pkg.packageName + " in multi-package install request.");
                                                            if (0 == 0) {
                                                                Iterator<PackageSetting> it5 = preparedScans.values().iterator();
                                                                while (it5.hasNext()) {
                                                                    ScanResult result6 = (ScanResult) it5.next();
                                                                    if (createdAppId.getOrDefault(result6.request.pkg.packageName, false).booleanValue()) {
                                                                        cleanUpAppIdCreation(result6);
                                                                    }
                                                                }
                                                                for (InstallRequest request5 : requests) {
                                                                    if (request5.installResult.returnCode == 1) {
                                                                        request5.installResult.returnCode = 0;
                                                                    }
                                                                }
                                                            }
                                                            for (PrepareResult result7 : prepareResults.values()) {
                                                                if (result7.freezer != null) {
                                                                    result7.freezer.close();
                                                                }
                                                            }
                                                            Trace.traceEnd(262144);
                                                            return;
                                                        }
                                                        createdAppId.put(packageName, Boolean.valueOf(optimisticallyRegisterAppId(result5)));
                                                        versionInfos.put(result5.pkgSetting.pkg.packageName, getSettingsVersionForPackage(result5.pkgSetting.pkg));
                                                        if (!(result5.staticSharedLibraryInfo == null || (sharedLibLatestVersionSetting = getSharedLibLatestVersionSetting(result5)) == null)) {
                                                            lastStaticSharedLibSettings2.put(result5.pkgSetting.pkg.packageName, sharedLibLatestVersionSetting);
                                                        }
                                                    }
                                                    createdAppId2 = createdAppId;
                                                    lastStaticSharedLibSettings2 = lastStaticSharedLibSettings2;
                                                    versionInfos3 = versionInfos;
                                                    it2 = it2;
                                                    versionInfos2 = installArgs;
                                                    childModeOobeStatus = childModeOobeStatus;
                                                    deviceProvisionedState = deviceProvisionedState;
                                                    suwFrpState = suwFrpState;
                                                    j3 = 262144;
                                                    prepareResults3 = prepareResults;
                                                    installResults = installResults;
                                                } catch (PackageManagerException e3) {
                                                    e2 = e3;
                                                    try {
                                                        request.installResult.setError("Scanning Failed.", e2);
                                                        if (0 == 0) {
                                                            Iterator<PackageSetting> it6 = preparedScans.values().iterator();
                                                            while (it6.hasNext()) {
                                                                ScanResult result8 = (ScanResult) it6.next();
                                                                if (createdAppId.getOrDefault(result8.request.pkg.packageName, false).booleanValue()) {
                                                                    cleanUpAppIdCreation(result8);
                                                                }
                                                            }
                                                            for (InstallRequest request6 : requests) {
                                                                if (request6.installResult.returnCode == 1) {
                                                                    request6.installResult.returnCode = 0;
                                                                }
                                                            }
                                                        }
                                                        for (PrepareResult result9 : prepareResults.values()) {
                                                            if (result9.freezer != null) {
                                                                result9.freezer.close();
                                                            }
                                                        }
                                                        Trace.traceEnd(j2);
                                                        return;
                                                    } catch (Throwable th3) {
                                                        e = th3;
                                                        lastStaticSharedLibSettings = preparedScans;
                                                        if (0 == 0) {
                                                        }
                                                        it = prepareResults.values().iterator();
                                                        while (it.hasNext()) {
                                                        }
                                                        Trace.traceEnd(262144);
                                                        throw e;
                                                    }
                                                }
                                            } catch (PackageManagerException e4) {
                                                e2 = e4;
                                                installArgs = versionInfos2;
                                                prepareResults = prepareResults3;
                                                j2 = 262144;
                                                versionInfos = versionInfos3;
                                                createdAppId = createdAppId2;
                                                request = request2;
                                                request.installResult.setError("Scanning Failed.", e2);
                                                if (0 == 0) {
                                                }
                                                while (r1.hasNext()) {
                                                }
                                                Trace.traceEnd(j2);
                                                return;
                                            } catch (Throwable th4) {
                                            }
                                        } catch (PackageManagerException e5) {
                                            e2 = e5;
                                            prepareResults = prepareResults3;
                                            installArgs = versionInfos2;
                                            j2 = 262144;
                                            versionInfos = versionInfos3;
                                            createdAppId = createdAppId2;
                                            request = request2;
                                            request.installResult.setError("Scanning Failed.", e2);
                                            if (0 == 0) {
                                            }
                                            while (r1.hasNext()) {
                                            }
                                            Trace.traceEnd(j2);
                                            return;
                                        }
                                    } catch (Throwable th5) {
                                        e = th5;
                                        prepareResults = prepareResults3;
                                        createdAppId = createdAppId2;
                                        lastStaticSharedLibSettings = preparedScans;
                                        if (0 == 0) {
                                        }
                                        it = prepareResults.values().iterator();
                                        while (it.hasNext()) {
                                        }
                                        Trace.traceEnd(262144);
                                        throw e;
                                    }
                                } catch (Throwable th6) {
                                    e = th6;
                                    prepareResults = prepareResults3;
                                }
                            } catch (PrepareFailure e6) {
                                prepareFailure2 = e6;
                                prepareResults2 = prepareResults3;
                                j = 262144;
                                try {
                                    request2.installResult.setError(prepareFailure2.error, prepareFailure2.getMessage());
                                    request2.installResult.origPackage = prepareFailure2.conflictingPackage;
                                    request2.installResult.origPermission = prepareFailure2.conflictingPermission;
                                    Trace.traceEnd(j);
                                    if (0 == 0) {
                                    }
                                    while (r1.hasNext()) {
                                    }
                                    Trace.traceEnd(j);
                                    return;
                                } catch (Throwable th7) {
                                    prepareFailure = th7;
                                    Trace.traceEnd(j);
                                    throw prepareFailure;
                                }
                            } catch (Throwable th8) {
                                prepareFailure = th8;
                                j = 262144;
                                Trace.traceEnd(j);
                                throw prepareFailure;
                            }
                        } catch (PrepareFailure e7) {
                            prepareFailure2 = e7;
                            j = 262144;
                            prepareResults2 = prepareResults3;
                            request2.installResult.setError(prepareFailure2.error, prepareFailure2.getMessage());
                            request2.installResult.origPackage = prepareFailure2.conflictingPackage;
                            request2.installResult.origPermission = prepareFailure2.conflictingPermission;
                            Trace.traceEnd(j);
                            if (0 == 0) {
                                Iterator<PackageSetting> it7 = preparedScans.values().iterator();
                                while (it7.hasNext()) {
                                    ScanResult result10 = (ScanResult) it7.next();
                                    if (createdAppId2.getOrDefault(result10.request.pkg.packageName, false).booleanValue()) {
                                        cleanUpAppIdCreation(result10);
                                    }
                                }
                                for (InstallRequest request7 : requests) {
                                    if (request7.installResult.returnCode == 1) {
                                        request7.installResult.returnCode = 0;
                                    }
                                }
                            }
                            for (PrepareResult result11 : prepareResults2.values()) {
                                if (result11.freezer != null) {
                                    result11.freezer.close();
                                }
                            }
                            Trace.traceEnd(j);
                            return;
                        } catch (Throwable th9) {
                            prepareFailure = th9;
                            j = 262144;
                            Trace.traceEnd(j);
                            throw prepareFailure;
                        }
                    }
                } catch (Throwable th10) {
                    e = th10;
                    prepareResults = prepareResults3;
                    createdAppId = createdAppId2;
                    lastStaticSharedLibSettings = preparedScans;
                    if (0 == 0) {
                    }
                    it = prepareResults.values().iterator();
                    while (it.hasNext()) {
                    }
                    Trace.traceEnd(262144);
                    throw e;
                }
            }
            prepareResults = prepareResults3;
            createdAppId = createdAppId2;
            try {
                lastStaticSharedLibSettings = preparedScans;
            } catch (Throwable th11) {
                e = th11;
                lastStaticSharedLibSettings = preparedScans;
                if (0 == 0) {
                }
                it = prepareResults.values().iterator();
                while (it.hasNext()) {
                }
                Trace.traceEnd(262144);
                throw e;
            }
            try {
                ReconcileRequest reconcileRequest = new ReconcileRequest(preparedScans, versionInfos2, installResults, prepareResults, this.mSharedLibraries, Collections.unmodifiableMap(this.mPackages), versionInfos3, lastStaticSharedLibSettings2);
                synchronized (this.mPackages) {
                    try {
                        Trace.traceBegin(j3, "reconcilePackages");
                        Map<String, ReconciledPackage> reconciledPackages = reconcilePackagesLocked(reconcileRequest, this.mSettings.mKeySetManagerService);
                        Trace.traceEnd(j3);
                        try {
                            Trace.traceBegin(j3, "commitPackages");
                            commitRequest = new CommitRequest(reconciledPackages, sUserManager.getUserIds());
                            commitPackagesLocked(commitRequest);
                            for (PrepareResult result12 : prepareResults.values()) {
                                if (result12.freezer != null) {
                                    result12.freezer.close();
                                }
                            }
                            Trace.traceEnd(j3);
                        } catch (Throwable th12) {
                            for (PrepareResult result13 : prepareResults.values()) {
                                if (result13.freezer != null) {
                                    result13.freezer.close();
                                }
                            }
                            throw th12;
                        }
                    } catch (ReconcileFailure e8) {
                        for (InstallRequest request8 : requests) {
                            request8.installResult.setError("Reconciliation failed...", e8);
                        }
                        if (0 == 0) {
                            Iterator<PackageSetting> it8 = lastStaticSharedLibSettings.values().iterator();
                            while (it8.hasNext()) {
                                ScanResult result14 = (ScanResult) it8.next();
                                if (createdAppId.getOrDefault(result14.request.pkg.packageName, false).booleanValue()) {
                                    cleanUpAppIdCreation(result14);
                                }
                            }
                            for (InstallRequest request9 : requests) {
                                if (request9.installResult.returnCode == 1) {
                                    request9.installResult.returnCode = 0;
                                }
                            }
                        }
                        for (PrepareResult result15 : prepareResults.values()) {
                            if (result15.freezer != null) {
                                result15.freezer.close();
                            }
                        }
                        return;
                    } finally {
                        Trace.traceEnd(262144);
                    }
                }
                executePostCommitSteps(commitRequest);
                if (1 == 0) {
                    Iterator<PackageSetting> it9 = lastStaticSharedLibSettings.values().iterator();
                    while (it9.hasNext()) {
                        ScanResult result16 = (ScanResult) it9.next();
                        if (createdAppId.getOrDefault(result16.request.pkg.packageName, false).booleanValue()) {
                            cleanUpAppIdCreation(result16);
                        }
                    }
                    for (InstallRequest request10 : requests) {
                        if (request10.installResult.returnCode == 1) {
                            request10.installResult.returnCode = 0;
                        }
                    }
                }
                for (PrepareResult result17 : prepareResults.values()) {
                    if (result17.freezer != null) {
                        result17.freezer.close();
                    }
                }
                Trace.traceEnd(j3);
            } catch (Throwable th13) {
                e = th13;
                if (0 == 0) {
                }
                it = prepareResults.values().iterator();
                while (it.hasNext()) {
                }
                Trace.traceEnd(262144);
                throw e;
            }
        } catch (Throwable th14) {
            e = th14;
            prepareResults = prepareResults3;
            createdAppId = createdAppId2;
            lastStaticSharedLibSettings = preparedScans;
            if (0 == 0) {
            }
            it = prepareResults.values().iterator();
            while (it.hasNext()) {
            }
            Trace.traceEnd(262144);
            throw e;
        }
    }

    private void executePostCommitSteps(CommitRequest commitRequest) {
        boolean isHwSkipDexOpt;
        int i;
        String packageName;
        String str;
        long j;
        for (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) {
            boolean instantApp = (reconciledPkg.scanResult.request.scanFlags & 16384) != 0;
            PackageParser.Package pkg = reconciledPkg.pkgSetting.pkg;
            String packageName2 = pkg.packageName;
            prepareAppDataAfterInstallLIF(pkg);
            if (reconciledPkg.prepareResult.clearCodeCache) {
                clearAppDataLIF(pkg, -1, 39);
            }
            if (mHwPMSEx.isMplPackage(reconciledPkg.prepareResult.existingPackage)) {
                Slog.i(TAG, "[DCP] -> clearMplCacheLIF for package " + pkg);
                mHwPMSEx.clearMplCacheLIF(pkg, -1, 7);
            }
            if (reconciledPkg.prepareResult.replace) {
                this.mDexManager.notifyPackageUpdated(pkg.packageName, pkg.baseCodePath, pkg.splitCodePaths);
            }
            this.mArtManagerService.prepareAppProfiles(pkg, resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()), true);
            boolean performDexopt = (!instantApp || Settings.Global.getInt(this.mContext.getContentResolver(), "instant_app_dexopt_enabled", 0) != 0) && (pkg.applicationInfo.flags & 2) == 0;
            if ((reconciledPkg.installArgs.hwInstallFlags & 8) != 0) {
                Slog.i(TAG, "package:" + packageName2 + " delay perform dexOpt");
                mHwPMSEx.addWaitDexOptPackage(packageName2);
                isHwSkipDexOpt = true;
            } else {
                isHwSkipDexOpt = false;
            }
            if (!performDexopt || isHwSkipDexOpt) {
                str = TAG;
                i = -1;
                packageName = packageName2;
            } else {
                if (SystemProperties.getBoolean(PRECOMPILE_LAYOUTS, false)) {
                    Trace.traceBegin(262144, "compileLayouts");
                    this.mViewCompiler.compileLayouts(pkg);
                    Trace.traceEnd(262144);
                }
                Trace.traceBegin(262144, "dexopt");
                DexoptOptions dexoptOptions = new DexoptOptions(packageName2, 2, (int) UsbTerminalTypes.TERMINAL_BIDIR_SKRPHONE_SUPRESS);
                if ((reconciledPkg.installArgs.hwInstallFlags & 2) != 0) {
                    Slog.i(TAG, "HW_FLAG_ONLY_PERFORM_BASE_DEXOPT:" + packageName2);
                    dexoptOptions.setOnlyPerformBaseDexopt();
                }
                if (reconciledPkg.installArgs.dexOptPolicy == 1) {
                    IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
                    CompilerStats.PackageStats orCreateCompilerPackageStats = getOrCreateCompilerPackageStats(pkg);
                    PackageDexUsage.PackageUseInfo packageUseInfoOrDefault = this.mDexManager.getPackageUseInfoOrDefault(packageName2);
                    j = 262144;
                    str = TAG;
                    iHwPackageManagerServiceEx.parallelPerformDexOpt(pkg, null, orCreateCompilerPackageStats, packageUseInfoOrDefault, dexoptOptions);
                    i = -1;
                    packageName = packageName2;
                } else {
                    j = 262144;
                    str = TAG;
                    i = -1;
                    packageName = packageName2;
                    this.mPackageDexOptimizer.performDexOpt(pkg, null, getOrCreateCompilerPackageStats(pkg), this.mDexManager.getPackageUseInfoOrDefault(packageName2), dexoptOptions);
                }
                Trace.traceEnd(j);
            }
            if (SystemProperties.getBoolean(MAPLE_DECOUPLE_CACHE_ENABLE, true) && mHwPMSEx.isMygoteEnabled() && !((pkg.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) == 0 && (pkg.applicationInfo.hwFlags & 8388608) == 0)) {
                Slog.i(str, "[DCP] -> executePostCommitSteps is called " + pkg.baseCodePath);
                long startTime = System.nanoTime();
                int cacheLevel = mHwPMSEx.getCacheLevelForMapleApp(pkg);
                String mapleClassPath = mHwPMSEx.obtainMapleClassPathByPkg(pkg);
                if (!(cacheLevel == i || mapleClassPath == null)) {
                    mHwPMSEx.callGenMplCacheAtPmsInstaller(pkg.baseCodePath, UserHandle.getSharedAppGid(pkg.applicationInfo.uid), cacheLevel, mapleClassPath);
                }
                Slog.i(str, "[DCP] -> extra time incurred at installation : " + ((int) TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime)) + " seconds");
            }
            BackgroundDexOptService.notifyPackageChanged(packageName);
            this.mHandler.post(new Runnable(packageName) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$ijIEHvxrHjnOrAs1vjyDLntQvpA */
                private final /* synthetic */ String f$0;

                {
                    this.f$0 = r1;
                }

                @Override // java.lang.Runnable
                public final void run() {
                    HwServiceExFactory.getHwPackageDynamicCodeLoading().record(this.f$0, System.currentTimeMillis(), 1);
                }
            });
        }
    }

    /* access modifiers changed from: private */
    public static class PrepareResult {
        public final PackageSetting[] childPackageSettings;
        public final boolean clearCodeCache;
        public final PackageSetting disabledPs;
        public final PackageParser.Package existingPackage;
        public final PackageFreezer freezer;
        public final int installReason;
        public final String installerPackageName;
        public final PackageSetting originalPs;
        public final PackageParser.Package packageToScan;
        public final int parseFlags;
        public final String renamedPackage;
        public final boolean replace;
        public final int scanFlags;
        public final boolean system;
        public final UserHandle user;
        public final String volumeUuid;

        private PrepareResult(int installReason2, String volumeUuid2, String installerPackageName2, UserHandle user2, boolean replace2, int scanFlags2, int parseFlags2, PackageParser.Package existingPackage2, PackageParser.Package packageToScan2, boolean clearCodeCache2, boolean system2, String renamedPackage2, PackageFreezer freezer2, PackageSetting originalPs2, PackageSetting disabledPs2, PackageSetting[] childPackageSettings2) {
            this.installReason = installReason2;
            this.volumeUuid = volumeUuid2;
            this.installerPackageName = installerPackageName2;
            this.user = user2;
            this.replace = replace2;
            this.scanFlags = scanFlags2;
            this.parseFlags = parseFlags2;
            this.existingPackage = existingPackage2;
            this.packageToScan = packageToScan2;
            this.clearCodeCache = clearCodeCache2;
            this.system = system2;
            this.renamedPackage = renamedPackage2;
            this.freezer = freezer2;
            this.originalPs = originalPs2;
            this.disabledPs = disabledPs2;
            this.childPackageSettings = childPackageSettings2;
        }
    }

    /* access modifiers changed from: private */
    public static class PrepareFailure extends PackageManagerException {
        public String conflictingPackage;
        public String conflictingPermission;

        PrepareFailure(int error) {
            super(error, "Failed to prepare for install.");
        }

        PrepareFailure(int error, String detailMessage) {
            super(error, detailMessage);
        }

        /* JADX WARNING: Illegal instructions before constructor call */
        PrepareFailure(String message, Exception e) {
            super(r0, ExceptionUtils.getCompleteMessage(message, e));
            int i;
            if (e instanceof PackageParser.PackageParserException) {
                i = ((PackageParser.PackageParserException) e).error;
            } else {
                i = ((PackageManagerException) e).error;
            }
        }

        /* access modifiers changed from: package-private */
        public PrepareFailure conflictsWithExistingPermission(String conflictingPermission2, String conflictingPackage2) {
            this.conflictingPermission = conflictingPermission2;
            this.conflictingPackage = conflictingPackage2;
            return this;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:775:0x11fa, code lost:
        r0 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:776:0x11fb, code lost:
        r2 = r0;
     */
    /* JADX WARNING: Removed duplicated region for block: B:199:0x03ec A[Catch:{ all -> 0x0599 }] */
    /* JADX WARNING: Removed duplicated region for block: B:250:0x0558 A[Catch:{ all -> 0x0441, all -> 0x058a }] */
    /* JADX WARNING: Removed duplicated region for block: B:325:0x0703 A[Catch:{ all -> 0x0740 }] */
    /* JADX WARNING: Removed duplicated region for block: B:335:0x072a A[Catch:{ all -> 0x0740 }] */
    /* JADX WARNING: Removed duplicated region for block: B:497:0x0b62 A[SYNTHETIC, Splitter:B:497:0x0b62] */
    /* JADX WARNING: Removed duplicated region for block: B:782:0x1212  */
    @GuardedBy({"mInstallLock"})
    private PrepareResult preparePackageLI(InstallArgs args, PackageInstalledInfo res) throws PrepareFailure {
        Throwable th;
        Exception exc;
        String volumeUuid;
        int parseFlags;
        File tmpPackageFile;
        String installerPackageName;
        Exception exc2;
        PackageParser.Package pkg;
        PackageManagerException e;
        Throwable th2;
        boolean onExternal;
        boolean systemApp;
        String pkgName;
        boolean replace;
        int installFlags;
        int scanFlags;
        boolean replace2;
        boolean shouldCloseFreezerBeforeReturn;
        Throwable th3;
        PackageSetting ps;
        PackageSetting disabledPs;
        int installFlags2;
        int targetParseFlags;
        int targetScanFlags;
        PackageParser.Package existingPackage;
        String targetVolumeUuid;
        boolean sysPkg;
        String renamedPackage;
        boolean replace3;
        PackageSetting[] childPackages;
        Throwable th4;
        String renamedPackage2;
        boolean isInstantApp;
        HwGunstallSwitchState hwGunstallSwitchState;
        Throwable th5;
        PackageParser.Package oldPackage;
        PackageSetting ps2;
        int[] allUsers;
        int[] installedUsers;
        PackageSetting[] childPackages2;
        boolean sysPkg2;
        String pkgName11;
        int i;
        PackageSetting ps3;
        ActivityInfo activityInfo;
        PackageManagerException pme;
        String abiOverride;
        int N;
        String installerPackageName2;
        PackageSetting ps4;
        boolean sigsOk;
        PackageManagerException e2;
        SharedLibraryInfo libraryInfo;
        boolean replace4;
        Throwable th6;
        String volumeUuid2;
        int installFlags3 = args.installFlags;
        String installerPackageName3 = args.installerPackageName;
        String volumeUuid3 = args.volumeUuid;
        File tmpPackageFile2 = new File(args.getCodePath());
        boolean onExternal2 = args.volumeUuid != null;
        boolean instantApp = (installFlags3 & 2048) != 0;
        boolean fullApp = (installFlags3 & 16384) != 0;
        boolean virtualPreload = (65536 & installFlags3) != 0;
        int scanFlags2 = 6;
        if (args.move != null) {
            scanFlags2 = 6 | 512;
        }
        if ((installFlags3 & 4096) != 0) {
            scanFlags2 |= 2048;
        }
        if (instantApp) {
            scanFlags2 |= 16384;
        }
        if (fullApp) {
            scanFlags2 |= 32768;
        }
        if (virtualPreload) {
            scanFlags2 |= 65536;
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile2);
        }
        if (!instantApp || !onExternal2) {
            int parseFlags2 = (onExternal2 ? 8 : 0) | this.mDefParseFlags | Integer.MIN_VALUE | 64;
            PackageParser pp = new PackageParser();
            pp.setSeparateProcesses(this.mSeparateProcesses);
            pp.setDisplayMetrics(this.mMetrics);
            pp.setCallback(this.mPackageParserCallback);
            Trace.traceBegin(262144, "parsePackage");
            try {
                PackageParser.Package pkg2 = pp.parsePackage(tmpPackageFile2, parseFlags2);
                if ((args.hwInstallFlags & 16) != 0) {
                    try {
                        Slog.i(TAG, "install from foundation: " + pkg2.packageName);
                        setSplitPermission(pkg2);
                    } catch (PackageParser.PackageParserException e3) {
                        exc = e3;
                    } catch (Throwable th7) {
                        th = th7;
                        Trace.traceEnd(262144);
                        throw th;
                    }
                }
                DexMetadataHelper.validatePackageDexMetadata(pkg2);
                if (pkg2 != null && mHwPMSEx.isInMultiWinWhiteList(pkg2.packageName)) {
                    pkg2.forceResizeableAllActivity();
                }
                Trace.traceEnd(262144);
                if (instantApp) {
                    if (pkg2.applicationInfo.targetSdkVersion < 26) {
                        Slog.w(TAG, "Instant app package " + pkg2.packageName + " does not target at least O");
                        throw new PrepareFailure(-116, "Instant app package must target at least O");
                    } else if (pkg2.mSharedUserId != null) {
                        Slog.w(TAG, "Instant app package " + pkg2.packageName + " may not declare sharedUserId.");
                        throw new PrepareFailure(-116, "Instant app package may not declare a sharedUserId");
                    }
                }
                if (pkg2.applicationInfo.isStaticSharedLibrary()) {
                    renameStaticSharedLibraryPackage(pkg2);
                    if (onExternal2) {
                        Slog.i(TAG, "Static shared libs can only be installed on internal storage.");
                        throw new PrepareFailure(-19, "Packages declaring static-shared libs cannot be updated");
                    }
                }
                ArrayList<String> arrayList = this.mDelPackageList;
                if (arrayList == null || !arrayList.contains(pkg2.packageName)) {
                    if (pkg2.childPackages != null) {
                        synchronized (this.mPackages) {
                            try {
                                int childCount = pkg2.childPackages.size();
                                int i2 = 0;
                                while (i2 < childCount) {
                                    PackageParser.Package childPkg = (PackageParser.Package) pkg2.childPackages.get(i2);
                                    PackageInstalledInfo childRes = new PackageInstalledInfo();
                                    try {
                                        childRes.setReturnCode(1);
                                        childRes.pkg = childPkg;
                                        childRes.name = childPkg.packageName;
                                        try {
                                            PackageSetting childPs = this.mSettings.getPackageLPr(childPkg.packageName);
                                            if (childPs != null) {
                                                volumeUuid2 = volumeUuid3;
                                                childRes.origUsers = childPs.queryInstalledUsers(sUserManager.getUserIds(), true);
                                            } else {
                                                volumeUuid2 = volumeUuid3;
                                            }
                                            if (this.mPackages.containsKey(childPkg.packageName)) {
                                                childRes.removedInfo = new PackageRemovedInfo(this);
                                                childRes.removedInfo.removedPackage = childPkg.packageName;
                                                childRes.removedInfo.installerPackageName = childPs.installerPackageName;
                                            }
                                            if (res.addedChildPackages == null) {
                                                res.addedChildPackages = new ArrayMap<>();
                                            }
                                            res.addedChildPackages.put(childPkg.packageName, childRes);
                                            i2++;
                                            childCount = childCount;
                                            tmpPackageFile2 = tmpPackageFile2;
                                            pp = pp;
                                            parseFlags2 = parseFlags2;
                                            volumeUuid3 = volumeUuid2;
                                        } catch (Throwable th8) {
                                            th6 = th8;
                                            throw th6;
                                        }
                                    } catch (Throwable th9) {
                                        th6 = th9;
                                        throw th6;
                                    }
                                }
                                parseFlags = parseFlags2;
                                tmpPackageFile = tmpPackageFile2;
                                volumeUuid = volumeUuid3;
                            } catch (Throwable th10) {
                                th6 = th10;
                                throw th6;
                            }
                        }
                    } else {
                        parseFlags = parseFlags2;
                        tmpPackageFile = tmpPackageFile2;
                        volumeUuid = volumeUuid3;
                    }
                    if (TextUtils.isEmpty(pkg2.cpuAbiOverride)) {
                        pkg2.cpuAbiOverride = args.abiOverride;
                    }
                    String pkgName2 = pkg2.packageName;
                    res.name = pkgName2;
                    if (!mHwPMSEx.isAppInstallAllowed(pkgName2)) {
                        installerPackageName = installerPackageName3;
                    } else if (args.origin != null && mHwPMSEx.isUnAppInstallAllowed(args.origin.resolvedPath)) {
                        installerPackageName = installerPackageName3;
                    } else if ((pkg2.applicationInfo.flags & 256) == 0 || (installFlags3 & 4) != 0) {
                        try {
                            if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                                try {
                                    pkg2.setSigningDetails(args.signingDetails);
                                    pkg = pkg2;
                                } catch (PackageParser.PackageParserException e4) {
                                    exc2 = e4;
                                    throw new PrepareFailure("Failed collect during installPackageLI", exc2);
                                }
                            } else {
                                PackageParser.collectCertificates(pkg2, false);
                                pkg = pkg2;
                            }
                            if (instantApp && pkg.mSigningDetails.signatureSchemeVersion < 2) {
                                Slog.w(TAG, "Instant app package " + pkg.packageName + " is not signed with at least APK Signature Scheme v2");
                                throw new PrepareFailure(-116, "Instant app package must be signed with APK Signature Scheme v2 or greater");
                            } else if (mHwPMSEx.isInValidApkPatchPkg(pkg)) {
                                Slog.i(TAG, "this apk is invalid apk patch");
                                throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "PackageName is disallowd to be installed");
                            } else if (!mHwPMSEx.isMDMDisallowedInstallPackage(pkg, res)) {
                                try {
                                    if (mHwPMSEx.checkUninstalledSystemApp(pkg, args, res)) {
                                        try {
                                            Slog.i(TAG, "restore the uninstalled app and upgrad it");
                                            installFlags3 |= 2;
                                        } catch (PackageManagerException e5) {
                                            e = e5;
                                            Slog.w(TAG, "Failed checkUninstalledSystemApp: " + e.getMessage());
                                            throw new PrepareFailure("Failed checkUninstalledSystemApp during installPackageLI", e);
                                        }
                                    }
                                    boolean replace5 = false;
                                    synchronized (this.mPackages) {
                                        if ((installFlags3 & 2) != 0) {
                                            try {
                                                String oldName = this.mSettings.getRenamedPackageLPr(pkgName2);
                                                if (pkg.mOriginalPackages != null) {
                                                    try {
                                                        if (!pkg.mOriginalPackages.contains(oldName)) {
                                                            systemApp = false;
                                                        } else if (this.mPackages.containsKey(oldName)) {
                                                            pkg.setPackageName(oldName);
                                                            pkgName2 = pkg.packageName;
                                                            replace5 = true;
                                                            if (DEBUG_INSTALL) {
                                                                StringBuilder sb = new StringBuilder();
                                                                systemApp = false;
                                                                try {
                                                                    sb.append("Replacing existing renamed package: oldName=");
                                                                    sb.append(oldName);
                                                                    sb.append(" pkgName=");
                                                                    sb.append(pkgName2);
                                                                    Slog.d(TAG, sb.toString());
                                                                } catch (Throwable th11) {
                                                                    th2 = th11;
                                                                }
                                                            } else {
                                                                systemApp = false;
                                                            }
                                                            try {
                                                                if (pkg.parentPackage != null) {
                                                                    if (replace5) {
                                                                        PackageParser.Package oldPackage2 = this.mPackages.get(pkgName2);
                                                                        int oldTargetSdk = oldPackage2.applicationInfo.targetSdkVersion;
                                                                        int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                                                                        if (oldTargetSdk <= 22) {
                                                                            replace4 = replace5;
                                                                            onExternal = onExternal2;
                                                                        } else if (newTargetSdk > 22) {
                                                                            replace4 = replace5;
                                                                            onExternal = onExternal2;
                                                                        } else {
                                                                            try {
                                                                                StringBuilder sb2 = new StringBuilder();
                                                                                sb2.append("Package ");
                                                                                sb2.append(pkg.packageName);
                                                                                sb2.append(" new target SDK ");
                                                                                sb2.append(newTargetSdk);
                                                                                sb2.append(" doesn't support runtime permissions but the old target SDK ");
                                                                                sb2.append(oldTargetSdk);
                                                                                sb2.append(" does.");
                                                                                throw new PrepareFailure(-26, sb2.toString());
                                                                            } catch (Throwable th12) {
                                                                                th2 = th12;
                                                                                while (true) {
                                                                                    break;
                                                                                }
                                                                                throw th2;
                                                                            }
                                                                        }
                                                                        if (!mHwPMSEx.isNeedForbidHarmfulAppUpdateApp(pkgName2, installerPackageName3)) {
                                                                            if (mHwPMSEx != null) {
                                                                                if (mHwPMSEx.isNeedForbidAppAct(PREAS_APP_UPDATE_FORBIDDEN, oldPackage2.packageName, null, null) || mHwPMSEx.isNeedForbidAppAct(APP_UPDATE_FORBIDDEN, oldPackage2.packageName, null, null)) {
                                                                                    Slog.i(TAG, "isNeedForbidAppAct forbid app update");
                                                                                    throw new PrepareFailure(-2, "Package isNeedForbidAppAct true, need forbid update.");
                                                                                }
                                                                            }
                                                                            if ((oldPackage2.applicationInfo.flags & 8) != 0 && (2097152 & installFlags3) == 0) {
                                                                                if (!mHwPMSEx.isPersistentUpdatable(pkg)) {
                                                                                    throw new PrepareFailure(-2, "Package " + oldPackage2.packageName + " is a persistent app. Persistent apps are not updateable.");
                                                                                }
                                                                            }
                                                                            if (oldPackage2.parentPackage == null) {
                                                                                String isAppUpdateAllowedMsg = HwPackageManagerServiceUtils.isAppUpdateAllowed(oldPackage2, pkg, this);
                                                                                if (!TextUtils.isEmpty(isAppUpdateAllowedMsg)) {
                                                                                    throw new PrepareFailure(-2, isAppUpdateAllowedMsg);
                                                                                }
                                                                            } else {
                                                                                throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + oldPackage2.parentPackage + ". Child packages can be updated only through the parent package.");
                                                                            }
                                                                        } else {
                                                                            Slog.i(TAG, "forbid " + pkgName2 + " update! former installer Package is " + getInstallerPackageName(pkgName2));
                                                                            throw new PrepareFailure(-2, "Package " + pkgName2 + " is forbid update from " + installerPackageName3);
                                                                        }
                                                                    } else {
                                                                        replace4 = replace5;
                                                                        onExternal = onExternal2;
                                                                    }
                                                                    pkgName = pkgName2;
                                                                    replace5 = replace4;
                                                                } else {
                                                                    throw new PrepareFailure(-106, "Package " + pkg.packageName + " is child of package " + pkg.parentPackage.parentPackage + ". Child packages can be updated only through the parent package.");
                                                                }
                                                            } catch (Throwable th13) {
                                                                th2 = th13;
                                                                while (true) {
                                                                    break;
                                                                }
                                                                throw th2;
                                                            }
                                                        } else {
                                                            systemApp = false;
                                                        }
                                                    } catch (Throwable th14) {
                                                        th2 = th14;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th2;
                                                    }
                                                } else {
                                                    systemApp = false;
                                                }
                                            } catch (Throwable th15) {
                                                th2 = th15;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                            try {
                                                if (this.mPackages.containsKey(pkgName2)) {
                                                    replace5 = true;
                                                    if (DEBUG_INSTALL) {
                                                        Slog.d(TAG, "Replace existing pacakge: " + pkgName2);
                                                    }
                                                }
                                                if (pkg.parentPackage != null) {
                                                }
                                            } catch (Throwable th16) {
                                                th2 = th16;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                        } else {
                                            systemApp = false;
                                            onExternal = onExternal2;
                                            pkgName = pkgName2;
                                        }
                                        try {
                                            PackageSetting ps5 = this.mSettings.mPackages.get(pkgName);
                                            mHwPMSEx.checkHwCertification(pkg, true);
                                            mHwPMSEx.replaceSignatureIfNeeded(ps5, pkg, false, true);
                                            if (ps5 != null) {
                                                try {
                                                    if (DEBUG_INSTALL) {
                                                        try {
                                                            Slog.d(TAG, "Existing package: " + ps5);
                                                        } catch (Throwable th17) {
                                                            th2 = th17;
                                                        }
                                                    }
                                                    PackageSetting signatureCheckPs = ps5;
                                                    if (pkg.applicationInfo.isStaticSharedLibrary() && (libraryInfo = getLatestSharedLibraVersionLPr(pkg)) != null) {
                                                        signatureCheckPs = this.mSettings.getPackageLPr(libraryInfo.getPackageName());
                                                    }
                                                    KeySetManagerService ksms = this.mSettings.mKeySetManagerService;
                                                    if (ksms.shouldCheckUpgradeKeySetLocked(signatureCheckPs, scanFlags2)) {
                                                        try {
                                                            if (ksms.checkUpgradeKeySetLocked(signatureCheckPs, pkg)) {
                                                                installFlags = installFlags3;
                                                                replace = replace5;
                                                            } else {
                                                                StringBuilder sb3 = new StringBuilder();
                                                                try {
                                                                    sb3.append("Package ");
                                                                    sb3.append(pkg.packageName);
                                                                    sb3.append(" upgrade keys do not match the previously installed version");
                                                                    throw new PrepareFailure(-7, sb3.toString());
                                                                } catch (Throwable th18) {
                                                                    th2 = th18;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            }
                                                        } catch (Throwable th19) {
                                                            th2 = th19;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th2;
                                                        }
                                                    } else {
                                                        installFlags = installFlags3;
                                                        try {
                                                            replace = replace5;
                                                            try {
                                                                if (PackageManagerServiceUtils.verifySignatures(signatureCheckPs, null, pkg.mSigningDetails, isCompatSignatureUpdateNeeded(pkg), isRecoverSignatureUpdateNeeded(pkg))) {
                                                                    synchronized (this.mPackages) {
                                                                        ksms.removeAppKeySetDataLPw(pkg.packageName);
                                                                    }
                                                                }
                                                            } catch (PackageManagerException e6) {
                                                                e2 = e6;
                                                                try {
                                                                    if (ps5.sharedUser == null || !mHwPMSEx.isSystemSignatureUpdated(signatureCheckPs.signatures.mSigningDetails.signatures, pkg.mSigningDetails.signatures)) {
                                                                        throw new PrepareFailure(e2.error, e2.getMessage());
                                                                    }
                                                                    Slog.i(TAG, "CertCompat: " + pkg.packageName + " system signature updated. Update signatures.");
                                                                    ps5.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                    if (!HwPackageManagerServiceUtils.verifyValidVerifierInstall(installerPackageName3, pkgName, args.user.getIdentifier(), Binder.getCallingUid(), this)) {
                                                                    }
                                                                } catch (Throwable th20) {
                                                                    th2 = th20;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            }
                                                        } catch (PackageManagerException e7) {
                                                            replace = replace5;
                                                            e2 = e7;
                                                            if (ps5.sharedUser == null) {
                                                            }
                                                            throw new PrepareFailure(e2.error, e2.getMessage());
                                                        } catch (Throwable th21) {
                                                            th2 = th21;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th2;
                                                        }
                                                    }
                                                    if (!HwPackageManagerServiceUtils.verifyValidVerifierInstall(installerPackageName3, pkgName, args.user.getIdentifier(), Binder.getCallingUid(), this)) {
                                                        if (!(ps5.pkg == null || ps5.pkg.applicationInfo == null)) {
                                                            systemApp = (ps5.pkg.applicationInfo.flags & 1) != 0;
                                                        }
                                                        res.origUsers = ps5.queryInstalledUsers(sUserManager.getUserIds(), true);
                                                    } else {
                                                        throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "Invalid installer for verifyValidVerifierInstall failed!");
                                                    }
                                                } catch (Throwable th22) {
                                                    th2 = th22;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th2;
                                                }
                                            } else {
                                                installFlags = installFlags3;
                                                replace = replace5;
                                            }
                                            try {
                                                int N2 = pkg.permissions.size();
                                                int i3 = N2 - 1;
                                                while (i3 >= 0) {
                                                    try {
                                                        PackageParser.Permission perm = (PackageParser.Permission) pkg.permissions.get(i3);
                                                        BasePermission bp = this.mPermissionManager.getPermissionTEMP(perm.info.name);
                                                        if ((perm.info.protectionLevel & 4096) == 0 || systemApp) {
                                                            N = N2;
                                                        } else {
                                                            StringBuilder sb4 = new StringBuilder();
                                                            N = N2;
                                                            sb4.append("Non-System package ");
                                                            sb4.append(pkg.packageName);
                                                            sb4.append(" attempting to delcare ephemeral permission ");
                                                            sb4.append(perm.info.name);
                                                            sb4.append("; Removing ephemeral.");
                                                            Slog.w(TAG, sb4.toString());
                                                            perm.info.protectionLevel &= -4097;
                                                        }
                                                        if (bp != null) {
                                                            String sourcePackageName = bp.getSourcePackageName();
                                                            PackageSettingBase sourcePackageSetting = bp.getSourcePackageSetting();
                                                            KeySetManagerService ksms2 = this.mSettings.mKeySetManagerService;
                                                            ps4 = ps5;
                                                            if (!sourcePackageName.equals(pkg.packageName) || !ksms2.shouldCheckUpgradeKeySetLocked(sourcePackageSetting, scanFlags2)) {
                                                                installerPackageName2 = installerPackageName3;
                                                                try {
                                                                    if (sourcePackageSetting.signatures.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                                                                        sigsOk = true;
                                                                    } else if (pkg.mSigningDetails.checkCapability(sourcePackageSetting.signatures.mSigningDetails, 4)) {
                                                                        sourcePackageSetting.signatures.mSigningDetails = pkg.mSigningDetails;
                                                                        sigsOk = true;
                                                                    } else {
                                                                        sigsOk = false;
                                                                    }
                                                                } catch (Throwable th23) {
                                                                    th2 = th23;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th2;
                                                                }
                                                            } else {
                                                                sigsOk = ksms2.checkUpgradeKeySetLocked(sourcePackageSetting, pkg);
                                                                installerPackageName2 = installerPackageName3;
                                                            }
                                                            if (!sigsOk) {
                                                                if (!sourcePackageName.equals(PLATFORM_PACKAGE_NAME)) {
                                                                    PackageSetting basePackageSetting = this.mSettings.mPackages.get(sourcePackageName);
                                                                    if (basePackageSetting != null ? basePackageSetting.isSystem() : false) {
                                                                        if (((bp.getProtectionLevel() | perm.info.protectionLevel) & 15) != 2) {
                                                                            Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName + "; ignoring new declaration");
                                                                            pkg.permissions.remove(i3);
                                                                        }
                                                                    }
                                                                    throw new PrepareFailure(-112, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + sourcePackageName).conflictsWithExistingPermission(perm.info.name, sourcePackageName);
                                                                }
                                                                Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration");
                                                                pkg.permissions.remove(i3);
                                                            } else if (!PLATFORM_PACKAGE_NAME.equals(pkg.packageName) && (perm.info.protectionLevel & 15) == 1 && !bp.isRuntime()) {
                                                                Slog.w(TAG, "Package " + pkg.packageName + " trying to change a non-runtime permission " + perm.info.name + " to runtime; keeping old protection level");
                                                                perm.info.protectionLevel = bp.getProtectionLevel();
                                                            }
                                                        } else {
                                                            ps4 = ps5;
                                                            installerPackageName2 = installerPackageName3;
                                                        }
                                                        i3--;
                                                        N2 = N;
                                                        ps5 = ps4;
                                                        installerPackageName3 = installerPackageName2;
                                                    } catch (Throwable th24) {
                                                        th2 = th24;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th2;
                                                    }
                                                }
                                                try {
                                                } catch (Throwable th25) {
                                                    th2 = th25;
                                                    while (true) {
                                                        break;
                                                    }
                                                    throw th2;
                                                }
                                            } catch (Throwable th26) {
                                                th2 = th26;
                                                while (true) {
                                                    break;
                                                }
                                                throw th2;
                                            }
                                        } catch (Throwable th27) {
                                            th2 = th27;
                                            while (true) {
                                                break;
                                            }
                                            throw th2;
                                        }
                                    }
                                    if (systemApp) {
                                        if (onExternal) {
                                            throw new PrepareFailure(-19, "Cannot install updates to system apps on sdcard");
                                        } else if (instantApp) {
                                            throw new PrepareFailure(-116, "Cannot update a system app with an instant app");
                                        }
                                    }
                                    InstallerMgr.getInstance().installPackage(0, args.installerPackageName, pkgName);
                                    if (args.move != null) {
                                        scanFlags = scanFlags2 | 1 | 256;
                                        synchronized (this.mPackages) {
                                            PackageSetting ps6 = this.mSettings.mPackages.get(pkgName);
                                            if (ps6 == null) {
                                                res.setError(RequestStatus.SYS_ETIMEDOUT, "Missing settings for moved package " + pkgName);
                                            }
                                            pkg.applicationInfo.primaryCpuAbi = ps6.primaryCpuAbiString;
                                            pkg.applicationInfo.secondaryCpuAbi = ps6.secondaryCpuAbiString;
                                        }
                                    } else {
                                        int scanFlags3 = scanFlags2 | 1;
                                        try {
                                            if (TextUtils.isEmpty(pkg.cpuAbiOverride)) {
                                                try {
                                                    abiOverride = args.abiOverride;
                                                } catch (PackageManagerException e8) {
                                                    pme = e8;
                                                }
                                            } else {
                                                abiOverride = pkg.cpuAbiOverride;
                                            }
                                            derivePackageAbi(pkg, abiOverride, !pkg.isLibrary());
                                            scanFlags = scanFlags3;
                                        } catch (PackageManagerException e9) {
                                            pme = e9;
                                            Slog.e(TAG, "Error deriving application ABI", pme);
                                            throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "Error deriving application ABI");
                                        }
                                    }
                                    if (args.doRename(res.returnCode, pkg)) {
                                        try {
                                            setUpFsVerityIfPossible(pkg);
                                            if (!instantApp) {
                                                replace2 = replace;
                                                startIntentFilterVerifications(args.user.getIdentifier(), replace2, pkg);
                                            } else {
                                                replace2 = replace;
                                                if (DEBUG_DOMAIN_VERIFICATION) {
                                                    Slog.d(TAG, "Not verifying instant app install for app links: " + pkgName);
                                                }
                                            }
                                            if (!((installFlags & 4096) != 0 || (activityInfo = HwActivityTaskManager.getLastResumedActivity()) == null || activityInfo.getComponentName() == null)) {
                                                String topPkgName = activityInfo.getComponentName().getPackageName();
                                                Slog.i(TAG, "top pkgName: " + topPkgName + ", update pkgName: " + pkgName);
                                                if (pkgName.equals(topPkgName)) {
                                                    String appName = getCallingAppName(this.mContext, pkg);
                                                    Slog.i(TAG, "appName: " + appName);
                                                    Toast.makeText(this.mContext, String.format(Locale.ENGLISH, this.mContext.getString(17041404), appName), 1).show();
                                                }
                                            }
                                            PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, "installPackageLI");
                                            if (replace2) {
                                                try {
                                                    if (pkg.applicationInfo.isStaticSharedLibrary()) {
                                                        try {
                                                            shouldCloseFreezerBeforeReturn = true;
                                                            try {
                                                                PackageParser.Package existingPkg = this.mPackages.get(pkg.packageName);
                                                                if (existingPkg != null) {
                                                                    renamedPackage = null;
                                                                    if (!"com.huawei.androidx".equals(pkg.manifestPackageName) || existingPkg.getLongVersionCode() > pkg.getLongVersionCode()) {
                                                                        if (existingPkg.getLongVersionCode() != pkg.getLongVersionCode()) {
                                                                            throw new PrepareFailure(-5, "Packages declaring static-shared libs cannot be updated");
                                                                        }
                                                                    }
                                                                } else {
                                                                    renamedPackage = null;
                                                                }
                                                            } catch (Throwable th28) {
                                                                th3 = th28;
                                                                if (shouldCloseFreezerBeforeReturn) {
                                                                }
                                                                throw th3;
                                                            }
                                                        } catch (Throwable th29) {
                                                            shouldCloseFreezerBeforeReturn = true;
                                                            th3 = th29;
                                                            if (shouldCloseFreezerBeforeReturn) {
                                                                freezer.close();
                                                            }
                                                            throw th3;
                                                        }
                                                    } else {
                                                        shouldCloseFreezerBeforeReturn = true;
                                                        renamedPackage = null;
                                                    }
                                                    isInstantApp = (scanFlags & 16384) != 0;
                                                } catch (Throwable th30) {
                                                    shouldCloseFreezerBeforeReturn = true;
                                                    th3 = th30;
                                                    if (shouldCloseFreezerBeforeReturn) {
                                                    }
                                                    throw th3;
                                                }
                                                try {
                                                    String pkgName112 = pkg.packageName;
                                                    if (IS_GMS_SCHEME) {
                                                        targetVolumeUuid = null;
                                                        if (this.callingSessionUid != -1) {
                                                            hwGunstallSwitchState = mHwPMSEx.updateGunstallState();
                                                            synchronized (this.mPackages) {
                                                                try {
                                                                    oldPackage = this.mPackages.get(pkgName112);
                                                                    existingPackage = oldPackage;
                                                                    this.updatePackageName = pkgName112;
                                                                    targetScanFlags = scanFlags;
                                                                    try {
                                                                        targetParseFlags = parseFlags;
                                                                        try {
                                                                            installFlags2 = installFlags;
                                                                            try {
                                                                                HwPackageManagerServiceUtils.sendUpdateBroadcast(this.mProcessLoggingHandler, 0, pkgName112, "com.huawei.android.launcher", this.mContext);
                                                                                Flog.i(207, "replacePackageLI: new = " + pkg + ", old = " + oldPackage);
                                                                                if (DEBUG_INSTALL) {
                                                                                    try {
                                                                                        Slog.d(TAG, "replacePackageLI: new=" + pkg + ", old=" + oldPackage);
                                                                                    } catch (Throwable th31) {
                                                                                        th5 = th31;
                                                                                    }
                                                                                }
                                                                                if (!IS_GMS_SCHEME || !mHwPMSEx.forbidGMSUpgrade(pkg, oldPackage, this.callingSessionUid, hwGunstallSwitchState)) {
                                                                                    ps2 = this.mSettings.mPackages.get(pkgName112);
                                                                                    PackageSetting disabledPs2 = this.mSettings.getDisabledSystemPkgLPr(ps2);
                                                                                    KeySetManagerService ksms3 = this.mSettings.mKeySetManagerService;
                                                                                    if (ksms3.shouldCheckUpgradeKeySetLocked(ps2, scanFlags)) {
                                                                                        try {
                                                                                            if (ksms3.checkUpgradeKeySetLocked(ps2, pkg)) {
                                                                                                disabledPs = disabledPs2;
                                                                                            } else {
                                                                                                try {
                                                                                                    throw new PrepareFailure(-7, "New package not signed by keys specified by upgrade-keysets: " + pkgName112);
                                                                                                } catch (Throwable th32) {
                                                                                                    th5 = th32;
                                                                                                    throw th5;
                                                                                                }
                                                                                            }
                                                                                        } catch (Throwable th33) {
                                                                                            th5 = th33;
                                                                                            throw th5;
                                                                                        }
                                                                                    } else {
                                                                                        disabledPs = disabledPs2;
                                                                                        try {
                                                                                            if (!pkg.mSigningDetails.checkCapability(oldPackage.mSigningDetails, 1) && !oldPackage.mSigningDetails.checkCapability(pkg.mSigningDetails, 8)) {
                                                                                                if (mHwPMSEx.isSystemSignatureUpdated(oldPackage.mSigningDetails.signatures, pkg.mSigningDetails.signatures)) {
                                                                                                    Slog.i(TAG, "CertCompat: " + pkg.packageName + " system signature updated. Ignore signature matching.");
                                                                                                } else {
                                                                                                    throw new PrepareFailure(-7, "New package has a different signature: " + pkgName112);
                                                                                                }
                                                                                            }
                                                                                        } catch (Throwable th34) {
                                                                                            th5 = th34;
                                                                                            throw th5;
                                                                                        }
                                                                                    }
                                                                                    if (oldPackage.restrictUpdateHash != null && oldPackage.isSystem()) {
                                                                                        try {
                                                                                            MessageDigest digest = MessageDigest.getInstance("SHA-512");
                                                                                            updateDigest(digest, new File(pkg.baseCodePath));
                                                                                            if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                                                                                                String[] strArr = pkg.splitCodePaths;
                                                                                                int i4 = 0;
                                                                                                for (int length = strArr.length; i4 < length; length = length) {
                                                                                                    try {
                                                                                                        updateDigest(digest, new File(strArr[i4]));
                                                                                                        i4++;
                                                                                                        strArr = strArr;
                                                                                                    } catch (IOException | NoSuchAlgorithmException e10) {
                                                                                                        throw new PrepareFailure(-2, "Could not compute hash: " + pkgName112);
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            if (Arrays.equals(oldPackage.restrictUpdateHash, digest.digest())) {
                                                                                                pkg.restrictUpdateHash = oldPackage.restrictUpdateHash;
                                                                                            } else {
                                                                                                throw new PrepareFailure(-2, "New package fails restrict-update check: " + pkgName112);
                                                                                            }
                                                                                        } catch (IOException | NoSuchAlgorithmException e11) {
                                                                                            throw new PrepareFailure(-2, "Could not compute hash: " + pkgName112);
                                                                                        }
                                                                                    }
                                                                                    String invalidPackageName = getParentOrChildPackageChangedSharedUser(oldPackage, pkg);
                                                                                    if (invalidPackageName == null) {
                                                                                        allUsers = sUserManager.getUserIds();
                                                                                        installedUsers = ps2.queryInstalledUsers(allUsers, true);
                                                                                        if (isInstantApp) {
                                                                                            try {
                                                                                                if (args.user != null) {
                                                                                                    if (args.user.getIdentifier() != -1) {
                                                                                                        try {
                                                                                                            if (!ps2.getInstantApp(args.user.getIdentifier())) {
                                                                                                                Slog.w(TAG, "Can't replace full app with instant app: " + pkgName112 + " for user: " + args.user.getIdentifier());
                                                                                                                throw new PrepareFailure(-116);
                                                                                                            }
                                                                                                        } catch (Throwable th35) {
                                                                                                            th5 = th35;
                                                                                                            throw th5;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                for (int currentUser : allUsers) {
                                                                                                    if (!ps2.getInstantApp(currentUser)) {
                                                                                                        Slog.w(TAG, "Can't replace full app with instant app: " + pkgName112 + " for user: " + currentUser);
                                                                                                        throw new PrepareFailure(-116);
                                                                                                    }
                                                                                                }
                                                                                            } catch (Throwable th36) {
                                                                                                th5 = th36;
                                                                                                throw th5;
                                                                                            }
                                                                                        }
                                                                                        try {
                                                                                        } catch (Throwable th37) {
                                                                                            th5 = th37;
                                                                                            throw th5;
                                                                                        }
                                                                                    } else {
                                                                                        throw new PrepareFailure(-8, "Package " + invalidPackageName + " tried to change user " + oldPackage.mSharedUserId);
                                                                                    }
                                                                                } else {
                                                                                    throw new PrepareFailure(-115, "New package is incompatible");
                                                                                }
                                                                            } catch (Throwable th38) {
                                                                                th5 = th38;
                                                                                throw th5;
                                                                            }
                                                                        } catch (Throwable th39) {
                                                                            th5 = th39;
                                                                            throw th5;
                                                                        }
                                                                    } catch (Throwable th40) {
                                                                        th5 = th40;
                                                                        throw th5;
                                                                    }
                                                                } catch (Throwable th41) {
                                                                    th5 = th41;
                                                                    throw th5;
                                                                }
                                                            }
                                                            try {
                                                                res.removedInfo = new PackageRemovedInfo(this);
                                                                res.removedInfo.uid = oldPackage.applicationInfo.uid;
                                                                res.removedInfo.removedPackage = oldPackage.packageName;
                                                                res.removedInfo.installerPackageName = ps2.installerPackageName;
                                                                res.removedInfo.isStaticSharedLib = pkg.staticSharedLibName != null;
                                                                res.removedInfo.isUpdate = true;
                                                                res.removedInfo.origUsers = installedUsers;
                                                                res.removedInfo.installReasons = new SparseArray<>(installedUsers.length);
                                                                for (int userId : installedUsers) {
                                                                    try {
                                                                        res.removedInfo.installReasons.put(userId, Integer.valueOf(ps2.getInstallReason(userId)));
                                                                    } catch (Throwable th42) {
                                                                        th3 = th42;
                                                                        if (shouldCloseFreezerBeforeReturn) {
                                                                        }
                                                                        throw th3;
                                                                    }
                                                                }
                                                                PackageSetting[] childPackages3 = this.mSettings.getChildSettingsLPr(ps2);
                                                                if (childPackages3 != null) {
                                                                    int length2 = childPackages3.length;
                                                                    int i5 = 0;
                                                                    while (i5 < length2) {
                                                                        PackageSetting childPs2 = childPackages3[i5];
                                                                        boolean childPackageUpdated = false;
                                                                        PackageParser.Package childPkg2 = childPs2 == null ? null : childPs2.pkg;
                                                                        if (res.addedChildPackages != null) {
                                                                            pkgName11 = pkgName112;
                                                                            PackageInstalledInfo childRes2 = res.addedChildPackages.get(childPkg2.packageName);
                                                                            if (childRes2 != null) {
                                                                                i = length2;
                                                                                childRes2.removedInfo.uid = childPkg2.applicationInfo.uid;
                                                                                childRes2.removedInfo.removedPackage = childPkg2.packageName;
                                                                                if (childPs2 != null) {
                                                                                    childRes2.removedInfo.installerPackageName = childPs2.installerPackageName;
                                                                                }
                                                                                childRes2.removedInfo.isUpdate = true;
                                                                                childRes2.removedInfo.installReasons = res.removedInfo.installReasons;
                                                                                childPackageUpdated = true;
                                                                            } else {
                                                                                i = length2;
                                                                            }
                                                                        } else {
                                                                            pkgName11 = pkgName112;
                                                                            i = length2;
                                                                        }
                                                                        if (!childPackageUpdated) {
                                                                            PackageRemovedInfo childRemovedRes = new PackageRemovedInfo(this);
                                                                            childRemovedRes.removedPackage = childPkg2.packageName;
                                                                            if (childPs2 != null) {
                                                                                childRemovedRes.installerPackageName = childPs2.installerPackageName;
                                                                            }
                                                                            childRemovedRes.isUpdate = false;
                                                                            childRemovedRes.dataRemoved = true;
                                                                            synchronized (this.mPackages) {
                                                                                if (childPs2 != null) {
                                                                                    ps3 = ps2;
                                                                                    childRemovedRes.origUsers = childPs2.queryInstalledUsers(allUsers, true);
                                                                                } else {
                                                                                    ps3 = ps2;
                                                                                }
                                                                            }
                                                                            if (res.removedInfo.removedChildPackages == null) {
                                                                                res.removedInfo.removedChildPackages = new ArrayMap<>();
                                                                            }
                                                                            res.removedInfo.removedChildPackages.put(childPkg2.packageName, childRemovedRes);
                                                                        } else {
                                                                            ps3 = ps2;
                                                                        }
                                                                        i5++;
                                                                        childPackages3 = childPackages3;
                                                                        length2 = i;
                                                                        pkgName112 = pkgName11;
                                                                        ps2 = ps3;
                                                                    }
                                                                    childPackages2 = childPackages3;
                                                                    ps = ps2;
                                                                } else {
                                                                    childPackages2 = childPackages3;
                                                                    ps = ps2;
                                                                }
                                                                boolean sysPkg3 = isSystemApp(oldPackage);
                                                                if (sysPkg3 && isSystemAppGrantByMdmAndNonPreload(pkg)) {
                                                                    sysPkg3 = false;
                                                                }
                                                                Flog.i(207, "update pkg: " + pkgName + ", old pkg is system: " + sysPkg3);
                                                                if (sysPkg3) {
                                                                    int systemScanFlags = scanFlags | 131072 | (isPrivilegedApp(oldPackage) ? 262144 : 0) | (isOemApp(oldPackage) ? 524288 : 0) | (isVendorApp(oldPackage) ? 1048576 : 0) | (isProductApp(oldPackage) ? 2097152 : 0) | (isOdmApp(oldPackage) ? 8388608 : 0);
                                                                    try {
                                                                        sysPkg2 = sysPkg3;
                                                                        mHwPMSEx.resolvePersistentFlagForPackage(oldPackage.applicationInfo.flags, pkg);
                                                                        if (DEBUG_INSTALL) {
                                                                            Slog.d(TAG, "replaceSystemPackageLI: new=" + pkg + ", old=" + oldPackage);
                                                                        }
                                                                        res.setReturnCode(1);
                                                                        pkg.setApplicationInfoFlags(128, 128);
                                                                        targetParseFlags = parseFlags;
                                                                        targetScanFlags = systemScanFlags;
                                                                        replace3 = replace2;
                                                                    } catch (Throwable th43) {
                                                                        th3 = th43;
                                                                        if (shouldCloseFreezerBeforeReturn) {
                                                                        }
                                                                        throw th3;
                                                                    }
                                                                } else {
                                                                    sysPkg2 = sysPkg3;
                                                                    replace3 = true;
                                                                    try {
                                                                        if (DEBUG_INSTALL) {
                                                                            Slog.d(TAG, "replaceNonSystemPackageLI: new=" + pkg + ", old=" + oldPackage);
                                                                        }
                                                                        String str = oldPackage.packageName;
                                                                        if (pkg.mExtras != null) {
                                                                            long j = ((PackageSetting) pkg.mExtras).lastUpdateTime;
                                                                        }
                                                                    } catch (Throwable th44) {
                                                                        th3 = th44;
                                                                        if (shouldCloseFreezerBeforeReturn) {
                                                                        }
                                                                        throw th3;
                                                                    }
                                                                }
                                                                sysPkg = sysPkg2;
                                                                childPackages = childPackages2;
                                                            } catch (Throwable th45) {
                                                                th3 = th45;
                                                                if (shouldCloseFreezerBeforeReturn) {
                                                                }
                                                                throw th3;
                                                            }
                                                        }
                                                    } else {
                                                        targetVolumeUuid = null;
                                                    }
                                                    hwGunstallSwitchState = null;
                                                    synchronized (this.mPackages) {
                                                    }
                                                } catch (Throwable th46) {
                                                    th3 = th46;
                                                    if (shouldCloseFreezerBeforeReturn) {
                                                    }
                                                    throw th3;
                                                }
                                            } else {
                                                shouldCloseFreezerBeforeReturn = true;
                                                sysPkg = false;
                                                targetScanFlags = scanFlags;
                                                targetParseFlags = parseFlags;
                                                installFlags2 = installFlags;
                                                try {
                                                    String pkgName1 = pkg.packageName;
                                                    Flog.i(207, "installNewPackageLI: " + pkg);
                                                    synchronized (this.mPackages) {
                                                        try {
                                                            renamedPackage2 = this.mSettings.getRenamedPackageLPr(pkgName1);
                                                            if (renamedPackage2 == null) {
                                                                try {
                                                                    if (this.mPackages.containsKey(pkgName1)) {
                                                                        throw new PrepareFailure(-1, "Attempt to re-install " + pkgName1 + " without first uninstalling.");
                                                                    }
                                                                } catch (Throwable th47) {
                                                                    th4 = th47;
                                                                    while (true) {
                                                                        break;
                                                                    }
                                                                    throw th4;
                                                                }
                                                            } else {
                                                                throw new PrepareFailure(-1, "Attempt to re-install " + pkgName1 + " without first uninstalling package running as " + renamedPackage2);
                                                            }
                                                        } catch (Throwable th48) {
                                                            th4 = th48;
                                                            while (true) {
                                                                break;
                                                            }
                                                            throw th4;
                                                        }
                                                    }
                                                    ps = null;
                                                    childPackages = null;
                                                    disabledPs = null;
                                                    existingPackage = null;
                                                    targetVolumeUuid = volumeUuid;
                                                    renamedPackage = renamedPackage2;
                                                    replace3 = false;
                                                } catch (Throwable th49) {
                                                    th3 = th49;
                                                    if (shouldCloseFreezerBeforeReturn) {
                                                    }
                                                    throw th3;
                                                }
                                            }
                                            try {
                                                try {
                                                    PrepareResult prepareResult = new PrepareResult(args.installReason, targetVolumeUuid, installerPackageName3, args.user, replace3, targetScanFlags, targetParseFlags, existingPackage, pkg, replace3, sysPkg, renamedPackage, freezer, ps, disabledPs, childPackages);
                                                    if (0 != 0) {
                                                        freezer.close();
                                                    }
                                                    return prepareResult;
                                                } catch (Throwable th50) {
                                                    th3 = th50;
                                                    shouldCloseFreezerBeforeReturn = false;
                                                    if (shouldCloseFreezerBeforeReturn) {
                                                    }
                                                    throw th3;
                                                }
                                            } catch (Throwable th51) {
                                                th3 = th51;
                                                shouldCloseFreezerBeforeReturn = false;
                                                if (shouldCloseFreezerBeforeReturn) {
                                                }
                                                throw th3;
                                            }
                                        } catch (Installer.InstallerException | IOException | DigestException | NoSuchAlgorithmException e12) {
                                            throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "Failed to set up verity: " + e12);
                                        }
                                    } else {
                                        throw new PrepareFailure(-4, "Failed rename");
                                    }
                                } catch (PackageManagerException e13) {
                                    e = e13;
                                    Slog.w(TAG, "Failed checkUninstalledSystemApp: " + e.getMessage());
                                    throw new PrepareFailure("Failed checkUninstalledSystemApp during installPackageLI", e);
                                }
                            } else {
                                throw new PrepareFailure((int) RequestStatus.SYS_ETIMEDOUT, "app disallow install by mdm control");
                            }
                        } catch (PackageParser.PackageParserException e14) {
                            exc2 = e14;
                            throw new PrepareFailure("Failed collect during installPackageLI", exc2);
                        }
                    } else {
                        throw new PrepareFailure(-15, "installPackageLI");
                    }
                    Slog.i(TAG, installerPackageName + " is disallowed to install new app " + pkgName2);
                    throw new PrepareFailure(-111, "Disallow install new apps");
                }
                throw new PrepareFailure(-111, "Package: " + pkg2.packageName + "in the delete_system_app file, no need to install");
            } catch (PackageParser.PackageParserException e15) {
                exc = e15;
                try {
                    throw new PrepareFailure("Failed parse during installPackageLI", exc);
                } catch (Throwable th52) {
                    th = th52;
                    Trace.traceEnd(262144);
                    throw th;
                }
            } catch (Throwable th53) {
                th = th53;
                Trace.traceEnd(262144);
                throw th;
            }
        } else {
            Slog.i(TAG, "Incompatible ephemeral install; external=" + onExternal2);
            throw new PrepareFailure(-116);
        }
    }

    private void setUpFsVerityIfPossible(PackageParser.Package pkg) throws Installer.InstallerException, PrepareFailure, IOException, DigestException, NoSuchAlgorithmException {
        boolean standardMode = PackageManagerServiceUtils.isApkVerityEnabled();
        boolean legacyMode = PackageManagerServiceUtils.isLegacyApkVerityEnabled();
        if (standardMode || legacyMode) {
            ArrayMap<String, String> fsverityCandidates = new ArrayMap<>();
            int i = 0;
            if (legacyMode) {
                synchronized (this.mPackages) {
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null && ps.isPrivileged()) {
                        fsverityCandidates.put(pkg.baseCodePath, null);
                        if (pkg.splitCodePaths != null) {
                            String[] strArr = pkg.splitCodePaths;
                            int length = strArr.length;
                            while (i < length) {
                                fsverityCandidates.put(strArr[i], null);
                                i++;
                            }
                        }
                    }
                }
            } else {
                fsverityCandidates.put(pkg.baseCodePath, VerityUtils.getFsveritySignatureFilePath(pkg.baseCodePath));
                String dmPath = DexMetadataHelper.buildDexMetadataPathForApk(pkg.baseCodePath);
                if (new File(dmPath).exists()) {
                    fsverityCandidates.put(dmPath, VerityUtils.getFsveritySignatureFilePath(dmPath));
                }
                if (pkg.splitCodePaths != null) {
                    String[] strArr2 = pkg.splitCodePaths;
                    int length2 = strArr2.length;
                    while (i < length2) {
                        String path = strArr2[i];
                        fsverityCandidates.put(path, VerityUtils.getFsveritySignatureFilePath(path));
                        String splitDmPath = DexMetadataHelper.buildDexMetadataPathForApk(path);
                        if (new File(splitDmPath).exists()) {
                            fsverityCandidates.put(splitDmPath, VerityUtils.getFsveritySignatureFilePath(splitDmPath));
                        }
                        i++;
                    }
                }
            }
            for (Map.Entry<String, String> entry : fsverityCandidates.entrySet()) {
                String filePath = entry.getKey();
                String signaturePath = entry.getValue();
                if (legacyMode) {
                    VerityUtils.SetupResult result = VerityUtils.generateApkVeritySetupData(filePath);
                    if (result.isOk()) {
                        if (Build.IS_DEBUGGABLE) {
                            Slog.i(TAG, "Enabling verity to " + filePath);
                        }
                        FileDescriptor fd = result.getUnownedFileDescriptor();
                        try {
                            byte[] rootHash = VerityUtils.generateApkVerityRootHash(filePath);
                            try {
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            } catch (Installer.InstallerException e) {
                                this.mInstaller.installApkVerity(filePath, fd, result.getContentSize());
                                this.mInstaller.assertFsverityRootHashMatches(filePath, rootHash);
                            }
                        } finally {
                            IoUtils.closeQuietly(fd);
                        }
                    } else if (result.isFailed()) {
                        throw new PrepareFailure(-118, "Failed to generate verity");
                    }
                } else if (new File(signaturePath).exists() && !VerityUtils.hasFsverity(filePath)) {
                    try {
                        VerityUtils.setUpFsverity(filePath, signaturePath);
                    } catch (IOException | SecurityException | DigestException | NoSuchAlgorithmException e2) {
                        throw new PrepareFailure(-118, "Failed to enable fs-verity: " + e2);
                    }
                }
            }
        }
    }

    private void startIntentFilterVerifications(int userId, boolean replacing, PackageParser.Package pkg) {
        ComponentName componentName = this.mIntentFilterVerifierComponent;
        if (componentName == null) {
            Slog.w(TAG, "No IntentFilter verification will not be done as there is no IntentFilterVerifier available!");
            return;
        }
        int childCount = 0;
        int verifierUid = getPackageUid(componentName.getPackageName(), 268435456, userId == -1 ? 0 : userId);
        Message msg = this.mHandler.obtainMessage(17);
        msg.obj = new IFVerificationParams(pkg, replacing, userId, verifierUid);
        this.mHandler.sendMessage(msg);
        if (pkg.childPackages != null) {
            childCount = pkg.childPackages.size();
        }
        for (int i = 0; i < childCount; i++) {
            Message msg2 = this.mHandler.obtainMessage(17);
            msg2.obj = new IFVerificationParams((PackageParser.Package) pkg.childPackages.get(i), replacing, userId, verifierUid);
            this.mHandler.sendMessage(msg2);
        }
    }

    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:130:0x010f */
    /* JADX DEBUG: Failed to insert an additional move for type inference into block B:105:0x0208 */
    /* JADX DEBUG: Multi-variable search result rejected for r9v2, resolved type: boolean */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r9v1 */
    /* JADX WARN: Type inference failed for: r9v3 */
    /* JADX WARN: Type inference failed for: r9v4 */
    /* JADX WARN: Type inference failed for: r9v10 */
    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    /* JADX WARNING: Removed duplicated region for block: B:82:0x01b0  */
    private void verifyIntentFiltersIfNeeded(int userId, int verifierUid, boolean replacing, PackageParser.Package pkg) {
        IntentFilterVerificationInfo ivi;
        boolean needToRunVerify;
        boolean z;
        boolean z2;
        boolean hostSetExpanded;
        boolean keepCurState;
        PackageParser.Activity a;
        int size = pkg.activities.size();
        if (size == 0) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No activity, so no need to verify any IntentFilter!");
            }
        } else if (hasDomainURLs(pkg)) {
            if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "Checking for userId:" + userId + " if any IntentFilter from the " + size + " Activities needs verification ...");
            }
            int count = 0;
            String packageName = pkg.packageName;
            ArraySet<String> domains = new ArraySet<>();
            synchronized (this.mPackages) {
                try {
                    IntentFilterVerificationInfo ivi2 = this.mSettings.getIntentFilterVerificationLPr(packageName);
                    boolean previouslyVerified = ivi2 != null;
                    if (replacing || !previouslyVerified) {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("    Previous verified hosts: ");
                            sb.append(ivi2 == null ? "[none]" : ivi2.getDomainsString());
                            Slog.i(TAG, sb.toString());
                        }
                        boolean needsVerification = needsNetworkVerificationLPr(packageName);
                        Iterator it = pkg.activities.iterator();
                        boolean handlesWebUris = false;
                        needToRunVerify = false;
                        while (it.hasNext()) {
                            try {
                                Iterator it2 = ((PackageParser.Activity) it.next()).intents.iterator();
                                boolean handlesWebUris2 = handlesWebUris;
                                while (true) {
                                    if (!it2.hasNext()) {
                                        break;
                                    }
                                    PackageParser.ActivityIntentInfo filter = (PackageParser.ActivityIntentInfo) it2.next();
                                    handlesWebUris2 = handlesWebUris2;
                                    if (filter.handlesWebUris(true)) {
                                        handlesWebUris2 = true;
                                    }
                                    if (!needsVerification || !filter.needsVerification()) {
                                        handlesWebUris2 = handlesWebUris2;
                                    } else {
                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                            Slog.d(TAG, "autoVerify requested, processing all filters");
                                        }
                                        needToRunVerify = true;
                                    }
                                }
                                needToRunVerify = needToRunVerify;
                                handlesWebUris = handlesWebUris2;
                            } catch (Throwable th) {
                                ivi = th;
                                throw ivi;
                            }
                        }
                        if (!needToRunVerify) {
                            if (!previouslyVerified) {
                                z2 = 1;
                                z = false;
                                if (DEBUG_DOMAIN_VERIFICATION) {
                                    Slog.i(TAG, "    Update published hosts: " + domains.toString());
                                }
                                hostSetExpanded = (previouslyVerified || (ivi2 != null && !ivi2.getDomains().containsAll(domains))) ? z2 : z;
                                int currentPolicy = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                                if (!hostSetExpanded || currentPolicy != 2) {
                                    keepCurState = z;
                                } else {
                                    boolean z3 = z2 == true ? 1 : 0;
                                    boolean z4 = z2 == true ? 1 : 0;
                                    boolean z5 = z2 == true ? 1 : 0;
                                    boolean z6 = z2 == true ? 1 : 0;
                                    keepCurState = z3;
                                }
                                if (!needToRunVerify && keepCurState) {
                                    if (DEBUG_DOMAIN_VERIFICATION) {
                                        Slog.i(TAG, "Host set not expanding + ALWAYS -> no need to reverify");
                                    }
                                    ivi2.setDomains(domains);
                                    scheduleWriteSettingsLocked();
                                    return;
                                } else if (!previouslyVerified && !needToRunVerify) {
                                    if (keepCurState) {
                                        z2 = z;
                                    }
                                    clearIntentFilterVerificationsLPw(packageName, userId, z2);
                                    return;
                                }
                            }
                        }
                        int verificationId = this.mIntentFilterVerificationToken;
                        this.mIntentFilterVerificationToken = verificationId + 1;
                        Iterator it3 = pkg.activities.iterator();
                        while (it3.hasNext()) {
                            PackageParser.Activity a2 = (PackageParser.Activity) it3.next();
                            Iterator it4 = a2.intents.iterator();
                            int count2 = count;
                            while (it4.hasNext()) {
                                try {
                                    PackageParser.ActivityIntentInfo filter2 = (PackageParser.ActivityIntentInfo) it4.next();
                                    if (filter2.handlesWebUris(false)) {
                                        if (DEBUG_DOMAIN_VERIFICATION) {
                                            Slog.d(TAG, "Verification needed for IntentFilter:" + filter2.toString());
                                        }
                                        a = a2;
                                        this.mIntentFilterVerifier.addOneIntentFilterVerification(verifierUid, userId, verificationId, filter2, packageName);
                                        domains.addAll(filter2.getHostsList());
                                        count2++;
                                    } else {
                                        a = a2;
                                    }
                                    a2 = a;
                                } catch (Throwable th2) {
                                    ivi = th2;
                                    throw ivi;
                                }
                            }
                            count = count2;
                        }
                        z2 = 1;
                        z = false;
                        if (DEBUG_DOMAIN_VERIFICATION) {
                        }
                        if (previouslyVerified) {
                        }
                        int currentPolicy2 = this.mSettings.getIntentFilterVerificationStatusLPr(packageName, userId);
                        if (!hostSetExpanded) {
                        }
                        keepCurState = z;
                        if (!needToRunVerify) {
                        }
                        if (!previouslyVerified) {
                        }
                    } else {
                        if (DEBUG_DOMAIN_VERIFICATION) {
                            Slog.i(TAG, "Package " + packageName + " already verified: status=" + ivi2.getStatusString());
                        }
                        return;
                    }
                } catch (Throwable th3) {
                    ivi = th3;
                    throw ivi;
                }
            }
            if (needToRunVerify && count > 0) {
                if (DEBUG_DOMAIN_VERIFICATION) {
                    StringBuilder sb2 = new StringBuilder();
                    sb2.append("Starting ");
                    sb2.append(count);
                    sb2.append(" IntentFilter verification");
                    sb2.append(count > z2 ? "s" : "");
                    sb2.append(" for userId:");
                    sb2.append(userId);
                    Slog.d(TAG, sb2.toString());
                }
                this.mIntentFilterVerifier.startVerifications(userId);
            } else if (DEBUG_DOMAIN_VERIFICATION) {
                Slog.d(TAG, "No web filters or no new host policy for " + packageName);
            }
        } else if (DEBUG_DOMAIN_VERIFICATION) {
            Slog.d(TAG, "No domain URLs, so no need to verify any IntentFilter!");
        }
    }

    @GuardedBy({"mPackages"})
    private boolean needsNetworkVerificationLPr(String packageName) {
        int status;
        IntentFilterVerificationInfo ivi = this.mSettings.getIntentFilterVerificationLPr(packageName);
        if (ivi == null || (status = ivi.getStatus()) == 0 || status == 1 || status == 2) {
            return true;
        }
        return false;
    }

    private static boolean isMultiArch(ApplicationInfo info) {
        return (info.flags & Integer.MIN_VALUE) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isExternal(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 262144) != 0;
    }

    private static boolean isExternal(PackageSetting ps) {
        return (ps.pkgFlags & 262144) != 0;
    }

    /* access modifiers changed from: private */
    public static boolean isSystemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.flags & 1) != 0;
    }

    private static boolean isPrivilegedApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 8) != 0;
    }

    private static boolean isOemApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 131072) != 0;
    }

    private static boolean isVendorApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 262144) != 0;
    }

    private static boolean isProductApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 524288) != 0;
    }

    private static boolean isProductServicesApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 2097152) != 0;
    }

    private static boolean isOdmApp(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 1073741824) != 0;
    }

    private static boolean hasDomainURLs(PackageParser.Package pkg) {
        return (pkg.applicationInfo.privateFlags & 16) != 0;
    }

    private static boolean isSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 1) != 0;
    }

    private static boolean isUpdatedSystemApp(PackageSetting ps) {
        return (ps.pkgFlags & 128) != 0;
    }

    private Settings.VersionInfo getSettingsVersionForPackage(PackageParser.Package pkg) {
        if (!isExternal(pkg)) {
            return this.mSettings.getInternalVersion();
        }
        if (TextUtils.isEmpty(pkg.volumeUuid)) {
            return this.mSettings.getExternalVersion();
        }
        return this.mSettings.findOrCreateVersion(pkg.volumeUuid);
    }

    private void deleteTempPackageFiles() {
        $$Lambda$PackageManagerService$62xvSFYLew0DWoz4SkFLSkHjBU r0 = $$Lambda$PackageManagerService$62xvSFYLew0DWoz4SkFLSkHjBU.INSTANCE;
    }

    static /* synthetic */ boolean lambda$deleteTempPackageFiles$19(File dir, String name) {
        return name.startsWith("vmdl") && name.endsWith(".tmp");
    }

    public void deletePackageAsUser(String packageName, int versionCode, IPackageDeleteObserver observer, int userId, int flags) {
        deletePackageVersioned(new VersionedPackage(packageName, versionCode), new PackageManager.LegacyPackageDeleteObserver(observer).getBinder(), userId, flags);
    }

    /* JADX WARNING: Code restructure failed: missing block: B:52:0x015e, code lost:
        r0 = th;
     */
    public void deletePackageVersioned(VersionedPackage versionedPackage, IPackageDeleteObserver2 observer, int userId, int deleteFlags) {
        String internalPackageName;
        int callingUid = Binder.getCallingUid();
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        boolean canViewInstantApps = canViewInstantApps(callingUid, userId);
        Preconditions.checkNotNull(versionedPackage);
        Preconditions.checkNotNull(observer);
        Preconditions.checkArgumentInRange(versionedPackage.getLongVersionCode(), -1, (long) JobStatus.NO_LATEST_RUNTIME, "versionCode must be >= -1");
        String packageName = versionedPackage.getPackageName();
        long versionCode = versionedPackage.getLongVersionCode();
        synchronized (this.mPackages) {
            internalPackageName = resolveInternalPackageNameLPr(packageName, versionCode);
        }
        int uid = Binder.getCallingUid();
        if (isOrphaned(internalPackageName) || isCallerAllowedToSilentlyUninstall(uid, internalPackageName)) {
            boolean deleteAllUsers = (deleteFlags & 2) != 0;
            int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]{userId};
            if (UserHandle.getUserId(uid) != userId || (deleteAllUsers && users.length > 1)) {
                Context context = this.mContext;
                context.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "deletePackage for user " + userId);
            }
            if (isUserRestricted(userId, "no_uninstall_apps")) {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$1JG8qNS9Pf_Vy5QuXkI_0x57268 */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$21(this.f$0, this.f$1);
                    }
                });
                return;
            } else if (!deleteAllUsers && getBlockUninstallForUser(internalPackageName, userId)) {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$gFqmgisdF87zjhXdkVlcZ6o6RcU */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$22(this.f$0, this.f$1);
                    }
                });
                return;
            } else if (mHwPMSEx.isNeedForbidHarmfulAppSlientDeleteApp(packageName)) {
                this.mHandler.post(new Runnable(observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$fY_nnjN_Ni8wawWS9ezZts0lmmY */
                    private final /* synthetic */ IPackageDeleteObserver2 f$0;
                    private final /* synthetic */ String f$1;

                    {
                        this.f$0 = r1;
                        this.f$1 = r2;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.lambda$deletePackageVersioned$23(this.f$0, this.f$1);
                    }
                });
                Slog.i(TAG, "forbid packageName " + packageName + " be deleted!");
                return;
            } else {
                if (DEBUG_REMOVE) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("deletePackageAsUser: pkg=");
                    sb.append(internalPackageName);
                    sb.append(" user=");
                    sb.append(userId);
                    sb.append(" deleteAllUsers: ");
                    sb.append(deleteAllUsers);
                    sb.append(" version=");
                    sb.append(versionCode == -1 ? "VERSION_CODE_HIGHEST" : Long.valueOf(versionCode));
                    Slog.d(TAG, sb.toString());
                }
                this.mHandler.post(new Runnable(internalPackageName, callingUid, canViewInstantApps, deleteAllUsers, versionCode, userId, deleteFlags, users, observer, packageName) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$HlhQaOlv5Zi_eRE98LaAZ56Ybr4 */
                    private final /* synthetic */ String f$1;
                    private final /* synthetic */ String f$10;
                    private final /* synthetic */ int f$2;
                    private final /* synthetic */ boolean f$3;
                    private final /* synthetic */ boolean f$4;
                    private final /* synthetic */ long f$5;
                    private final /* synthetic */ int f$6;
                    private final /* synthetic */ int f$7;
                    private final /* synthetic */ int[] f$8;
                    private final /* synthetic */ IPackageDeleteObserver2 f$9;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r4;
                        this.f$4 = r5;
                        this.f$5 = r6;
                        this.f$6 = r8;
                        this.f$7 = r9;
                        this.f$8 = r10;
                        this.f$9 = r11;
                        this.f$10 = r12;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.this.lambda$deletePackageVersioned$24$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6, this.f$7, this.f$8, this.f$9, this.f$10);
                    }
                });
                return;
            }
        } else {
            this.mHandler.post(new Runnable(packageName, observer) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$a0KwVfjTwG7XHbMM19bYN79pbT8 */
                private final /* synthetic */ String f$0;
                private final /* synthetic */ IPackageDeleteObserver2 f$1;

                {
                    this.f$0 = r1;
                    this.f$1 = r2;
                }

                @Override // java.lang.Runnable
                public final void run() {
                    PackageManagerService.lambda$deletePackageVersioned$20(this.f$0, this.f$1);
                }
            });
            return;
        }
        while (true) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$20(String packageName, IPackageDeleteObserver2 observer) {
        try {
            Intent intent = new Intent("android.intent.action.UNINSTALL_PACKAGE");
            intent.setData(Uri.fromParts("package", packageName, null));
            intent.putExtra("android.content.pm.extra.CALLBACK", observer.asBinder());
            observer.onUserActionRequired(intent);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$21(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -3, (String) null);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$22(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -4, (String) null);
        } catch (RemoteException e) {
        }
    }

    static /* synthetic */ void lambda$deletePackageVersioned$23(IPackageDeleteObserver2 observer, String packageName) {
        try {
            observer.onPackageDeleted(packageName, -1, (String) null);
        } catch (RemoteException e) {
            Slog.i(TAG, "Observer no longer exists.");
        }
    }

    public /* synthetic */ void lambda$deletePackageVersioned$24$PackageManagerService(String internalPackageName, int callingUid, boolean canViewInstantApps, boolean deleteAllUsers, long versionCode, int userId, int deleteFlags, int[] users, IPackageDeleteObserver2 observer, String packageName) {
        boolean doDeletePackage;
        int returnCode;
        int returnCode2;
        int i;
        PackageSetting ps = this.mSettings.mPackages.get(internalPackageName);
        if (ps != null) {
            doDeletePackage = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || canViewInstantApps;
        } else {
            doDeletePackage = true;
        }
        if (!doDeletePackage) {
            returnCode = -1;
        } else if (!deleteAllUsers) {
            returnCode = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
        } else {
            int[] blockUninstallUserIds = getBlockUninstallForUsers(internalPackageName, users);
            if (ArrayUtils.isEmpty(blockUninstallUserIds)) {
                returnCode2 = deletePackageX(internalPackageName, versionCode, userId, deleteFlags);
            } else {
                int userFlags = deleteFlags & -3;
                int length = users.length;
                int i2 = 0;
                while (i2 < length) {
                    int userId1 = users[i2];
                    if (!ArrayUtils.contains(blockUninstallUserIds, userId1)) {
                        i = i2;
                        int returnCode3 = deletePackageX(internalPackageName, versionCode, userId1, userFlags);
                        if (returnCode3 != 1) {
                            Slog.w(TAG, "Package delete failed for user " + userId1 + ", returnCode " + returnCode3);
                        }
                    } else {
                        i = i2;
                    }
                    i2 = i + 1;
                }
                returnCode2 = -4;
            }
            returnCode = returnCode2;
        }
        if (returnCode == 1) {
            reportDeleteEvent(callingUid);
        }
        try {
            observer.onPackageDeleted(packageName, returnCode, (String) null);
        } catch (RemoteException e) {
            Log.i(TAG, "Observer no longer exists.");
        }
    }

    private void reportDeleteEvent(final int callingUid) {
        Set<Long> deleteTimeSet;
        synchronized (this.mDeletePackageCallMap) {
            if (this.mDeletePackageCallMap.containsKey(Integer.valueOf(callingUid))) {
                deleteTimeSet = this.mDeletePackageCallMap.get(Integer.valueOf(callingUid));
            } else {
                deleteTimeSet = new HashSet<>();
            }
            deleteTimeSet.add(Long.valueOf(SystemClock.elapsedRealtime()));
            this.mDeletePackageCallMap.put(Integer.valueOf(callingUid), deleteTimeSet);
            if (!this.mDeleteCheckingSet.contains(Integer.valueOf(callingUid))) {
                this.mDeleteCheckingSet.add(Integer.valueOf(callingUid));
                new Handler().postDelayed(new Runnable() {
                    /* class com.android.server.pm.PackageManagerService.AnonymousClass4 */

                    @Override // java.lang.Runnable
                    public void run() {
                        synchronized (PackageManagerService.this.mDeletePackageCallMap) {
                            int deleteCount = ((Set) PackageManagerService.this.mDeletePackageCallMap.get(Integer.valueOf(callingUid))).size();
                            if (deleteCount >= 5) {
                                long elapsedRealtime = SystemClock.elapsedRealtime();
                                String callingName = PackageManagerService.this.getNameForUid(callingUid);
                                Slog.i(PackageManagerService.TAG, "Delete package occur frequently, delete " + deleteCount + " package, callingUid:" + callingUid + ", callingName:" + callingName + ", elapsedRealtime:" + elapsedRealtime);
                                HwPackageManagerServiceUtils.reportPmsDeleteDataApp(callingUid, callingName, deleteCount, elapsedRealtime);
                            }
                            PackageManagerService.this.mDeletePackageCallMap.remove(Integer.valueOf(callingUid));
                            PackageManagerService.this.mDeleteCheckingSet.remove(Integer.valueOf(callingUid));
                        }
                    }
                }, 60000);
            }
        }
    }

    private String resolveExternalPackageNameLPr(PackageParser.Package pkg) {
        if (pkg.staticSharedLibName != null) {
            return pkg.manifestPackageName;
        }
        return pkg.packageName;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String resolveInternalPackageNameLPr(String packageName, long versionCode) {
        String normalizedPackageName = this.mSettings.getRenamedPackageLPr(packageName);
        String packageName2 = normalizedPackageName != null ? normalizedPackageName : packageName;
        LongSparseArray<SharedLibraryInfo> versionedLib = this.mStaticLibsByDeclaringPackage.get(packageName2);
        if (versionedLib == null || versionedLib.size() <= 0) {
            return packageName2;
        }
        LongSparseLongArray versionsCallerCanSee = null;
        int callingAppId = UserHandle.getAppId(Binder.getCallingUid());
        if (!(callingAppId == 1000 || callingAppId == 2000 || callingAppId == 0)) {
            versionsCallerCanSee = new LongSparseLongArray();
            String libName = versionedLib.valueAt(0).getName();
            String[] uidPackages = getPackagesForUid(Binder.getCallingUid());
            if (uidPackages != null) {
                for (String uidPackage : uidPackages) {
                    PackageSetting ps = this.mSettings.getPackageLPr(uidPackage);
                    int libIdx = ArrayUtils.indexOf(ps.usesStaticLibraries, libName);
                    if (libIdx >= 0) {
                        long libVersion = ps.usesStaticLibrariesVersions[libIdx];
                        versionsCallerCanSee.append(libVersion, libVersion);
                    }
                }
            }
        }
        if (versionsCallerCanSee != null && versionsCallerCanSee.size() <= 0) {
            return packageName2;
        }
        SharedLibraryInfo highestVersion = null;
        int versionCount = versionedLib.size();
        for (int i = 0; i < versionCount; i++) {
            SharedLibraryInfo libraryInfo = versionedLib.valueAt(i);
            if (versionsCallerCanSee == null || versionsCallerCanSee.indexOfKey(libraryInfo.getLongVersion()) >= 0) {
                long libVersionCode = libraryInfo.getDeclaringPackage().getLongVersionCode();
                if (versionCode != -1) {
                    if (libVersionCode == versionCode) {
                        return libraryInfo.getPackageName();
                    }
                } else if (highestVersion == null) {
                    highestVersion = libraryInfo;
                } else if (libVersionCode > highestVersion.getDeclaringPackage().getLongVersionCode()) {
                    highestVersion = libraryInfo;
                }
            }
        }
        if (highestVersion != null) {
            return highestVersion.getPackageName();
        }
        return packageName2;
    }

    /* access modifiers changed from: package-private */
    public boolean isCallerVerifier(int callingUid) {
        int callingUserId = UserHandle.getUserId(callingUid);
        String str = this.mRequiredVerifierPackage;
        if (str == null || callingUid != getPackageUid(str, 0, callingUserId)) {
            return false;
        }
        return true;
    }

    private boolean isCallerAllowedToSilentlyUninstall(int callingUid, String pkgName) {
        if (callingUid == 2000 || callingUid == 0 || UserHandle.getAppId(callingUid) == 1000) {
            return true;
        }
        int callingUserId = UserHandle.getUserId(callingUid);
        if (callingUid == getPackageUid(getInstallerPackageName(pkgName), 0, callingUserId)) {
            return true;
        }
        String str = this.mRequiredVerifierPackage;
        if (str != null && callingUid == getPackageUid(str, 0, callingUserId)) {
            return true;
        }
        String str2 = this.mRequiredUninstallerPackage;
        if (str2 != null && callingUid == getPackageUid(str2, 0, callingUserId)) {
            return true;
        }
        String str3 = this.mStorageManagerPackage;
        if ((str3 == null || callingUid != getPackageUid(str3, 0, callingUserId)) && checkUidPermission("android.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS", callingUid) != 0) {
            return false;
        }
        return true;
    }

    private int[] getBlockUninstallForUsers(String packageName, int[] userIds) {
        int[] result = EMPTY_INT_ARRAY;
        for (int userId : userIds) {
            if (getBlockUninstallForUser(packageName, userId)) {
                result = ArrayUtils.appendInt(result, userId);
            }
        }
        return result;
    }

    public boolean isPackageDeviceAdminOnAnyUser(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (checkUidPermission("android.permission.MANAGE_USERS", callingUid) != 0) {
            EventLog.writeEvent(1397638484, "128599183", -1, "");
            throw new SecurityException("android.permission.MANAGE_USERS permission is required to call this API");
        } else if (getInstantAppPackageName(callingUid) == null || isCallerSameApp(packageName, callingUid)) {
            return isPackageDeviceAdmin(packageName, -1);
        } else {
            return false;
        }
    }

    private boolean isPackageDeviceAdmin(String packageName, int userId) {
        IDevicePolicyManager dpm;
        String deviceOwnerPackageName;
        int[] users;
        if (!(packageName == null || (dpm = IDevicePolicyManager.Stub.asInterface(ServiceManager.getService("device_policy"))) == null)) {
            try {
                ComponentName deviceOwnerComponentName = dpm.getDeviceOwnerComponent(false);
                if (deviceOwnerComponentName == null) {
                    deviceOwnerPackageName = null;
                } else {
                    deviceOwnerPackageName = deviceOwnerComponentName.getPackageName();
                }
                if (packageName.equals(deviceOwnerPackageName)) {
                    return true;
                }
                for (int i : userId == -1 ? sUserManager.getUserIds() : new int[]{userId}) {
                    if (dpm.packageHasActiveAdmins(packageName, i)) {
                        return true;
                    }
                }
            } catch (RemoteException e) {
            }
        }
        return false;
    }

    private boolean shouldKeepUninstalledPackageLPr(String packageName) {
        List<String> list = this.mKeepUninstalledPackages;
        return list != null && list.contains(packageName);
    }

    private boolean isForbidModeShowDialog() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "gunstall_forbid_mode", 0) != 0;
    }

    /* JADX INFO: Multiple debug info for r12v4 'freezer'  com.android.server.pm.PackageManagerService$PackageFreezer: [D('freezeUser' int), D('freezer' com.android.server.pm.PackageManagerService$PackageFreezer)] */
    /* access modifiers changed from: package-private */
    /* JADX WARNING: Code restructure failed: missing block: B:218:0x03c7, code lost:
        r0 = th;
     */
    public int deletePackageX(String packageName, long versionCode, int userId, int deleteFlags) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        PackageSetting disabledSystemPs;
        int origEnabledState;
        int freezeUser;
        int deleteFlags2;
        Object obj;
        Throwable th2;
        PackageFreezer freezer;
        Throwable th3;
        Throwable th4;
        Throwable th5;
        Throwable th6;
        int origEnabledState2;
        PackageSetting disabledSystemPs2;
        int origEnabledState3;
        int currUserId;
        int currUserId2;
        PackageRemovedInfo info = new PackageRemovedInfo(this);
        int i = -1;
        int removeUser = (deleteFlags & 2) != 0 ? -1 : userId;
        if (!mHwPMSEx.isAllowUninstallApp(packageName)) {
            Slog.w(TAG, "Not removing package " + packageName + ": limited by its own");
            return -1;
        }
        HwFrameworkFactory.getHwBehaviorCollectManager().sendEvent(2, 0, 0, packageName, (String) null);
        if (isPackageDeviceAdmin(packageName, removeUser)) {
            Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
            if (!IS_GMS_SCHEME || !isForbidModeShowDialog() || !GMS_CORE_NAME.equals(packageName)) {
                return -2;
            }
            Slog.w(TAG, "gunstall need to");
        }
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx = mHwPMSEx;
        if (iHwPackageManagerServiceEx == null || !iHwPackageManagerServiceEx.isDisallowUninstallApk(packageName)) {
            ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
            synchronized (arrayMap2) {
                try {
                    PackageSetting uninstalledPs = this.mSettings.mPackages.get(packageName);
                    if (uninstalledPs == null) {
                        try {
                            Slog.w(TAG, "Not removing non-existent package " + packageName);
                            return -1;
                        } catch (Throwable th7) {
                            th = th7;
                            arrayMap = arrayMap2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th8) {
                                    th = th8;
                                }
                            }
                            throw th;
                        }
                    } else if (versionCode == -1 || uninstalledPs.versionCode == versionCode) {
                        PackageSetting disabledSystemPs3 = this.mSettings.getDisabledSystemPkgLPr(packageName);
                        int origEnabledState4 = uninstalledPs.getEnabled(userId);
                        PackageParser.Package pkg = this.mPackages.get(packageName);
                        int[] allUsers = sUserManager.getUserIds();
                        if (pkg == null || pkg.staticSharedLibName == null) {
                            arrayMap = arrayMap2;
                            origEnabledState = origEnabledState4;
                            disabledSystemPs = disabledSystemPs3;
                        } else {
                            arrayMap = arrayMap2;
                            try {
                                SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(pkg.staticSharedLibName, pkg.staticSharedLibVersion);
                                if (libraryInfo != null) {
                                    int length = allUsers.length;
                                    int i2 = 0;
                                    while (i2 < length) {
                                        int currUserId3 = allUsers[i2];
                                        if (removeUser != i) {
                                            currUserId2 = currUserId3;
                                            if (removeUser != currUserId2) {
                                                currUserId = length;
                                                origEnabledState3 = origEnabledState4;
                                                disabledSystemPs2 = disabledSystemPs3;
                                                i2++;
                                                length = currUserId;
                                                origEnabledState4 = origEnabledState3;
                                                disabledSystemPs3 = disabledSystemPs2;
                                                i = -1;
                                            }
                                        } else {
                                            currUserId2 = currUserId3;
                                        }
                                        currUserId = length;
                                        List<VersionedPackage> libClientPackages = getPackagesUsingSharedLibraryLPr(libraryInfo, 4202496, currUserId2);
                                        if (!ArrayUtils.isEmpty(libClientPackages)) {
                                            Slog.w(TAG, "Not removing package " + pkg.manifestPackageName + " hosting lib " + libraryInfo.getName() + " version " + libraryInfo.getLongVersion() + " used by " + libClientPackages + " for user " + currUserId2);
                                            return -6;
                                        }
                                        origEnabledState3 = origEnabledState4;
                                        disabledSystemPs2 = disabledSystemPs3;
                                        i2++;
                                        length = currUserId;
                                        origEnabledState4 = origEnabledState3;
                                        disabledSystemPs3 = disabledSystemPs2;
                                        i = -1;
                                    }
                                    origEnabledState = origEnabledState4;
                                    disabledSystemPs = disabledSystemPs3;
                                } else {
                                    origEnabledState = origEnabledState4;
                                    disabledSystemPs = disabledSystemPs3;
                                }
                            } catch (Throwable th9) {
                                th = th9;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        }
                        try {
                            info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);
                            if (!isUpdatedSystemApp(uninstalledPs) || (deleteFlags & 4) != 0) {
                                freezeUser = removeUser;
                            } else {
                                freezeUser = -1;
                            }
                            if (!HwPackageManagerServiceUtils.isInAntiFillingWhiteList(packageName, hasSystemFeature("android.software.home_screen", 0)) || (uninstalledPs.pkgFlags & 1) == 0) {
                                deleteFlags2 = deleteFlags;
                            } else if (isUpdatedSystemApp(uninstalledPs)) {
                                deleteFlags2 = deleteFlags & -5;
                            } else {
                                Slog.w(TAG, "Not removing package " + packageName + ": limited by anti-filling");
                                return -1;
                            }
                            Object obj2 = this.mInstallLock;
                            synchronized (obj2) {
                                try {
                                    Slog.i(TAG, "deletePackageX: pkg = " + packageName + " user = " + userId);
                                    PackageFreezer freezer2 = freezePackageForDelete(packageName, freezeUser, deleteFlags2, "deletePackageX");
                                    try {
                                        obj = obj2;
                                        freezer = freezer2;
                                        try {
                                            boolean res = deletePackageLIF(packageName, UserHandle.of(removeUser), true, allUsers, deleteFlags2 | Integer.MIN_VALUE, info, true, null);
                                            PackageParser.Package stubPkg = null;
                                            if (freezer != null) {
                                                try {
                                                    $closeResource(null, freezer);
                                                } catch (Throwable th10) {
                                                    th2 = th10;
                                                }
                                            }
                                            try {
                                                synchronized (this.mPackages) {
                                                    if (res) {
                                                        if (pkg != null) {
                                                            try {
                                                                this.mInstantAppRegistry.onPackageUninstalledLPw(pkg, info.removedUsers);
                                                            } catch (Throwable th11) {
                                                                th4 = th11;
                                                            }
                                                        }
                                                        try {
                                                            try {
                                                                updateSequenceNumberLP(uninstalledPs, info.removedUsers);
                                                                updateInstantAppInstallerLocked(packageName);
                                                            } catch (Throwable th12) {
                                                                th4 = th12;
                                                            }
                                                        } catch (Throwable th13) {
                                                            th4 = th13;
                                                            while (true) {
                                                                try {
                                                                    break;
                                                                } catch (Throwable th14) {
                                                                    th4 = th14;
                                                                }
                                                            }
                                                            throw th4;
                                                        }
                                                    }
                                                    try {
                                                    } catch (Throwable th15) {
                                                        th4 = th15;
                                                        while (true) {
                                                            break;
                                                        }
                                                        throw th4;
                                                    }
                                                }
                                            } catch (Throwable th16) {
                                                th2 = th16;
                                                throw th2;
                                            }
                                            try {
                                                if (res) {
                                                    if (info.removedForAllUsers || info.isRemovedPackageSystemUpdate) {
                                                        mHwPMSEx.updatePackageBlackListInfo(packageName);
                                                    }
                                                    mHwPMSEx.sendIncompatibleNotificationIfNeeded(packageName);
                                                    info.sendPackageRemovedBroadcasts((deleteFlags2 & 8) == 0);
                                                    info.sendSystemPackageUpdatedBroadcasts();
                                                    info.sendSystemPackageAppearedBroadcasts();
                                                }
                                                Runtime.getRuntime().gc();
                                                synchronized (this.mInstallLock) {
                                                    try {
                                                        if (info.args != null) {
                                                            try {
                                                                info.args.doPostDeleteLI(true);
                                                            } catch (Throwable th17) {
                                                                th5 = th17;
                                                            }
                                                        }
                                                        if (disabledSystemPs != null) {
                                                            try {
                                                                stubPkg = disabledSystemPs.pkg;
                                                            } catch (Throwable th18) {
                                                                th5 = th18;
                                                                throw th5;
                                                            }
                                                        }
                                                        if (stubPkg != null && stubPkg.isStub) {
                                                            synchronized (this.mPackages) {
                                                                try {
                                                                    PackageSetting stubPs = this.mSettings.mPackages.get(stubPkg.packageName);
                                                                    if (stubPs != null) {
                                                                        origEnabledState2 = origEnabledState;
                                                                        try {
                                                                            stubPs.setEnabled(origEnabledState2, userId, PLATFORM_PACKAGE_NAME);
                                                                        } catch (Throwable th19) {
                                                                            th6 = th19;
                                                                            throw th6;
                                                                        }
                                                                    } else {
                                                                        origEnabledState2 = origEnabledState;
                                                                    }
                                                                } catch (Throwable th20) {
                                                                    th6 = th20;
                                                                    throw th6;
                                                                }
                                                            }
                                                            if (origEnabledState2 == 0 || origEnabledState2 == 1) {
                                                                try {
                                                                    if (DEBUG_COMPRESSION) {
                                                                        Slog.i(TAG, "Enabling system stub after removal; pkg: " + stubPkg.packageName);
                                                                    }
                                                                    enableCompressedPackage(stubPkg);
                                                                } catch (Throwable th21) {
                                                                    th5 = th21;
                                                                    throw th5;
                                                                }
                                                            }
                                                        }
                                                    } catch (Throwable th22) {
                                                        th5 = th22;
                                                        throw th5;
                                                    }
                                                }
                                                if (res) {
                                                    return 1;
                                                }
                                                return -1;
                                            } catch (Throwable th23) {
                                                th2 = th23;
                                                throw th2;
                                            }
                                        } catch (Throwable th24) {
                                            th3 = th24;
                                            try {
                                                throw th3;
                                            } catch (Throwable th25) {
                                                if (freezer != null) {
                                                    $closeResource(th3, freezer);
                                                }
                                                throw th25;
                                            }
                                        }
                                    } catch (Throwable th26) {
                                        freezer = freezer2;
                                        th3 = th26;
                                        throw th3;
                                    }
                                } catch (Throwable th27) {
                                    th2 = th27;
                                    obj = obj2;
                                    throw th2;
                                }
                            }
                        } catch (Throwable th28) {
                            th = th28;
                            while (true) {
                                break;
                            }
                            throw th;
                        }
                    } else {
                        Slog.w(TAG, "Not removing package " + packageName + " with versionCode " + uninstalledPs.versionCode + " != " + versionCode);
                        return -1;
                    }
                } catch (Throwable th29) {
                    th = th29;
                    arrayMap = arrayMap2;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            }
        } else {
            Flog.i(209, "Not removing package " + packageName + ": is disallowed!");
            return -4;
        }
    }

    /* access modifiers changed from: package-private */
    public static class PackageRemovedInfo {
        ArrayMap<String, PackageInstalledInfo> appearedChildPackages;
        InstallArgs args = null;
        int[] broadcastUsers = null;
        boolean dataRemoved;
        SparseArray<Integer> installReasons;
        String installerPackageName;
        int[] instantUserIds = null;
        boolean isRemovedPackageSystemUpdate = false;
        boolean isStaticSharedLib;
        boolean isUpdate;
        int[] origUsers;
        final PackageSender packageSender;
        int removedAppId = -1;
        ArrayMap<String, PackageRemovedInfo> removedChildPackages;
        boolean removedForAllUsers;
        String removedPackage;
        int[] removedUsers = null;
        int uid = -1;

        PackageRemovedInfo(PackageSender packageSender2) {
            this.packageSender = packageSender2;
        }

        /* access modifiers changed from: package-private */
        public void sendPackageRemovedBroadcasts(boolean killApp) {
            sendPackageRemovedBroadcastInternal(killApp);
            ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
            int childCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < childCount; i++) {
                this.removedChildPackages.valueAt(i).sendPackageRemovedBroadcastInternal(killApp);
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageUpdatedBroadcasts() {
            if (this.isRemovedPackageSystemUpdate) {
                sendSystemPackageUpdatedBroadcastsInternal();
                ArrayMap<String, PackageRemovedInfo> arrayMap = this.removedChildPackages;
                int childCount = arrayMap != null ? arrayMap.size() : 0;
                for (int i = 0; i < childCount; i++) {
                    PackageRemovedInfo childInfo = this.removedChildPackages.valueAt(i);
                    if (childInfo.isRemovedPackageSystemUpdate) {
                        childInfo.sendSystemPackageUpdatedBroadcastsInternal();
                    }
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void sendSystemPackageAppearedBroadcasts() {
            ArrayMap<String, PackageInstalledInfo> arrayMap = this.appearedChildPackages;
            int packageCount = arrayMap != null ? arrayMap.size() : 0;
            for (int i = 0; i < packageCount; i++) {
                PackageInstalledInfo installedInfo = this.appearedChildPackages.valueAt(i);
                this.packageSender.sendPackageAddedForNewUsers(installedInfo.name, true, false, UserHandle.getAppId(installedInfo.uid), installedInfo.newUsers, null);
            }
        }

        private void sendSystemPackageUpdatedBroadcastsInternal() {
            Bundle extras = new Bundle(2);
            int i = this.removedAppId;
            if (i < 0) {
                i = this.uid;
            }
            extras.putInt("android.intent.extra.UID", i);
            extras.putBoolean("android.intent.extra.REPLACING", true);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, null, null, null, null);
            this.packageSender.sendPackageBroadcast("android.intent.action.MY_PACKAGE_REPLACED", null, null, 0, this.removedPackage, null, null, null);
            String str = this.installerPackageName;
            if (str != null) {
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_ADDED", this.removedPackage, extras, 0, str, null, null, null);
                this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REPLACED", this.removedPackage, extras, 0, this.installerPackageName, null, null, null);
            }
        }

        private void sendPackageRemovedBroadcastInternal(boolean killApp) {
            if (!this.isStaticSharedLib) {
                Bundle extras = new Bundle(2);
                int removedUid = this.removedAppId;
                if (removedUid < 0) {
                    removedUid = this.uid;
                }
                extras.putInt("android.intent.extra.UID", removedUid);
                extras.putBoolean("android.intent.extra.DATA_REMOVED", this.dataRemoved);
                extras.putBoolean("android.intent.extra.DONT_KILL_APP", !killApp);
                if (this.isUpdate || this.isRemovedPackageSystemUpdate) {
                    extras.putBoolean("android.intent.extra.REPLACING", true);
                }
                extras.putBoolean("android.intent.extra.REMOVED_FOR_ALL_USERS", this.removedForAllUsers);
                String str = this.removedPackage;
                if (str != null) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", str, extras, 0, null, null, this.broadcastUsers, this.instantUserIds);
                    String str2 = this.installerPackageName;
                    if (str2 != null) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_REMOVED", this.removedPackage, extras, 0, str2, null, this.broadcastUsers, this.instantUserIds);
                    }
                    if (this.dataRemoved && !this.isRemovedPackageSystemUpdate) {
                        this.packageSender.sendPackageBroadcast("android.intent.action.PACKAGE_FULLY_REMOVED", this.removedPackage, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                        this.packageSender.notifyPackageRemoved(this.removedPackage, removedUid);
                    }
                }
                if (this.removedAppId >= 0) {
                    this.packageSender.sendPackageBroadcast("android.intent.action.UID_REMOVED", null, extras, DumpState.DUMP_SERVICE_PERMISSIONS, null, null, this.broadcastUsers, this.instantUserIds);
                }
                PackageSender packageSender2 = this.packageSender;
                if (packageSender2 instanceof PackageManagerService) {
                    ((PackageManagerService) packageSender2).deleteClonedProfileIfNeed(this.broadcastUsers);
                }
            }
        }

        /* access modifiers changed from: package-private */
        public void populateUsers(int[] userIds, PackageSetting deletedPackageSetting) {
            this.removedUsers = userIds;
            if (this.removedUsers == null) {
                this.broadcastUsers = null;
                return;
            }
            this.broadcastUsers = PackageManagerService.EMPTY_INT_ARRAY;
            this.instantUserIds = PackageManagerService.EMPTY_INT_ARRAY;
            for (int i = userIds.length - 1; i >= 0; i--) {
                int userId = userIds[i];
                if (deletedPackageSetting.getInstantApp(userId)) {
                    this.instantUserIds = ArrayUtils.appendInt(this.instantUserIds, userId);
                } else {
                    this.broadcastUsers = ArrayUtils.appendInt(this.broadcastUsers, userId);
                }
            }
        }
    }

    private void removePackageDataLIF(PackageSetting deletedPs, int[] allUserHandles, PackageRemovedInfo outInfo, int flags, boolean writeSettings) {
        PackageParser.Package resolvedPkg;
        String packageName = deletedPs.name;
        Slog.i(TAG, "removePackageDataLI: " + packageName);
        PackageParser.Package deletedPkg = deletedPs.pkg;
        if (outInfo != null) {
            outInfo.removedPackage = packageName;
            outInfo.installerPackageName = deletedPs.installerPackageName;
            outInfo.isStaticSharedLib = (deletedPkg == null || deletedPkg.staticSharedLibName == null) ? false : true;
            outInfo.populateUsers(deletedPs.queryInstalledUsers(sUserManager.getUserIds(), true), deletedPs);
        }
        removePackageLI(deletedPs.name, (flags & Integer.MIN_VALUE) != 0);
        if ((flags & 1) == 0) {
            if (deletedPkg != null) {
                resolvedPkg = deletedPkg;
            } else {
                resolvedPkg = new PackageParser.Package(deletedPs.name);
                resolvedPkg.setVolumeUuid(deletedPs.volumeUuid);
            }
            long startTime = SystemClock.uptimeMillis();
            destroyAppDataLIF(resolvedPkg, -1, 7);
            Slog.i(TAG, "destroyAppDataLIF time cost : " + (SystemClock.uptimeMillis() - startTime) + " ms");
            destroyAppProfilesLIF(resolvedPkg);
            if (outInfo != null) {
                outInfo.dataRemoved = true;
            }
        }
        int removedAppId = -1;
        boolean installedStateChanged = false;
        if ((flags & 1) == 0) {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            synchronized (this.mPackages) {
                clearIntentFilterVerificationsLPw(deletedPs.name, -1, true);
                clearDefaultBrowserIfNeeded(packageName);
                this.mSettings.mKeySetManagerService.removeAppKeySetDataLPw(packageName);
                removedAppId = this.mSettings.removePackageLPw(packageName);
                if (outInfo != null) {
                    outInfo.removedAppId = removedAppId;
                }
                this.mPermissionManager.updatePermissions(deletedPs.name, null, false, this.mPackages.values(), this.mPermissionCallback);
                if (deletedPs.sharedUser != null) {
                    int[] userIds = UserManagerService.getInstance().getUserIds();
                    int length = userIds.length;
                    int i = 0;
                    while (true) {
                        if (i >= length) {
                            break;
                        }
                        int userIdToKill = this.mSettings.updateSharedUserPermsLPw(deletedPs, userIds[i]);
                        if (userIdToKill == -1) {
                            break;
                        } else if (userIdToKill >= 0) {
                            break;
                        } else {
                            i++;
                        }
                    }
                    this.mHandler.post(new Runnable(deletedPs) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$aKXP7ygIGtlFObKGVZdijCdnv74 */
                        private final /* synthetic */ PackageSetting f$1;

                        {
                            this.f$1 = r2;
                        }

                        @Override // java.lang.Runnable
                        public final void run() {
                            PackageManagerService.this.lambda$removePackageDataLIF$25$PackageManagerService(this.f$1);
                        }
                    });
                }
                if (!"com.huawei.android.launcher".equals(deletedPs.name)) {
                    clearPackagePreferredActivitiesLPw(deletedPs.name, changedUsers, -1);
                }
            }
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(-1);
            }
        }
        if (!(allUserHandles == null || outInfo == null || outInfo.origUsers == null)) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Propagating install state across downgrade");
            }
            for (int userId : allUserHandles) {
                boolean installed = ArrayUtils.contains(outInfo.origUsers, userId);
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "    user " + userId + " => " + installed);
                }
                if (installed != deletedPs.getInstalled(userId)) {
                    installedStateChanged = true;
                }
                deletedPs.setInstalled(installed, userId);
            }
        }
        synchronized (this.mPackages) {
            if (writeSettings) {
                try {
                    this.mSettings.writeLPr();
                } catch (Throwable th) {
                    throw th;
                }
            }
            if (installedStateChanged) {
                this.mSettings.writeKernelMappingLPr(deletedPs);
            }
            if ((deletedPs.pkg.applicationInfo.hwFlags & DumpState.DUMP_SERVICE_PERMISSIONS) != 0) {
                HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName);
            }
        }
        if (removedAppId != -1) {
            removeKeystoreDataIfNeeded(-1, removedAppId);
        }
    }

    public /* synthetic */ void lambda$removePackageDataLIF$25$PackageManagerService(PackageSetting deletedPs) {
        killApplication(deletedPs.name, deletedPs.appId, KILL_APP_REASON_GIDS_CHANGED);
    }

    static boolean locationIsPrivileged(String path) {
        try {
            boolean isPrivilegedAppHw = mHwPMSEx.isPrivAppNonSystemPartitionDir(new File(path));
            if (isPrivilegedAppHw) {
                return isPrivilegedAppHw;
            }
            File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
            File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), "priv-app");
            File privilegedOdmAppDir = new File(Environment.getOdmDirectory(), "priv-app");
            File privilegedProductAppDir = new File(Environment.getProductDirectory(), "priv-app");
            File privilegedProductServicesAppDir = new File(Environment.getProductServicesDirectory(), "priv-app");
            if (!path.startsWith(privilegedAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(privilegedVendorAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                    if (!path.startsWith(privilegedOdmAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                        if (!path.startsWith(privilegedProductAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                            if (!path.startsWith(privilegedProductServicesAppDir.getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                                return false;
                            }
                        }
                    }
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOem(String path) {
        try {
            return path.startsWith(Environment.getOemDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsVendor(String path) {
        try {
            if (!path.startsWith(Environment.getVendorDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER)) {
                if (!path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER) && !HwPackageManagerServiceUtils.hwlocationIsVendor(path)) {
                    return false;
                }
            }
            return true;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProduct(String path) {
        try {
            if (path.startsWith(Environment.getProductDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER) || HwPackageManagerServiceUtils.hwlocationIsProduct(path)) {
                return true;
            }
            return false;
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsProductServices(String path) {
        try {
            return path.startsWith(Environment.getProductServicesDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    static boolean locationIsOdm(String path) {
        try {
            return path.startsWith(Environment.getOdmDirectory().getCanonicalPath() + SliceClientPermissions.SliceAuthority.DELIMITER);
        } catch (IOException e) {
            Slog.e(TAG, "Unable to access code path " + path);
            return false;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:24:0x006e, code lost:
        if (com.android.server.pm.PackageManagerService.mHwPMSEx.isPreRemovableApp(r7.codePath.toString()) == false) goto L_0x007c;
     */
    private void deleteSystemPackageLIF(DeletePackageAction action, PackageSetting deletedPs, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings) throws SystemDeleteException {
        Throwable th;
        int flags2;
        PackageSetting stubPs;
        PackageSetting stubPs2;
        PackageRemovedInfo info;
        PackageRemovedInfo childInfo;
        boolean applyUserRestrictions = (allUserHandles == null || outInfo == null || outInfo.origUsers == null) ? false : true;
        PackageParser.Package deletedPkg = deletedPs.pkg;
        PackageSetting disabledPs = action.disabledPs;
        if (disabledPs != null) {
            if (disabledPs.pkg != null) {
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "deleteSystemPackageLI: newPs=" + deletedPkg.packageName + " disabledPs=" + disabledPs);
                }
                Slog.d(TAG, "Deleting system pkg from data partition");
                synchronized (this.mPackages) {
                    try {
                        if (!mHwPMSEx.isDelapp(disabledPs)) {
                            try {
                                if (!mHwPMSEx.isDelappInData(disabledPs)) {
                                }
                            } catch (Throwable th2) {
                                th = th2;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th3) {
                                        th = th3;
                                    }
                                }
                                throw th;
                            }
                        }
                        this.mSettings.removeDisabledSystemPackageLPw(deletedPs.name);
                    } catch (Throwable th4) {
                        th = th4;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                if (DEBUG_REMOVE && applyUserRestrictions) {
                    Slog.d(TAG, "Remembering install states:");
                    for (int userId : allUserHandles) {
                        Slog.d(TAG, "   u=" + userId + " inst=" + ArrayUtils.contains(outInfo.origUsers, userId));
                    }
                }
                if (outInfo != null) {
                    outInfo.isRemovedPackageSystemUpdate = true;
                }
                if (!(outInfo == null || outInfo.removedChildPackages == null)) {
                    int childCount = deletedPs.childPackageNames != null ? deletedPs.childPackageNames.size() : 0;
                    for (int i = 0; i < childCount; i++) {
                        String childPackageName = (String) deletedPs.childPackageNames.get(i);
                        if (!(disabledPs.childPackageNames == null || !disabledPs.childPackageNames.contains(childPackageName) || (childInfo = outInfo.removedChildPackages.get(childPackageName)) == null)) {
                            childInfo.isRemovedPackageSystemUpdate = true;
                        }
                    }
                }
                if (disabledPs.versionCode < deletedPs.versionCode) {
                    flags2 = flags & -2;
                } else if ((mHwPMSEx.isDelapp(disabledPs) || mHwPMSEx.isDelappInData(disabledPs) || mHwPMSEx.isPreRemovableApp(disabledPs.codePath.toString())) && disabledPs.versionCode == deletedPs.versionCode) {
                    flags2 = flags & -2;
                } else {
                    flags2 = flags | 1;
                }
                deleteInstalledPackageLIF(deletedPs, true, flags2, allUserHandles, outInfo, writeSettings, disabledPs.pkg);
                synchronized (this.mPackages) {
                    enableSystemPackageLPw(disabledPs.pkg);
                    removeNativeBinariesLI(deletedPs);
                }
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Re-installing system package: " + disabledPs);
                }
                try {
                    PackageRemovedInfo info2 = new PackageRemovedInfo(this);
                    if (mHwPMSEx.isDelapp(disabledPs) || mHwPMSEx.isDelappInData(disabledPs)) {
                        info = info2;
                    } else if (mHwPMSEx.isPreRemovableApp(disabledPs.codePath.toString())) {
                        info = info2;
                    } else {
                        installPackageFromSystemLIF(disabledPs.codePathString, allUserHandles, outInfo == null ? null : outInfo.origUsers, deletedPs.getPermissionsState(), writeSettings);
                        Slog.w(TAG, "restore system package");
                        if ("com.huawei.android.launcher".equals(disabledPs.pkg.packageName)) {
                            mHwPMSEx.restoreHwLauncherMode(allUserHandles);
                        }
                        if (disabledPs.pkg.isStub && (stubPs2 = this.mSettings.mPackages.get(deletedPkg.packageName)) != null) {
                            stubPs2.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                            return;
                        }
                        return;
                    }
                    mHwPMSEx.recordUninstalledDelapp(deletedPkg.packageName, disabledPs.codePathString);
                    info.removedPackage = deletedPkg.packageName;
                    if (outInfo != null) {
                        outInfo.isRemovedPackageSystemUpdate = false;
                    }
                    info.sendPackageRemovedBroadcasts(true);
                    Slog.w(TAG, "it is a preRemovable app, stop to restore system package");
                    if (disabledPs.pkg.isStub) {
                        return;
                    }
                    return;
                } catch (PackageManagerException e) {
                    Slog.w(TAG, "Failed to restore system package:" + deletedPkg.packageName + ": " + e.getMessage());
                    throw new SystemDeleteException(e);
                } catch (Throwable th5) {
                    if (disabledPs.pkg.isStub && (stubPs = this.mSettings.mPackages.get(deletedPkg.packageName)) != null) {
                        stubPs.setEnabled(2, 0, PLATFORM_PACKAGE_NAME);
                    }
                    throw th5;
                }
            }
        }
        Slog.w(TAG, "Attempt to delete unknown system package " + deletedPkg.packageName);
    }

    private PackageParser.Package installPackageFromSystemLIF(String codePathString, int[] allUserHandles, int[] origUserHandles, PermissionsState origPermissionState, boolean writeSettings) throws PackageManagerException {
        int scanFlags;
        int i;
        boolean applyUserRestrictions;
        File codePath;
        boolean installed;
        boolean z = true;
        int parseFlags = this.mDefParseFlags | 1 | 16;
        int scanFlags2 = 131072;
        if (locationIsPrivileged(codePathString)) {
            scanFlags2 = 131072 | 262144;
        }
        if (locationIsOem(codePathString)) {
            scanFlags2 |= 524288;
        }
        if (locationIsVendor(codePathString)) {
            scanFlags2 |= 1048576;
        }
        if (locationIsProduct(codePathString)) {
            scanFlags2 |= 2097152;
        }
        if (locationIsProductServices(codePathString)) {
            scanFlags2 |= 4194304;
        }
        if (locationIsOdm(codePathString)) {
            scanFlags = scanFlags2 | 8388608;
        } else {
            scanFlags = scanFlags2;
        }
        File codePath2 = new File(codePathString);
        PackageParser.Package pkg = scanPackageTracedLI(codePath2, parseFlags, scanFlags | 8192, 0, (UserHandle) null);
        try {
            updateSharedLibrariesLocked(pkg, null, Collections.unmodifiableMap(this.mPackages));
        } catch (PackageManagerException e) {
            Slog.e(TAG, "updateAllSharedLibrariesLPw failed: " + e.getMessage());
        }
        prepareAppDataAfterInstallLIF(pkg);
        synchronized (this.mPackages) {
            try {
                PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                if (origPermissionState != null) {
                    try {
                        ps.getPermissionsState().copyFrom(origPermissionState);
                    } catch (Throwable th) {
                        th = th;
                    }
                }
                this.mPermissionManager.updatePermissions(pkg.packageName, pkg, true, this.mPackages.values(), this.mPermissionCallback);
                if (allUserHandles == null || origUserHandles == null) {
                    z = false;
                }
                boolean applyUserRestrictions2 = z;
                if (applyUserRestrictions2) {
                    if (DEBUG_REMOVE) {
                        Slog.d(TAG, "Propagating install state across reinstall");
                    }
                    boolean installedStateChanged = false;
                    int i2 = 0;
                    for (int length = allUserHandles.length; i2 < length; length = i) {
                        int userId = allUserHandles[i2];
                        boolean installed2 = ArrayUtils.contains(origUserHandles, userId);
                        if (DEBUG_REMOVE) {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            StringBuilder sb = new StringBuilder();
                            i = length;
                            sb.append("    user ");
                            sb.append(userId);
                            sb.append(" => ");
                            installed = installed2;
                            sb.append(installed);
                            Slog.d(TAG, sb.toString());
                        } else {
                            codePath = codePath2;
                            applyUserRestrictions = applyUserRestrictions2;
                            i = length;
                            installed = installed2;
                        }
                        if (installed != ps.getInstalled(userId)) {
                            installedStateChanged = true;
                        }
                        ps.setInstalled(installed, userId);
                        this.mSettings.writeRuntimePermissionsForUserLPr(userId, false);
                        i2++;
                        codePath2 = codePath;
                        applyUserRestrictions2 = applyUserRestrictions;
                    }
                    this.mSettings.writeAllUsersPackageRestrictionsLPr();
                    if (installedStateChanged) {
                        this.mSettings.writeKernelMappingLPr(ps);
                    }
                }
                if (writeSettings) {
                    this.mSettings.writeLPr();
                }
                return pkg;
            } catch (Throwable th2) {
                th = th2;
                throw th;
            }
        }
    }

    private void deleteInstalledPackageLIF(PackageSetting ps, boolean deleteCodeAndResources, int flags, int[] allUserHandles, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        int childCount;
        PackageSetting childPs;
        synchronized (this.mPackages) {
            if (outInfo != null) {
                try {
                    outInfo.uid = ps.appId;
                } catch (Throwable th) {
                    throw th;
                }
            }
            childCount = 0;
            if (!(outInfo == null || outInfo.removedChildPackages == null)) {
                int childCount2 = ps.childPackageNames != null ? ps.childPackageNames.size() : 0;
                for (int i = 0; i < childCount2; i++) {
                    String childPackageName = (String) ps.childPackageNames.get(i);
                    PackageSetting childPs2 = this.mSettings.mPackages.get(childPackageName);
                    if (childPs2 != null) {
                        PackageRemovedInfo childInfo = outInfo.removedChildPackages.get(childPackageName);
                        if (childInfo != null) {
                            childInfo.uid = childPs2.appId;
                        }
                    } else {
                        return;
                    }
                }
            }
        }
        removePackageDataLIF(ps, allUserHandles, outInfo, flags, writeSettings);
        if (ps.childPackageNames != null) {
            childCount = ps.childPackageNames.size();
        }
        for (int i2 = 0; i2 < childCount; i2++) {
            synchronized (this.mPackages) {
                childPs = this.mSettings.getPackageLPr((String) ps.childPackageNames.get(i2));
            }
            if (childPs != null) {
                removePackageDataLIF(childPs, allUserHandles, (outInfo == null || outInfo.removedChildPackages == null) ? null : outInfo.removedChildPackages.get(childPs.name), ((flags & 1) == 0 || replacingPackage == null || replacingPackage.hasChildPackage(childPs.name)) ? flags : flags & -2, writeSettings);
            }
        }
        if (ps.parentPackageName == null && deleteCodeAndResources && outInfo != null) {
            outInfo.args = createInstallArgsForExisting(ps.codePathString, ps.resourcePathString, InstructionSets.getAppDexInstructionSets(ps));
        }
    }

    public boolean setBlockUninstallForUser(String packageName, boolean blockUninstall, int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.DELETE_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || pkg.staticSharedLibName == null) {
                this.mSettings.setBlockUninstallLPw(userId, packageName, blockUninstall);
                this.mSettings.writePackageRestrictionsLPr(userId);
                return true;
            }
            Slog.w(TAG, "Cannot block uninstall of package: " + packageName + " providing static shared library: " + pkg.staticSharedLibName);
            return false;
        }
    }

    public boolean getBlockUninstallForUser(String packageName, int userId) {
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps != null) {
                if (!filterAppAccessLPr(ps, Binder.getCallingUid(), userId)) {
                    return this.mSettings.getBlockUninstallLPr(userId, packageName);
                }
            }
            return false;
        }
    }

    public boolean setRequiredForSystemUser(String packageName, boolean systemUserApp) {
        enforceSystemOrRoot("setRequiredForSystemUser can only be run by the system or root");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Log.w(TAG, "Package doesn't exist: " + packageName);
                return false;
            }
            if (systemUserApp) {
                ps.pkgPrivateFlags |= 512;
            } else {
                ps.pkgPrivateFlags &= -513;
            }
            this.mSettings.writeLPr();
            return true;
        }
    }

    /* access modifiers changed from: private */
    public static class DeletePackageAction {
        public final PackageSetting deletingPs;
        public final PackageSetting disabledPs;
        public final int flags;
        public final PackageRemovedInfo outInfo;
        public final UserHandle user;

        private DeletePackageAction(PackageSetting deletingPs2, PackageSetting disabledPs2, PackageRemovedInfo outInfo2, int flags2, UserHandle user2) {
            this.deletingPs = deletingPs2;
            this.disabledPs = disabledPs2;
            this.outInfo = outInfo2;
            this.flags = flags2;
            this.user = user2;
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:39:0x0082  */
    /* JADX WARNING: Removed duplicated region for block: B:60:0x00d8  */
    /* JADX WARNING: Removed duplicated region for block: B:61:0x00df  */
    /* JADX WARNING: Removed duplicated region for block: B:64:0x00e3  */
    /* JADX WARNING: Removed duplicated region for block: B:65:0x00e5  */
    /* JADX WARNING: Removed duplicated region for block: B:68:0x00e9 A[RETURN] */
    /* JADX WARNING: Removed duplicated region for block: B:69:0x00ea A[ADDED_TO_REGION] */
    @GuardedBy({"mPackages"})
    private static DeletePackageAction mayDeletePackageLocked(PackageRemovedInfo outInfo, PackageSetting ps, PackageSetting disabledPs, PackageSetting[] children, int flags, UserHandle user) {
        int flags2;
        int parentReferenceCount;
        int childCount;
        if (ps == null) {
            return null;
        }
        if (ps.pkg == null) {
            Slog.w(TAG, "ps.pkg is null!");
            return null;
        } else if (ps.pkg.applicationInfo == null) {
            Slog.w(TAG, "ps.pkg.applicationInfo is null!");
            return null;
        } else {
            boolean deleteAllUsers = true;
            boolean isRemovableSysApp = isSystemApp(ps) && !((ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) == 0 && (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) == 0);
            if (isRemovableSysApp && user != null && user.getIdentifier() != -1 && sUserManager.getUserIds().length > 1) {
                int[] installUser = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                if (!(installUser.length == 0 || (installUser.length == 1 && installUser[0] == user.getIdentifier()))) {
                    flags2 = flags | 4;
                    if (isSystemApp(ps)) {
                        if (ps.parentPackageName != null) {
                            Slog.w(TAG, "Attempt to delete child system package " + ps.pkg.packageName);
                            return null;
                        }
                        boolean deleteSystem = (flags2 & 4) != 0;
                        if (!(user == null || user.getIdentifier() == -1)) {
                            deleteAllUsers = false;
                        }
                        if ((!deleteSystem || deleteAllUsers) && disabledPs == null && !isRemovableSysApp) {
                            Slog.w(TAG, "Attempt to delete unknown system package " + ps.pkg.packageName);
                            return null;
                        }
                    }
                    parentReferenceCount = ps.childPackageNames == null ? ps.childPackageNames.size() : 0;
                    childCount = children == null ? children.length : 0;
                    if (childCount == parentReferenceCount) {
                        return null;
                    }
                    if (!(childCount == 0 || outInfo == null || outInfo.removedChildPackages == null)) {
                        for (PackageSetting child : children) {
                            if (child == null || !ps.childPackageNames.contains(child.name)) {
                                return null;
                            }
                        }
                    }
                    return new DeletePackageAction(ps, disabledPs, outInfo, flags2, user);
                }
            }
            flags2 = flags;
            if (isSystemApp(ps)) {
            }
            if (ps.childPackageNames == null) {
            }
            if (children == null) {
            }
            if (childCount == parentReferenceCount) {
            }
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:29:0x0091, code lost:
        r0 = th;
     */
    private boolean deletePackageLIF(String packageName, UserHandle user, boolean deleteCodeAndResources, int[] allUserHandles, int flags, PackageRemovedInfo outInfo, boolean writeSettings, PackageParser.Package replacingPackage) {
        DeletePackageAction action;
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            action = mayDeletePackageLocked(outInfo, ps, this.mSettings.getDisabledSystemPkgLPr(ps), this.mSettings.getChildSettingsLPr(ps), flags, user);
        }
        if (DEBUG_REMOVE) {
            Slog.d(TAG, "deletePackageLI: " + packageName + " user " + user + " flags " + flags);
        }
        if (action == null) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: action was null");
            }
            return false;
        }
        try {
            executeDeletePackageLIF(action, packageName, deleteCodeAndResources, allUserHandles, writeSettings, replacingPackage);
            return true;
        } catch (SystemDeleteException e) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "deletePackageLI: system deletion failure", e);
            }
            return false;
        }
        while (true) {
        }
    }

    /* access modifiers changed from: private */
    public static class SystemDeleteException extends Exception {
        public final PackageManagerException reason;

        private SystemDeleteException(PackageManagerException reason2) {
            this.reason = reason2;
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r0v10 */
    /* JADX WARN: Type inference failed for: r0v47 */
    /* JADX WARN: Type inference failed for: r0v48 */
    /* JADX WARNING: Code restructure failed: missing block: B:80:0x0152, code lost:
        r0 = th;
     */
    private void executeDeletePackageLIF(DeletePackageAction action, String packageName, boolean deleteCodeAndResources, int[] allUserHandles, boolean writeSettings, PackageParser.Package replacingPackage) throws SystemDeleteException {
        boolean systemApp;
        boolean z;
        boolean z2;
        int childCount;
        boolean keepUninstalledPackage;
        PackageSetting disabledPs;
        PackageSetting ps = action.deletingPs;
        PackageRemovedInfo outInfo = action.outInfo;
        UserHandle user = action.user;
        int flags = action.flags;
        boolean systemApp2 = isSystemApp(ps);
        int removedUserId = -1;
        if (ps.parentPackageName == null || (systemApp2 && (flags & 4) == 0)) {
            if (DEBUG_REMOVE) {
                Flog.i(209, "executeDeletePackageLIF: pkg " + packageName + " isSysApp: " + systemApp2 + " hwflag: " + ps.pkg.applicationInfo.hwFlags + " for user " + user);
            }
            int userId = user == null ? -1 : user.getIdentifier();
            if (checkPermission("android.permission.SUSPEND_APPS", packageName, userId) == 0) {
                unsuspendForSuspendingPackage(packageName, userId);
            }
            if ((!systemApp2 || (flags & 4) != 0) && userId != -1) {
                synchronized (this.mPackages) {
                    markPackageUninstalledForUserLPw(ps, user);
                    if (!systemApp2) {
                        boolean keepUninstalledPackage2 = shouldKeepUninstalledPackageLPr(packageName);
                        if (!ps.isAnyInstalled(sUserManager.getUserIds())) {
                            if (!keepUninstalledPackage2) {
                                if (DEBUG_REMOVE) {
                                    Slog.d(TAG, "Not installed by other users, full delete");
                                }
                                ps.setInstalled(true, userId);
                                this.mSettings.writeKernelMappingLPr(ps);
                                keepUninstalledPackage = false;
                            }
                        }
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Still installed by other users");
                        }
                        keepUninstalledPackage = true;
                    } else {
                        if (DEBUG_REMOVE) {
                            Slog.d(TAG, "Deleting system app");
                        }
                        boolean isRemovablePreinstalledApp = (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0;
                        boolean isUpdatedPreApp = (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_HANDLE) != 0;
                        if (isRemovablePreinstalledApp) {
                            mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, ps.pkg.codePath);
                        } else if (isUpdatedPreApp) {
                            synchronized (this.mPackages) {
                                disabledPs = this.mSettings.getDisabledSystemPkgLPr(ps.pkg.packageName);
                            }
                            mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, disabledPs.codePathString);
                        }
                        keepUninstalledPackage = true;
                    }
                }
                if (keepUninstalledPackage) {
                    clearPackageStateForUserLIF(ps, userId, outInfo, flags);
                    synchronized (this.mPackages) {
                        scheduleWritePackageRestrictionsLocked(user);
                    }
                    return;
                }
            }
            if (ps.childPackageNames != null && outInfo != null) {
                synchronized (this.mPackages) {
                    int childCount2 = ps.childPackageNames.size();
                    outInfo.removedChildPackages = new ArrayMap<>(childCount2);
                    int i = 0;
                    while (i < childCount2) {
                        String childPackageName = (String) ps.childPackageNames.get(i);
                        PackageRemovedInfo childInfo = new PackageRemovedInfo(this);
                        childInfo.removedPackage = childPackageName;
                        childInfo.installerPackageName = ps.installerPackageName;
                        outInfo.removedChildPackages.put(childPackageName, childInfo);
                        PackageSetting childPs = this.mSettings.getPackageLPr(childPackageName);
                        if (childPs != null) {
                            childCount = childCount2;
                            childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true);
                        } else {
                            childCount = childCount2;
                        }
                        i++;
                        childCount2 = childCount;
                    }
                }
            }
            boolean isSystemAppGrantByMdm = isSystemAppGrantByMdmAndNonPreload(ps.name, ps.codePathString, ps.volumeUuid);
            if (!systemApp2 || (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0 || isSystemAppGrantByMdm) {
                systemApp = systemApp2;
                z = false;
                if (DEBUG_REMOVE) {
                    Slog.d(TAG, "Removing non-system package: " + ps.name);
                }
                boolean isRemovablePreinstalledApp2 = (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) != 0;
                Slog.i(TAG, "Removing non-system or removable preinstalled package: " + ps.name + ", isRemovablePreinstalledApp = " + isRemovablePreinstalledApp2);
                deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles, outInfo, writeSettings, replacingPackage);
                if (isRemovablePreinstalledApp2) {
                    mHwPMSEx.recordUninstalledDelapp(ps.pkg.packageName, ps.pkg.codePath);
                }
                synchronized (this.mPackages) {
                    mHwPMSEx.updateCertCompatPackage(ps.pkg, null);
                }
            } else {
                Slog.i(TAG, "Removing system package: " + ps.name);
                z = false;
                systemApp = systemApp2;
                deleteSystemPackageLIF(action, ps, allUserHandles, flags, outInfo, writeSettings);
            }
            synchronized (this.mPackages) {
                mHwPMSEx.writeCertCompatPackages(z);
            }
            if (outInfo != null) {
                outInfo.removedForAllUsers = this.mPackages.get(ps.name) == null ? true : z;
                if (outInfo.removedChildPackages != null) {
                    synchronized (this.mPackages) {
                        int childCount3 = outInfo.removedChildPackages.size();
                        for (int i2 = 0; i2 < childCount3; i2++) {
                            PackageRemovedInfo childInfo2 = outInfo.removedChildPackages.valueAt(i2);
                            if (childInfo2 != null) {
                                if (this.mPackages.get(childInfo2.removedPackage) == null) {
                                    z2 = true;
                                } else {
                                    boolean z3 = z ? 1 : 0;
                                    boolean z4 = z ? 1 : 0;
                                    boolean z5 = z ? 1 : 0;
                                    boolean z6 = z ? 1 : 0;
                                    z2 = z3;
                                }
                                childInfo2.removedForAllUsers = z2;
                            }
                        }
                    }
                }
                if (systemApp) {
                    synchronized (this.mPackages) {
                        PackageSetting updatedPs = this.mSettings.getPackageLPr(ps.name);
                        int childCount4 = z;
                        if (updatedPs != null) {
                            childCount4 = z;
                            if (updatedPs.childPackageNames != null) {
                                childCount4 = updatedPs.childPackageNames.size();
                            }
                        }
                        for (int i3 = 0; i3 < childCount4; i3++) {
                            String childPackageName2 = (String) updatedPs.childPackageNames.get(i3);
                            if (outInfo.removedChildPackages != null) {
                                if (outInfo.removedChildPackages.indexOfKey(childPackageName2) >= 0) {
                                }
                            }
                            PackageSetting childPs2 = this.mSettings.getPackageLPr(childPackageName2);
                            if (childPs2 != null) {
                                PackageInstalledInfo installRes = new PackageInstalledInfo();
                                installRes.name = childPackageName2;
                                installRes.newUsers = childPs2.queryInstalledUsers(allUserHandles, true);
                                installRes.pkg = this.mPackages.get(childPackageName2);
                                installRes.uid = childPs2.pkg.applicationInfo.uid;
                                if (outInfo.appearedChildPackages == null) {
                                    outInfo.appearedChildPackages = new ArrayMap<>();
                                }
                                outInfo.appearedChildPackages.put(childPackageName2, installRes);
                            }
                        }
                    }
                    return;
                }
                return;
            }
            return;
        }
        if (DEBUG_REMOVE) {
            StringBuilder sb = new StringBuilder();
            sb.append("Uninstalled child package:");
            sb.append(packageName);
            sb.append(" for user:");
            sb.append(user == null ? -1 : user);
            Slog.d(TAG, sb.toString());
        }
        if (user != null) {
            removedUserId = user.getIdentifier();
        }
        clearPackageStateForUserLIF(ps, removedUserId, outInfo, flags);
        synchronized (this.mPackages) {
            markPackageUninstalledForUserLPw(ps, user);
            scheduleWritePackageRestrictionsLocked(user);
        }
        return;
        while (true) {
        }
    }

    @GuardedBy({"mPackages"})
    private void markPackageUninstalledForUserLPw(PackageSetting ps, UserHandle user) {
        PackageSetting packageSetting = ps;
        int i = 0;
        int[] userIds = (user == null || user.getIdentifier() == -1) ? sUserManager.getUserIds() : new int[]{user.getIdentifier()};
        int length = userIds.length;
        while (i < length) {
            int nextUserId = userIds[i];
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Marking package:" + packageSetting.name + " uninstalled for user:" + nextUserId);
            }
            ps.setUserState(nextUserId, 0, 0, false, true, true, false, 0, false, null, null, null, null, false, false, null, null, null, packageSetting.readUserState(nextUserId).domainVerificationStatus, 0, 0, null);
            i++;
            packageSetting = ps;
            length = length;
            userIds = userIds;
        }
        this.mSettings.writeKernelMappingLPr(ps);
    }

    private void clearPackageStateForUserLIF(PackageSetting ps, int userId, PackageRemovedInfo outInfo, int flags) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(ps.name);
        }
        destroyAppProfilesLIF(pkg);
        boolean z = false;
        int[] userIds = userId == -1 ? sUserManager.getUserIds() : new int[]{userId};
        for (int nextUserId : userIds) {
            if (DEBUG_REMOVE) {
                Slog.d(TAG, "Updating package:" + ps.name + " install state for user:" + nextUserId);
            }
            destroyAppDataLIF(pkg, nextUserId, 7);
            clearDefaultBrowserIfNeededForUser(ps.name, nextUserId);
            removeKeystoreDataIfNeeded(nextUserId, ps.appId);
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(ps.name, changedUsers, nextUserId);
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(nextUserId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(nextUserId);
                }
            }
            synchronized (this.mPackages) {
                resetUserChangesToRuntimePermissionsAndFlagsLPw(ps, nextUserId);
            }
            if ((flags & 16) != 0) {
                try {
                    MediaStore.deleteContributedMedia(this.mContext, ps.name, UserHandle.of(nextUserId));
                } catch (IOException e) {
                    Slog.w(TAG, "Failed to delete contributed media for " + ps.name, e);
                }
            }
        }
        if (outInfo != null) {
            outInfo.removedPackage = ps.name;
            outInfo.installerPackageName = ps.installerPackageName;
            if (!(pkg == null || pkg.staticSharedLibName == null)) {
                z = true;
            }
            outInfo.isStaticSharedLib = z;
            outInfo.removedAppId = ps.appId;
            outInfo.removedUsers = userIds;
            outInfo.broadcastUsers = userIds;
        }
    }

    /* JADX WARNING: Code restructure failed: missing block: B:21:0x002b, code lost:
        r3 = move-exception;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:22:0x002c, code lost:
        if (r0 != null) goto L_0x002e;
     */
    /* JADX WARNING: Code restructure failed: missing block: B:23:0x002e, code lost:
        $closeResource(r2, r0);
     */
    /* JADX WARNING: Code restructure failed: missing block: B:24:0x0031, code lost:
        throw r3;
     */
    public void clearApplicationProfileData(String packageName) {
        PackageParser.Package pkg;
        enforceSystemOrRoot("Only the system can clear all profile data");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        PackageFreezer freezer = freezePackage(packageName, "clearApplicationProfileData");
        synchronized (this.mInstallLock) {
            clearAppProfilesLIF(pkg, -1);
        }
        if (freezer != null) {
            $closeResource(null, freezer);
        }
    }

    public void clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.CLEAR_APP_USER_DATA", null);
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "clear application data");
        PackageSetting ps = this.mSettings.getPackageLPr(packageName);
        final boolean filterApp = ps != null && filterAppAccessLPr(ps, callingUid, userId);
        if (filterApp || !this.mProtectedPackages.isPackageDataProtected(userId, packageName)) {
            this.mHandler.post(new Runnable() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass5 */

                /* JADX WARNING: Code restructure failed: missing block: B:33:0x00ba, code lost:
                    r2 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:34:0x00bb, code lost:
                    if (r0 != null) goto L_0x00bd;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:36:?, code lost:
                    r0.close();
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:37:0x00c1, code lost:
                    r3 = move-exception;
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:38:0x00c2, code lost:
                    r1.addSuppressed(r3);
                 */
                /* JADX WARNING: Code restructure failed: missing block: B:39:0x00c5, code lost:
                    throw r2;
                 */
                @Override // java.lang.Runnable
                public void run() {
                    boolean succeeded;
                    PackageManagerService.this.mHandler.removeCallbacks(this);
                    if (!filterApp) {
                        PackageFreezer freezer = PackageManagerService.this.freezePackage(packageName, "clearApplicationUserData");
                        long start = HwPackageManagerServiceUtils.hwTimingsBeginWithTag(PackageManagerService.TAG, "clearData for " + packageName);
                        synchronized (PackageManagerService.this.mInstallLock) {
                            succeeded = PackageManagerService.this.clearApplicationUserDataLIF(packageName, userId);
                        }
                        HwPackageManagerServiceUtils.hwTimingsEnd(PackageManagerService.TAG, "clearData user for " + packageName, start);
                        long start2 = SystemClock.uptimeMillis();
                        synchronized (PackageManagerService.this.mPackages) {
                            PackageManagerService.this.mInstantAppRegistry.deleteInstantApplicationMetadataLPw(packageName, userId);
                        }
                        HwPackageManagerServiceUtils.hwTimingsEnd(PackageManagerService.TAG, "clearData metadata for " + packageName, start2);
                        if (freezer != null) {
                            freezer.close();
                        }
                        if (succeeded) {
                            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
                            if (dsm != null) {
                                dsm.checkMemory();
                            }
                            if (PackageManagerService.this.checkPermission("android.permission.SUSPEND_APPS", packageName, userId) == 0) {
                                PackageManagerService.this.unsuspendForSuspendingPackage(packageName, userId);
                            }
                        }
                    } else {
                        succeeded = false;
                    }
                    IPackageDataObserver iPackageDataObserver = observer;
                    if (iPackageDataObserver != null) {
                        try {
                            iPackageDataObserver.onRemoveCompleted(packageName, succeeded);
                        } catch (RemoteException e) {
                            Log.i(PackageManagerService.TAG, "Observer no longer exists.");
                        }
                    }
                }
            });
            return;
        }
        throw new SecurityException("Cannot clear data for a protected package: " + packageName);
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean clearApplicationUserDataLIF(String packageName, int userId) {
        PackageParser.Package pkg;
        int flags;
        PackageSetting ps;
        if (packageName == null) {
            Slog.w(TAG, "Attempt to delete null packageName.");
            return false;
        }
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
            if (pkg == null && (ps = this.mSettings.mPackages.get(packageName)) != null) {
                pkg = ps.pkg;
            }
            if (pkg == null) {
                Slog.w(TAG, "Package named '" + packageName + "' doesn't exist.");
                return false;
            }
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) pkg.mExtras, userId);
        }
        clearAppDataLIF(pkg, userId, 7);
        removeKeystoreDataIfNeeded(userId, UserHandle.getAppId(pkg.applicationInfo.uid));
        UserManagerInternal umInternal = getUserManagerInternal();
        if (umInternal.isUserUnlockingOrUnlocked(userId)) {
            flags = 3;
        } else if (umInternal.isUserRunning(userId)) {
            flags = 1;
        } else {
            flags = 0;
        }
        prepareAppDataContentsLIF(pkg, userId, flags);
        return true;
    }

    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            resetUserChangesToRuntimePermissionsAndFlagsLPw((PackageSetting) this.mPackages.valueAt(i).mExtras, userId);
        }
    }

    private void resetNetworkPolicies(int userId) {
        ((NetworkPolicyManagerInternal) LocalServices.getService(NetworkPolicyManagerInternal.class)).resetUserState(userId);
    }

    @GuardedBy({"mPackages"})
    private void resetUserChangesToRuntimePermissionsAndFlagsLPw(final PackageSetting ps, int userId) {
        int i;
        final int i2;
        String packageName;
        boolean[] permissionRemoved;
        ArraySet<Long> revokedPermissions;
        SparseBooleanArray updatedUsers;
        int permissionCount;
        int i3 = userId;
        if (ps.pkg != null) {
            String packageName2 = ps.pkg.packageName;
            final boolean[] permissionRemoved2 = new boolean[1];
            final ArraySet<Long> revokedPermissions2 = new ArraySet<>();
            final SparseBooleanArray updatedUsers2 = new SparseBooleanArray();
            PermissionManagerServiceInternal.PermissionCallback delayingPermCallback = new PermissionManagerServiceInternal.PermissionCallback() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass6 */

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onGidsChanged(int appId, int userId) {
                    PackageManagerService.this.mPermissionCallback.onGidsChanged(appId, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionChanged() {
                    PackageManagerService.this.mPermissionCallback.onPermissionChanged();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionGranted(int uid, int userId) {
                    PackageManagerService.this.mPermissionCallback.onPermissionGranted(uid, userId);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionGranted() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionGranted();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRevoked(int uid, int userId) {
                    revokedPermissions2.add(Long.valueOf(IntPair.of(uid, userId)));
                    updatedUsers2.put(userId, true);
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionRevoked() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionRevoked();
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionUpdated(int[] updatedUserIds, boolean sync) {
                    for (int userId : updatedUserIds) {
                        if (sync) {
                            updatedUsers2.put(userId, true);
                        } else if (!updatedUsers2.get(userId)) {
                            updatedUsers2.put(userId, false);
                        }
                    }
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onPermissionRemoved() {
                    permissionRemoved2[0] = true;
                }

                @Override // com.android.server.pm.permission.PermissionManagerServiceInternal.PermissionCallback
                public void onInstallPermissionUpdated() {
                    PackageManagerService.this.mPermissionCallback.onInstallPermissionUpdated();
                }
            };
            int permissionCount2 = ps.pkg.requestedPermissions.size();
            int i4 = 0;
            while (i4 < permissionCount2) {
                final String permName = (String) ps.pkg.requestedPermissions.get(i4);
                BasePermission bp = this.mPermissionManager.getPermissionTEMP(permName);
                if (bp == null) {
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    permissionRemoved = permissionRemoved2;
                    packageName = packageName2;
                    i2 = i3;
                    i = i4;
                } else if (bp.isRemoved()) {
                    permissionCount = permissionCount2;
                    updatedUsers = updatedUsers2;
                    revokedPermissions = revokedPermissions2;
                    permissionRemoved = permissionRemoved2;
                    packageName = packageName2;
                    i2 = i3;
                    i = i4;
                } else {
                    if (ps.sharedUser != null) {
                        boolean used = false;
                        int packageCount = ps.sharedUser.packages.size();
                        int j = 0;
                        while (true) {
                            if (j >= packageCount) {
                                break;
                            }
                            PackageSetting pkg = ps.sharedUser.packages.valueAt(j);
                            if (!(pkg.pkg == null || pkg.pkg.packageName.equals(ps.pkg.packageName) || !pkg.pkg.requestedPermissions.contains(permName))) {
                                used = true;
                                break;
                            }
                            j++;
                        }
                        if (used) {
                            permissionCount = permissionCount2;
                            updatedUsers = updatedUsers2;
                            revokedPermissions = revokedPermissions2;
                            permissionRemoved = permissionRemoved2;
                            packageName = packageName2;
                            i2 = i3;
                            i = i4;
                        }
                    }
                    int oldFlags = this.mPermissionManager.getPermissionFlags(permName, packageName2, 1000, i3);
                    int flags = (ps.pkg.applicationInfo.targetSdkVersion >= DEFERRED_NO_KILL_POST_DELETE || !bp.isRuntime()) ? 0 : 0 | 72;
                    i = i4;
                    this.mPermissionManager.updatePermissionFlags(permName, packageName2, 65611, flags, 1000, userId, false, delayingPermCallback);
                    if (!bp.isRuntime()) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                    } else if ((oldFlags & 20) != 0) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                    } else if ((oldFlags & 32) != 0) {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                        this.mHandler.post(new Runnable(permName, packageName2, userId, delayingPermCallback) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$RCLgh3XEDiI6ytNodjm151sgBSc */
                            private final /* synthetic */ String f$1;
                            private final /* synthetic */ String f$2;
                            private final /* synthetic */ int f$3;
                            private final /* synthetic */ PermissionManagerServiceInternal.PermissionCallback f$4;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                                this.f$3 = r4;
                                this.f$4 = r5;
                            }

                            @Override // java.lang.Runnable
                            public final void run() {
                                PackageManagerService.this.lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$26$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4);
                            }
                        });
                        this.mHandler.post(new Runnable() {
                            /* class com.android.server.pm.PackageManagerService.AnonymousClass7 */

                            @Override // java.lang.Runnable
                            public void run() {
                                String op = AppOpsManager.permissionToOp(permName);
                                if (op != null) {
                                    int uid = UserHandle.getUid(i2, UserHandle.getAppId(ps.pkg.applicationInfo.uid));
                                    if (PackageManagerService.this.mAppOpsManager == null) {
                                        PackageManagerService packageManagerService = PackageManagerService.this;
                                        packageManagerService.mAppOpsManager = (AppOpsManager) packageManagerService.mContext.getSystemService(AppOpsManager.class);
                                    }
                                    try {
                                        PackageManagerService.this.mAppOpsManager.setUidMode(op, uid, 0);
                                    } catch (IllegalArgumentException e) {
                                        Log.i(PackageManagerService.TAG, "op is not in sOpStrToOp, so skip this operation");
                                    }
                                }
                            }
                        });
                    } else {
                        permissionCount = permissionCount2;
                        updatedUsers = updatedUsers2;
                        revokedPermissions = revokedPermissions2;
                        permissionRemoved = permissionRemoved2;
                        packageName = packageName2;
                        i2 = i3;
                        if ((flags & 64) == 0) {
                            this.mPermissionManager.revokeRuntimePermission(permName, packageName, false, userId, delayingPermCallback);
                        }
                    }
                }
                i4 = i + 1;
                permissionCount2 = permissionCount;
                updatedUsers2 = updatedUsers;
                revokedPermissions2 = revokedPermissions;
                permissionRemoved2 = permissionRemoved;
                packageName2 = packageName;
                i3 = i2;
            }
            if (permissionRemoved2[0]) {
                this.mPermissionCallback.onPermissionRemoved();
            }
            if (!revokedPermissions2.isEmpty()) {
                int numRevokedPermissions = revokedPermissions2.size();
                for (int i5 = 0; i5 < numRevokedPermissions; i5++) {
                    int revocationUID = IntPair.first(revokedPermissions2.valueAt(i5).longValue());
                    int revocationUserId = IntPair.second(revokedPermissions2.valueAt(i5).longValue());
                    this.mOnPermissionChangeListeners.onPermissionsChanged(revocationUID);
                    this.mHandler.post(new Runnable(revocationUID, revocationUserId) {
                        /* class com.android.server.pm.$$Lambda$PackageManagerService$MyCoLIOXga5heTtofaaohvITfY */
                        private final /* synthetic */ int f$1;
                        private final /* synthetic */ int f$2;

                        {
                            this.f$1 = r2;
                            this.f$2 = r3;
                        }

                        @Override // java.lang.Runnable
                        public final void run() {
                            PackageManagerService.this.lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$27$PackageManagerService(this.f$1, this.f$2);
                        }
                    });
                }
            }
            int numUpdatedUsers = updatedUsers2.size();
            for (int i6 = 0; i6 < numUpdatedUsers; i6++) {
                this.mSettings.writeRuntimePermissionsForUserLPr(updatedUsers2.keyAt(i6), updatedUsers2.valueAt(i6));
            }
        }
    }

    public /* synthetic */ void lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$26$PackageManagerService(String permName, String packageName, int userId, PermissionManagerServiceInternal.PermissionCallback delayingPermCallback) {
        this.mPermissionManager.grantRuntimePermission(permName, packageName, false, 1000, userId, delayingPermCallback);
    }

    public /* synthetic */ void lambda$resetUserChangesToRuntimePermissionsAndFlagsLPw$27$PackageManagerService(int revocationUID, int revocationUserId) {
        killUid(UserHandle.getAppId(revocationUID), revocationUserId, KILL_APP_REASON_PERMISSIONS_REVOKED);
    }

    private static void removeKeystoreDataIfNeeded(int userId, int appId) {
        if (appId >= 0) {
            KeyStore keyStore = KeyStore.getInstance();
            if (keyStore == null) {
                Slog.w(TAG, "Could not contact keystore to clear entries for app id " + appId);
            } else if (userId == -1) {
                for (int individual : sUserManager.getUserIds()) {
                    keyStore.clearUid(UserHandle.getUid(individual, appId));
                }
            } else {
                keyStore.clearUid(UserHandle.getUid(userId, appId));
            }
        }
    }

    public void deleteApplicationCacheFiles(String packageName, IPackageDataObserver observer) {
        if (packageName == null) {
            Slog.w(TAG, "Failed to delete cache files, for packageName is null!");
        } else {
            deleteApplicationCacheFilesAsUser(packageName, UserHandle.getCallingUserId(), observer);
        }
    }

    public void deleteApplicationCacheFilesAsUser(String packageName, int userId, IPackageDataObserver observer) {
        PackageParser.Package pkg;
        int callingUid = Binder.getCallingUid();
        if (this.mContext.checkCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES") != 0) {
            if (this.mContext.checkCallingOrSelfPermission("android.permission.DELETE_CACHE_FILES") == 0) {
                Slog.w(TAG, "Calling uid " + callingUid + " does not have android.permission.INTERNAL_DELETE_CACHE_FILES, silently ignoring");
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERNAL_DELETE_CACHE_FILES", null);
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "delete application cache files");
        int hasAccessInstantApps = this.mContext.checkCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS");
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        this.mHandler.post(new Runnable(pkg, callingUid, hasAccessInstantApps, userId, packageName, observer) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$8r42Vp4fp3avSpkV7DZbtKjUA */
            private final /* synthetic */ PackageParser.Package f$1;
            private final /* synthetic */ int f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ String f$5;
            private final /* synthetic */ IPackageDataObserver f$6;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
                this.f$6 = r7;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$deleteApplicationCacheFilesAsUser$28$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5, this.f$6);
            }
        });
    }

    public /* synthetic */ void lambda$deleteApplicationCacheFilesAsUser$28$PackageManagerService(PackageParser.Package pkg, int callingUid, int hasAccessInstantApps, int userId, String packageName, IPackageDataObserver observer) {
        PackageSetting ps = pkg == null ? null : (PackageSetting) pkg.mExtras;
        boolean doClearData = true;
        int reserveProfileFlag = 0;
        if (ps != null) {
            doClearData = !ps.getInstantApp(UserHandle.getUserId(callingUid)) || hasAccessInstantApps == 0;
        }
        if (doClearData) {
            synchronized (this.mInstallLock) {
                if (IS_SUPPORT_RESERVE_PROFILE) {
                    reserveProfileFlag = 128;
                }
                clearAppDataLIF(pkg, userId, reserveProfileFlag | DEFERRED_NO_KILL_POST_DELETE);
                clearAppDataLIF(pkg, userId, reserveProfileFlag | 39);
            }
            this.mContext.sendBroadcastAsUser(new Intent("com.huawei.intent.action.PACKAGE_CACHE_CLEARED", Uri.fromParts("package", packageName, null)).addFlags(DumpState.DUMP_SERVICE_PERMISSIONS).putExtra("android.intent.extra.PACKAGE_NAME", packageName).putExtra("android.intent.extra.UID", (pkg == null || pkg.applicationInfo == null) ? -1 : pkg.applicationInfo.uid), UserHandle.of(userId));
        }
        if (observer != null) {
            try {
                observer.onRemoveCompleted(packageName, true);
            } catch (RemoteException e) {
                Log.i(TAG, "Observer no longer exists.");
            }
        }
    }

    public void getPackageSizeInfo(String packageName, int userHandle, IPackageStatsObserver observer) {
        throw new UnsupportedOperationException("Shame on you for calling the hidden API getPackageSizeInfo(). Shame!");
    }

    @GuardedBy({"mInstallLock"})
    private boolean getPackageSizeInfoLI(String packageName, int userId, PackageStats stats) {
        PackageSetting ps;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(packageName);
            if (ps == null) {
                Slog.w(TAG, "Failed to find settings for " + packageName);
                return false;
            }
        }
        try {
            this.mInstaller.getAppSize(ps.volumeUuid, new String[]{packageName}, userId, 0, ps.appId, new long[]{ps.getCeDataInode(userId)}, new String[]{ps.codePathString}, stats);
            if (isSystemApp(ps) && !isUpdatedSystemApp(ps) && (ps.pkg.applicationInfo.hwFlags & DumpState.DUMP_APEX) == 0) {
                stats.codeSize = 0;
            }
            stats.dataSize -= stats.cacheSize;
            return true;
        } catch (Installer.InstallerException e) {
            Slog.w(TAG, String.valueOf(e));
            return false;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private int getUidTargetSdkVersionLockedLPr(int uid) {
        int v;
        Object obj = this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
        if (obj instanceof SharedUserSetting) {
            int vers = 10000;
            Iterator<PackageSetting> it = ((SharedUserSetting) obj).packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.pkg != null && (v = ps.pkg.applicationInfo.targetSdkVersion) < vers) {
                    vers = v;
                }
            }
            return vers;
        } else if (!(obj instanceof PackageSetting)) {
            return 10000;
        } else {
            PackageSetting ps2 = (PackageSetting) obj;
            if (ps2.pkg != null) {
                return ps2.pkg.applicationInfo.targetSdkVersion;
            }
            return 10000;
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private int getPackageTargetSdkVersionLockedLPr(String packageName) {
        PackageParser.Package p = this.mPackages.get(packageName);
        if (p != null) {
            return p.applicationInfo.targetSdkVersion;
        }
        return 10000;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void addPreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_ADDPREFERREDACTIVITY);
        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Adding preferred");
    }

    private void addPreferredActivityInternal(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, boolean always, int userId, String opname) {
        int callingUid = Binder.getCallingUid();
        if (activity != null) {
            Slog.d(TAG, opname + "add pref activity " + activity.flattenToShortString() + " from uid " + Binder.getCallingUid());
        }
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "add preferred activity");
        if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
            if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                Slog.w(TAG, "Ignoring addPreferredActivity() from uid " + callingUid);
                return;
            }
            this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        }
        if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else if (activity == null) {
            Slog.w(TAG, "Cannot set a preferred activity with activity is null");
        } else {
            if (filter.hasCategory("android.intent.category.HOME")) {
                if (!isAlreadyDefaultHomeActivity(activity, userId) && !mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                    Slog.i(TAG, "NOT ALLOWED TO add preferred activity current time!");
                    return;
                } else if (HwDeviceManager.disallowOp(17)) {
                    Slog.i(TAG, "NOT ALLOWED add preferred activity when mdm already set default home");
                    return;
                }
            }
            if (DEBUG_PREFERRED) {
                Slog.i(TAG, opname + " activity " + activity.flattenToShortString() + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            boolean isMultiScreenEnabled = mHwPMSEx.isMultiScreenCollaborationEnabled(null);
            synchronized (this.mPackages) {
                if (isMultiScreenEnabled) {
                    mHwPMSEx.putPreferredActivityInPcMode(userId, filter, new PreferredActivity(filter, match, set, activity, always));
                }
                if (!"com.huawei.pcassistant".equals(activity.getPackageName()) && (!always || !mHwPMSEx.resolvePreferredActivity(filter, match, set, activity, userId))) {
                    this.mSettings.editPreferredActivitiesLPw(userId).addFilter(new PreferredActivity(filter, match, set, activity, always));
                    scheduleWritePackageRestrictionsLocked(userId);
                }
            }
            if (!updateDefaultHomeNotLocked(userId)) {
                postPreferredActivityChangedBroadcast(userId);
            }
        }
    }

    private void postPreferredActivityChangedBroadcast(int userId) {
        this.mHandler.post(new Runnable(userId) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$mozSqBaYzz4jQjwZjKIapdRXflc */
            private final /* synthetic */ int f$0;

            {
                this.f$0 = r1;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.lambda$postPreferredActivityChangedBroadcast$29(this.f$0);
            }
        });
    }

    static /* synthetic */ void lambda$postPreferredActivityChangedBroadcast$29(int userId) {
        IActivityManager am = ActivityManager.getService();
        if (am != null) {
            Intent intent = new Intent("android.intent.action.ACTION_PREFERRED_ACTIVITY_CHANGED");
            intent.putExtra("android.intent.extra.user_handle", userId);
            intent.addFlags(DumpState.DUMP_HANDLE);
            try {
                am.broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, (String[]) null, -1, (Bundle) null, false, false, userId);
            } catch (RemoteException e) {
            }
        }
    }

    public void replacePreferredActivity(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
        Throwable th;
        if (filter.countActions() == 1) {
            if (filter.countDataAuthorities() == 0) {
                if (filter.countDataPaths() == 0) {
                    if (filter.countDataSchemes() <= 1) {
                        if (filter.countDataTypes() == 0) {
                            if (!filter.hasCategory("android.intent.category.HOME") || activity == null || isAlreadyDefaultHomeActivity(activity, userId) || mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
                                int callingUid = Binder.getCallingUid();
                                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "replace preferred activity");
                                if (this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                                    synchronized (this.mPackages) {
                                        if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                                            Slog.w(TAG, "Ignoring replacePreferredActivity() from uid " + Binder.getCallingUid());
                                            return;
                                        }
                                    }
                                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                                }
                                synchronized (this.mPackages) {
                                    try {
                                        PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
                                        if (pir != null) {
                                            ArrayList<PreferredActivity> existing = pir.findFilters(filter);
                                            if (existing != null && existing.size() == 1) {
                                                PreferredActivity cur = existing.get(0);
                                                if (DEBUG_PREFERRED) {
                                                    Slog.i(TAG, "Checking replace of preferred:");
                                                    filter.dump(new LogPrinter(4, TAG), "  ");
                                                    if (!cur.mPref.mAlways) {
                                                        Slog.i(TAG, "  -- CUR; not mAlways!");
                                                    } else {
                                                        Slog.i(TAG, "  -- CUR: mMatch=" + cur.mPref.mMatch);
                                                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(cur.mPref.mSetComponents));
                                                        Slog.i(TAG, "  -- CUR: mComponent=" + cur.mPref.mShortComponent);
                                                        Slog.i(TAG, "  -- NEW: mMatch=" + (match & 268369920));
                                                        Slog.i(TAG, "  -- CUR: mSet=" + Arrays.toString(set));
                                                        Slog.i(TAG, "  -- CUR: mComponent=" + activity.flattenToShortString());
                                                    }
                                                }
                                                if (cur.mPref.mAlways && cur.mPref.mComponent.equals(activity) && cur.mPref.mMatch == (match & 268369920)) {
                                                    try {
                                                        if (cur.mPref.sameSet(set)) {
                                                            if (DEBUG_PREFERRED) {
                                                                Slog.i(TAG, "Replacing with same preferred activity " + cur.mPref.mShortComponent + " for user " + userId + ":");
                                                                filter.dump(new LogPrinter(4, TAG), "  ");
                                                            }
                                                            return;
                                                        }
                                                    } catch (Throwable th2) {
                                                        th = th2;
                                                        throw th;
                                                    }
                                                }
                                            }
                                            if (existing != null) {
                                                if (DEBUG_PREFERRED) {
                                                    Slog.i(TAG, existing.size() + " existing preferred matches for:");
                                                    filter.dump(new LogPrinter(4, TAG), "  ");
                                                }
                                                for (int i = existing.size() - 1; i >= 0; i--) {
                                                    PreferredActivity pa = existing.get(i);
                                                    if (DEBUG_PREFERRED) {
                                                        Slog.i(TAG, "Removing existing preferred activity " + pa.mPref.mComponent + ":");
                                                        pa.dump(new LogPrinter(4, TAG), "  ");
                                                    }
                                                    pir.removeFilter(pa);
                                                }
                                            }
                                        }
                                        addPreferredActivityInternal(filter, match, set, activity, true, userId, "Replacing preferred");
                                        return;
                                    } catch (Throwable th3) {
                                        th = th3;
                                        throw th;
                                    }
                                }
                            } else {
                                Slog.i(TAG, "NOT ALLOWED TO replace preferred activity current time!");
                                throw new IllegalArgumentException("Component " + activity + " not allowed to be default home on user " + userId);
                            }
                        }
                    }
                }
            }
            throw new IllegalArgumentException("replacePreferredActivity expects filter to have no data authorities, paths, or types; and at most one scheme.");
        }
        throw new IllegalArgumentException("replacePreferredActivity expects filter to have only 1 action.");
    }

    private boolean isAlreadyDefaultHomeActivity(ComponentName activity, int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "Default home provider has not been set");
            return false;
        }
        String currentPackageName = provider.getDefaultHome(userId);
        Slog.i(TAG, "currentPackageName: " + currentPackageName + ", packageName: " + activity.getPackageName());
        if (!TextUtils.equals(currentPackageName, activity.getPackageName())) {
            return false;
        }
        Slog.i(TAG, "packageName: " + currentPackageName + " is already default home");
        return true;
    }

    public void clearPackagePreferredActivities(String packageName) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_CLEARPACKAGEPREFERREDACTIVITIES);
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) == null) {
            synchronized (this.mPackages) {
                if ((this.mPackages.get(packageName) == null || !isCallerSameApp(packageName, callingUid)) && this.mContext.checkCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS") != 0) {
                    if (getUidTargetSdkVersionLockedLPr(callingUid) < 8) {
                        Slog.w(TAG, "Ignoring clearPackagePreferredActivities() from uid " + callingUid);
                        return;
                    }
                    this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
                }
                PackageSetting ps = this.mSettings.getPackageLPr(packageName);
                if (ps != null && filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                    return;
                }
            }
            int callingUserId = UserHandle.getCallingUserId();
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            synchronized (this.mPackages) {
                clearPackagePreferredActivitiesLPw(packageName, changedUsers, callingUserId);
            }
            if (changedUsers.size() > 0) {
                updateDefaultHomeNotLocked(changedUsers);
                postPreferredActivityChangedBroadcast(callingUserId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(callingUserId);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearPackagePreferredActivitiesLPw(String packageName, SparseBooleanArray outUserChanged, int userId) {
        Slog.d(TAG, "clear pref activity " + packageName + " outUserChanged " + outUserChanged + " for user " + userId + "from uid " + Binder.getCallingUid());
        ArrayList<PreferredActivity> removed = null;
        for (int i = 0; i < this.mSettings.mPreferredActivities.size(); i++) {
            int thisUserId = this.mSettings.mPreferredActivities.keyAt(i);
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i);
            if (userId == -1 || userId == thisUserId) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (removed == null) {
                            removed = new ArrayList<>();
                        }
                        removed.add(pa);
                    }
                }
                if (removed != null) {
                    for (int j = 0; j < removed.size(); j++) {
                        pir.removeFilter(removed.get(j));
                    }
                    outUserChanged.put(thisUserId, true);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void clearIntentFilterVerificationsLPw(int userId) {
        int packageCount = this.mPackages.size();
        for (int i = 0; i < packageCount; i++) {
            clearIntentFilterVerificationsLPw(this.mPackages.valueAt(i).packageName, userId, true);
        }
    }

    /* access modifiers changed from: package-private */
    @GuardedBy({"mPackages"})
    public void clearIntentFilterVerificationsLPw(String packageName, int userId, boolean alsoResetStatus) {
        if (userId == -1) {
            if (this.mSettings.removeIntentFilterVerificationLPw(packageName, sUserManager.getUserIds())) {
                for (int oneUserId : sUserManager.getUserIds()) {
                    scheduleWritePackageRestrictionsLocked(oneUserId);
                }
            }
        } else if (this.mSettings.removeIntentFilterVerificationLPw(packageName, userId, alsoResetStatus)) {
            scheduleWritePackageRestrictionsLocked(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void clearDefaultBrowserIfNeeded(String packageName) {
        for (int oneUserId : sUserManager.getUserIds()) {
            clearDefaultBrowserIfNeededForUser(packageName, oneUserId);
        }
    }

    private void clearDefaultBrowserIfNeededForUser(String packageName, int userId) {
        String defaultBrowserPackageName = getDefaultBrowserPackageName(userId);
        if (!TextUtils.isEmpty(defaultBrowserPackageName) && packageName.equals(defaultBrowserPackageName)) {
            setDefaultBrowserPackageName(null, userId);
        }
    }

    public void resetApplicationPreferences(int userId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.SET_PREFERRED_APPLICATIONS", null);
        long identity = Binder.clearCallingIdentity();
        try {
            SparseBooleanArray changedUsers = new SparseBooleanArray();
            clearPackagePreferredActivitiesLPw(null, changedUsers, userId);
            synchronized (this.mPackages) {
                this.mSettings.applyDefaultPreferredAppsLPw(userId);
                clearIntentFilterVerificationsLPw(userId);
                primeDomainVerificationsLPw(userId);
                resetUserChangesToRuntimePermissionsAndFlagsLPw(userId);
            }
            if (changedUsers.size() > 0) {
                postPreferredActivityChangedBroadcast(userId);
            }
            updateDefaultHomeNotLocked(userId);
            setDefaultBrowserPackageName(null, userId);
            resetNetworkPolicies(userId);
            synchronized (this.mPackages) {
                scheduleWritePackageRestrictionsLocked(userId);
            }
        } finally {
            Binder.restoreCallingIdentity(identity);
        }
    }

    public int getPreferredActivities(List<IntentFilter> outFilters, List<ComponentName> outActivities, String packageName) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return 0;
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this.mPackages) {
            PreferredIntentResolver pir = this.mSettings.mPreferredActivities.get(userId);
            if (pir != null) {
                Iterator<PreferredActivity> it = pir.filterIterator();
                while (it.hasNext()) {
                    PreferredActivity pa = it.next();
                    if (packageName == null || (pa.mPref.mComponent.getPackageName().equals(packageName) && pa.mPref.mAlways)) {
                        if (outFilters != null) {
                            outFilters.add(new IntentFilter(pa));
                        }
                        if (outActivities != null) {
                            outActivities.add(pa.mPref.mComponent);
                        }
                    }
                }
            }
        }
        return 0;
    }

    public void addPersistentPreferredActivity(IntentFilter filter, ComponentName activity, int userId) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("addPersistentPreferredActivity can only be run by the system");
        } else if (filter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a preferred activity with no filter actions");
        } else if (!filter.hasCategory("android.intent.category.HOME") || activity == null || isAlreadyDefaultHomeActivity(activity, userId) || mHwPMSEx.isAllowedSetHomeActivityForAntiMal(getPackageInfo(activity.getPackageName(), 0, userId), userId)) {
            if (DEBUG_PREFERRED) {
                Slog.i(TAG, "Adding persistent preferred activity " + activity + " for user " + userId + ":");
                filter.dump(new LogPrinter(4, TAG), "  ");
            }
            synchronized (this.mPackages) {
                this.mSettings.editPersistentPreferredActivitiesLPw(userId).addFilter(new PersistentPreferredActivity(filter, activity));
                scheduleWritePackageRestrictionsLocked(userId);
            }
            updateDefaultHomeNotLocked(userId);
            postPreferredActivityChangedBroadcast(userId);
        } else {
            Slog.i(TAG, "NOT ALLOWED TO add persistent preferred activity current time!");
        }
    }

    public void clearPackagePersistentPreferredActivities(String packageName, int userId) {
        if (Binder.getCallingUid() == 1000) {
            ArrayList<PersistentPreferredActivity> removed = null;
            boolean changed = false;
            synchronized (this.mPackages) {
                Slog.i(TAG, "clearPackagePersistentPreferredActivities with  " + packageName + " for user " + userId);
                for (int i = 0; i < this.mSettings.mPersistentPreferredActivities.size(); i++) {
                    int thisUserId = this.mSettings.mPersistentPreferredActivities.keyAt(i);
                    PersistentPreferredIntentResolver ppir = this.mSettings.mPersistentPreferredActivities.valueAt(i);
                    if (userId == thisUserId) {
                        Iterator<PersistentPreferredActivity> it = ppir.filterIterator();
                        while (it.hasNext()) {
                            PersistentPreferredActivity ppa = it.next();
                            if (ppa.mComponent.getPackageName().equals(packageName)) {
                                if (removed == null) {
                                    removed = new ArrayList<>();
                                }
                                removed.add(ppa);
                            }
                        }
                        if (removed != null) {
                            for (int j = 0; j < removed.size(); j++) {
                                ppir.removeFilter(removed.get(j));
                            }
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                updateDefaultHomeNotLocked(userId);
                postPreferredActivityChangedBroadcast(userId);
                synchronized (this.mPackages) {
                    scheduleWritePackageRestrictionsLocked(userId);
                }
                return;
            }
            return;
        }
        throw new SecurityException("clearPackagePersistentPreferredActivities can only be run by the system");
    }

    private void restoreFromXml(XmlPullParser parser, int userId, String expectedStartTag, BlobXmlRestorer functor) throws IOException, XmlPullParserException {
        int type;
        do {
            type = parser.next();
            if (type == 2) {
                break;
            }
        } while (type != 1);
        if (type != 2) {
            if (DEBUG_BACKUP) {
                Slog.e(TAG, "Didn't find start tag during restore");
            }
        } else if (expectedStartTag.equals(parser.getName())) {
            do {
            } while (parser.next() == 4);
            functor.apply(parser, userId);
        } else if (DEBUG_BACKUP) {
            Slog.e(TAG, "Found unexpected tag " + parser.getName());
        }
    }

    public byte[] getPreferredActivityBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_PREFERRED_BACKUP);
                synchronized (this.mPackages) {
                    this.mSettings.writePreferredActivitiesLPr(serializer, userId, true);
                }
                serializer.endTag(null, TAG_PREFERRED_BACKUP);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write preferred activities for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getPreferredActivityBackup()");
        }
    }

    public void restorePreferredActivities(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_PREFERRED_BACKUP, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$XrodqQtXF63SFPD_WxRBB7sfa4 */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restorePreferredActivities$30$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restorePreferredActivities$30$PackageManagerService(XmlPullParser readParser, int readUserId) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readPreferredActivitiesLPw(readParser, readUserId);
        }
        updateDefaultHomeNotLocked(readUserId);
    }

    public byte[] getDefaultAppsBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_DEFAULT_APPS);
                synchronized (this.mPackages) {
                    this.mSettings.writeDefaultAppsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_DEFAULT_APPS);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getDefaultAppsBackup()");
        }
    }

    public void restoreDefaultApps(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_DEFAULT_APPS, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$DWomXCDpiVbZPOk7h4gWI0gNMDM */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreDefaultApps$31$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring default apps: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restoreDefaultApps()");
        }
    }

    public /* synthetic */ void lambda$restoreDefaultApps$31$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        String defaultBrowser;
        PackageManagerInternal.DefaultBrowserProvider provider;
        synchronized (this.mPackages) {
            this.mSettings.readDefaultAppsLPw(parser1, userId1);
            defaultBrowser = this.mSettings.removeDefaultBrowserPackageNameLPw(userId1);
        }
        if (defaultBrowser != null) {
            synchronized (this.mPackages) {
                provider = this.mDefaultBrowserProvider;
            }
            provider.setDefaultBrowser(defaultBrowser, userId1);
        }
    }

    public byte[] getIntentFilterVerificationBackup(int userId) {
        if (Binder.getCallingUid() == 1000) {
            ByteArrayOutputStream dataStream = new ByteArrayOutputStream();
            try {
                XmlSerializer serializer = new FastXmlSerializer();
                serializer.setOutput(dataStream, StandardCharsets.UTF_8.name());
                serializer.startDocument(null, true);
                serializer.startTag(null, TAG_INTENT_FILTER_VERIFICATION);
                synchronized (this.mPackages) {
                    this.mSettings.writeAllDomainVerificationsLPr(serializer, userId);
                }
                serializer.endTag(null, TAG_INTENT_FILTER_VERIFICATION);
                serializer.endDocument();
                serializer.flush();
                return dataStream.toByteArray();
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Unable to write default apps for backup", e);
                }
                return null;
            }
        } else {
            throw new SecurityException("Only the system may call getIntentFilterVerificationBackup()");
        }
    }

    public void restoreIntentFilterVerification(byte[] backup, int userId) {
        if (Binder.getCallingUid() == 1000) {
            try {
                XmlPullParser parser = Xml.newPullParser();
                parser.setInput(new ByteArrayInputStream(backup), StandardCharsets.UTF_8.name());
                restoreFromXml(parser, userId, TAG_INTENT_FILTER_VERIFICATION, new BlobXmlRestorer() {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$hLkpaH_y40nbOItNYjiR8EOZUgM */

                    @Override // com.android.server.pm.PackageManagerService.BlobXmlRestorer
                    public final void apply(XmlPullParser xmlPullParser, int i) {
                        PackageManagerService.this.lambda$restoreIntentFilterVerification$32$PackageManagerService(xmlPullParser, i);
                    }
                });
            } catch (Exception e) {
                if (DEBUG_BACKUP) {
                    Slog.e(TAG, "Exception restoring preferred activities: " + e.getMessage());
                }
            }
        } else {
            throw new SecurityException("Only the system may call restorePreferredActivities()");
        }
    }

    public /* synthetic */ void lambda$restoreIntentFilterVerification$32$PackageManagerService(XmlPullParser parser1, int userId1) throws IOException, XmlPullParserException {
        synchronized (this.mPackages) {
            this.mSettings.readAllDomainVerificationsLPr(parser1, userId1);
            this.mSettings.writeLPr();
        }
    }

    public void addCrossProfileIntentFilter(IntentFilter intentFilter, String ownerPackage, int sourceUserId, int targetUserId, int flags) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        if (intentFilter.countActions() == 0) {
            Slog.w(TAG, "Cannot set a crossProfile intent filter with no filter actions");
            return;
        }
        synchronized (this.mPackages) {
            CrossProfileIntentFilter newFilter = new CrossProfileIntentFilter(intentFilter, ownerPackage, targetUserId, flags);
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            ArrayList<CrossProfileIntentFilter> existing = resolver.findFilters(intentFilter);
            if (existing != null) {
                int size = existing.size();
                for (int i = 0; i < size; i++) {
                    if (newFilter.equalsIgnoreFilter(existing.get(i))) {
                        return;
                    }
                }
            }
            resolver.addFilter(newFilter);
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    public void clearCrossProfileIntentFilters(int sourceUserId, String ownerPackage) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", null);
        int callingUid = Binder.getCallingUid();
        enforceOwnerRights(ownerPackage, callingUid);
        PackageManagerServiceUtils.enforceShellRestriction("no_debugging_features", callingUid, sourceUserId);
        synchronized (this.mPackages) {
            CrossProfileIntentResolver resolver = this.mSettings.editCrossProfileIntentResolverLPw(sourceUserId);
            Iterator<CrossProfileIntentFilter> it = new ArraySet<>(resolver.filterSet()).iterator();
            while (it.hasNext()) {
                CrossProfileIntentFilter filter = it.next();
                if (filter.getOwnerPackage().equals(ownerPackage)) {
                    resolver.removeFilter(filter);
                }
            }
            scheduleWritePackageRestrictionsLocked(sourceUserId);
        }
    }

    private void enforceOwnerRights(String pkg, int callingUid) {
        if (UserHandle.getAppId(callingUid) != 1000) {
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageInfo pi = getPackageInfo(pkg, 0, callingUserId);
            if (pi == null) {
                throw new IllegalArgumentException("Unknown package " + pkg + " on user " + callingUserId);
            } else if (!UserHandle.isSameApp(pi.applicationInfo.uid, callingUid)) {
                throw new SecurityException("Calling uid " + callingUid + " does not own package " + pkg);
            }
        }
    }

    public ComponentName getHomeActivities(List<ResolveInfo> allHomeCandidates) {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return getHomeActivitiesAsUser(allHomeCandidates, UserHandle.getCallingUserId());
    }

    public void sendSessionUpdatedBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        if (!TextUtils.isEmpty(sessionInfo.installerPackageName)) {
            this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_UPDATED").putExtra("android.content.pm.extra.SESSION", sessionInfo).setPackage(sessionInfo.installerPackageName), UserHandle.of(userId));
        }
    }

    public void sendSessionCommitBroadcast(PackageInstaller.SessionInfo sessionInfo, int userId) {
        UserManagerService ums = UserManagerService.getInstance();
        if (ums != null) {
            UserInfo parent = ums.getProfileParent(userId);
            int launcherUid = parent != null ? parent.id : userId;
            ComponentName launcherComponent = getDefaultHomeActivity(launcherUid);
            if (launcherComponent != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(launcherComponent.getPackageName()), UserHandle.of(launcherUid));
            }
            if (this.mAppPredictionServicePackage != null) {
                this.mContext.sendBroadcastAsUser(new Intent("android.content.pm.action.SESSION_COMMITTED").putExtra("android.content.pm.extra.SESSION", sessionInfo).putExtra("android.intent.extra.USER", UserHandle.of(userId)).setPackage(this.mAppPredictionServicePackage), UserHandle.of(launcherUid));
            }
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private ComponentName getDefaultHomeActivity(int userId) {
        List<ResolveInfo> allHomeCandidates = new ArrayList<>();
        ComponentName cn = getHomeActivitiesAsUser(allHomeCandidates, userId);
        if (cn != null) {
            return cn;
        }
        int lastPriority = Integer.MIN_VALUE;
        ComponentName lastComponent = null;
        int size = allHomeCandidates.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo ri = allHomeCandidates.get(i);
            if (ri.priority > lastPriority) {
                lastComponent = ri.activityInfo.getComponentName();
                lastPriority = ri.priority;
            } else if (ri.priority == lastPriority) {
                lastComponent = null;
            }
        }
        return lastComponent;
    }

    private Intent getHomeIntent() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.HOME");
        intent.addCategory("android.intent.category.DEFAULT");
        return intent;
    }

    private IntentFilter getHomeFilter() {
        IntentFilter filter = new IntentFilter("android.intent.action.MAIN");
        filter.addCategory("android.intent.category.HOME");
        filter.addCategory("android.intent.category.DEFAULT");
        return filter;
    }

    /* access modifiers changed from: package-private */
    public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        ComponentName componentName;
        List<ResolveInfo> resolveInfos = queryIntentActivitiesInternal(getHomeIntent(), null, 128, userId);
        allHomeCandidates.clear();
        if (resolveInfos == null) {
            return null;
        }
        allHomeCandidates.addAll(resolveInfos);
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "mDefaultHomeProvider is null");
            return null;
        }
        String packageName = provider.getDefaultHome(userId);
        if (packageName == null) {
            return null;
        }
        if (HwDeviceManager.disallowOp(17) && (componentName = mHwPMSEx.getMdmDefaultLauncher(resolveInfos)) != null) {
            return componentName;
        }
        int resolveInfosSize = resolveInfos.size();
        for (int i = 0; i < resolveInfosSize; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            if (resolveInfo.activityInfo != null && TextUtils.equals(resolveInfo.activityInfo.packageName, packageName)) {
                return new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);
            }
        }
        return null;
    }

    private void updateDefaultHomeNotLocked(SparseBooleanArray userIds) {
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        for (int i = userIds.size() - 1; i >= 0; i--) {
            updateDefaultHomeNotLocked(userIds.keyAt(i));
        }
    }

    private boolean updateDefaultHomeNotLocked(int userId) {
        PackageManagerInternal.DefaultHomeProvider provider;
        if (Thread.holdsLock(this.mPackages)) {
            Slog.wtf(TAG, "Calling thread " + Thread.currentThread().getName() + " is holding mPackages", new Throwable());
        }
        if (!this.mSystemReady) {
            return false;
        }
        Intent intent = getHomeIntent();
        String packageName = null;
        ResolveInfo preferredResolveInfo = findPreferredActivityNotLocked(intent, null, 0, queryIntentActivitiesInternal(intent, null, 786560, userId), 0, true, false, false, userId);
        if (!(preferredResolveInfo == null || preferredResolveInfo.activityInfo == null)) {
            packageName = preferredResolveInfo.activityInfo.packageName;
        }
        synchronized (this.mPackages) {
            provider = this.mDefaultHomeProvider;
        }
        if (provider == null) {
            Slog.e(TAG, "Default home provider has not been set");
            return false;
        } else if (TextUtils.equals(provider.getDefaultHome(userId), packageName)) {
            return false;
        } else {
            String[] callingPackages = getPackagesForUid(Binder.getCallingUid());
            if (callingPackages != null && ArrayUtils.contains(callingPackages, this.mRequiredPermissionControllerPackage)) {
                return false;
            }
            provider.setDefaultHomeAsync(packageName, userId, new Consumer(userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$ms4g2QGGQv1AIanhd1siLhoElkI */
                private final /* synthetic */ int f$1;

                {
                    this.f$1 = r2;
                }

                @Override // java.util.function.Consumer
                public final void accept(Object obj) {
                    PackageManagerService.this.lambda$updateDefaultHomeNotLocked$33$PackageManagerService(this.f$1, (Boolean) obj);
                }
            });
            return true;
        }
    }

    public /* synthetic */ void lambda$updateDefaultHomeNotLocked$33$PackageManagerService(int userId, Boolean successful) {
        if (successful.booleanValue()) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    public void setHomeActivity(ComponentName comp, int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null) {
            ArrayList<ResolveInfo> homeActivities = new ArrayList<>();
            getHomeActivitiesAsUser(homeActivities, userId);
            boolean found = false;
            int size = homeActivities.size();
            ComponentName[] set = new ComponentName[size];
            for (int i = 0; i < size; i++) {
                ActivityInfo info = homeActivities.get(i).activityInfo;
                ComponentName activityName = new ComponentName(info.packageName, info.name);
                set[i] = activityName;
                if (!found && activityName.equals(comp)) {
                    found = true;
                }
            }
            if (found) {
                replacePreferredActivity(getHomeFilter(), 1048576, set, comp, userId);
                return;
            }
            throw new IllegalArgumentException("Component " + comp + " cannot be home on user " + userId);
        }
    }

    private String getSetupWizardPackageName() {
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory("android.intent.category.SETUP_WIZARD");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one setup wizard; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getStorageManagerPackageName() {
        List<ResolveInfo> matches = queryIntentActivitiesInternal(new Intent("android.os.storage.action.MANAGE_STORAGE"), null, 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one storage manager; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    public String getSystemTextClassifierPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039823));
    }

    public String getAttentionServicePackageName() {
        ComponentName componentName;
        String flattenedComponentName = this.mContext.getString(17039809);
        if (flattenedComponentName == null || (componentName = ComponentName.unflattenFromString(flattenedComponentName)) == null || componentName.getPackageName() == null) {
            return null;
        }
        return ensureSystemPackageName(componentName.getPackageName());
    }

    private String getDocumenterPackageName() {
        Intent intent = new Intent("android.intent.action.OPEN_DOCUMENT");
        intent.addCategory("android.intent.category.OPENABLE");
        intent.setType("*/*");
        List<ResolveInfo> matches = queryIntentActivitiesInternal(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), 1835520, UserHandle.myUserId());
        if (matches.size() == 1) {
            return matches.get(0).getComponentInfo().packageName;
        }
        Slog.e(TAG, "There should probably be exactly one documenter; found " + matches.size() + ": matches=" + matches);
        return null;
    }

    private String getDeviceConfiguratorPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039827));
    }

    public String getWellbeingPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039825));
    }

    public String getAppPredictionServicePackageName() {
        ComponentName appPredictionServiceComponentName;
        String flattenedAppPredictionServiceComponentName = this.mContext.getString(17039807);
        if (flattenedAppPredictionServiceComponentName == null || (appPredictionServiceComponentName = ComponentName.unflattenFromString(flattenedAppPredictionServiceComponentName)) == null) {
            return null;
        }
        return ensureSystemPackageName(appPredictionServiceComponentName.getPackageName());
    }

    public String getSystemCaptionsServicePackageName() {
        ComponentName systemCaptionsServiceComponentName;
        String flattenedSystemCaptionsServiceComponentName = this.mContext.getString(17039822);
        if (!TextUtils.isEmpty(flattenedSystemCaptionsServiceComponentName) && (systemCaptionsServiceComponentName = ComponentName.unflattenFromString(flattenedSystemCaptionsServiceComponentName)) != null) {
            return ensureSystemPackageName(systemCaptionsServiceComponentName.getPackageName());
        }
        return null;
    }

    public String getIncidentReportApproverPackageName() {
        return ensureSystemPackageName(this.mContext.getString(17039853));
    }

    private String ensureSystemPackageName(String packageName) {
        if (packageName == null) {
            return null;
        }
        long token = Binder.clearCallingIdentity();
        try {
            if (getPackageInfo(packageName, 2097152, 0) == null) {
                PackageInfo packageInfo = getPackageInfo(packageName, 0, 0);
                if (packageInfo != null) {
                    EventLog.writeEvent(1397638484, "145981139", Integer.valueOf(packageInfo.applicationInfo.uid), "");
                }
                return null;
            }
            Binder.restoreCallingIdentity(token);
            return packageName;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public void setApplicationEnabledSetting(String appPackageName, int newState, int flags, int userId, String callingPackage) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETAPPLICATIONENABLEDSETTING);
        if (sUserManager.exists(userId)) {
            if (callingPackage == null) {
                callingPackage = Integer.toString(Binder.getCallingUid());
            }
            if (!mHwPMSEx.isNeedForbidHarmfulAppDisableApp(callingPackage, appPackageName) || !(newState == 2 || newState == 3 || newState == 4)) {
                Log.v(TAG, "Setting application enabled setting: appPackageName=" + appPackageName + " newState=" + newState + " flags=" + flags + " userId=" + userId + " callingPackage=" + callingPackage);
                setEnabledSetting(appPackageName, null, newState, flags, userId, callingPackage);
                return;
            }
            Slog.i(TAG, appPackageName + " will not to be disabled application!");
        }
    }

    public void setUpdateAvailable(String packageName, boolean updateAvailable) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.INSTALL_PACKAGES", null);
        synchronized (this.mPackages) {
            PackageSetting pkgSetting = this.mSettings.mPackages.get(packageName);
            if (pkgSetting != null) {
                pkgSetting.setUpdateAvailable(updateAvailable);
            }
        }
    }

    public void setComponentEnabledSetting(ComponentName componentName, int newState, int flags, int userId) {
        HwFrameworkFactory.getHwBehaviorCollectManager().sendBehavior(IHwBehaviorCollectManager.BehaviorId.PACKAGEMANAGER_SETCOMPONENTENABLEDSETTING, new Object[]{Integer.valueOf(newState)});
        if (sUserManager.exists(userId) && componentName != null) {
            setEnabledSetting(componentName.getPackageName(), componentName.getClassName(), newState, flags, userId, null);
        }
    }

    /* JADX INFO: finally extract failed */
    /* JADX WARNING: Removed duplicated region for block: B:206:0x03a6  */
    /* JADX WARNING: Removed duplicated region for block: B:221:0x03d4  */
    private void setEnabledSetting(String packageName, String className, int newState, int flags, int userId, String callingPackage) {
        int permission;
        Throwable th;
        PackageSetting pkgSetting;
        boolean sendNow;
        Throwable th2;
        Throwable th3;
        ArrayList<String> components;
        boolean allowedByPermission;
        long broadcastDelay;
        PackageParser.Package pkg;
        String callingPackage2;
        String str;
        String str2;
        IHwPackageManagerServiceEx iHwPackageManagerServiceEx;
        if ((newState == 2 || newState == 3 || newState == 4) && (HwPackageManagerServiceUtils.isNotAllowUninstallAndDisable(userId, packageName) || ((iHwPackageManagerServiceEx = mHwPMSEx) != null && iHwPackageManagerServiceEx.isNeedForbidShellFunc(packageName)))) {
            Slog.i(TAG, "disablePackage NeedForbidShellFunc, " + packageName + " won't be disabled");
        } else if (newState != 0 && newState != 1 && newState != 2 && newState != 3 && newState != 4) {
            throw new IllegalArgumentException("Invalid new component state: " + newState);
        } else if (mHwPMSEx.isNeedForbidHarmfulAppDisableApp(callingPackage, packageName) && (newState == 2 || newState == 3 || newState == 4)) {
            Slog.i(TAG, packageName + " will not to be disabled component!");
        } else if (newState == 2 || !mHwPMSEx.isNeedForbidAppAct(FORBID_ENABLE_COMPONENT, packageName, className, null)) {
            Flog.i(206, "setEnabledSetting pkg:" + packageName + ", className:" + className + ", newState:" + newState + ", flags:" + flags + ", userId:" + userId + ", CallingPid:" + Binder.getCallingPid() + ", CallingUid:" + Binder.getCallingUid());
            int callingUid = Binder.getCallingUid();
            if (!"com.huawei.systemmanager".equals(packageName) || !HwPackageManagerServiceUtils.isDisableStatus(newState) || (callingUid != 2000 && !"com.android.shell".equals(callingPackage))) {
                if (callingUid == 1000) {
                    permission = 0;
                } else {
                    permission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE");
                }
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "set enabled");
                boolean allowedByPermission2 = permission == 0;
                boolean isApp = className == null;
                boolean isCallerInstantApp = getInstantAppPackageName(callingUid) != null;
                String componentName = isApp ? packageName : className;
                synchronized (this.mPackages) {
                    try {
                        pkgSetting = this.mSettings.mPackages.get(packageName);
                        if (pkgSetting != null) {
                            sendNow = false;
                            try {
                            } catch (Throwable th4) {
                                th = th4;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } else if (isCallerInstantApp) {
                            try {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Attempt to change component state; pid=");
                                sb.append(Binder.getCallingPid());
                                sb.append(", uid=");
                                sb.append(callingUid);
                                if (className == null) {
                                    StringBuilder sb2 = new StringBuilder();
                                    try {
                                        sb2.append(", package=");
                                        sb2.append(packageName);
                                        str2 = sb2.toString();
                                    } catch (Throwable th5) {
                                        th = th5;
                                        while (true) {
                                            break;
                                        }
                                        throw th;
                                    }
                                } else {
                                    str2 = ", component=" + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className;
                                }
                                sb.append(str2);
                                throw new SecurityException(sb.toString());
                            } catch (Throwable th6) {
                                th = th6;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } else if (className == null) {
                            try {
                                try {
                                    StringBuilder sb3 = new StringBuilder();
                                    sb3.append("Unknown package: ");
                                    sb3.append(packageName);
                                    throw new IllegalArgumentException(sb3.toString());
                                } catch (Throwable th7) {
                                    th = th7;
                                    while (true) {
                                        break;
                                    }
                                    throw th;
                                }
                            } catch (Throwable th8) {
                                th = th8;
                                while (true) {
                                    break;
                                }
                                throw th;
                            }
                        } else {
                            throw new IllegalArgumentException("Unknown component: " + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className);
                        }
                    } catch (Throwable th9) {
                        th = th9;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                if (!UserHandle.isSameApp(callingUid, pkgSetting.appId)) {
                    if (!allowedByPermission2 || filterAppAccessLPr(pkgSetting, callingUid, userId)) {
                        StringBuilder sb4 = new StringBuilder();
                        sb4.append("Attempt to change component state; pid=");
                        sb4.append(Binder.getCallingPid());
                        sb4.append(", uid=");
                        sb4.append(callingUid);
                        if (className == null) {
                            str = ", package=" + packageName;
                        } else {
                            str = ", component=" + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className;
                        }
                        sb4.append(str);
                        throw new SecurityException(sb4.toString());
                    } else if (this.mProtectedPackages.isPackageStateProtected(userId, packageName)) {
                        throw new SecurityException("Cannot disable a protected package: " + packageName);
                    }
                }
                if (!PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME.equals(className) || allowedByPermission2) {
                    synchronized (this.mPackages) {
                        if (callingUid == 2000) {
                            try {
                                if ((pkgSetting.pkgFlags & 256) == 0) {
                                    int oldState = pkgSetting.getEnabled(userId);
                                    if (className != null || ((oldState != 3 && oldState != 0 && oldState != 1) || (newState != 3 && newState != 0 && newState != 1))) {
                                        throw new SecurityException("Shell cannot change component state for " + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + className + " to " + newState);
                                    }
                                }
                            } catch (Throwable th10) {
                                th2 = th10;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th11) {
                                        th2 = th11;
                                    }
                                }
                                throw th2;
                            }
                        }
                        try {
                        } catch (Throwable th12) {
                            th2 = th12;
                            while (true) {
                                break;
                            }
                            throw th2;
                        }
                    }
                    if (className == null) {
                        synchronized (this.mPackages) {
                            if (pkgSetting.getEnabled(userId) == newState) {
                                return;
                            }
                        }
                        PackageParser.Package deletedPkg = pkgSetting.pkg;
                        if (!(deletedPkg.isStub && deletedPkg.isSystem()) || (!(newState == 0 || newState == 1) || enableCompressedPackage(deletedPkg))) {
                            if (newState == 0 || newState == 1) {
                                callingPackage2 = null;
                            } else {
                                callingPackage2 = callingPackage;
                            }
                            synchronized (this.mPackages) {
                                pkgSetting.setEnabled(newState, userId, callingPackage2);
                            }
                        } else {
                            return;
                        }
                    } else {
                        synchronized (this.mPackages) {
                            try {
                                PackageParser.Package pkg2 = pkgSetting.pkg;
                                if (pkg2 != null) {
                                    try {
                                        if (!pkg2.hasComponentClassName(className)) {
                                        }
                                        if (newState == 0) {
                                            if (newState != 1) {
                                                if (newState != 2) {
                                                    Slog.e(TAG, "Invalid new component state: " + newState);
                                                    return;
                                                } else if (!pkgSetting.disableComponentLPw(className, userId)) {
                                                    return;
                                                }
                                            } else if (!pkgSetting.enableComponentLPw(className, userId)) {
                                                return;
                                            }
                                        } else if (!pkgSetting.restoreComponentLPw(className, userId)) {
                                            return;
                                        }
                                    } catch (Throwable th13) {
                                        pkg = th13;
                                        while (true) {
                                            try {
                                                break;
                                            } catch (Throwable th14) {
                                                pkg = th14;
                                            }
                                        }
                                        throw pkg;
                                    }
                                }
                                if (pkg2 != null) {
                                    if (pkg2.applicationInfo.targetSdkVersion >= 16) {
                                        throw new IllegalArgumentException("Component class " + className + " does not exist in " + packageName);
                                    }
                                }
                                Slog.w(TAG, "Failed setComponentEnabledSetting: component class " + className + " does not exist in " + packageName);
                                if (newState == 0) {
                                }
                            } catch (Throwable th15) {
                                pkg = th15;
                                while (true) {
                                    break;
                                }
                                throw pkg;
                            }
                        }
                    }
                    synchronized (this.mPackages) {
                        try {
                            scheduleWritePackageRestrictionsLocked(userId);
                            updateSequenceNumberLP(pkgSetting, new int[]{userId});
                            long callingId = Binder.clearCallingIdentity();
                            try {
                                updateInstantAppInstallerLocked(packageName);
                                Binder.restoreCallingIdentity(callingId);
                                components = this.mPendingBroadcasts.get(userId, packageName);
                                boolean newPackage = components == null;
                                if (newPackage) {
                                    try {
                                        components = new ArrayList<>();
                                    } catch (Throwable th16) {
                                        th3 = th16;
                                        throw th3;
                                    }
                                }
                                if (!components.contains(componentName)) {
                                    components.add(componentName);
                                }
                                if ((flags & 1) == 0) {
                                    try {
                                        this.mPendingBroadcasts.remove(userId, packageName);
                                        sendNow = true;
                                        allowedByPermission = true;
                                    } catch (Throwable th17) {
                                        th3 = th17;
                                        throw th3;
                                    }
                                } else {
                                    if (newPackage) {
                                        this.mPendingBroadcasts.put(userId, packageName, components);
                                    }
                                    if (!this.mHandler.hasMessages(1)) {
                                        if (SystemClock.uptimeMillis() > this.mServiceStartWithDelay) {
                                            broadcastDelay = 1000;
                                        } else {
                                            broadcastDelay = JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY;
                                        }
                                        allowedByPermission = true;
                                        try {
                                            this.mHandler.sendEmptyMessageDelayed(1, broadcastDelay);
                                        } catch (Throwable th18) {
                                            th3 = th18;
                                            throw th3;
                                        }
                                    } else {
                                        allowedByPermission = true;
                                    }
                                }
                            } catch (Throwable th19) {
                                Binder.restoreCallingIdentity(callingId);
                                throw th19;
                            }
                        } catch (Throwable th20) {
                            th3 = th20;
                            throw th3;
                        }
                    }
                    long callingId2 = Binder.clearCallingIdentity();
                    if (sendNow) {
                        try {
                            int packageUid = UserHandle.getUid(userId, pkgSetting.appId);
                            if ((flags & 1) == 0) {
                                allowedByPermission = false;
                            }
                            sendPackageChangedBroadcast(packageName, allowedByPermission, components, packageUid);
                        } catch (Throwable th21) {
                            Binder.restoreCallingIdentity(callingId2);
                            throw th21;
                        }
                    }
                    Binder.restoreCallingIdentity(callingId2);
                    return;
                }
                throw new SecurityException("Cannot disable a system-generated component");
            }
            Slog.i(TAG, "not allowed to disable systemmanager in adb shell");
        } else {
            Slog.i(TAG, "isNeedForbidAppAct forbid enable component");
        }
    }

    public void flushPackageRestrictionsAsUser(int userId) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && sUserManager.exists(userId)) {
            this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "flushPackageRestrictions");
            synchronized (this.mPackages) {
                this.mSettings.writePackageRestrictionsLPr(userId);
                this.mDirtyUsers.remove(Integer.valueOf(userId));
                if (this.mDirtyUsers.isEmpty()) {
                    this.mHandler.removeMessages(14);
                }
            }
        }
    }

    /* access modifiers changed from: protected */
    public void sendPackageChangedBroadcast(String packageName, boolean killFlag, ArrayList<String> componentNames, int packageUid) {
        if (DEBUG_INSTALL) {
            Log.v(TAG, "Sending package changed: package=" + packageName + " components=" + componentNames);
        }
        Bundle extras = new Bundle(4);
        extras.putString("android.intent.extra.changed_component_name", componentNames.get(0));
        String[] nameList = new String[componentNames.size()];
        componentNames.toArray(nameList);
        extras.putStringArray("android.intent.extra.changed_component_name_list", nameList);
        extras.putBoolean("android.intent.extra.DONT_KILL_APP", killFlag);
        extras.putInt("android.intent.extra.UID", packageUid);
        int flags = !componentNames.contains(packageName) ? 1073741824 : 0;
        int userId = UserHandle.getUserId(packageUid);
        boolean isInstantApp = isInstantApp(packageName, userId);
        sendPackageBroadcast("android.intent.action.PACKAGE_CHANGED", packageName, extras, flags, null, null, isInstantApp ? EMPTY_INT_ARRAY : new int[]{userId}, isInstantApp ? new int[]{userId} : EMPTY_INT_ARRAY);
    }

    public void setPackageStoppedState(String packageName, boolean stopped, int userId) {
        if (sUserManager.exists(userId)) {
            int callingUid = Binder.getCallingUid();
            if (getInstantAppPackageName(callingUid) == null) {
                boolean allowedByPermission = this.mContext.checkCallingOrSelfPermission("android.permission.CHANGE_COMPONENT_ENABLED_STATE") == 0;
                this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "stop package");
                synchronized (this.mPackages) {
                    try {
                        try {
                            if (!filterAppAccessLPr(this.mSettings.mPackages.get(packageName), callingUid, userId)) {
                                if (this.mSettings.setPackageStoppedStateLPw(this, packageName, stopped, allowedByPermission, callingUid, userId)) {
                                    scheduleWritePackageRestrictionsLocked(userId);
                                }
                            }
                        } catch (Throwable th) {
                            th = th;
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                        throw th;
                    }
                }
            }
        }
    }

    public String getInstallerPackageName(String packageName) {
        int callingUid = Binder.getCallingUid();
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, UserHandle.getUserId(callingUid))) {
                return null;
            }
            if (ps == null && this.mApexManager.isApexPackage(packageName)) {
                return null;
            }
            return this.mSettings.getInstallerPackageNameLPr(packageName);
        }
    }

    public boolean isOrphaned(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mPackages.containsKey(packageName)) {
                return false;
            }
            return this.mSettings.isOrphaned(packageName);
        }
    }

    public int getApplicationEnabledSetting(String packageName, int userId) {
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "get enabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(packageName), callingUid, userId)) {
                return 2;
            }
            return this.mSettings.getApplicationEnabledSettingLPr(packageName, userId);
        }
    }

    public int getComponentEnabledSetting(ComponentName component, int userId) {
        if (component == null) {
            return 0;
        }
        if (!sUserManager.exists(userId)) {
            return 2;
        }
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, false, "getComponentEnabled");
        synchronized (this.mPackages) {
            if (filterAppAccessLPr(this.mSettings.getPackageLPr(component.getPackageName()), callingUid, component, 0, userId)) {
                return 2;
            }
            return this.mSettings.getComponentEnabledSettingLPr(component, userId);
        }
    }

    public void enterSafeMode() {
        enforceSystemOrRoot("Only the system can request entering safe mode");
        if (!this.mSystemReady) {
            this.mSafeMode = true;
        }
    }

    public void systemReady() {
        Throwable th;
        int[] grantPermissionsUserIds;
        int i;
        enforceSystemOrRoot("Only the system can claim the system is ready");
        this.mSystemReady = true;
        final ContentResolver resolver = this.mContext.getContentResolver();
        ContentObserver co = new ContentObserver(this.mHandler) {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass8 */

            @Override // android.database.ContentObserver
            public void onChange(boolean selfChange) {
                boolean ephemeralFeatureDisabled = Settings.Global.getInt(resolver, "enable_ephemeral_feature", 1) == 0;
                int[] userIds = UserManagerService.getInstance().getUserIds();
                for (int userId : userIds) {
                    PackageManagerService.this.mWebInstantAppsDisabled.put(userId, ephemeralFeatureDisabled || Settings.Secure.getIntForUser(resolver, "instant_apps_enabled", 1, userId) == 0);
                }
            }
        };
        boolean z = false;
        this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("enable_ephemeral_feature"), false, co, -1);
        this.mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor("instant_apps_enabled"), false, co, -1);
        co.onChange(true);
        CarrierAppUtils.disableCarrierAppsUntilPrivileged(this.mContext.getOpPackageName(), this, this.mContext.getContentResolver(), 0);
        disableSkuSpecificApps();
        boolean compatibilityModeEnabled = Settings.Global.getInt(this.mContext.getContentResolver(), "compatibility_mode", 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, "compatibility mode:" + compatibilityModeEnabled);
        }
        boolean isPackageSettingsError = this.mSettings.isPackageSettingsError();
        int[] grantPermissionsUserIds2 = EMPTY_INT_ARRAY;
        synchronized (this.mPackages) {
            try {
                ArrayList<PreferredActivity> removed = new ArrayList<>();
                for (int i2 = 0; i2 < this.mSettings.mPreferredActivities.size(); i2++) {
                    PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i2);
                    removed.clear();
                    for (PreferredActivity pa : pir.filterSet()) {
                        if (!this.mComponentResolver.isActivityDefined(pa.mPref.mComponent)) {
                            removed.add(pa);
                        }
                    }
                    if (removed.size() > 0) {
                        for (int r = 0; r < removed.size(); r++) {
                            PreferredActivity pa2 = removed.get(r);
                            Slog.w(TAG, "Removing dangling preferred activity: " + pa2.mPref.mComponent);
                            pir.removeFilter(pa2);
                        }
                        this.mSettings.writePackageRestrictionsLPr(this.mSettings.mPreferredActivities.keyAt(i2));
                    }
                }
                int[] userIds = UserManagerService.getInstance().getUserIds();
                int length = userIds.length;
                grantPermissionsUserIds = grantPermissionsUserIds2;
                int i3 = 0;
                while (i3 < length) {
                    try {
                        int userId = userIds[i3];
                        boolean isNeedDefaultGrant = !this.mSettings.areDefaultRuntimePermissionsGrantedLPr(userId) ? true : z;
                        Slog.i(TAG, "TO DO, pms system ready grant default permission for user " + userId + ",default grant:" + isNeedDefaultGrant + ", catch settings error:" + isPackageSettingsError);
                        if (isPackageSettingsError || isNeedDefaultGrant || isUpgrade() || isSystemUIScanErr()) {
                            int[] grantPermissionsUserIds3 = ArrayUtils.appendInt(grantPermissionsUserIds, userId);
                            try {
                                resetSystemUIScanErr();
                                grantPermissionsUserIds = grantPermissionsUserIds3;
                            } catch (Throwable th2) {
                                th = th2;
                                throw th;
                            }
                        }
                        i3++;
                        z = false;
                    } catch (Throwable th3) {
                        th = th3;
                        throw th;
                    }
                }
            } catch (Throwable th4) {
                th = th4;
                throw th;
            }
        }
        sUserManager.systemReady();
        HwThemeManager.applyDefaultHwTheme(true, this.mContext, 0);
        for (int userId2 : grantPermissionsUserIds) {
            this.mDefaultPermissionPolicy.grantDefaultPermissions(userId2);
        }
        if (isPackageSettingsError) {
            Settings.resetPackageSettingsError();
            Slog.i(TAG, "booting after package manager settings file broken, systemReady now!");
        }
        if (grantPermissionsUserIds == EMPTY_INT_ARRAY) {
            this.mDefaultPermissionPolicy.scheduleReadDefaultPermissionExceptions();
        }
        for (int userId3 : UserManagerService.getInstance().getUserIds()) {
            this.mDefaultPermissionPolicy.grantCustDefaultPermissions(userId3);
        }
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
            ((PermissionPolicyInternal) LocalServices.getService(PermissionPolicyInternal.class)).setOnInitializedCallback(new PermissionPolicyInternal.OnInitializedCallback() {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$gTdGTY3KRPUMHJCUp_d_C37vf88 */

                @Override // com.android.server.policy.PermissionPolicyInternal.OnInitializedCallback
                public final void onInitialized(int i) {
                    PackageManagerService.this.lambda$systemReady$34$PackageManagerService(i);
                }
            });
        }
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).registerListener(this.mStorageListener);
        this.mInstallerService.systemReady();
        this.mApexManager.systemReady();
        this.mPackageDexOptimizer.systemReady();
        mHwPMSEx.systemReady();
        getStorageManagerInternal().addExternalStoragePolicy(new StorageManagerInternal.ExternalStorageMountPolicy() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass9 */

            public int getMountMode(int uid, String packageName) {
                if (Process.isIsolated(uid)) {
                    return 0;
                }
                if (PackageManagerService.this.checkUidPermission("android.permission.READ_EXTERNAL_STORAGE", uid) == -1) {
                    return 1;
                }
                if (PackageManagerService.this.checkUidPermission("android.permission.WRITE_EXTERNAL_STORAGE", uid) == -1) {
                    return 2;
                }
                return 3;
            }

            public boolean hasExternalStorage(int uid, String packageName) {
                return true;
            }
        });
        sUserManager.reconcileUsers(StorageManager.UUID_PRIVATE_INTERNAL);
        reconcileApps(StorageManager.UUID_PRIVATE_INTERNAL);
        this.mPermissionManager.systemReady();
        if (this.mInstantAppResolverConnection != null) {
            this.mContext.registerReceiver(new BroadcastReceiver() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass10 */

                @Override // android.content.BroadcastReceiver
                public void onReceive(Context context, Intent intent) {
                    PackageManagerService.this.mInstantAppResolverConnection.optimisticBind();
                    PackageManagerService.this.mContext.unregisterReceiver(this);
                }
            }, new IntentFilter("android.intent.action.BOOT_COMPLETED"));
        }
        this.mModuleInfoProvider.systemReady();
        this.mInstallerService.restoreAndApplyStagedSessionIfNeeded();
        if (IS_HW_PREFER_APP_POLICY && isUpgrade()) {
            long hwStartTime = HwPackageManagerServiceUtils.hwTimingsBegin();
            for (int userId4 : UserManagerService.getInstance().getUserIds()) {
                mHwPMSEx.rebuildPreferredActivity(userId4);
            }
            HwPackageManagerServiceUtils.hwTimingsEnd(TAG, "rebuildPreferredActivity", hwStartTime);
        }
    }

    public /* synthetic */ void lambda$systemReady$34$PackageManagerService(int userId) {
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, false, this.mPackages.values(), this.mPermissionCallback);
        }
    }

    public void waitForAppDataPrepared() {
        Future<?> future = this.mPrepareAppDataFuture;
        if (future != null) {
            ConcurrentUtils.waitForFutureNoInterrupt(future, "wait for prepareAppData");
            this.mPrepareAppDataFuture = null;
        }
    }

    public boolean isSafeMode() {
        return this.mSafeMode;
    }

    public boolean hasSystemUidErrors() {
        return this.mHasSystemUidErrors;
    }

    static String arrayToString(int[] array) {
        StringBuilder stringBuilder = new StringBuilder(128);
        stringBuilder.append('[');
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                if (i > 0) {
                    stringBuilder.append(", ");
                }
                stringBuilder.append(array[i]);
            }
        }
        stringBuilder.append(']');
        return stringBuilder.toString();
    }

    /* JADX DEBUG: Multi-variable search result rejected for r8v0, resolved type: com.android.server.pm.PackageManagerService */
    /* JADX WARN: Multi-variable type inference failed */
    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new PackageManagerShellCommand(this).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* access modifiers changed from: protected */
    /* JADX WARNING: Removed duplicated region for block: B:425:0x09ca  */
    /* JADX WARNING: Removed duplicated region for block: B:457:0x0a78  */
    /* JADX WARNING: Removed duplicated region for block: B:505:0x0c18  */
    /* JADX WARNING: Removed duplicated region for block: B:507:0x0c1c  */
    /* JADX WARNING: Removed duplicated region for block: B:532:0x0c63 A[SYNTHETIC, Splitter:B:532:0x0c63] */
    /* JADX WARNING: Removed duplicated region for block: B:541:0x0c7d  */
    /* JADX WARNING: Removed duplicated region for block: B:546:0x0c87  */
    /* JADX WARNING: Removed duplicated region for block: B:549:0x0c9c  */
    /* JADX WARNING: Removed duplicated region for block: B:564:0x0d28  */
    /* JADX WARNING: Removed duplicated region for block: B:587:0x0d8d A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:590:0x0daa A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:591:0x0db0 A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:607:0x0e12 A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:610:0x0e1f A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:621:0x0e6d A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:624:0x0e75 A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:631:0x0e9a A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:641:0x0eba A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:643:0x0ebf A[Catch:{ all -> 0x0ff2 }] */
    /* JADX WARNING: Removed duplicated region for block: B:646:0x0ec7 A[SYNTHETIC] */
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        String packageName;
        boolean fullPreferred;
        ArraySet<String> permissionNames;
        ArrayMap<String, PackageParser.Package> arrayMap;
        Throwable th;
        ArrayMap<String, PackageParser.Package> arrayMap2;
        boolean fullPreferred2;
        ArraySet<String> permissionNames2;
        char c;
        boolean fullPreferred3;
        ArraySet<String> permissionNames3;
        char c2;
        String packageName2;
        boolean z;
        String packageName3;
        ArraySet<String> permissionNames4;
        String packageName4;
        String packageName5;
        int i;
        String prefix;
        IllegalArgumentException e;
        IllegalStateException e2;
        IOException e3;
        ArrayMap<String, PackageParser.Package> arrayMap3;
        int versionCount;
        boolean fullPreferred4;
        ArraySet<String> permissionNames5;
        boolean fullPreferred5;
        int i2;
        int user;
        String opt;
        if (DumpUtils.checkDumpAndUsageStatsPermission(this.mContext, TAG, pw)) {
            int callingPid = Binder.getCallingPid();
            int ppid = Process.getParentPid(callingPid);
            int callingUid = Binder.getCallingUid();
            Log.i(TAG, "Start dump, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            DumpState dumpState = new DumpState();
            int opti = 0;
            boolean checkin = false;
            while (opti < args.length && (opt = args[opti]) != null && opt.length() > 0 && opt.charAt(0) == '-') {
                opti++;
                if (!"-a".equals(opt)) {
                    if ("-h".equals(opt)) {
                        pw.println("Package manager dump options:");
                        pw.println("  [-h] [-f] [--checkin] [--all-components] [cmd] ...");
                        pw.println("    --checkin: dump for a checkin");
                        pw.println("    -f: print details of intent filters");
                        pw.println("    -h: print this help");
                        pw.println("    --all-components: include all component names in package dump");
                        pw.println("  cmd may be one of:");
                        pw.println("    apex: list active APEXes and APEX session state");
                        pw.println("    l[ibraries]: list known shared libraries");
                        pw.println("    f[eatures]: list device features");
                        pw.println("    k[eysets]: print known keysets");
                        pw.println("    r[esolvers] [activity|service|receiver|content]: dump intent resolvers");
                        pw.println("    perm[issions]: dump permissions");
                        pw.println("    permission [name ...]: dump declaration and use of given permission");
                        pw.println("    pref[erred]: print preferred package settings");
                        pw.println("    preferred-xml [--full]: print preferred package settings as xml");
                        pw.println("    prov[iders]: dump content providers");
                        pw.println("    p[ackages]: dump installed packages");
                        pw.println("    s[hared-users]: dump shared user IDs");
                        pw.println("    m[essages]: print collected runtime messages");
                        pw.println("    h[andle]: dump message list");
                        pw.println("    v[erifiers]: print package verifier info");
                        pw.println("    d[omain-preferred-apps]: print domains preferred apps");
                        pw.println("    i[ntent-filter-verifiers]|ifv: print intent filter verifier info");
                        pw.println("    version: print database version info");
                        pw.println("    write: write current settings now");
                        pw.println("    maple: print disabled maple apps");
                        pw.println("    installs: details about install sessions");
                        pw.println("    check-permission <permission> <package> [<user>]: does pkg hold perm?");
                        pw.println("    dexopt: dump dexopt state");
                        pw.println("    compiler-stats: dump compiler statistics");
                        pw.println("    service-permissions: dump permissions required by services");
                        pw.println("    <package.name>: info about given package");
                        pw.println("    hwfeatures: list device hwfeatures");
                        return;
                    } else if ("--checkin".equals(opt)) {
                        checkin = true;
                    } else if ("--all-components".equals(opt)) {
                        dumpState.setOptionEnabled(2);
                    } else if ("-f".equals(opt)) {
                        dumpState.setOptionEnabled(1);
                    } else if (PriorityDump.PROTO_ARG.equals(opt)) {
                        dumpProto(fd);
                        return;
                    } else {
                        pw.println("Unknown argument: " + opt + "; use -h for help");
                    }
                }
            }
            if (opti < args.length) {
                String cmd = args[opti];
                int opti2 = opti + 1;
                if (PLATFORM_PACKAGE_NAME.equals(cmd)) {
                    fullPreferred5 = false;
                    permissionNames5 = null;
                    i2 = 1;
                } else if (cmd.contains(".")) {
                    fullPreferred5 = false;
                    permissionNames5 = null;
                    i2 = 1;
                } else if (!"check-permission".equals(cmd)) {
                    if (!"l".equals(cmd)) {
                        if (!"libraries".equals(cmd)) {
                            if (!"f".equals(cmd)) {
                                if (!"features".equals(cmd)) {
                                    if (!"r".equals(cmd)) {
                                        if (!"resolvers".equals(cmd)) {
                                            if (!TAG_PERMISSION.equals(cmd)) {
                                                if (!"permissions".equals(cmd)) {
                                                    if (!"permission".equals(cmd)) {
                                                        if (!"pref".equals(cmd)) {
                                                            if (!"preferred".equals(cmd)) {
                                                                if ("preferred-xml".equals(cmd)) {
                                                                    dumpState.setDump(8192);
                                                                    if (opti2 < args.length && "--full".equals(args[opti2])) {
                                                                        int opti3 = opti2 + 1;
                                                                        fullPreferred = true;
                                                                        packageName = null;
                                                                        permissionNames = null;
                                                                    }
                                                                } else {
                                                                    if (!"d".equals(cmd)) {
                                                                        if (!"domain-preferred-apps".equals(cmd)) {
                                                                            if (!"p".equals(cmd)) {
                                                                                if (!"packages".equals(cmd)) {
                                                                                    if (!"s".equals(cmd)) {
                                                                                        if (!"shared-users".equals(cmd)) {
                                                                                            if (!"prov".equals(cmd)) {
                                                                                                if (!"providers".equals(cmd)) {
                                                                                                    if ("m".equals(cmd) || "messages".equals(cmd)) {
                                                                                                        dumpState.setDump(512);
                                                                                                    } else if ("v".equals(cmd) || "verifiers".equals(cmd)) {
                                                                                                        dumpState.setDump(2048);
                                                                                                    } else if ("i".equals(cmd) || "ifv".equals(cmd) || "intent-filter-verifiers".equals(cmd)) {
                                                                                                        dumpState.setDump(131072);
                                                                                                    } else if ("version".equals(cmd)) {
                                                                                                        dumpState.setDump(32768);
                                                                                                    } else if ("k".equals(cmd) || "keysets".equals(cmd)) {
                                                                                                        dumpState.setDump(16384);
                                                                                                    } else if ("installs".equals(cmd)) {
                                                                                                        dumpState.setDump(65536);
                                                                                                    } else if ("frozen".equals(cmd)) {
                                                                                                        dumpState.setDump(524288);
                                                                                                    } else if ("volumes".equals(cmd)) {
                                                                                                        dumpState.setDump(8388608);
                                                                                                    } else if ("dexopt".equals(cmd)) {
                                                                                                        dumpState.setDump(1048576);
                                                                                                    } else if ("compiler-stats".equals(cmd)) {
                                                                                                        dumpState.setDump(2097152);
                                                                                                    } else if ("changes".equals(cmd)) {
                                                                                                        dumpState.setDump(4194304);
                                                                                                    } else if ("service-permissions".equals(cmd)) {
                                                                                                        dumpState.setDump(DumpState.DUMP_SERVICE_PERMISSIONS);
                                                                                                    } else if ("h".equals(cmd) || "handle".equals(cmd)) {
                                                                                                        dumpState.setDump(DumpState.DUMP_HANDLE);
                                                                                                    } else if ("write".equals(cmd)) {
                                                                                                        synchronized (this.mPackages) {
                                                                                                            this.mSettings.writeLPr();
                                                                                                            pw.println("Settings written.");
                                                                                                        }
                                                                                                        return;
                                                                                                    } else if ("maple".equals(cmd)) {
                                                                                                        if (ZygoteInit.sIsMygote) {
                                                                                                            HwMaplePMServiceUtils.dumpDisabledMaplePkgs(pw);
                                                                                                            return;
                                                                                                        } else {
                                                                                                            pw.println("The system not run in maple.");
                                                                                                            return;
                                                                                                        }
                                                                                                    } else if ("hwfeatures".equals(cmd)) {
                                                                                                        dumpState.setDump(DumpState.DUMP_HWFEATURES);
                                                                                                    } else if (DEBUG_INSTALL) {
                                                                                                        Slog.d(TAG, "cmd not equals anything.");
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            dumpState.setDump(1024);
                                                                                        }
                                                                                    }
                                                                                    dumpState.setDump(256);
                                                                                    if (opti2 < args.length && "noperm".equals(args[opti2])) {
                                                                                        dumpState.setOptionEnabled(4);
                                                                                    }
                                                                                }
                                                                            }
                                                                            dumpState.setDump(128);
                                                                        }
                                                                    }
                                                                    dumpState.setDump(262144);
                                                                }
                                                                fullPreferred = false;
                                                                packageName = null;
                                                                permissionNames = null;
                                                            }
                                                        }
                                                        dumpState.setDump(4096);
                                                        fullPreferred = false;
                                                        packageName = null;
                                                        permissionNames = null;
                                                    } else if (opti2 >= args.length) {
                                                        pw.println("Error: permission requires permission name");
                                                        return;
                                                    } else {
                                                        ArraySet<String> permissionNames6 = new ArraySet<>();
                                                        while (opti2 < args.length) {
                                                            permissionNames6.add(args[opti2]);
                                                            opti2++;
                                                        }
                                                        dumpState.setDump(448);
                                                        permissionNames = permissionNames6;
                                                        fullPreferred = false;
                                                        packageName = null;
                                                    }
                                                }
                                            }
                                            dumpState.setDump(64);
                                            fullPreferred = false;
                                            packageName = null;
                                            permissionNames = null;
                                        }
                                    }
                                    if (opti2 >= args.length) {
                                        dumpState.setDump(60);
                                        fullPreferred = false;
                                        packageName = null;
                                        permissionNames = null;
                                    } else {
                                        while (opti2 < args.length) {
                                            String name = args[opti2];
                                            if ("a".equals(name) || "activity".equals(name)) {
                                                dumpState.setDump(4);
                                            } else if ("s".equals(name) || "service".equals(name)) {
                                                dumpState.setDump(8);
                                            } else if ("r".equals(name) || HwBroadcastRadarUtil.KEY_RECEIVER.equals(name)) {
                                                dumpState.setDump(16);
                                            } else if ("c".equals(name) || "content".equals(name)) {
                                                dumpState.setDump(32);
                                            } else {
                                                pw.println("Error: unknown resolver table type: " + name);
                                                return;
                                            }
                                            opti2++;
                                        }
                                        fullPreferred = false;
                                        packageName = null;
                                        permissionNames = null;
                                    }
                                }
                            }
                            dumpState.setDump(2);
                            fullPreferred = false;
                            packageName = null;
                            permissionNames = null;
                        }
                    }
                    dumpState.setDump(1);
                    fullPreferred = false;
                    packageName = null;
                    permissionNames = null;
                } else if (opti2 >= args.length) {
                    pw.println("Error: check-permission missing permission argument");
                    return;
                } else {
                    String perm = args[opti2];
                    int opti4 = opti2 + 1;
                    if (opti4 >= args.length) {
                        pw.println("Error: check-permission missing package argument");
                        return;
                    }
                    String pkg = args[opti4];
                    int opti5 = opti4 + 1;
                    int user2 = UserHandle.getUserId(Binder.getCallingUid());
                    if (opti5 < args.length) {
                        try {
                            user = Integer.parseInt(args[opti5]);
                        } catch (NumberFormatException e4) {
                            pw.println("Error: check-permission user argument is not a number: " + args[opti5]);
                            return;
                        }
                    } else {
                        user = user2;
                    }
                    pw.println(checkPermission(perm, resolveInternalPackageNameLPr(pkg, -1), user));
                    return;
                }
                dumpState.setOptionEnabled(i2);
                permissionNames = permissionNames5;
                packageName = cmd;
                fullPreferred = fullPreferred5;
            } else {
                fullPreferred = false;
                packageName = null;
                permissionNames = null;
            }
            if (checkin) {
                pw.println("vers,1");
            }
            Log.i(TAG, "Start dump with packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
            ArrayMap<String, PackageParser.Package> arrayMap4 = this.mPackages;
            synchronized (arrayMap4) {
                try {
                    if (dumpState.isDumping(32768) && packageName == null && !checkin) {
                        try {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Database versions:");
                            this.mSettings.dumpVersionLPr(new IndentingPrintWriter(pw, "  "));
                        } catch (Throwable th2) {
                            th = th2;
                            arrayMap = arrayMap4;
                            throw th;
                        }
                    }
                    if (dumpState.isDumping(2048) && packageName == null) {
                        if (!checkin) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            pw.println("Verifiers:");
                            pw.print("  Required: ");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(" (uid=");
                            pw.print(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                            pw.println(")");
                        } else if (this.mRequiredVerifierPackage != null) {
                            pw.print("vrfy,");
                            pw.print(this.mRequiredVerifierPackage);
                            pw.print(",");
                            pw.println(getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
                        }
                    }
                    if (dumpState.isDumping(131072) && packageName == null) {
                        if (this.mIntentFilterVerifierComponent != null) {
                            String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                            if (!checkin) {
                                if (dumpState.onTitlePrinted()) {
                                    pw.println();
                                }
                                pw.println("Intent Filter Verifier:");
                                pw.print("  Using: ");
                                pw.print(verifierPackageName);
                                pw.print(" (uid=");
                                pw.print(getPackageUid(verifierPackageName, 268435456, 0));
                                pw.println(")");
                            } else if (verifierPackageName != null) {
                                pw.print("ifv,");
                                pw.print(verifierPackageName);
                                pw.print(",");
                                pw.println(getPackageUid(verifierPackageName, 268435456, 0));
                            }
                        } else {
                            pw.println();
                            pw.println("No Intent Filter Verifier available!");
                        }
                    }
                    if (!dumpState.isDumping(1) || packageName != null) {
                        permissionNames2 = permissionNames;
                        fullPreferred2 = fullPreferred;
                        arrayMap2 = arrayMap4;
                    } else {
                        boolean printedHeader = false;
                        try {
                            for (String libName : this.mSharedLibraries.keySet()) {
                                boolean printedHeader2 = printedHeader;
                                LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(libName);
                                if (versionedLib == null) {
                                    printedHeader = printedHeader2;
                                } else {
                                    int versionCount2 = versionedLib.size();
                                    int i3 = 0;
                                    while (i3 < versionCount2) {
                                        try {
                                            SharedLibraryInfo libraryInfo = versionedLib.valueAt(i3);
                                            if (!checkin) {
                                                if (!printedHeader2) {
                                                    try {
                                                        if (dumpState.onTitlePrinted()) {
                                                            pw.println();
                                                        }
                                                        versionCount = versionCount2;
                                                        pw.println("Libraries:");
                                                        printedHeader2 = true;
                                                    } catch (Throwable th3) {
                                                        th = th3;
                                                        arrayMap = arrayMap4;
                                                        throw th;
                                                    }
                                                } else {
                                                    versionCount = versionCount2;
                                                }
                                                pw.print("  ");
                                            } else {
                                                versionCount = versionCount2;
                                                pw.print("lib,");
                                            }
                                            pw.print(libraryInfo.getName());
                                            if (libraryInfo.isStatic()) {
                                                StringBuilder sb = new StringBuilder();
                                                fullPreferred4 = fullPreferred;
                                                try {
                                                    sb.append(" version=");
                                                    arrayMap3 = arrayMap4;
                                                    sb.append(libraryInfo.getLongVersion());
                                                    pw.print(sb.toString());
                                                } catch (Throwable th4) {
                                                    th = th4;
                                                    arrayMap = arrayMap3;
                                                    throw th;
                                                }
                                            } else {
                                                fullPreferred4 = fullPreferred;
                                                arrayMap3 = arrayMap4;
                                            }
                                            if (!checkin) {
                                                pw.print(" -> ");
                                            }
                                            if (libraryInfo.getPath() != null) {
                                                pw.print(" (jar) ");
                                                pw.print(libraryInfo.getPath());
                                            } else {
                                                pw.print(" (apk) ");
                                                pw.print(libraryInfo.getPackageName());
                                            }
                                            pw.println();
                                            i3++;
                                            permissionNames = permissionNames;
                                            versionCount2 = versionCount;
                                            fullPreferred = fullPreferred4;
                                            arrayMap4 = arrayMap3;
                                        } catch (Throwable th5) {
                                            th = th5;
                                            arrayMap = arrayMap4;
                                            throw th;
                                        }
                                    }
                                    arrayMap3 = arrayMap4;
                                    permissionNames = permissionNames;
                                    printedHeader = printedHeader2;
                                }
                            }
                            permissionNames2 = permissionNames;
                            fullPreferred2 = fullPreferred;
                            arrayMap2 = arrayMap4;
                        } catch (Throwable th6) {
                            th = th6;
                            arrayMap = arrayMap4;
                            throw th;
                        }
                    }
                    try {
                        if (dumpState.isDumping(2) && packageName == null) {
                            if (dumpState.onTitlePrinted()) {
                                pw.println();
                            }
                            if (!checkin) {
                                pw.println("Features:");
                            }
                            synchronized (this.mAvailableFeatures) {
                                for (FeatureInfo feat : this.mAvailableFeatures.values()) {
                                    if (checkin) {
                                        pw.print("feat,");
                                        pw.print(feat.name);
                                        pw.print(",");
                                        pw.println(feat.version);
                                    } else {
                                        pw.print("  ");
                                        pw.print(feat.name);
                                        if (feat.version > 0) {
                                            pw.print(" version=");
                                            pw.print(feat.version);
                                        }
                                        pw.println();
                                    }
                                }
                            }
                        }
                        if (!checkin && dumpState.isDumping(4)) {
                            this.mComponentResolver.dumpActivityResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin && dumpState.isDumping(16)) {
                            this.mComponentResolver.dumpReceiverResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin && dumpState.isDumping(8)) {
                            this.mComponentResolver.dumpServiceResolvers(pw, dumpState, packageName);
                        }
                        if (!checkin) {
                            c = ' ';
                            if (dumpState.isDumping(32)) {
                                this.mComponentResolver.dumpProviderResolvers(pw, dumpState, packageName);
                            }
                        } else {
                            c = ' ';
                        }
                        if (!checkin) {
                            try {
                                if (dumpState.isDumping(4096)) {
                                    int i4 = 0;
                                    while (i4 < this.mSettings.mPreferredActivities.size()) {
                                        PreferredIntentResolver pir = this.mSettings.mPreferredActivities.valueAt(i4);
                                        int user3 = this.mSettings.mPreferredActivities.keyAt(i4);
                                        arrayMap = arrayMap2;
                                        try {
                                            if (pir.dump(pw, dumpState.getTitlePrinted() ? "\nPreferred Activities User " + user3 + ":" : "Preferred Activities User " + user3 + ":", "  ", packageName, true, false)) {
                                                dumpState.setTitlePrinted(true);
                                            }
                                            i4++;
                                            packageName = packageName;
                                            c = ' ';
                                            arrayMap2 = arrayMap;
                                            permissionNames2 = permissionNames2;
                                            fullPreferred2 = fullPreferred2;
                                        } catch (Throwable th7) {
                                            th = th7;
                                            throw th;
                                        }
                                    }
                                    packageName2 = packageName;
                                    c2 = c;
                                    permissionNames3 = permissionNames2;
                                    fullPreferred3 = fullPreferred2;
                                    arrayMap = arrayMap2;
                                    z = true;
                                    if (!checkin) {
                                        try {
                                            if (dumpState.isDumping(8192)) {
                                                pw.flush();
                                                BufferedOutputStream str = new BufferedOutputStream(new FileOutputStream(fd));
                                                XmlSerializer serializer = new FastXmlSerializer();
                                                try {
                                                    serializer.setOutput(str, StandardCharsets.UTF_8.name());
                                                    serializer.startDocument(null, Boolean.valueOf(z));
                                                    serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", z);
                                                    try {
                                                        this.mSettings.writePreferredActivitiesLPr(serializer, 0, fullPreferred3);
                                                        serializer.endDocument();
                                                        serializer.flush();
                                                    } catch (IllegalArgumentException e5) {
                                                        e = e5;
                                                    } catch (IllegalStateException e6) {
                                                        e2 = e6;
                                                        pw.println("Failed writing: " + e2);
                                                        if (checkin) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames4 = permissionNames3;
                                                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(4194304)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        packageName5 = packageName4;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ", 120);
                                                        ipw.println();
                                                        ipw.println("Loaded volumes:");
                                                        ipw.increaseIndent();
                                                        if (this.mLoadedVolumes.size() == 0) {
                                                        }
                                                        ipw.decreaseIndent();
                                                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                        }
                                                        pw.flush();
                                                        HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(pw, packageName5);
                                                        if (!checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        synchronized (this.mAvailableHwFeatures) {
                                                        }
                                                    } catch (IOException e7) {
                                                        e3 = e7;
                                                        pw.println("Failed writing: " + e3);
                                                        if (checkin) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        permissionNames4 = permissionNames3;
                                                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                        if (dumpState.isDumping(128)) {
                                                        }
                                                        if (dumpState.isDumping(256)) {
                                                        }
                                                        if (dumpState.isDumping(4194304)) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        packageName5 = packageName4;
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        IndentingPrintWriter ipw2 = new IndentingPrintWriter(pw, "  ", 120);
                                                        ipw2.println();
                                                        ipw2.println("Loaded volumes:");
                                                        ipw2.increaseIndent();
                                                        if (this.mLoadedVolumes.size() == 0) {
                                                        }
                                                        ipw2.decreaseIndent();
                                                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                        }
                                                        pw.flush();
                                                        HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        dumpCompilerStatsLPr(pw, packageName5);
                                                        if (!checkin) {
                                                        }
                                                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                        if (dumpState.onTitlePrinted()) {
                                                        }
                                                        if (!checkin) {
                                                        }
                                                        synchronized (this.mAvailableHwFeatures) {
                                                        }
                                                    }
                                                } catch (IllegalArgumentException e8) {
                                                    e = e8;
                                                    pw.println("Failed writing: " + e);
                                                    if (checkin) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames4 = permissionNames3;
                                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(4194304)) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    packageName5 = packageName4;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw22 = new IndentingPrintWriter(pw, "  ", 120);
                                                    ipw22.println();
                                                    ipw22.println("Loaded volumes:");
                                                    ipw22.increaseIndent();
                                                    if (this.mLoadedVolumes.size() == 0) {
                                                    }
                                                    ipw22.decreaseIndent();
                                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                    }
                                                    pw.flush();
                                                    HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(pw, packageName5);
                                                    if (!checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    synchronized (this.mAvailableHwFeatures) {
                                                    }
                                                } catch (IllegalStateException e9) {
                                                    e2 = e9;
                                                    pw.println("Failed writing: " + e2);
                                                    if (checkin) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames4 = permissionNames3;
                                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(4194304)) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    packageName5 = packageName4;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw222 = new IndentingPrintWriter(pw, "  ", 120);
                                                    ipw222.println();
                                                    ipw222.println("Loaded volumes:");
                                                    ipw222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() == 0) {
                                                    }
                                                    ipw222.decreaseIndent();
                                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                    }
                                                    pw.flush();
                                                    HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(pw, packageName5);
                                                    if (!checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    synchronized (this.mAvailableHwFeatures) {
                                                    }
                                                } catch (IOException e10) {
                                                    e3 = e10;
                                                    pw.println("Failed writing: " + e3);
                                                    if (checkin) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    permissionNames4 = permissionNames3;
                                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                    if (dumpState.isDumping(128)) {
                                                    }
                                                    if (dumpState.isDumping(256)) {
                                                    }
                                                    if (dumpState.isDumping(4194304)) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    packageName5 = packageName4;
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    IndentingPrintWriter ipw2222 = new IndentingPrintWriter(pw, "  ", 120);
                                                    ipw2222.println();
                                                    ipw2222.println("Loaded volumes:");
                                                    ipw2222.increaseIndent();
                                                    if (this.mLoadedVolumes.size() == 0) {
                                                    }
                                                    ipw2222.decreaseIndent();
                                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                    }
                                                    pw.flush();
                                                    HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    dumpCompilerStatsLPr(pw, packageName5);
                                                    if (!checkin) {
                                                    }
                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                    if (dumpState.onTitlePrinted()) {
                                                    }
                                                    if (!checkin) {
                                                    }
                                                    synchronized (this.mAvailableHwFeatures) {
                                                    }
                                                } catch (Throwable th8) {
                                                    th = th8;
                                                    throw th;
                                                }
                                                if (checkin) {
                                                    try {
                                                        if (dumpState.isDumping(262144)) {
                                                            packageName3 = packageName2;
                                                            if (packageName3 == null) {
                                                                try {
                                                                    pw.println();
                                                                    if (this.mSettings.mPackages.size() == 0) {
                                                                        pw.println("No applications!");
                                                                        pw.println();
                                                                    } else {
                                                                        String prefix2 = "  ";
                                                                        Collection<PackageSetting> allPackageSettings = this.mSettings.mPackages.values();
                                                                        if (allPackageSettings.size() == 0) {
                                                                            pw.println("No domain preferred apps!");
                                                                            pw.println();
                                                                        } else {
                                                                            pw.println("App verification status:");
                                                                            pw.println();
                                                                            int count = 0;
                                                                            for (PackageSetting ps : allPackageSettings) {
                                                                                IntentFilterVerificationInfo ivi = ps.getIntentFilterVerificationInfo();
                                                                                if (ivi == null) {
                                                                                    prefix = prefix2;
                                                                                } else if (ivi.getPackageName() == null) {
                                                                                    prefix = prefix2;
                                                                                } else {
                                                                                    pw.println("  Package: " + ivi.getPackageName());
                                                                                    pw.println("  Domains: " + ivi.getDomainsString());
                                                                                    pw.println("  Status:  " + ivi.getStatusString());
                                                                                    pw.println();
                                                                                    count++;
                                                                                    prefix2 = prefix2;
                                                                                }
                                                                                prefix2 = prefix;
                                                                            }
                                                                            if (count == 0) {
                                                                                pw.println("  No app verification established.");
                                                                                pw.println();
                                                                            }
                                                                            int[] userIds = sUserManager.getUserIds();
                                                                            int length = userIds.length;
                                                                            int count2 = 0;
                                                                            while (count2 < length) {
                                                                                int userId = userIds[count2];
                                                                                pw.println("App linkages for user " + userId + ":");
                                                                                pw.println();
                                                                                Iterator<PackageSetting> it = allPackageSettings.iterator();
                                                                                int count3 = 0;
                                                                                while (it.hasNext()) {
                                                                                    PackageSetting ps2 = it.next();
                                                                                    long status = ps2.getDomainVerificationStatusForUser(userId);
                                                                                    if ((status >> c2) != 0 || DEBUG_DOMAIN_VERIFICATION) {
                                                                                        pw.println("  Package: " + ps2.name);
                                                                                        pw.println("  Domains: " + dumpDomainString(ps2.name));
                                                                                        pw.println("  Status:  " + IntentFilterVerificationInfo.getStatusStringFromValue(status));
                                                                                        pw.println();
                                                                                        count3++;
                                                                                        allPackageSettings = allPackageSettings;
                                                                                        it = it;
                                                                                    }
                                                                                }
                                                                                if (count3 == 0) {
                                                                                    pw.println("  No configured app linkages.");
                                                                                    pw.println();
                                                                                }
                                                                                count2++;
                                                                                userIds = userIds;
                                                                                length = length;
                                                                                allPackageSettings = allPackageSettings;
                                                                            }
                                                                        }
                                                                    }
                                                                } catch (Throwable th9) {
                                                                    th = th9;
                                                                    throw th;
                                                                }
                                                            }
                                                        } else {
                                                            packageName3 = packageName2;
                                                        }
                                                    } catch (Throwable th10) {
                                                        th = th10;
                                                        throw th;
                                                    }
                                                } else {
                                                    packageName3 = packageName2;
                                                }
                                                if (!checkin) {
                                                    try {
                                                        if (dumpState.isDumping(64)) {
                                                            permissionNames4 = permissionNames3;
                                                            this.mSettings.dumpPermissionsLPr(pw, packageName3, permissionNames4, dumpState);
                                                            if (!checkin && dumpState.isDumping(1024)) {
                                                                this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                            }
                                                            if (!checkin && dumpState.isDumping(16384)) {
                                                                this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                            }
                                                            if (dumpState.isDumping(128)) {
                                                                try {
                                                                    packageName4 = packageName3;
                                                                    try {
                                                                        this.mSettings.dumpPackagesLPr(pw, packageName3, permissionNames4, dumpState, checkin);
                                                                    } catch (Throwable th11) {
                                                                        th = th11;
                                                                    }
                                                                } catch (Throwable th12) {
                                                                    th = th12;
                                                                    throw th;
                                                                }
                                                            } else {
                                                                packageName4 = packageName3;
                                                            }
                                                            if (dumpState.isDumping(256)) {
                                                                this.mSettings.dumpSharedUsersLPr(pw, packageName4, permissionNames4, dumpState, checkin);
                                                            }
                                                            if (dumpState.isDumping(4194304)) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                pw.println("Package Changes:");
                                                                pw.print("  Sequence number=");
                                                                pw.println(this.mChangedPackagesSequenceNumber);
                                                                int K = this.mChangedPackages.size();
                                                                int i5 = 0;
                                                                while (i5 < K) {
                                                                    SparseArray<String> changes = this.mChangedPackages.valueAt(i5);
                                                                    pw.print("  User ");
                                                                    pw.print(this.mChangedPackages.keyAt(i5));
                                                                    pw.println(":");
                                                                    int N = changes.size();
                                                                    if (N == 0) {
                                                                        pw.print("    ");
                                                                        pw.println("No packages changed");
                                                                    } else {
                                                                        int j = 0;
                                                                        while (j < N) {
                                                                            int sequenceNumber = changes.keyAt(j);
                                                                            pw.print("    ");
                                                                            pw.print("seq=");
                                                                            pw.print(sequenceNumber);
                                                                            pw.print(", package=");
                                                                            pw.println(changes.valueAt(j));
                                                                            j++;
                                                                            K = K;
                                                                        }
                                                                    }
                                                                    i5++;
                                                                    K = K;
                                                                }
                                                            }
                                                            if (!checkin || !dumpState.isDumping(524288)) {
                                                                packageName5 = packageName4;
                                                            } else {
                                                                packageName5 = packageName4;
                                                                if (packageName5 == null) {
                                                                    try {
                                                                        if (dumpState.onTitlePrinted()) {
                                                                            pw.println();
                                                                        }
                                                                        IndentingPrintWriter ipw3 = new IndentingPrintWriter(pw, "  ", 120);
                                                                        ipw3.println();
                                                                        ipw3.println("Frozen packages:");
                                                                        ipw3.increaseIndent();
                                                                        if (this.mFrozenPackages.size() == 0) {
                                                                            ipw3.println("(none)");
                                                                        } else {
                                                                            for (int i6 = 0; i6 < this.mFrozenPackages.size(); i6++) {
                                                                                ipw3.println(this.mFrozenPackages.valueAt(i6));
                                                                            }
                                                                        }
                                                                        ipw3.decreaseIndent();
                                                                    } catch (Throwable th13) {
                                                                        th = th13;
                                                                        throw th;
                                                                    }
                                                                }
                                                            }
                                                            if (!checkin && dumpState.isDumping(8388608) && packageName5 == null) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                IndentingPrintWriter ipw22222 = new IndentingPrintWriter(pw, "  ", 120);
                                                                ipw22222.println();
                                                                ipw22222.println("Loaded volumes:");
                                                                ipw22222.increaseIndent();
                                                                if (this.mLoadedVolumes.size() == 0) {
                                                                    ipw22222.println("(none)");
                                                                } else {
                                                                    for (int i7 = 0; i7 < this.mLoadedVolumes.size(); i7++) {
                                                                        ipw22222.println(this.mLoadedVolumes.valueAt(i7));
                                                                    }
                                                                }
                                                                ipw22222.decreaseIndent();
                                                            }
                                                            if (!checkin && dumpState.isDumping(DumpState.DUMP_SERVICE_PERMISSIONS) && packageName5 == null) {
                                                                this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                            }
                                                            Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (!checkin && dumpState.isDumping(1048576)) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                                    dumpDexoptStateLPr(pw, packageName5);
                                                                }
                                                                if (DEBUG_DEXOPT && packageName5 == null) {
                                                                    pw.flush();
                                                                    HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                                }
                                                            }
                                                            Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (!checkin && dumpState.isDumping(2097152)) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                dumpCompilerStatsLPr(pw, packageName5);
                                                            }
                                                            if (!checkin) {
                                                                i = 512;
                                                                if (dumpState.isDumping(512) && packageName5 == null) {
                                                                    if (dumpState.onTitlePrinted()) {
                                                                        pw.println();
                                                                    }
                                                                    this.mSettings.dumpReadMessagesLPr(pw, dumpState);
                                                                    pw.println();
                                                                    pw.println("Package warning messages:");
                                                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, null);
                                                                }
                                                            } else {
                                                                i = 512;
                                                            }
                                                            if (checkin && dumpState.isDumping(i)) {
                                                                PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                            }
                                                            if (dumpState.isDumping(DumpState.DUMP_HWFEATURES) && packageName5 == null) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                if (!checkin) {
                                                                    pw.println("HwFeatures:");
                                                                }
                                                                synchronized (this.mAvailableHwFeatures) {
                                                                    for (FeatureInfo feat2 : this.mAvailableHwFeatures.values()) {
                                                                        if (checkin) {
                                                                            pw.print("feat,");
                                                                            pw.print(feat2.name);
                                                                            pw.print(",");
                                                                            pw.println(feat2.version);
                                                                        } else {
                                                                            String featureValue = "  " + feat2.name;
                                                                            pw.print(feat2.version > 0 ? featureValue + " version=" + feat2.version : featureValue);
                                                                            pw.println();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            Log.i(TAG, "Finish start dump whit packages, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            if (!checkin && dumpState.isDumping(65536) && packageName5 == null) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                this.mInstallerService.dump(new IndentingPrintWriter(pw, "  ", 120));
                                                            }
                                                            if (!checkin && dumpState.isDumping(DumpState.DUMP_APEX)) {
                                                                this.mApexManager.dump(pw, packageName5);
                                                            }
                                                            if (!checkin && dumpState.isDumping(DumpState.DUMP_HANDLE) && packageName5 == null) {
                                                                if (dumpState.onTitlePrinted()) {
                                                                    pw.println();
                                                                }
                                                                this.mHandler.dump(new PrintWriterPrinter(pw), " ");
                                                            }
                                                            Log.i(TAG, "Finish start dump , calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                            return;
                                                        }
                                                    } catch (Throwable th14) {
                                                        th = th14;
                                                        throw th;
                                                    }
                                                }
                                                permissionNames4 = permissionNames3;
                                                this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                                this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                                if (dumpState.isDumping(128)) {
                                                }
                                                if (dumpState.isDumping(256)) {
                                                }
                                                if (dumpState.isDumping(4194304)) {
                                                }
                                                if (!checkin) {
                                                }
                                                packageName5 = packageName4;
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                IndentingPrintWriter ipw222222 = new IndentingPrintWriter(pw, "  ", 120);
                                                ipw222222.println();
                                                ipw222222.println("Loaded volumes:");
                                                ipw222222.increaseIndent();
                                                if (this.mLoadedVolumes.size() == 0) {
                                                }
                                                ipw222222.decreaseIndent();
                                                this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                                Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                                }
                                                pw.flush();
                                                HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                                Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                dumpCompilerStatsLPr(pw, packageName5);
                                                if (!checkin) {
                                                }
                                                PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                                if (dumpState.onTitlePrinted()) {
                                                }
                                                if (!checkin) {
                                                }
                                                synchronized (this.mAvailableHwFeatures) {
                                                }
                                            }
                                        } catch (Throwable th15) {
                                            th = th15;
                                            throw th;
                                        }
                                    }
                                    if (checkin) {
                                    }
                                    if (!checkin) {
                                    }
                                    permissionNames4 = permissionNames3;
                                    this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                                    this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                                    if (dumpState.isDumping(128)) {
                                    }
                                    if (dumpState.isDumping(256)) {
                                    }
                                    if (dumpState.isDumping(4194304)) {
                                    }
                                    if (!checkin) {
                                    }
                                    packageName5 = packageName4;
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    IndentingPrintWriter ipw2222222 = new IndentingPrintWriter(pw, "  ", 120);
                                    ipw2222222.println();
                                    ipw2222222.println("Loaded volumes:");
                                    ipw2222222.increaseIndent();
                                    if (this.mLoadedVolumes.size() == 0) {
                                    }
                                    ipw2222222.decreaseIndent();
                                    this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                                    Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                                    }
                                    pw.flush();
                                    HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                                    Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    dumpCompilerStatsLPr(pw, packageName5);
                                    if (!checkin) {
                                    }
                                    PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                                    if (dumpState.onTitlePrinted()) {
                                    }
                                    if (!checkin) {
                                    }
                                    synchronized (this.mAvailableHwFeatures) {
                                    }
                                }
                            } catch (Throwable th16) {
                                arrayMap = arrayMap2;
                                th = th16;
                                throw th;
                            }
                        }
                        packageName2 = packageName;
                        c2 = c;
                        permissionNames3 = permissionNames2;
                        fullPreferred3 = fullPreferred2;
                        arrayMap = arrayMap2;
                        z = true;
                        if (!checkin) {
                        }
                        if (checkin) {
                        }
                        if (!checkin) {
                        }
                        permissionNames4 = permissionNames3;
                        this.mComponentResolver.dumpContentProviders(pw, dumpState, packageName3);
                        this.mSettings.mKeySetManagerService.dumpLPr(pw, packageName3, dumpState);
                        try {
                            if (dumpState.isDumping(128)) {
                            }
                        } catch (Throwable th17) {
                            th = th17;
                            throw th;
                        }
                    } catch (Throwable th18) {
                        arrayMap = arrayMap2;
                        th = th18;
                        throw th;
                    }
                    try {
                        if (dumpState.isDumping(256)) {
                        }
                        if (dumpState.isDumping(4194304)) {
                        }
                        if (!checkin) {
                        }
                        packageName5 = packageName4;
                        if (dumpState.onTitlePrinted()) {
                        }
                        IndentingPrintWriter ipw22222222 = new IndentingPrintWriter(pw, "  ", 120);
                        ipw22222222.println();
                        ipw22222222.println("Loaded volumes:");
                        ipw22222222.increaseIndent();
                        if (this.mLoadedVolumes.size() == 0) {
                        }
                        ipw22222222.decreaseIndent();
                        this.mComponentResolver.dumpServicePermissions(pw, dumpState, packageName5);
                        Log.i(TAG, "Start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        if (SystemProperties.getBoolean("persist.sys.dumpdex", false)) {
                        }
                        pw.flush();
                        HwServiceExFactory.getHwPackageDynamicCodeLoading().dump(new FileOutputStream(fd));
                        Log.i(TAG, "Finish start dump DUMP_DEXOPT, calling from : pid=" + callingPid + ",ppid=" + ppid + ", uid=" + callingUid);
                        if (dumpState.onTitlePrinted()) {
                        }
                        dumpCompilerStatsLPr(pw, packageName5);
                        if (!checkin) {
                        }
                        PackageManagerServiceUtils.dumpCriticalInfo(pw, "msg,");
                        if (dumpState.onTitlePrinted()) {
                        }
                        if (!checkin) {
                        }
                        synchronized (this.mAvailableHwFeatures) {
                        }
                    } catch (Throwable th19) {
                        th = th19;
                        throw th;
                    }
                } catch (Throwable th20) {
                    arrayMap = arrayMap4;
                    th = th20;
                    throw th;
                }
            }
        }
    }

    private void disableSkuSpecificApps() {
        String[] apkList = this.mContext.getResources().getStringArray(17236009);
        String[] skuArray = this.mContext.getResources().getStringArray(17236008);
        if (!ArrayUtils.isEmpty(apkList)) {
            String sku = SystemProperties.get("ro.boot.hardware.sku");
            if (TextUtils.isEmpty(sku) || !ArrayUtils.contains(skuArray, sku)) {
                for (String packageName : apkList) {
                    setSystemAppHiddenUntilInstalled(packageName, true);
                    for (UserInfo user : sUserManager.getUsers(false)) {
                        setSystemAppInstallState(packageName, false, user.id);
                    }
                }
            }
        }
    }

    private void dumpProto(FileDescriptor fd) {
        ProtoOutputStream proto = new ProtoOutputStream(fd);
        synchronized (this.mPackages) {
            long requiredVerifierPackageToken = proto.start(1146756268033L);
            proto.write(1138166333441L, this.mRequiredVerifierPackage);
            proto.write(1120986464258L, getPackageUid(this.mRequiredVerifierPackage, 268435456, 0));
            proto.end(requiredVerifierPackageToken);
            if (this.mIntentFilterVerifierComponent != null) {
                String verifierPackageName = this.mIntentFilterVerifierComponent.getPackageName();
                long verifierPackageToken = proto.start(1146756268034L);
                proto.write(1138166333441L, verifierPackageName);
                proto.write(1120986464258L, getPackageUid(verifierPackageName, 268435456, 0));
                proto.end(verifierPackageToken);
            }
            dumpSharedLibrariesProto(proto);
            dumpFeaturesProto(proto);
            dumpHwFeaturesProto(proto);
            this.mSettings.dumpPackagesProto(proto);
            this.mSettings.dumpSharedUsersProto(proto);
            PackageManagerServiceUtils.dumpCriticalInfo(proto);
        }
        proto.flush();
    }

    private void dumpFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableFeatures) {
            int count = this.mAvailableFeatures.size();
            for (int i = 0; i < count; i++) {
                this.mAvailableFeatures.valueAt(i).writeToProto(proto, 2246267895812L);
            }
        }
    }

    private void dumpHwFeaturesProto(ProtoOutputStream proto) {
        synchronized (this.mAvailableHwFeatures) {
            int count = this.mAvailableHwFeatures.size();
            for (int i = 0; i < count; i++) {
                this.mAvailableHwFeatures.valueAt(i).writeToProto(proto, 2246267895816L);
            }
        }
    }

    private void dumpSharedLibrariesProto(ProtoOutputStream proto) {
        int count = this.mSharedLibraries.size();
        for (int i = 0; i < count; i++) {
            LongSparseArray<SharedLibraryInfo> versionedLib = this.mSharedLibraries.get(this.mSharedLibraries.keyAt(i));
            if (versionedLib != null) {
                int versionCount = versionedLib.size();
                for (int j = 0; j < versionCount; j++) {
                    SharedLibraryInfo libraryInfo = versionedLib.valueAt(j);
                    long sharedLibraryToken = proto.start(2246267895811L);
                    proto.write(1138166333441L, libraryInfo.getName());
                    boolean isJar = libraryInfo.getPath() != null;
                    proto.write(1133871366146L, isJar);
                    if (isJar) {
                        proto.write(1138166333443L, libraryInfo.getPath());
                    } else {
                        proto.write(1138166333444L, libraryInfo.getPackageName());
                    }
                    proto.end(sharedLibraryToken);
                }
            }
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpDexoptStateLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Dexopt state:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        if (ZygoteInit.sIsMygote) {
            MplDexOptAdaptor.getInstance().dumpPkgListDexoptState(ipw, packages, this.mDexManager);
            return;
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            this.mPackageDexOptimizer.dumpDexoptState(ipw, pkg, this.mDexManager.getPackageUseInfoOrDefault(pkg.packageName));
            ipw.decreaseIndent();
        }
    }

    @GuardedBy({"mPackages"})
    private void dumpCompilerStatsLPr(PrintWriter pw, String packageName) {
        Collection<PackageParser.Package> packages;
        IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
        ipw.println();
        ipw.println("Compiler stats:");
        ipw.increaseIndent();
        if (packageName != null) {
            PackageParser.Package targetPackage = this.mPackages.get(packageName);
            if (targetPackage != null) {
                packages = Collections.singletonList(targetPackage);
            } else {
                ipw.println("Unable to find package: " + packageName);
                return;
            }
        } else {
            packages = this.mPackages.values();
        }
        for (PackageParser.Package pkg : packages) {
            ipw.println("[" + pkg.packageName + "]");
            ipw.increaseIndent();
            CompilerStats.PackageStats stats = getCompilerPackageStats(pkg.packageName);
            if (stats == null) {
                ipw.println("(No recorded stats)");
            } else {
                stats.dump(ipw);
            }
            ipw.decreaseIndent();
        }
    }

    private String dumpDomainString(String packageName) {
        List<IntentFilterVerificationInfo> iviList = getIntentFilterVerifications(packageName).getList();
        List<IntentFilter> filters = getAllIntentFilters(packageName).getList();
        ArraySet<String> result = new ArraySet<>();
        if (iviList.size() > 0) {
            for (IntentFilterVerificationInfo ivi : iviList) {
                result.addAll(ivi.getDomains());
            }
        }
        if (filters != null && filters.size() > 0) {
            for (IntentFilter filter : filters) {
                if (filter.hasCategory("android.intent.category.BROWSABLE") && (filter.hasDataScheme("http") || filter.hasDataScheme("https"))) {
                    result.addAll(filter.getHostsList());
                }
            }
        }
        StringBuilder sb = new StringBuilder(result.size() * 16);
        Iterator<String> it = result.iterator();
        while (it.hasNext()) {
            String domain = it.next();
            if (sb.length() > 0) {
                sb.append(" ");
            }
            sb.append(domain);
        }
        return sb.toString();
    }

    static String getEncryptKey() {
        try {
            String sdEncKey = SystemKeyStore.getInstance().retrieveKeyHexString(SD_ENCRYPTION_KEYSTORE_NAME);
            if (sdEncKey != null || (sdEncKey = SystemKeyStore.getInstance().generateNewKeyHexString(128, SD_ENCRYPTION_ALGORITHM, SD_ENCRYPTION_KEYSTORE_NAME)) != null) {
                return sdEncKey;
            }
            Slog.e(TAG, "Failed to create encryption keys");
            return null;
        } catch (NoSuchAlgorithmException nsae) {
            Slog.e(TAG, "Failed to create encryption keys with exception: " + nsae);
            return null;
        } catch (IOException ioe) {
            Slog.e(TAG, "Failed to retrieve encryption keys with exception: " + ioe);
            return null;
        }
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        int size = infos.size();
        String[] packageNames = new String[size];
        int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            ApplicationInfo info = infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, ArrayList<String> pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        sendResourcesChangedBroadcast(mediaStatus, replacing, (String[]) pkgList.toArray(new String[pkgList.size()]), uidArr, finishedReceiver);
    }

    private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing, String[] pkgList, int[] uidArr, IIntentReceiver finishedReceiver) {
        String action;
        if (pkgList.length > 0) {
            Bundle extras = new Bundle();
            extras.putStringArray("android.intent.extra.changed_package_list", pkgList);
            if (uidArr != null) {
                extras.putIntArray("android.intent.extra.changed_uid_list", uidArr);
            }
            if (replacing) {
                extras.putBoolean("android.intent.extra.REPLACING", replacing);
            }
            if (mediaStatus) {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_AVAILABLE";
            } else {
                action = "android.intent.action.EXTERNAL_APPLICATIONS_UNAVAILABLE";
            }
            sendPackageBroadcast(action, null, extras, 0, null, finishedReceiver, null, null);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void loadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$X2AMq2iK5xKRBnqBz7UVMpJ_Fw */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$loadPrivatePackages$35$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* renamed from: loadPrivatePackagesInner */
    public void lambda$loadPrivatePackages$35$PackageManagerService(VolumeInfo vol) {
        Settings.VersionInfo ver;
        List<PackageSetting> packages;
        int flags;
        Object obj;
        PackageParser.Package pkg;
        PackageSetting ps;
        PackageManagerException e;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Loading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<PackageFreezer> freezers = new ArrayList<>();
        ArrayList<ApplicationInfo> loaded = new ArrayList<>();
        int parseFlags = this.mDefParseFlags | 8;
        synchronized (this.mPackages) {
            ver = this.mSettings.findOrCreateVersion(volumeUuid);
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        for (PackageSetting ps2 : packages) {
            freezers.add(freezePackage(ps2.name, "loadPrivatePackagesInner"));
            Object obj2 = this.mInstallLock;
            synchronized (obj2) {
                try {
                    obj = obj2;
                    ps = ps2;
                    try {
                        loaded.add(scanPackageTracedLI(ps2.codePath, parseFlags, 512, 0, (UserHandle) null).applicationInfo);
                    } catch (PackageManagerException e2) {
                        e = e2;
                    }
                } catch (PackageManagerException e3) {
                    e = e3;
                    obj = obj2;
                    ps = ps2;
                    try {
                        Slog.w(TAG, "Failed to scan " + ps.codePath + ": " + e.getMessage());
                        clearAppDataLIF(ps.pkg, -1, 39);
                    } catch (Throwable th) {
                        pkg = th;
                        throw pkg;
                    }
                } catch (Throwable th2) {
                    pkg = th2;
                    obj = obj2;
                    throw pkg;
                }
                if (!Build.FINGERPRINT.equals(ver.fingerprint) || !Build.FINGERPRINTEX.equals(ver.fingerprintEx)) {
                    clearAppDataLIF(ps.pkg, -1, 39);
                }
            }
        }
        StorageManager sm = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : ((UserManager) this.mContext.getSystemService(UserManager.class)).getUsers()) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            } else {
                continue;
            }
            try {
                sm.prepareUserStorage(volumeUuid, user.id, user.serialNumber, flags);
                synchronized (this.mInstallLock) {
                    reconcileAppsDataLI(volumeUuid, user.id, flags, true);
                }
            } catch (IllegalStateException e4) {
                Slog.w(TAG, "Failed to prepare storage: " + e4);
            }
        }
        synchronized (this.mPackages) {
            boolean sdkUpdated = ver.sdkVersion != this.mSdkVersion;
            if (sdkUpdated) {
                PackageManagerServiceUtils.logCriticalInfo(4, "Platform changed from " + ver.sdkVersion + " to " + this.mSdkVersion + "; regranting permissions for " + volumeUuid);
            }
            this.mPermissionManager.updateAllPermissions(volumeUuid, sdkUpdated, this.mPackages.values(), this.mPermissionCallback);
            ver.forceCurrent();
            this.mSettings.writeLPr();
        }
        Iterator<PackageFreezer> it = freezers.iterator();
        while (it.hasNext()) {
            it.next().close();
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Loaded packages " + loaded);
        }
        sendResourcesChangedBroadcast(true, false, loaded, null);
        this.mLoadedVolumes.add(vol.getId());
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void unloadPrivatePackages(VolumeInfo vol) {
        this.mHandler.post(new Runnable(vol) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$UosoyEVsIQxES6XaYARCR7vQm9Y */
            private final /* synthetic */ VolumeInfo f$1;

            {
                this.f$1 = r2;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$unloadPrivatePackages$36$PackageManagerService(this.f$1);
            }
        });
    }

    /* access modifiers changed from: private */
    /* renamed from: unloadPrivatePackagesInner */
    public void lambda$unloadPrivatePackages$36$PackageManagerService(VolumeInfo vol) {
        Throwable th;
        PackageFreezer freezer;
        PackageSetting ps;
        StringBuilder sb;
        String volumeUuid = vol.fsUuid;
        if (TextUtils.isEmpty(volumeUuid)) {
            Slog.e(TAG, "Unloading internal storage is probably a mistake; ignoring");
            return;
        }
        ArrayList<ApplicationInfo> unloaded = new ArrayList<>();
        synchronized (this.mInstallLock) {
            synchronized (this.mPackages) {
                Iterator<PackageSetting> it = this.mSettings.getVolumePackagesLPr(volumeUuid).iterator();
                while (it.hasNext()) {
                    PackageSetting ps2 = it.next();
                    if (ps2.pkg != null) {
                        ApplicationInfo info = ps2.pkg.applicationInfo;
                        PackageRemovedInfo outInfo = new PackageRemovedInfo(this);
                        PackageFreezer freezer2 = freezePackageForDelete(ps2.name, 1, "unloadPrivatePackagesInner");
                        try {
                            try {
                                if (deletePackageLIF(ps2.name, null, false, null, 1, outInfo, false, null)) {
                                    try {
                                        unloaded.add(info);
                                        ps = ps2;
                                    } catch (Throwable th2) {
                                        th = th2;
                                        freezer = freezer2;
                                        try {
                                            throw th;
                                        } catch (Throwable th3) {
                                            if (freezer != null) {
                                                $closeResource(th, freezer);
                                            }
                                            throw th3;
                                        }
                                    }
                                } else {
                                    try {
                                        sb = new StringBuilder();
                                        sb.append("Failed to unload ");
                                        ps = ps2;
                                    } catch (Throwable th4) {
                                        freezer = freezer2;
                                        th = th4;
                                        throw th;
                                    }
                                    try {
                                        sb.append(ps.codePath);
                                        Slog.w(TAG, sb.toString());
                                    } catch (Throwable th5) {
                                        freezer = freezer2;
                                        th = th5;
                                        throw th;
                                    }
                                }
                                if (freezer2 != null) {
                                    $closeResource(null, freezer2);
                                }
                                AttributeCache.instance().removePackage(ps.name);
                                it = it;
                            } catch (Throwable th6) {
                                freezer = freezer2;
                                th = th6;
                                throw th;
                            }
                        } catch (Throwable th7) {
                            freezer = freezer2;
                            th = th7;
                            throw th;
                        }
                    }
                }
                this.mSettings.writeLPr();
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Unloaded packages " + unloaded);
        }
        sendResourcesChangedBroadcast(false, false, unloaded, null);
        this.mLoadedVolumes.remove(vol.getId());
        ResourcesManager.getInstance().invalidatePath(vol.getPath().getAbsolutePath());
        for (int i = 0; i < 3; i++) {
            System.gc();
            System.runFinalization();
        }
    }

    private void assertPackageKnownAndInstalled(String volumeUuid, String packageName, int userId) throws PackageManagerException {
        synchronized (this.mPackages) {
            String packageName2 = normalizePackageNameLPr(packageName);
            PackageSetting ps = this.mSettings.mPackages.get(packageName2);
            if (ps == null) {
                throw new PackageManagerException("Package " + packageName2 + " is unknown");
            } else if (!TextUtils.equals(volumeUuid, ps.volumeUuid)) {
                throw new PackageManagerException("Package " + packageName2 + " found on unknown volume " + volumeUuid + "; expected volume " + ps.volumeUuid);
            } else if (!ps.getInstalled(userId)) {
                throw new PackageManagerException("Package " + packageName2 + " not installed for user " + userId);
            }
        }
    }

    private List<String> collectAbsoluteCodePaths() {
        List<String> codePaths;
        synchronized (this.mPackages) {
            codePaths = new ArrayList<>();
            int packageCount = this.mSettings.mPackages.size();
            for (int i = 0; i < packageCount; i++) {
                codePaths.add(this.mSettings.mPackages.valueAt(i).codePath.getAbsolutePath());
            }
        }
        return codePaths;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void reconcileApps(String volumeUuid) {
        List<String> absoluteCodePaths = collectAbsoluteCodePaths();
        File[] files = FileUtils.listFilesOrEmpty(Environment.getDataAppDirectory(volumeUuid));
        List<File> filesToDelete = null;
        for (File file : files) {
            if ((PackageParser.isApkFile(file) || file.isDirectory()) && !PackageInstallerService.isStageName(file.getName())) {
                String absolutePath = file.getAbsolutePath();
                boolean pathValid = false;
                int absoluteCodePathCount = absoluteCodePaths.size();
                int i = 0;
                while (true) {
                    if (i >= absoluteCodePathCount) {
                        break;
                    } else if (absolutePath.startsWith(absoluteCodePaths.get(i))) {
                        pathValid = true;
                        break;
                    } else {
                        i++;
                    }
                }
                if (!pathValid) {
                    if (filesToDelete == null) {
                        filesToDelete = new ArrayList<>();
                    }
                    filesToDelete.add(file);
                }
            }
        }
        if (filesToDelete != null) {
            int fileToDeleteCount = filesToDelete.size();
            reportVolumeApkScanError(volumeUuid, fileToDeleteCount);
            for (int i2 = 0; i2 < fileToDeleteCount; i2++) {
                File fileToDelete = filesToDelete.get(i2);
                PackageManagerServiceUtils.logCriticalInfo(5, "Destroying orphaned" + fileToDelete);
                synchronized (this.mInstallLock) {
                    removeCodePathLI(fileToDelete);
                }
            }
        }
    }

    private void reportVolumeApkScanError(String volumeUuid, int fileToDeleteCount) {
        long elapsedRealtime = SystemClock.elapsedRealtime();
        Slog.i(TAG, "Scan volume file in volumeUuid :" + volumeUuid + ", delete orphaned apk files:" + fileToDeleteCount + ", elapsedRealtime:" + elapsedRealtime + ", effective apps:" + this.mPackages.size());
        HwPackageManagerServiceUtils.reportPmsDeleteDataApp(this.mPackages.size(), fileToDeleteCount, elapsedRealtime);
    }

    /* access modifiers changed from: package-private */
    public void reconcileAppsData(int userId, int flags, boolean migrateAppsData) {
        for (VolumeInfo vol : ((StorageManager) this.mContext.getSystemService(StorageManager.class)).getWritablePrivateVolumes()) {
            String volumeUuid = vol.getFsUuid();
            synchronized (this.mInstallLock) {
                reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppsData);
            }
        }
    }

    @GuardedBy({"mInstallLock"})
    private void reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData) {
        reconcileAppsDataLI(volumeUuid, userId, flags, migrateAppData, false);
    }

    @GuardedBy({"mInstallLock"})
    private List<String> reconcileAppsDataLI(String volumeUuid, int userId, int flags, boolean migrateAppData, boolean onlyCoreApps) {
        int i;
        List<PackageSetting> packages;
        int i2;
        File[] files;
        int i3;
        Installer.InstallerException e2;
        File[] files2;
        int i4;
        int i5;
        File ceDir;
        int i6;
        Installer.InstallerException e22;
        Slog.v(TAG, "reconcileAppsData for " + volumeUuid + " u" + userId + " 0x" + Integer.toHexString(flags) + " migrateAppData=" + migrateAppData);
        List<String> result = onlyCoreApps ? new ArrayList<>() : null;
        File ceDir2 = Environment.getDataUserCeDirectory(volumeUuid, userId);
        File deDir = Environment.getDataUserDeDirectory(volumeUuid, userId);
        int i7 = 5;
        if ((flags & 2) == 0) {
            i = 5;
        } else if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
            File[] files3 = FileUtils.listFilesOrEmpty(ceDir2);
            int length = files3.length;
            int i8 = 0;
            while (i8 < length) {
                File file = files3[i8];
                String packageName = file.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName, userId);
                    i5 = i8;
                    i4 = length;
                    files2 = files3;
                    ceDir = ceDir2;
                    i6 = i7;
                } catch (PackageManagerException e) {
                    PackageManagerServiceUtils.logCriticalInfo(i7, "Destroying " + file + " due to: " + e);
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(packageName)) {
                        HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName);
                    }
                    try {
                        i5 = i8;
                        i4 = length;
                        files2 = files3;
                        ceDir = ceDir2;
                        i6 = i7;
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName, userId, 2, 0);
                        } catch (Installer.InstallerException e3) {
                            e22 = e3;
                        }
                    } catch (Installer.InstallerException e4) {
                        e22 = e4;
                        i5 = i8;
                        i4 = length;
                        files2 = files3;
                        ceDir = ceDir2;
                        i6 = i7;
                        PackageManagerServiceUtils.logCriticalInfo(i6, "Failed to destroy: " + e22);
                        i8 = i5 + 1;
                        i7 = i6;
                        ceDir2 = ceDir;
                        length = i4;
                        files3 = files2;
                    }
                }
                i8 = i5 + 1;
                i7 = i6;
                ceDir2 = ceDir;
                length = i4;
                files3 = files2;
            }
            i = i7;
        } else {
            throw new RuntimeException("Yikes, someone asked us to reconcile CE storage while " + userId + " was still locked; this would have caused massive data loss!");
        }
        if ((flags & 1) != 0) {
            File[] files4 = FileUtils.listFilesOrEmpty(deDir);
            int length2 = files4.length;
            int i9 = 0;
            while (i9 < length2) {
                File file2 = files4[i9];
                String packageName2 = file2.getName();
                try {
                    assertPackageKnownAndInstalled(volumeUuid, packageName2, userId);
                    i3 = i9;
                    files = files4;
                    i2 = length2;
                } catch (PackageManagerException e5) {
                    PackageManagerServiceUtils.logCriticalInfo(i, "Destroying " + file2 + " due to: " + e5);
                    if (!HwMaplePMServiceUtils.getMapleEnableFlag(packageName2)) {
                        HwMaplePMServiceUtils.removeDisabledMaplePkg(packageName2);
                    }
                    try {
                        i3 = i9;
                        files = files4;
                        i2 = length2;
                        try {
                            this.mInstaller.destroyAppData(volumeUuid, packageName2, userId, 1, 0);
                        } catch (Installer.InstallerException e6) {
                            e2 = e6;
                        }
                    } catch (Installer.InstallerException e7) {
                        e2 = e7;
                        i3 = i9;
                        files = files4;
                        i2 = length2;
                        PackageManagerServiceUtils.logCriticalInfo(i, "Failed to destroy: " + e2);
                        i9 = i3 + 1;
                        files4 = files;
                        length2 = i2;
                    }
                }
                i9 = i3 + 1;
                files4 = files;
                length2 = i2;
            }
        }
        synchronized (this.mPackages) {
            packages = this.mSettings.getVolumePackagesLPr(volumeUuid);
        }
        if ((flags & 2) != 0) {
            try {
                UniPerf.getInstance().uniPerfEvent(4099, "", new int[0]);
            } catch (RuntimeException e8) {
                Slog.v(TAG, "raise cpu error!");
            }
        }
        int preparedCount = 0;
        for (PackageSetting ps : packages) {
            String packageName3 = ps.name;
            if (ps.pkg == null) {
                Slog.w(TAG, "Odd, missing scanned package " + packageName3);
            } else if (onlyCoreApps && !ps.pkg.coreApp) {
                result.add(packageName3);
            } else if (ps.getInstalled(userId)) {
                prepareAppDataAndMigrateLIF(ps.pkg, userId, flags, migrateAppData);
                preparedCount++;
            }
        }
        Slog.v(TAG, "reconcileAppsData finished " + preparedCount + " packages");
        return result;
    }

    /* access modifiers changed from: protected */
    public void prepareAppDataAfterInstallLIF(PackageParser.Package pkg) {
        PackageSetting ps;
        int flags;
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
            this.mSettings.writeKernelMappingLPr(ps);
        }
        UserManagerService um = sUserManager;
        UserManagerInternal umInternal = getUserManagerInternal();
        for (UserInfo user : um.getUsers(false)) {
            if (umInternal.isUserUnlockingOrUnlocked(user.id)) {
                flags = 3;
            } else if (umInternal.isUserRunning(user.id)) {
                flags = 1;
            }
            if (ps != null && ps.getInstalled(user.id)) {
                prepareAppDataLIF(pkg, user.id, flags);
            }
        }
    }

    private void prepareAppDataLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataAndMigrateLIF(PackageParser.Package pkg, int userId, int flags, boolean maybeMigrateAppData) {
        prepareAppDataLIF(pkg, userId, flags);
        if (maybeMigrateAppData && maybeMigrateAppDataLIF(pkg, userId)) {
            prepareAppDataLIF(pkg, userId, flags);
        }
    }

    /* JADX WARNING: Removed duplicated region for block: B:48:0x0116  */
    private void prepareAppDataLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        PackageSetting ps;
        ApplicationInfo app;
        ApplicationInfo app2;
        boolean z;
        long ceDataInode;
        Installer.InstallerException e;
        if (DEBUG_APP_DATA) {
            Slog.v(TAG, "prepareAppData for " + pkg.packageName + " u" + userId + " 0x" + Integer.toHexString(flags));
        }
        synchronized (this.mPackages) {
            ps = this.mSettings.mPackages.get(pkg.packageName);
        }
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        if (ps == null) {
            app = pkg.applicationInfo;
        } else {
            app = PackageParser.generateApplicationInfo(pkg, 0, ps.readUserState(userId), userId);
        }
        if (app == null) {
            app2 = pkg.applicationInfo;
        } else {
            app2 = app;
        }
        int appId = UserHandle.getAppId(app2.uid);
        Preconditions.checkNotNull(app2.seInfo);
        if (!isUpgradeAndEmuiVersionUpgrade() || mHwPMSEx.migrateDataForRenamedPackageLocked(pkg, userId, flags)) {
            StringBuilder sb = new StringBuilder();
            sb.append(app2.seInfo);
            sb.append(app2.seInfoUser != null ? app2.seInfoUser : "");
            try {
                z = false;
                try {
                    ceDataInode = this.mInstaller.createAppData(volumeUuid, packageName, userId, flags, appId, sb.toString(), app2.targetSdkVersion);
                } catch (Installer.InstallerException e2) {
                    e = e2;
                    Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
                    ceDataInode = -1;
                    this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
                    synchronized (this.mPackages) {
                    }
                }
            } catch (Installer.InstallerException e3) {
                e = e3;
                z = false;
                Slog.e(TAG, "Failed to create app data for " + packageName + ": " + e);
                ceDataInode = -1;
                this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
                synchronized (this.mPackages) {
                }
            }
            if (this.mIsUpgrade || this.mFirstBoot || userId != 0) {
                this.mArtManagerService.prepareAppProfiles(pkg, userId, z);
            }
            if (!((flags & 2) == 0 || ceDataInode == -1)) {
                synchronized (this.mPackages) {
                    if (ps != null) {
                        ps.setCeDataInode(ceDataInode, userId);
                    }
                }
            }
            prepareAppDataContentsLeafLIF(pkg, userId, flags);
            return;
        }
        Slog.i(TAG, "PACKAGE_NAME_CHANGE renamed package :" + pkg.packageName + ", no need to prepare the data directory");
    }

    private void prepareAppDataContentsLIF(PackageParser.Package pkg, int userId, int flags) {
        if (pkg == null) {
            Slog.wtf(TAG, "Package was null!", new Throwable());
            return;
        }
        prepareAppDataContentsLeafLIF(pkg, userId, flags);
        int childCount = pkg.childPackages != null ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            prepareAppDataContentsLeafLIF((PackageParser.Package) pkg.childPackages.get(i), userId, flags);
        }
    }

    private void prepareAppDataContentsLeafLIF(PackageParser.Package pkg, int userId, int flags) {
        String volumeUuid = pkg.volumeUuid;
        String packageName = pkg.packageName;
        ApplicationInfo app = pkg.applicationInfo;
        if ((flags & 2) != 0 && app.primaryCpuAbi != null && !VMRuntime.is64BitAbi(app.primaryCpuAbi)) {
            try {
                this.mInstaller.linkNativeLibraryDirectory(volumeUuid, packageName, app.nativeLibraryDir, userId);
            } catch (Installer.InstallerException e) {
                Slog.e(TAG, "Failed to link native for " + packageName + ": " + e);
            }
        }
    }

    private boolean maybeMigrateAppDataLIF(PackageParser.Package pkg, int userId) {
        if (!pkg.isSystem() || StorageManager.isFileEncryptedNativeOrEmulated()) {
            return false;
        }
        try {
            this.mInstaller.migrateAppData(pkg.volumeUuid, pkg.packageName, userId, pkg.applicationInfo.isDefaultToDeviceProtectedStorage() ? 1 : 2);
        } catch (Installer.InstallerException e) {
            PackageManagerServiceUtils.logCriticalInfo(5, "Failed to migrate " + pkg.packageName + ": " + e.getMessage());
        }
        return true;
    }

    public PackageFreezer freezePackage(String packageName, String killReason) {
        return freezePackage(packageName, -1, killReason);
    }

    public PackageFreezer freezePackage(String packageName, int userId, String killReason) {
        return new PackageFreezer(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int installFlags, String killReason) {
        return freezePackageForInstall(packageName, -1, installFlags, killReason);
    }

    public PackageFreezer freezePackageForInstall(String packageName, int userId, int installFlags, String killReason) {
        if ((installFlags & 4096) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int deleteFlags, String killReason) {
        return freezePackageForDelete(packageName, -1, deleteFlags, killReason);
    }

    public PackageFreezer freezePackageForDelete(String packageName, int userId, int deleteFlags, String killReason) {
        if ((deleteFlags & 8) != 0) {
            return new PackageFreezer();
        }
        return freezePackage(packageName, userId, killReason);
    }

    /* access modifiers changed from: private */
    public class PackageFreezer implements AutoCloseable {
        private final PackageFreezer[] mChildren;
        private final CloseGuard mCloseGuard;
        private final AtomicBoolean mClosed;
        private final String mPackageName;
        private final boolean mWeFroze;

        public PackageFreezer() {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            this.mPackageName = null;
            this.mChildren = null;
            this.mWeFroze = false;
            this.mCloseGuard.open("close");
        }

        public PackageFreezer(String packageName, int userId, String killReason) {
            this.mClosed = new AtomicBoolean();
            this.mCloseGuard = CloseGuard.get();
            synchronized (PackageManagerService.this.mPackages) {
                this.mPackageName = packageName;
                this.mWeFroze = PackageManagerService.this.mFrozenPackages.add(this.mPackageName);
                Slog.d(PackageManagerService.TAG, "mFrozenPackages add package:" + this.mPackageName);
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(this.mPackageName);
                if (ps != null) {
                    PackageManagerService.this.killApplication(ps.name, ps.appId, userId, killReason);
                }
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null || p.childPackages == null) {
                    this.mChildren = null;
                } else {
                    int N = p.childPackages.size();
                    this.mChildren = new PackageFreezer[N];
                    for (int i = 0; i < N; i++) {
                        this.mChildren[i] = new PackageFreezer(((PackageParser.Package) p.childPackages.get(i)).packageName, userId, killReason);
                    }
                }
            }
            this.mCloseGuard.open("close");
        }

        /* access modifiers changed from: protected */
        @Override // java.lang.Object
        public void finalize() throws Throwable {
            try {
                this.mCloseGuard.warnIfOpen();
                close();
            } finally {
                super.finalize();
            }
        }

        @Override // java.lang.AutoCloseable
        public void close() {
            this.mCloseGuard.close();
            if (this.mClosed.compareAndSet(false, true)) {
                synchronized (PackageManagerService.this.mPackages) {
                    if (this.mWeFroze) {
                        PackageManagerService.this.mFrozenPackages.remove(this.mPackageName);
                        Slog.d(PackageManagerService.TAG, "mFrozenPackages remove package:" + this.mPackageName);
                    }
                    if (this.mChildren != null) {
                        for (PackageFreezer freezer : this.mChildren) {
                            freezer.close();
                        }
                    }
                }
            }
        }
    }

    private void checkPackageFrozen(String packageName) {
        synchronized (this.mPackages) {
            if (!this.mFrozenPackages.contains(packageName)) {
                Slog.wtf(TAG, "Expected " + packageName + " to be frozen!", new Throwable());
            }
        }
    }

    public int movePackage(String packageName, String volumeUuid) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        int callingUid = Binder.getCallingUid();
        UserHandle user = new UserHandle(UserHandle.getUserId(callingUid));
        int moveId = this.mNextMoveId.getAndIncrement();
        this.mHandler.post(new Runnable(packageName, volumeUuid, moveId, callingUid, user) {
            /* class com.android.server.pm.$$Lambda$PackageManagerService$TVENvVKVrn8wdG2nHQ7cv9AmWII */
            private final /* synthetic */ String f$1;
            private final /* synthetic */ String f$2;
            private final /* synthetic */ int f$3;
            private final /* synthetic */ int f$4;
            private final /* synthetic */ UserHandle f$5;

            {
                this.f$1 = r2;
                this.f$2 = r3;
                this.f$3 = r4;
                this.f$4 = r5;
                this.f$5 = r6;
            }

            @Override // java.lang.Runnable
            public final void run() {
                PackageManagerService.this.lambda$movePackage$37$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
            }
        });
        return moveId;
    }

    public /* synthetic */ void lambda$movePackage$37$PackageManagerService(String packageName, String volumeUuid, int moveId, int callingUid, UserHandle user) {
        try {
            movePackageInternal(packageName, volumeUuid, moveId, callingUid, user);
        } catch (PackageManagerException e) {
            Slog.w(TAG, "Failed to move " + packageName, e);
            this.mMoveCallbacks.notifyStatusChanged(moveId, e.error);
        }
    }

    private void movePackageInternal(final String packageName, String volumeUuid, final int moveId, int callingUid, UserHandle user) throws PackageManagerException {
        String currentVolumeUuid;
        final boolean isCurrentLocationExternal;
        File codeFile;
        String installerPackageName;
        String packageAbiOverride;
        int appId;
        String seinfo;
        String label;
        int targetSdkVersion;
        final PackageFreezer freezer;
        int[] installedUserIds;
        boolean moveCompleteApp;
        VolumeInfo measurePath;
        String label2;
        Bundle extras;
        Throwable th;
        long sizeBytes;
        String currentVolumeUuid2;
        PackageManagerService packageManagerService;
        MoveInfo move;
        StorageManager storage = (StorageManager) this.mContext.getSystemService(StorageManager.class);
        PackageManager pm = this.mContext.getPackageManager();
        synchronized (this.mPackages) {
            try {
                PackageParser.Package pkg = this.mPackages.get(packageName);
                PackageSetting ps = this.mSettings.mPackages.get(packageName);
                if (pkg != null && ps != null) {
                    if (!filterAppAccessLPr(ps, callingUid, user.getIdentifier())) {
                        if (!pkg.applicationInfo.isSystemApp()) {
                            boolean isInternalStorage = "private".equals(volumeUuid);
                            boolean allow3rdPartyOnInternal = this.mContext.getResources().getBoolean(17891340);
                            if (!isInternalStorage || allow3rdPartyOnInternal) {
                                currentVolumeUuid = ps.volumeUuid;
                                File probe = new File(pkg.codePath);
                                File probeOat = new File(probe, "oat");
                                if (!probe.isDirectory() || !probeOat.isDirectory()) {
                                    throw new PackageManagerException(-6, "Move only supported for modern cluster style installs");
                                } else if (!Objects.equals(currentVolumeUuid, volumeUuid)) {
                                    if (pkg.applicationInfo.isInternal()) {
                                        if (isPackageDeviceAdminOnAnyUser(packageName)) {
                                            throw new PackageManagerException(-8, "Device admin cannot be moved");
                                        }
                                    }
                                    if (!this.mFrozenPackages.contains(packageName)) {
                                        isCurrentLocationExternal = isExternal(pkg);
                                        codeFile = new File(pkg.codePath);
                                        installerPackageName = ps.installerPackageName;
                                        packageAbiOverride = ps.cpuAbiOverrideString;
                                        appId = UserHandle.getAppId(pkg.applicationInfo.uid);
                                        seinfo = pkg.applicationInfo.seInfo;
                                        label = String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
                                        targetSdkVersion = pkg.applicationInfo.targetSdkVersion;
                                        freezer = freezePackage(packageName, "movePackageInternal");
                                        installedUserIds = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
                                    } else {
                                        throw new PackageManagerException(-7, "Failed to move already frozen package");
                                    }
                                } else {
                                    throw new PackageManagerException(-6, "Package already moved to " + volumeUuid);
                                }
                            } else {
                                try {
                                    throw new PackageManagerException(-9, "3rd party apps are not allowed on internal storage");
                                } catch (Throwable th2) {
                                    pkg = th2;
                                    throw pkg;
                                }
                            }
                        } else {
                            throw new PackageManagerException(-3, "Cannot move system application");
                        }
                    }
                }
                throw new PackageManagerException(-2, "Missing package");
            } catch (Throwable th3) {
                pkg = th3;
                throw pkg;
            }
        }
        Bundle extras2 = new Bundle();
        extras2.putString("android.intent.extra.PACKAGE_NAME", packageName);
        extras2.putString("android.intent.extra.TITLE", label);
        this.mMoveCallbacks.notifyCreated(moveId, extras2);
        if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, volumeUuid)) {
            measurePath = Environment.getDataAppDirectory(volumeUuid);
            moveCompleteApp = true;
        } else if (Objects.equals("primary_physical", volumeUuid)) {
            measurePath = storage.getPrimaryPhysicalVolume().getPath();
            moveCompleteApp = false;
        } else {
            VolumeInfo volume = storage.findVolumeByUuid(volumeUuid);
            if (volume != null && volume.getType() == 1) {
                if (volume.isMountedWritable()) {
                    moveCompleteApp = true;
                    measurePath = Environment.getDataAppDirectory(volumeUuid);
                }
            }
            freezer.close();
            throw new PackageManagerException(-6, "Move location not mounted private volume");
        }
        if (moveCompleteApp) {
            int length = installedUserIds.length;
            int i = 0;
            while (i < length) {
                int userId = installedUserIds[i];
                if (!StorageManager.isFileEncryptedNativeOrEmulated() || StorageManager.isUserKeyUnlocked(userId)) {
                    i++;
                    length = length;
                    extras2 = extras2;
                    label = label;
                } else {
                    throw new PackageManagerException(-10, "User " + userId + " must be unlocked");
                }
            }
            extras = extras2;
            label2 = label;
        } else {
            extras = extras2;
            label2 = label;
        }
        PackageStats stats = new PackageStats(null, -1);
        synchronized (this.mInstaller) {
            try {
                int i2 = 0;
                for (int length2 = installedUserIds.length; i2 < length2; length2 = length2) {
                    try {
                        if (getPackageSizeInfoLI(packageName, installedUserIds[i2], stats)) {
                            i2++;
                        } else {
                            freezer.close();
                            try {
                                throw new PackageManagerException(-6, "Failed to measure package size");
                            } catch (Throwable th4) {
                                th = th4;
                                while (true) {
                                    try {
                                        break;
                                    } catch (Throwable th5) {
                                        th = th5;
                                    }
                                }
                                throw th;
                            }
                        }
                    } catch (Throwable th6) {
                        th = th6;
                        while (true) {
                            break;
                        }
                        throw th;
                    }
                }
                try {
                } catch (Throwable th7) {
                    th = th7;
                    while (true) {
                        break;
                    }
                    throw th;
                }
            } catch (Throwable th8) {
                th = th8;
                while (true) {
                    break;
                }
                throw th;
            }
        }
        if (DEBUG_INSTALL) {
            Slog.d(TAG, "Measured code size " + stats.codeSize + ", data size " + stats.dataSize);
        }
        long startFreeBytes = measurePath.getUsableSpace();
        if (moveCompleteApp) {
            currentVolumeUuid2 = currentVolumeUuid;
            sizeBytes = stats.codeSize + stats.dataSize;
        } else {
            currentVolumeUuid2 = currentVolumeUuid;
            sizeBytes = stats.codeSize;
        }
        if (sizeBytes <= storage.getStorageBytesUntilLow(measurePath)) {
            this.mMoveCallbacks.notifyStatusChanged(moveId, 10);
            final CountDownLatch installedLatch = new CountDownLatch(1);
            IPackageInstallObserver2 installObserver = new IPackageInstallObserver2.Stub() {
                /* class com.android.server.pm.PackageManagerService.AnonymousClass11 */

                public void onUserActionRequired(Intent intent) throws RemoteException {
                    throw new IllegalStateException();
                }

                public void onPackageInstalled(String basePackageName, int returnCode, String msg, Bundle extras) throws RemoteException {
                    if (PackageManagerService.DEBUG_INSTALL) {
                        Slog.d(PackageManagerService.TAG, "Install result for move: " + PackageManager.installStatusToString(returnCode, msg));
                    }
                    installedLatch.countDown();
                    freezer.close();
                    int status = PackageManager.installStatusToPublicStatus(returnCode);
                    if (status == 0) {
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(moveId, -100);
                        PackageManagerService.this.logAppMovedStorage(packageName, isCurrentLocationExternal);
                    } else if (status != 6) {
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(moveId, -6);
                    } else {
                        PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(moveId, -1);
                    }
                }
            };
            if (moveCompleteApp) {
                packageManagerService = this;
                new Thread(new Runnable(installedLatch, startFreeBytes, measurePath, sizeBytes, moveId) {
                    /* class com.android.server.pm.$$Lambda$PackageManagerService$Eb7TttKZNlL25KL0xH6LpfSOU8 */
                    private final /* synthetic */ CountDownLatch f$1;
                    private final /* synthetic */ long f$2;
                    private final /* synthetic */ File f$3;
                    private final /* synthetic */ long f$4;
                    private final /* synthetic */ int f$5;

                    {
                        this.f$1 = r2;
                        this.f$2 = r3;
                        this.f$3 = r5;
                        this.f$4 = r6;
                        this.f$5 = r8;
                    }

                    @Override // java.lang.Runnable
                    public final void run() {
                        PackageManagerService.this.lambda$movePackageInternal$38$PackageManagerService(this.f$1, this.f$2, this.f$3, this.f$4, this.f$5);
                    }
                }).start();
                move = new MoveInfo(moveId, currentVolumeUuid2, volumeUuid, packageName, codeFile.getName(), appId, seinfo, targetSdkVersion);
            } else {
                packageManagerService = this;
                move = null;
            }
            Message msg = packageManagerService.mHandler.obtainMessage(5);
            InstallParams params = new InstallParams(OriginInfo.fromExistingFile(codeFile), move, installObserver, 16 | 2, installerPackageName, volumeUuid, null, user, packageAbiOverride, null, null, PackageParser.SigningDetails.UNKNOWN, 0, -1);
            params.setTraceMethod("movePackage").setTraceCookie(System.identityHashCode(params));
            msg.obj = params;
            Trace.asyncTraceBegin(262144, "movePackage", System.identityHashCode(msg.obj));
            Trace.asyncTraceBegin(262144, "queueInstall", System.identityHashCode(msg.obj));
            packageManagerService.mHandler.sendMessage(msg);
            return;
        }
        freezer.close();
        throw new PackageManagerException(-6, "Not enough free space to move");
    }

    public /* synthetic */ void lambda$movePackageInternal$38$PackageManagerService(CountDownLatch installedLatch, long startFreeBytes, File measurePath, long sizeBytes, int moveId) {
        while (!installedLatch.await(1, TimeUnit.SECONDS)) {
            this.mMoveCallbacks.notifyStatusChanged(moveId, ((int) MathUtils.constrain((80 * (startFreeBytes - measurePath.getUsableSpace())) / sizeBytes, 0, 80)) + 10);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void logAppMovedStorage(String packageName, boolean isPreviousLocationExternal) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        if (pkg != null) {
            int packageExternalStorageType = getPackageExternalStorageType(((StorageManager) this.mContext.getSystemService(StorageManager.class)).findVolumeByUuid(pkg.applicationInfo.storageUuid.toString()), isExternal(pkg));
            if (!isPreviousLocationExternal && isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 1, packageName);
            } else if (isPreviousLocationExternal && !isExternal(pkg)) {
                StatsLog.write(183, packageExternalStorageType, 2, packageName);
            }
        }
    }

    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOVE_PACKAGE", null);
        final int realMoveId = this.mNextMoveId.getAndIncrement();
        Bundle extras = new Bundle();
        extras.putString("android.os.storage.extra.FS_UUID", volumeUuid);
        this.mMoveCallbacks.notifyCreated(realMoveId, extras);
        ((StorageManager) this.mContext.getSystemService(StorageManager.class)).setPrimaryStorageUuid(volumeUuid, new IPackageMoveObserver.Stub() {
            /* class com.android.server.pm.PackageManagerService.AnonymousClass12 */

            public void onCreated(int moveId, Bundle extras) {
            }

            public void onStatusChanged(int moveId, int status, long estMillis) {
                PackageManagerService.this.mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        });
        return realMoveId;
    }

    public int getMoveStatus(int moveId) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        return this.mMoveCallbacks.mLastStatus.get(moveId);
    }

    public void registerMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.register(callback);
    }

    public void unregisterMoveCallback(IPackageMoveObserver callback) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.MOUNT_UNMOUNT_FILESYSTEMS", null);
        this.mMoveCallbacks.unregister(callback);
    }

    public boolean setInstallLocation(int loc) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.WRITE_SECURE_SETTINGS", null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc != 0 && loc != 1 && loc != 2) {
            return false;
        }
        Settings.Global.putInt(this.mContext.getContentResolver(), "default_install_location", loc);
        return true;
    }

    public int getInstallLocation() {
        return Settings.Global.getInt(this.mContext.getContentResolver(), "default_install_location", 0);
    }

    /* access modifiers changed from: package-private */
    public void cleanUpUser(UserManagerService userManager, int userHandle) {
        synchronized (this.mPackages) {
            this.mDirtyUsers.remove(Integer.valueOf(userHandle));
            this.mUserNeedsBadging.delete(userHandle);
            this.mSettings.removeUserLPw(userHandle);
            this.mPendingBroadcasts.remove(userHandle);
            this.mInstantAppRegistry.onUserRemovedLPw(userHandle);
            removeUnusedPackagesLPw(userManager, userHandle);
        }
        mHwPMSEx.onUserRemoved(userHandle);
    }

    @GuardedBy({"mPackages"})
    private void removeUnusedPackagesLPw(UserManagerService userManager, int userHandle) {
        int[] users = userManager.getUserIds();
        for (PackageSetting ps : this.mSettings.mPackages.values()) {
            if (ps.pkg != null) {
                String packageName = ps.pkg.packageName;
                if (((ps.pkgFlags & 1) == 0 && TextUtils.isEmpty(ps.pkg.staticSharedLibName)) || HwPackageManagerServiceUtils.isPreRemovableApp(ps)) {
                    boolean keep = shouldKeepUninstalledPackageLPr(packageName);
                    if (!keep) {
                        int i = 0;
                        while (true) {
                            if (i >= users.length) {
                                break;
                            }
                            if (users[i] != userHandle && ps.getInstalled(users[i])) {
                                keep = true;
                                break;
                            }
                            i++;
                        }
                    }
                    if (!keep) {
                        this.mHandler.post(new Runnable(packageName, userHandle) {
                            /* class com.android.server.pm.$$Lambda$PackageManagerService$FA8tLJEucMxUI3u48DLGcXRmmg */
                            private final /* synthetic */ String f$1;
                            private final /* synthetic */ int f$2;

                            {
                                this.f$1 = r2;
                                this.f$2 = r3;
                            }

                            @Override // java.lang.Runnable
                            public final void run() {
                                PackageManagerService.this.lambda$removeUnusedPackagesLPw$39$PackageManagerService(this.f$1, this.f$2);
                            }
                        });
                    }
                }
            }
        }
    }

    public /* synthetic */ void lambda$removeUnusedPackagesLPw$39$PackageManagerService(String packageName, int userHandle) {
        deletePackageX(packageName, -1, userHandle, 0);
    }

    /* access modifiers changed from: package-private */
    public void createNewUser(int userId, String[] disallowedPackages) {
        synchronized (this.mInstallLock) {
            this.mSettings.createNewUserLI(this, this.mInstaller, userId, disallowedPackages);
        }
        synchronized (this.mPackages) {
            scheduleWritePackageRestrictionsLocked(userId);
            scheduleWritePackageListLocked(userId);
            primeDomainVerificationsLPw(userId);
        }
    }

    /* access modifiers changed from: package-private */
    public void onNewUserCreated(int userId) {
        this.mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        synchronized (this.mPackages) {
            this.mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, true, this.mPackages.values(), this.mPermissionCallback);
        }
        mHwPMSEx.onNewUserCreated(userId);
    }

    public VerifierDeviceIdentity getVerifierDeviceIdentity() throws RemoteException {
        VerifierDeviceIdentity verifierDeviceIdentityLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.PACKAGE_VERIFICATION_AGENT", "Only package verification agents can read the verifier device identity");
        synchronized (this.mPackages) {
            verifierDeviceIdentityLPw = this.mSettings.getVerifierDeviceIdentityLPw();
        }
        return verifierDeviceIdentityLPw;
    }

    public void setPermissionEnforced(String permission, boolean enforced) {
        this.mContext.enforceCallingOrSelfPermission("android.permission.GRANT_RUNTIME_PERMISSIONS", "setPermissionEnforced");
        if ("android.permission.READ_EXTERNAL_STORAGE".equals(permission)) {
            synchronized (this.mPackages) {
                if (this.mSettings.mReadExternalStorageEnforced == null || this.mSettings.mReadExternalStorageEnforced.booleanValue() != enforced) {
                    this.mSettings.mReadExternalStorageEnforced = enforced ? Boolean.TRUE : Boolean.FALSE;
                    this.mSettings.writeLPr();
                }
            }
            IActivityManager am = ActivityManager.getService();
            if (am != null) {
                long token = Binder.clearCallingIdentity();
                try {
                    am.killProcessesBelowForeground("setPermissionEnforcement");
                } catch (RemoteException e) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(token);
                    throw th;
                }
                Binder.restoreCallingIdentity(token);
                return;
            }
            return;
        }
        throw new IllegalArgumentException("No selective enforcement for " + permission);
    }

    @Deprecated
    public boolean isPermissionEnforced(String permission) {
        return true;
    }

    public boolean isStorageLow() {
        long token = Binder.clearCallingIdentity();
        try {
            DeviceStorageMonitorInternal dsm = (DeviceStorageMonitorInternal) LocalServices.getService(DeviceStorageMonitorInternal.class);
            if (dsm != null) {
                return dsm.isMemoryLow();
            }
            Binder.restoreCallingIdentity(token);
            return false;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public IPackageInstaller getPackageInstaller() {
        if (getInstantAppPackageName(Binder.getCallingUid()) != null) {
            return null;
        }
        return this.mInstallerService;
    }

    public IArtManager getArtManager() {
        return this.mArtManagerService;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private boolean userNeedsBadging(int userId) {
        boolean b;
        int index = this.mUserNeedsBadging.indexOfKey(userId);
        if (index >= 0) {
            return this.mUserNeedsBadging.valueAt(index);
        }
        long token = Binder.clearCallingIdentity();
        try {
            UserInfo userInfo = sUserManager.getUserInfo(userId);
            if (userInfo == null || !userInfo.isManagedProfile()) {
                b = false;
            } else {
                b = true;
            }
            this.mUserNeedsBadging.put(userId, b);
            return b;
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    public KeySet getKeySetByAlias(String packageName, String alias) {
        KeySet keySet;
        if (packageName == null || alias == null) {
            return null;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, Binder.getCallingUid(), UserHandle.getCallingUserId())) {
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getKeySetByAliasAndPackageNameLPr(packageName, alias));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public KeySet getSigningKeySet(String packageName) {
        KeySet keySet;
        if (packageName == null) {
            return null;
        }
        synchronized (this.mPackages) {
            int callingUid = Binder.getCallingUid();
            int callingUserId = UserHandle.getUserId(callingUid);
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            } else if (!filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, callingUserId)) {
                if (pkg.applicationInfo.uid != callingUid) {
                    if (1000 != callingUid) {
                        throw new SecurityException("May not access signing KeySet of other apps.");
                    }
                }
                keySet = new KeySet(this.mSettings.mKeySetManagerService.getSigningKeySetByPackageNameLPr(packageName));
            } else {
                Slog.w(TAG, "KeySet requested for filtered package: " + packageName + ", uid:" + callingUid);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
        }
        return keySet;
    }

    public boolean isPackageSignedByKeySet(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByLPr(packageName, (KeySetHandle) ksh);
        }
    }

    public boolean isPackageSignedByKeySetExactly(String packageName, KeySet ks) {
        int callingUid = Binder.getCallingUid();
        if (getInstantAppPackageName(callingUid) != null || packageName == null || ks == null) {
            return false;
        }
        synchronized (this.mPackages) {
            PackageParser.Package pkg = this.mPackages.get(packageName);
            if (pkg == null || filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, UserHandle.getUserId(callingUid))) {
                Slog.w(TAG, "KeySet requested for unknown package: " + packageName);
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            IBinder ksh = ks.getToken();
            if (!(ksh instanceof KeySetHandle)) {
                return false;
            }
            return this.mSettings.mKeySetManagerService.packageIsSignedByExactlyLPr(packageName, (KeySetHandle) ksh);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private void deletePackageIfUnusedLPr(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps != null && !ps.isAnyInstalled(sUserManager.getUserIds())) {
            this.mHandler.post(new Runnable(packageName) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$QuqawyC4sV3R6UrEMHfuJA735a0 */
                private final /* synthetic */ String f$1;

                {
                    this.f$1 = r2;
                }

                @Override // java.lang.Runnable
                public final void run() {
                    PackageManagerService.this.lambda$deletePackageIfUnusedLPr$40$PackageManagerService(this.f$1);
                }
            });
        }
    }

    public /* synthetic */ void lambda$deletePackageIfUnusedLPr$40$PackageManagerService(String packageName) {
        deletePackageX(packageName, -1, 0, 2);
    }

    /* access modifiers changed from: private */
    public static void checkDowngrade(PackageParser.Package before, PackageInfoLite after) throws PackageManagerException {
        if (after.getLongVersionCode() < before.getLongVersionCode()) {
            throw new PackageManagerException(-25, "Update version code " + after.versionCode + " is older than current " + before.getLongVersionCode());
        } else if (after.getLongVersionCode() == before.getLongVersionCode()) {
            if (after.baseRevisionCode < before.baseRevisionCode) {
                throw new PackageManagerException(-25, "Update base revision code " + after.baseRevisionCode + " is older than current " + before.baseRevisionCode);
            } else if (!ArrayUtils.isEmpty(after.splitNames)) {
                for (int i = 0; i < after.splitNames.length; i++) {
                    String splitName = after.splitNames[i];
                    int j = ArrayUtils.indexOf(before.splitNames, splitName);
                    if (j != -1) {
                        if (after.hasPlugin && after.splitVersionCodes[i] < before.splitVersionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " version code " + after.splitVersionCodes[i] + " is older than current " + before.splitVersionCodes[j]);
                        } else if (after.splitRevisionCodes[i] < before.splitRevisionCodes[j]) {
                            throw new PackageManagerException(-25, "Update split " + splitName + " revision code " + after.splitRevisionCodes[i] + " is older than current " + before.splitRevisionCodes[j]);
                        }
                    }
                }
            }
        }
    }

    /* access modifiers changed from: private */
    public static class MoveCallbacks extends Handler {
        private static final int MSG_CREATED = 1;
        private static final int MSG_STATUS_CHANGED = 2;
        private final RemoteCallbackList<IPackageMoveObserver> mCallbacks = new RemoteCallbackList<>();
        private final SparseIntArray mLastStatus = new SparseIntArray();

        public MoveCallbacks(Looper looper) {
            super(looper);
        }

        public void register(IPackageMoveObserver callback) {
            this.mCallbacks.register(callback);
        }

        public void unregister(IPackageMoveObserver callback) {
            this.mCallbacks.unregister(callback);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            SomeArgs args = (SomeArgs) msg.obj;
            int n = this.mCallbacks.beginBroadcast();
            for (int i = 0; i < n; i++) {
                try {
                    invokeCallback(this.mCallbacks.getBroadcastItem(i), msg.what, args);
                } catch (RemoteException e) {
                }
            }
            this.mCallbacks.finishBroadcast();
            args.recycle();
        }

        private void invokeCallback(IPackageMoveObserver callback, int what, SomeArgs args) throws RemoteException {
            if (what == 1) {
                callback.onCreated(args.argi1, (Bundle) args.arg2);
            } else if (what == 2) {
                callback.onStatusChanged(args.argi1, args.argi2, ((Long) args.arg3).longValue());
            }
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyCreated(int moveId, Bundle extras) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " created " + extras.toString());
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.arg2 = extras;
            obtainMessage(1, args).sendToTarget();
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyStatusChanged(int moveId, int status) {
            notifyStatusChanged(moveId, status, -1);
        }

        /* access modifiers changed from: private */
        /* access modifiers changed from: public */
        private void notifyStatusChanged(int moveId, int status, long estMillis) {
            Slog.v(PackageManagerService.TAG, "Move " + moveId + " status " + status);
            SomeArgs args = SomeArgs.obtain();
            args.argi1 = moveId;
            args.argi2 = status;
            args.arg3 = Long.valueOf(estMillis);
            obtainMessage(2, args).sendToTarget();
            synchronized (this.mLastStatus) {
                this.mLastStatus.put(moveId, status);
            }
        }
    }

    /* access modifiers changed from: private */
    public static final class OnPermissionChangeListeners extends Handler {
        private static final int MSG_ON_PERMISSIONS_CHANGED = 1;
        private final RemoteCallbackList<IOnPermissionsChangeListener> mPermissionListeners = new RemoteCallbackList<>();

        public OnPermissionChangeListeners(Looper looper) {
            super(looper);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                handleOnPermissionsChanged(msg.arg1);
            }
        }

        public void addListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.register(listener);
        }

        public void removeListenerLocked(IOnPermissionsChangeListener listener) {
            this.mPermissionListeners.unregister(listener);
        }

        public void onPermissionsChanged(int uid) {
            if (this.mPermissionListeners.getRegisteredCallbackCount() > 0) {
                obtainMessage(1, uid, 0).sendToTarget();
            }
        }

        private void handleOnPermissionsChanged(int uid) {
            int count = this.mPermissionListeners.beginBroadcast();
            for (int i = 0; i < count; i++) {
                try {
                    try {
                        this.mPermissionListeners.getBroadcastItem(i).onPermissionsChanged(uid);
                    } catch (RemoteException e) {
                        Log.e(PackageManagerService.TAG, "Permission listener is dead", e);
                    }
                } catch (Throwable th) {
                    this.mPermissionListeners.finishBroadcast();
                    throw th;
                }
            }
            this.mPermissionListeners.finishBroadcast();
        }
    }

    /* access modifiers changed from: private */
    public class PackageManagerNative extends IPackageManagerNative.Stub {
        private PackageManagerNative() {
        }

        public String[] getNamesForUids(int[] uids) throws RemoteException {
            String[] results = PackageManagerService.this.getNamesForUids(uids);
            for (int i = results.length - 1; i >= 0; i--) {
                if (results[i] == null) {
                    results[i] = "";
                }
            }
            return results;
        }

        public String getInstallerForPackage(String packageName) throws RemoteException {
            String installerName = PackageManagerService.this.getInstallerPackageName(packageName);
            if (!TextUtils.isEmpty(installerName)) {
                return installerName;
            }
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo == null || (appInfo.flags & 1) == 0) {
                return "";
            }
            return "preload";
        }

        public long getVersionCodeForPackage(String packageName) throws RemoteException {
            try {
                PackageInfo pInfo = PackageManagerService.this.getPackageInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
                if (pInfo != null) {
                    return pInfo.getLongVersionCode();
                }
                return 0;
            } catch (Exception e) {
                return 0;
            }
        }

        public int getTargetSdkVersionForPackage(String packageName) throws RemoteException {
            ApplicationInfo info = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (info != null) {
                return info.targetSdkVersion;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public boolean[] isAudioPlaybackCaptureAllowed(String[] packageNames) throws RemoteException {
            int callingUser = UserHandle.getUserId(Binder.getCallingUid());
            boolean[] results = new boolean[packageNames.length];
            for (int i = results.length - 1; i >= 0; i--) {
                boolean z = false;
                ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageNames[i], 0, callingUser);
                if (appInfo != null) {
                    z = appInfo.isAudioPlaybackCaptureAllowed();
                }
                results[i] = z;
            }
            return results;
        }

        public int getLocationFlags(String packageName) throws RemoteException {
            int i = 0;
            ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageName, 0, UserHandle.getUserId(Binder.getCallingUid()));
            if (appInfo != null) {
                int isSystemApp = appInfo.isSystemApp() | (appInfo.isVendor() ? 2 : 0);
                if (appInfo.isProduct()) {
                    i = 4;
                }
                return i | isSystemApp;
            }
            throw new RemoteException("Couldn't get ApplicationInfo for package " + packageName);
        }

        public String getModuleMetadataPackageName() throws RemoteException {
            return PackageManagerService.this.mModuleInfoProvider.getPackageName();
        }

        public boolean[] hasAllowAudioPlaybackCaptureConfig(String[] packageNames) throws RemoteException {
            if (packageNames == null) {
                Slog.i(PackageManagerService.TAG, "hasAllowAudioPlaybackCaptureConfig packageNames is null");
                return null;
            } else if (packageNames.length == 0) {
                Slog.i(PackageManagerService.TAG, "hasAllowAudioPlaybackCaptureConfig packageNames is empty");
                return new boolean[0];
            } else {
                int callingUser = UserHandle.getUserId(Binder.getCallingUid());
                boolean[] results = new boolean[packageNames.length];
                for (int i = results.length - 1; i >= 0; i--) {
                    ApplicationInfo appInfo = PackageManagerService.this.getApplicationInfo(packageNames[i], 0, callingUser);
                    results[i] = appInfo == null ? false : appInfo.hasAllowAudioPlaybackCaptureConfig();
                }
                return results;
            }
        }

        public String[] getPackagesForUid(int uid) throws RemoteException {
            return PackageManagerService.this.getPackagesForUid(uid);
        }
    }

    private class PackageManagerInternalImpl extends PackageManagerInternal {
        private PackageManagerInternalImpl() {
        }

        public void updatePermissionFlagsTEMP(String permName, String packageName, int flagMask, int flagValues, int userId) {
            PackageManagerService.this.updatePermissionFlags(permName, packageName, flagMask, flagValues, true, userId);
        }

        public List<ApplicationInfo> getInstalledApplications(int flags, int userId, int callingUid) {
            return PackageManagerService.this.getInstalledApplicationsListInternal(flags, userId, callingUid);
        }

        public boolean isPlatformSigned(String packageName) {
            PackageParser.Package pkg;
            PackageSetting packageSetting = PackageManagerService.this.mSettings.mPackages.get(packageName);
            if (packageSetting == null || (pkg = packageSetting.pkg) == null) {
                return false;
            }
            if (pkg.mSigningDetails.hasAncestorOrSelf(PackageManagerService.this.mPlatformPackage.mSigningDetails) || PackageManagerService.this.mPlatformPackage.mSigningDetails.checkCapability(pkg.mSigningDetails, 4)) {
                return true;
            }
            return false;
        }

        public boolean isDataRestoreSafe(byte[] restoringFromSigHash, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasSha256Certificate(restoringFromSigHash, 1);
        }

        public boolean isDataRestoreSafe(Signature restoringFromSig, String packageName) {
            PackageParser.SigningDetails sd = getSigningDetails(packageName);
            if (sd == null) {
                return false;
            }
            return sd.hasCertificate(restoringFromSig, 1);
        }

        public boolean hasSignatureCapability(int serverUid, int clientUid, @PackageParser.SigningDetails.CertCapabilities int capability) {
            PackageParser.SigningDetails serverSigningDetails = getSigningDetails(serverUid);
            PackageParser.SigningDetails clientSigningDetails = getSigningDetails(clientUid);
            return serverSigningDetails.checkCapability(clientSigningDetails, capability) || clientSigningDetails.hasAncestorOrSelf(serverSigningDetails);
        }

        private PackageParser.SigningDetails getSigningDetails(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package p = PackageManagerService.this.mPackages.get(packageName);
                if (p == null) {
                    return null;
                }
                return p.mSigningDetails;
            }
        }

        private PackageParser.SigningDetails getSigningDetails(int uid) {
            synchronized (PackageManagerService.this.mPackages) {
                Object obj = PackageManagerService.this.mSettings.getSettingLPr(UserHandle.getAppId(uid));
                if (obj != null) {
                    if (obj instanceof SharedUserSetting) {
                        return ((SharedUserSetting) obj).signatures.mSigningDetails;
                    } else if (obj instanceof PackageSetting) {
                        return ((PackageSetting) obj).signatures.mSigningDetails;
                    }
                }
                return PackageParser.SigningDetails.UNKNOWN;
            }
        }

        public int getPermissionFlagsTEMP(String permName, String packageName, int userId) {
            return PackageManagerService.this.getPermissionFlags(permName, packageName, userId);
        }

        public boolean isInstantApp(String packageName, int userId) {
            return PackageManagerService.this.isInstantApp(packageName, userId);
        }

        public String getInstantAppPackageName(int uid) {
            return PackageManagerService.this.getInstantAppPackageName(uid);
        }

        public boolean filterAppAccess(PackageParser.Package pkg, int callingUid, int userId) {
            boolean filterAppAccessLPr;
            synchronized (PackageManagerService.this.mPackages) {
                filterAppAccessLPr = PackageManagerService.this.filterAppAccessLPr((PackageSetting) pkg.mExtras, callingUid, userId);
            }
            return filterAppAccessLPr;
        }

        public PackageParser.Package getPackage(String packageName) {
            PackageParser.Package r1;
            synchronized (PackageManagerService.this.mPackages) {
                r1 = PackageManagerService.this.mPackages.get(PackageManagerService.this.resolveInternalPackageNameLPr(packageName, -1));
            }
            return r1;
        }

        public PackageList getPackageList(PackageManagerInternal.PackageListObserver observer) {
            PackageList packageList;
            synchronized (PackageManagerService.this.mPackages) {
                int N = PackageManagerService.this.mPackages.size();
                ArrayList<String> list = new ArrayList<>(N);
                for (int i = 0; i < N; i++) {
                    list.add(PackageManagerService.this.mPackages.keyAt(i));
                }
                packageList = new PackageList(list, observer);
                if (observer != null) {
                    PackageManagerService.this.mPackageListObservers.add(packageList);
                }
            }
            return packageList;
        }

        public void removePackageListObserver(PackageManagerInternal.PackageListObserver observer) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mPackageListObservers.remove(observer);
            }
        }

        public PackageParser.Package getDisabledSystemPackage(String packageName) {
            PackageParser.Package r2;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.getDisabledSystemPkgLPr(packageName);
                r2 = ps != null ? ps.pkg : null;
            }
            return r2;
        }

        public String getDisabledSystemPackageName(String packageName) {
            PackageParser.Package pkg = getDisabledSystemPackage(packageName);
            if (pkg == null) {
                return null;
            }
            return pkg.packageName;
        }

        public String getKnownPackageName(int knownPackage, int userId) {
            switch (knownPackage) {
                case 0:
                    return PackageManagerService.PLATFORM_PACKAGE_NAME;
                case 1:
                    return PackageManagerService.this.mSetupWizardPackage;
                case 2:
                    return PackageManagerService.this.mRequiredInstallerPackage;
                case 3:
                    return PackageManagerService.this.mRequiredVerifierPackage;
                case 4:
                    return PackageManagerService.this.getDefaultBrowserPackageName(userId);
                case 5:
                    return PackageManagerService.this.mSystemTextClassifierPackage;
                case 6:
                    return PackageManagerService.this.mRequiredPermissionControllerPackage;
                case 7:
                    return PackageManagerService.this.mWellbeingPackage;
                case 8:
                    return PackageManagerService.this.mDocumenterPackage;
                case 9:
                    return PackageManagerService.this.mConfiguratorPackage;
                case 10:
                    return PackageManagerService.this.mIncidentReportApproverPackage;
                case 11:
                    return PackageManagerService.this.mAppPredictionServicePackage;
                default:
                    return null;
            }
        }

        public boolean isResolveActivityComponent(ComponentInfo component) {
            return PackageManagerService.this.mResolveActivity.packageName.equals(component.packageName) && PackageManagerService.this.mResolveActivity.name.equals(component.name);
        }

        public void setLocationPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationPackagesProvider(provider);
        }

        public void setLocationExtraPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setLocationExtraPackagesProvider(provider);
        }

        public void setVoiceInteractionPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setVoiceInteractionPackagesProvider(provider);
        }

        public void setUseOpenWifiAppPackagesProvider(PackageManagerInternal.PackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setUseOpenWifiAppPackagesProvider(provider);
        }

        public void setSyncAdapterPackagesprovider(PackageManagerInternal.SyncAdapterPackagesProvider provider) {
            PackageManagerService.this.mDefaultPermissionPolicy.setSyncAdapterPackagesProvider(provider);
        }

        public void grantDefaultPermissionsToDefaultUseOpenWifiApp(String packageName, int userId) {
            PackageManagerService.this.mDefaultPermissionPolicy.grantDefaultPermissionsToDefaultUseOpenWifiApp(packageName, userId);
        }

        public void setKeepUninstalledPackages(List<String> packageList) {
            Preconditions.checkNotNull(packageList);
            List<String> removedFromList = null;
            synchronized (PackageManagerService.this.mPackages) {
                if (PackageManagerService.this.mKeepUninstalledPackages != null) {
                    int packagesCount = PackageManagerService.this.mKeepUninstalledPackages.size();
                    for (int i = 0; i < packagesCount; i++) {
                        String oldPackage = (String) PackageManagerService.this.mKeepUninstalledPackages.get(i);
                        if (packageList == null || !packageList.contains(oldPackage)) {
                            if (removedFromList == null) {
                                removedFromList = new ArrayList<>();
                            }
                            removedFromList.add(oldPackage);
                        }
                    }
                }
                PackageManagerService.this.mKeepUninstalledPackages = new ArrayList(packageList);
                if (removedFromList != null) {
                    int removedCount = removedFromList.size();
                    for (int i2 = 0; i2 < removedCount; i2++) {
                        PackageManagerService.this.deletePackageIfUnusedLPr(removedFromList.get(i2));
                    }
                }
            }
        }

        public boolean isPermissionsReviewRequired(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mPermissionManager.isPermissionsReviewRequired(pkg, userId);
            }
        }

        public PackageInfo getPackageInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getPackageInfoInternal(packageName, -1, flags, filterCallingUid, userId);
        }

        public Bundle getSuspendedPackageLauncherExtras(String packageName, int userId) {
            Bundle bundle;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                PersistableBundle launcherExtras = null;
                if (ps != null) {
                    launcherExtras = ps.readUserState(userId).suspendedLauncherExtras;
                }
                bundle = launcherExtras != null ? new Bundle(launcherExtras.deepCopy()) : null;
            }
            return bundle;
        }

        public boolean isPackageSuspended(String packageName, int userId) {
            boolean suspended;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                suspended = ps != null ? ps.getSuspended(userId) : false;
            }
            return suspended;
        }

        public String getSuspendingPackage(String suspendedPackage, int userId) {
            String str;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                str = ps != null ? ps.readUserState(userId).suspendingPackage : null;
            }
            return str;
        }

        public SuspendDialogInfo getSuspendedDialogInfo(String suspendedPackage, int userId) {
            SuspendDialogInfo suspendDialogInfo;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(suspendedPackage);
                suspendDialogInfo = ps != null ? ps.readUserState(userId).dialogInfo : null;
            }
            return suspendDialogInfo;
        }

        public int getDistractingPackageRestrictions(String packageName, int userId) {
            int distractionFlags;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                distractionFlags = ps != null ? ps.getDistractionFlags(userId) : 0;
            }
            return distractionFlags;
        }

        public int getPackageUid(String packageName, int flags, int userId) {
            return PackageManagerService.this.getPackageUid(packageName, flags, userId);
        }

        public ApplicationInfo getApplicationInfo(String packageName, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getApplicationInfoInternal(packageName, flags, filterCallingUid, userId);
        }

        public ActivityInfo getActivityInfo(ComponentName component, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.getActivityInfoInternal(component, flags, filterCallingUid, userId);
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, int flags, int filterCallingUid, int userId) {
            String resolvedType = intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver());
            List<ResolveInfo> result = PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, false, true);
            PackageManagerService.mHwPMSEx.filterResolveInfo(intent, resolvedType, result);
            return result;
        }

        public List<ResolveInfo> queryIntentActivities(Intent intent, String resolvedType, int flags, int filterCallingUid, int userId) {
            return PackageManagerService.this.queryIntentActivitiesInternal(intent, resolvedType, flags, filterCallingUid, userId, false, true);
        }

        public List<ResolveInfo> queryIntentServices(Intent intent, int flags, int callingUid, int userId) {
            return PackageManagerService.this.queryIntentServicesInternal(intent, intent.resolveTypeIfNeeded(PackageManagerService.this.mContext.getContentResolver()), flags, userId, callingUid, false);
        }

        public ComponentName getHomeActivitiesAsUser(List<ResolveInfo> allHomeCandidates, int userId) {
            return PackageManagerService.this.getHomeActivitiesAsUser(allHomeCandidates, userId);
        }

        public ComponentName getDefaultHomeActivity(int userId) {
            return PackageManagerService.this.getDefaultHomeActivity(userId);
        }

        public void setDeviceAndProfileOwnerPackages(int deviceOwnerUserId, String deviceOwnerPackage, SparseArray<String> profileOwnerPackages) {
            PackageManagerService.this.mProtectedPackages.setDeviceAndProfileOwnerPackages(deviceOwnerUserId, deviceOwnerPackage, profileOwnerPackages);
            ArraySet<Integer> usersWithPoOrDo = new ArraySet<>();
            if (deviceOwnerPackage != null) {
                usersWithPoOrDo.add(Integer.valueOf(deviceOwnerUserId));
            }
            int sz = profileOwnerPackages.size();
            for (int i = 0; i < sz; i++) {
                if (profileOwnerPackages.valueAt(i) != null) {
                    usersWithPoOrDo.add(Integer.valueOf(profileOwnerPackages.keyAt(i)));
                }
            }
            PackageManagerService.this.unsuspendForNonSystemSuspendingPackages(usersWithPoOrDo);
        }

        public boolean isPackageDataProtected(int userId, String packageName) {
            return PackageManagerService.this.mProtectedPackages.isPackageDataProtected(userId, packageName);
        }

        public boolean isPackageStateProtected(String packageName, int userId) {
            return PackageManagerService.this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }

        public boolean isPackageEphemeral(int userId, String packageName) {
            boolean instantApp;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
                instantApp = ps != null ? ps.getInstantApp(userId) : false;
            }
            return instantApp;
        }

        public boolean wasPackageEverLaunched(String packageName, int userId) {
            boolean wasPackageEverLaunchedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                wasPackageEverLaunchedLPr = PackageManagerService.this.mSettings.wasPackageEverLaunchedLPr(packageName, userId);
            }
            return wasPackageEverLaunchedLPr;
        }

        public boolean isEnabledAndMatches(ComponentInfo info, int flags, int userId) {
            boolean isEnabledAndMatchLPr;
            synchronized (PackageManagerService.this.mPackages) {
                isEnabledAndMatchLPr = PackageManagerService.this.mSettings.isEnabledAndMatchLPr(info, flags, userId);
            }
            return isEnabledAndMatchLPr;
        }

        public boolean userNeedsBadging(int userId) {
            boolean userNeedsBadging;
            synchronized (PackageManagerService.this.mPackages) {
                userNeedsBadging = PackageManagerService.this.userNeedsBadging(userId);
            }
            return userNeedsBadging;
        }

        public void grantRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.grantRuntimePermission(permName, packageName, overridePolicy, Binder.getCallingUid(), userId, PackageManagerService.this.mPermissionCallback);
        }

        public void revokeRuntimePermission(String packageName, String permName, int userId, boolean overridePolicy) {
            PackageManagerService.this.mPermissionManager.revokeRuntimePermission(permName, packageName, overridePolicy, userId, PackageManagerService.this.mPermissionCallback);
        }

        public String getNameForUid(int uid) {
            return PackageManagerService.this.getNameForUid(uid);
        }

        public void requestInstantAppResolutionPhaseTwo(AuxiliaryResolveInfo responseObj, Intent origIntent, String resolvedType, String callingPackage, Bundle verificationBundle, int userId) {
            PackageManagerService.this.requestInstantAppResolutionPhaseTwo(responseObj, origIntent, resolvedType, callingPackage, verificationBundle, userId);
        }

        public void grantEphemeralAccess(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mInstantAppRegistry.grantInstantAccessLPw(userId, intent, targetAppId, ephemeralAppId);
            }
        }

        public boolean isInstantAppInstallerComponent(ComponentName component) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                z = PackageManagerService.this.mInstantAppInstallerActivity != null && PackageManagerService.this.mInstantAppInstallerActivity.getComponentName().equals(component);
            }
            return z;
        }

        public void pruneInstantApps() {
            PackageManagerService.this.mInstantAppRegistry.pruneInstantApps();
        }

        public String getSetupWizardPackageName() {
            return PackageManagerService.this.mSetupWizardPackage;
        }

        public void setExternalSourcesPolicy(PackageManagerInternal.ExternalSourcesPolicy policy) {
            if (policy != null) {
                PackageManagerService.this.mExternalSourcesPolicy = policy;
            }
        }

        public boolean isPackagePersistent(String packageName) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                z = false;
                if (pkg != null && (pkg.applicationInfo.flags & 9) == 9) {
                    z = true;
                }
            }
            return z;
        }

        public boolean isLegacySystemApp(PackageParser.Package pkg) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = (PackageSetting) pkg.mExtras;
                z = PackageManagerService.this.mPromoteSystemApps && ps.isSystem() && PackageManagerService.this.mExistingSystemPackages.contains(ps.name);
            }
            return z;
        }

        public List<PackageInfo> getOverlayPackages(int userId) {
            PackageInfo pkg;
            ArrayList<PackageInfo> overlayPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (!(p.mOverlayTarget == null || (pkg = PackageManagerService.this.generatePackageInfo((PackageSetting) p.mExtras, 0, userId)) == null)) {
                        overlayPackages.add(pkg);
                    }
                }
            }
            return overlayPackages;
        }

        public List<String> getTargetPackageNames(int userId) {
            List<String> targetPackages = new ArrayList<>();
            synchronized (PackageManagerService.this.mPackages) {
                for (PackageParser.Package p : PackageManagerService.this.mPackages.values()) {
                    if (p.mOverlayTarget == null) {
                        targetPackages.add(p.packageName);
                    }
                }
            }
            return targetPackages;
        }

        public boolean setEnabledOverlayPackages(int userId, String targetPackageName, List<String> overlayPackageNames) {
            synchronized (PackageManagerService.this.mPackages) {
                if (targetPackageName != null) {
                    if (PackageManagerService.this.mPackages.get(targetPackageName) != null) {
                        ArrayList<String> overlayPaths = null;
                        if (overlayPackageNames != null && overlayPackageNames.size() > 0) {
                            int N = overlayPackageNames.size();
                            overlayPaths = new ArrayList<>(N);
                            for (int i = 0; i < N; i++) {
                                String packageName = overlayPackageNames.get(i);
                                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                                if (pkg == null) {
                                    Slog.e(PackageManagerService.TAG, "failed to find package " + packageName);
                                    return false;
                                }
                                overlayPaths.add(pkg.baseCodePath);
                            }
                        }
                        PackageManagerService.this.mSettings.mPackages.get(targetPackageName).setOverlayPaths(overlayPaths, userId);
                        return true;
                    }
                }
                Slog.e(PackageManagerService.TAG, "failed to find package " + targetPackageName);
                return false;
            }
        }

        public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId, boolean resolveForStart, int filterCallingUid) {
            return PackageManagerService.this.resolveIntentInternal(intent, resolvedType, flags, userId, resolveForStart, filterCallingUid);
        }

        public ResolveInfo resolveService(Intent intent, String resolvedType, int flags, int userId, int callingUid) {
            return PackageManagerService.this.resolveServiceInternal(intent, resolvedType, flags, userId, callingUid);
        }

        public ProviderInfo resolveContentProvider(String name, int flags, int userId) {
            return PackageManagerService.this.resolveContentProviderInternal(name, flags, userId);
        }

        public void addIsolatedUid(int isolatedUid, int ownerUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.put(isolatedUid, ownerUid);
            }
        }

        public void removeIsolatedUid(int isolatedUid) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mIsolatedOwners.delete(isolatedUid);
            }
        }

        public boolean isInMWPortraitWhiteList(String packageName) {
            return PackageManagerService.mHwPMSEx.isInMWPortraitWhiteList(packageName);
        }

        public int getUidTargetSdkVersion(int uid) {
            int uidTargetSdkVersionLockedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                uidTargetSdkVersionLockedLPr = PackageManagerService.this.getUidTargetSdkVersionLockedLPr(uid);
            }
            return uidTargetSdkVersionLockedLPr;
        }

        public int getPackageTargetSdkVersion(String packageName) {
            int packageTargetSdkVersionLockedLPr;
            synchronized (PackageManagerService.this.mPackages) {
                packageTargetSdkVersionLockedLPr = PackageManagerService.this.getPackageTargetSdkVersionLockedLPr(packageName);
            }
            return packageTargetSdkVersionLockedLPr;
        }

        public boolean canAccessInstantApps(int callingUid, int userId) {
            return PackageManagerService.this.canViewInstantApps(callingUid, userId);
        }

        public boolean canAccessComponent(int callingUid, ComponentName component, int userId) {
            boolean z;
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting ps = PackageManagerService.this.mSettings.mPackages.get(component.getPackageName());
                z = ps != null && !PackageManagerService.this.filterAppAccessLPr(ps, callingUid, component, 0, userId);
            }
            return z;
        }

        public boolean hasInstantApplicationMetadata(String packageName, int userId) {
            boolean hasInstantApplicationMetadataLPr;
            synchronized (PackageManagerService.this.mPackages) {
                hasInstantApplicationMetadataLPr = PackageManagerService.this.mInstantAppRegistry.hasInstantApplicationMetadataLPr(packageName, userId);
            }
            return hasInstantApplicationMetadataLPr;
        }

        public void notifyPackageUse(String packageName, int reason) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.notifyPackageUseLocked(packageName, reason);
            }
        }

        public PackageManagerInternal.CheckPermissionDelegate getCheckPermissionDelegate() {
            PackageManagerInternal.CheckPermissionDelegate checkPermissionDelegateLocked;
            synchronized (PackageManagerService.this.mPackages) {
                checkPermissionDelegateLocked = PackageManagerService.this.getCheckPermissionDelegateLocked();
            }
            return checkPermissionDelegateLocked;
        }

        public void setCheckPermissionDelegate(PackageManagerInternal.CheckPermissionDelegate delegate) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.setCheckPermissionDelegateLocked(delegate);
            }
        }

        public SparseArray<String> getAppsWithSharedUserIds() {
            SparseArray<String> appsWithSharedUserIdsLocked;
            synchronized (PackageManagerService.this.mPackages) {
                appsWithSharedUserIdsLocked = PackageManagerService.this.getAppsWithSharedUserIdsLocked();
            }
            return appsWithSharedUserIdsLocked;
        }

        public String getSharedUserIdForPackage(String packageName) {
            String sharedUserIdForPackageLocked;
            synchronized (PackageManagerService.this.mPackages) {
                sharedUserIdForPackageLocked = PackageManagerService.this.getSharedUserIdForPackageLocked(packageName);
            }
            return sharedUserIdForPackageLocked;
        }

        public String[] getPackagesForSharedUserId(String sharedUserId, int userId) {
            String[] packagesForSharedUserIdLocked;
            synchronized (PackageManagerService.this.mPackages) {
                packagesForSharedUserIdLocked = PackageManagerService.this.getPackagesForSharedUserIdLocked(sharedUserId, userId);
            }
            return packagesForSharedUserIdLocked;
        }

        public boolean isOnlyCoreApps() {
            return PackageManagerService.this.isOnlyCoreApps();
        }

        public void freeStorage(String volumeUuid, long bytes, int storageFlags) throws IOException {
            PackageManagerService.this.freeStorage(volumeUuid, bytes, storageFlags);
        }

        public float getUserAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public void checkPackageStartable(String packageName, int userId) {
            PackageManagerService.this.checkPackageStartable(packageName, userId);
        }

        public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
            return PackageManagerService.this.getHwCertPermission(allowed, pkg, perm);
        }

        public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) {
            PackageManagerService.mHwPMSEx.installPackageAsUser(originPath, observer, installFlags, installerPackageName, userId);
        }

        public boolean isUpgrade() {
            return PackageManagerService.this.isUpgrade();
        }

        public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
            PackageManagerService.this.forEachPackage(actionLocked);
        }

        public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
            PackageManagerService.this.forEachInstalledPackage(actionLocked, userId);
        }

        public ArraySet<String> getEnabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getEnabledComponents(userId);
            }
        }

        public ArraySet<String> getDisabledComponents(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return new ArraySet<>();
                }
                return setting.getDisabledComponents(userId);
            }
        }

        public int getApplicationEnabledState(String packageName, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageSetting setting = PackageManagerService.this.mSettings.getPackageLPr(packageName);
                if (setting == null) {
                    return 0;
                }
                return setting.getEnabled(userId);
            }
        }

        public void setEnableRollbackCode(int token, int enableRollbackCode) {
            PackageManagerService.this.setEnableRollbackCode(token, enableRollbackCode);
        }

        public boolean compileLayouts(String packageName) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageParser.Package pkg = PackageManagerService.this.mPackages.get(packageName);
                if (pkg == null) {
                    return false;
                }
                return PackageManagerService.this.mArtManagerService.compileLayouts(pkg);
            }
        }

        public void finishPackageInstall(int token, boolean didLaunch) {
            PackageManagerService.this.finishPackageInstall(token, didLaunch);
        }

        public String removeLegacyDefaultBrowserPackageName(int userId) {
            String removeDefaultBrowserPackageNameLPw;
            synchronized (PackageManagerService.this.mPackages) {
                removeDefaultBrowserPackageNameLPw = PackageManagerService.this.mSettings.removeDefaultBrowserPackageNameLPw(userId);
            }
            return removeDefaultBrowserPackageNameLPw;
        }

        public void setDefaultBrowserProvider(PackageManagerInternal.DefaultBrowserProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultBrowserProvider = provider;
            }
        }

        public void setDefaultDialerProvider(PackageManagerInternal.DefaultDialerProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultDialerProvider = provider;
            }
        }

        public void setDefaultHomeProvider(PackageManagerInternal.DefaultHomeProvider provider) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mDefaultHomeProvider = provider;
            }
        }

        public boolean isNeedForbidAppAct(String packageName) {
            if (TextUtils.isEmpty(packageName)) {
                return false;
            }
            return PackageManagerService.this.getHwPMSEx().isNeedForbidAppAct(PackageManagerService.PACKAGE_FORBIDDEN, packageName, null, null);
        }

        public boolean isApexPackage(String packageName) {
            return PackageManagerService.this.mApexManager.isApexPackage(packageName);
        }

        public void uninstallApex(String packageName, long versionCode, int userId, IntentSender intentSender) {
            int callerUid = Binder.getCallingUid();
            if (callerUid == 0 || callerUid == 2000) {
                PackageInstallerService.PackageDeleteObserverAdapter adapter = new PackageInstallerService.PackageDeleteObserverAdapter(PackageManagerService.this.mContext, intentSender, packageName, false, userId);
                if (userId != -1) {
                    adapter.onPackageDeleted(packageName, -5, "Can't uninstall an apex for a single user");
                    return;
                }
                ApexManager am = PackageManagerService.this.mApexManager;
                PackageInfo activePackage = am.getPackageInfo(packageName, 1);
                if (activePackage == null) {
                    adapter.onPackageDeleted(packageName, -5, packageName + " is not an apex package");
                } else if (versionCode != -1 && activePackage.getLongVersionCode() != versionCode) {
                    adapter.onPackageDeleted(packageName, -5, "Active version " + activePackage.getLongVersionCode() + " is not equal to " + versionCode + "]");
                } else if (!am.uninstallApex(activePackage.applicationInfo.sourceDir)) {
                    adapter.onPackageDeleted(packageName, -5, "Failed to uninstall apex " + packageName);
                } else {
                    adapter.onPackageDeleted(packageName, 1, null);
                }
            } else {
                throw new SecurityException("Not allowed to uninstall apexes");
            }
        }

        public boolean wereDefaultPermissionsGrantedSinceBoot(int userId) {
            boolean wereDefaultPermissionsGrantedSinceBoot;
            synchronized (PackageManagerService.this.mPackages) {
                wereDefaultPermissionsGrantedSinceBoot = PackageManagerService.this.mDefaultPermissionPolicy.wereDefaultPermissionsGrantedSinceBoot(userId);
            }
            return wereDefaultPermissionsGrantedSinceBoot;
        }

        public void setRuntimePermissionsFingerPrint(String fingerPrint, int userId) {
            synchronized (PackageManagerService.this.mPackages) {
                PackageManagerService.this.mSettings.setRuntimePermissionsFingerPrintLPr(fingerPrint, userId);
            }
        }

        public void migrateLegacyObbData() {
            new Thread(new Runnable() {
                /* class com.android.server.pm.PackageManagerService.PackageManagerInternalImpl.AnonymousClass1 */

                @Override // java.lang.Runnable
                public void run() {
                    try {
                        PackageManagerService.this.mInstaller.migrateLegacyObbData();
                    } catch (Exception e) {
                        Slog.wtf(PackageManagerService.TAG, e);
                    }
                }
            }).start();
        }

        public boolean isSystemAppGrantByMdmAndNonPreload(String pkgName) {
            PackageSetting pkgSetting;
            if (TextUtils.isEmpty(pkgName) || (pkgSetting = PackageManagerService.this.mSettings.mPackages.get(pkgName)) == null) {
                return false;
            }
            PackageManagerService packageManagerService = PackageManagerService.this;
            return PackageManagerService.isSystemAppGrantByMdmAndNonPreload(pkgSetting.name, pkgSetting.codePathString, pkgSetting.volumeUuid);
        }

        public void adjustDisplayMetricsInRog() {
            PackageManagerService.getDefaultDisplayMetrics(PackageManagerService.this.mContext, PackageManagerService.this.mMetrics);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private SparseArray<String> getAppsWithSharedUserIdsLocked() {
        SparseArray<String> sharedUserIds = new SparseArray<>();
        synchronized (this.mPackages) {
            for (SharedUserSetting setting : this.mSettings.getAllSharedUsersLPw()) {
                sharedUserIds.put(UserHandle.getAppId(setting.userId), setting.name);
            }
        }
        return sharedUserIds;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String getSharedUserIdForPackageLocked(String packageName) {
        PackageSetting ps = this.mSettings.mPackages.get(packageName);
        if (ps == null || !ps.isSharedUser()) {
            return null;
        }
        return ps.sharedUser.name;
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    @GuardedBy({"mPackages"})
    private String[] getPackagesForSharedUserIdLocked(String sharedUserId, int userId) {
        try {
            int i = 0;
            SharedUserSetting sus = this.mSettings.getSharedUserLPw(sharedUserId, 0, 0, false);
            if (sus == null) {
                return EmptyArray.STRING;
            }
            String[] res = new String[sus.packages.size()];
            Iterator<PackageSetting> it = sus.packages.iterator();
            while (it.hasNext()) {
                PackageSetting ps = it.next();
                if (ps.getInstalled(userId)) {
                    res[i] = ps.name;
                    i++;
                } else {
                    res = (String[]) ArrayUtils.removeElement(String.class, res, res[i]);
                }
            }
            return res;
        } catch (PackageManagerException e) {
            return EmptyArray.STRING;
        }
    }

    public int getRuntimePermissionsVersion(int userId) {
        int defaultRuntimePermissionsVersionLPr;
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            defaultRuntimePermissionsVersionLPr = this.mSettings.getDefaultRuntimePermissionsVersionLPr(userId);
        }
        return defaultRuntimePermissionsVersionLPr;
    }

    public void setRuntimePermissionsVersion(int version, int userId) {
        Preconditions.checkArgumentNonnegative(version);
        Preconditions.checkArgumentNonnegative(userId);
        this.mContext.enforceCallingOrSelfPermission("android.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY", "setRuntimePermissionVersion");
        synchronized (this.mPackages) {
            this.mSettings.setDefaultRuntimePermissionsVersionLPr(version, userId);
        }
    }

    public void grantDefaultPermissionsToEnabledCarrierApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantPermissionsToEnabledCarrierApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledCarrierApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledImsServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledImsServices");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledImsServices(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void grantDefaultPermissionsToEnabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToEnabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$XSGe1ELf4qdPFVPoRn9qdzOcOk */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$41$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$grantDefaultPermissionsToEnabledTelephonyDataServices$41$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.grantDefaultPermissionsToEnabledTelephonyDataServices(packageNames, userId);
    }

    public void revokeDefaultPermissionsFromDisabledTelephonyDataServices(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromDisabledTelephonyDataServices");
        synchronized (this.mPackages) {
            Binder.withCleanCallingIdentity(new FunctionalUtils.ThrowingRunnable(packageNames, userId) {
                /* class com.android.server.pm.$$Lambda$PackageManagerService$px9UdrSea0vD2hMqurDgycjMnM */
                private final /* synthetic */ String[] f$1;
                private final /* synthetic */ int f$2;

                {
                    this.f$1 = r2;
                    this.f$2 = r3;
                }

                public final void runOrThrow() {
                    PackageManagerService.this.lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$42$PackageManagerService(this.f$1, this.f$2);
                }
            });
        }
    }

    public /* synthetic */ void lambda$revokeDefaultPermissionsFromDisabledTelephonyDataServices$42$PackageManagerService(String[] packageNames, int userId) throws Exception {
        this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromDisabledTelephonyDataServices(packageNames, userId);
    }

    public void grantDefaultPermissionsToActiveLuiApp(String packageName, int userId) {
        enforceSystemOrPhoneCaller("grantDefaultPermissionsToActiveLuiApp");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.grantDefaultPermissionsToActiveLuiApp(packageName, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    public void revokeDefaultPermissionsFromLuiApps(String[] packageNames, int userId) {
        enforceSystemOrPhoneCaller("revokeDefaultPermissionsFromLuiApps");
        synchronized (this.mPackages) {
            long identity = Binder.clearCallingIdentity();
            try {
                this.mDefaultPermissionPolicy.revokeDefaultPermissionsFromLuiApps(packageNames, userId);
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachPackage(Consumer<PackageParser.Package> actionLocked) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                actionLocked.accept(this.mPackages.valueAt(i));
            }
        }
    }

    /* access modifiers changed from: package-private */
    public void forEachInstalledPackage(Consumer<PackageParser.Package> actionLocked, int userId) {
        synchronized (this.mPackages) {
            int numPackages = this.mPackages.size();
            for (int i = 0; i < numPackages; i++) {
                PackageParser.Package pkg = this.mPackages.valueAt(i);
                PackageSetting setting = this.mSettings.getPackageLPr(pkg.packageName);
                if (setting != null) {
                    if (setting.getInstalled(userId)) {
                        actionLocked.accept(pkg);
                    }
                }
            }
        }
    }

    private static void enforceSystemOrPhoneCaller(String tag) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 1001 && callingUid != 1000) {
            throw new SecurityException("Cannot call " + tag + " from UID " + callingUid);
        }
    }

    /* access modifiers changed from: package-private */
    public boolean isHistoricalPackageUsageAvailable() {
        return this.mPackageUsage.isHistoricalPackageUsageAvailable();
    }

    /* access modifiers changed from: package-private */
    public Collection<PackageParser.Package> getPackages() {
        ArrayList arrayList;
        synchronized (this.mPackages) {
            arrayList = new ArrayList(this.mPackages.values());
        }
        return arrayList;
    }

    public void logAppProcessStartIfNeeded(String processName, int uid, String seinfo, String apkFile, int pid) {
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && SecurityLog.isLoggingEnabled()) {
            Bundle data = new Bundle();
            data.putLong("startTimestamp", System.currentTimeMillis());
            data.putString("processName", processName);
            data.putInt(WatchlistLoggingHandler.WatchlistEventKeys.UID, uid);
            data.putString("seinfo", seinfo);
            data.putString("apkFile", apkFile);
            data.putInt("pid", pid);
            Message msg = this.mProcessLoggingHandler.obtainMessage(1);
            msg.setData(data);
            this.mProcessLoggingHandler.sendMessage(msg);
        }
    }

    public CompilerStats.PackageStats getCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getPackageStats(pkgName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(PackageParser.Package pkg) {
        return getOrCreateCompilerPackageStats(pkg.packageName);
    }

    public CompilerStats.PackageStats getOrCreateCompilerPackageStats(String pkgName) {
        return this.mCompilerStats.getOrCreatePackageStats(pkgName);
    }

    public void deleteCompilerPackageStats(String pkgName) {
        this.mCompilerStats.deletePackageStats(pkgName);
    }

    public int getInstallReason(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, false, "get install reason");
        synchronized (this.mPackages) {
            PackageSetting ps = this.mSettings.mPackages.get(packageName);
            if (filterAppAccessLPr(ps, callingUid, userId)) {
                return 0;
            }
            if (ps == null) {
                return 0;
            }
            if (isSystemAppGrantByMdmAndNonPreload(ps.name, ps.codePathString, ps.volumeUuid)) {
                return 9;
            }
            return ps.getInstallReason(userId);
        }
    }

    public boolean canRequestPackageInstalls(String packageName, int userId) {
        return canRequestPackageInstallsInternal(packageName, 0, userId, true);
    }

    private boolean canRequestPackageInstallsInternal(String packageName, int flags, int userId, boolean throwIfPermNotDeclared) {
        PackageManagerInternal.ExternalSourcesPolicy externalSourcesPolicy;
        int callingUid = Binder.getCallingUid();
        int uid = getPackageUid(packageName, 0, userId);
        if (callingUid == uid || callingUid == 0 || callingUid == 1000) {
            ApplicationInfo info = getApplicationInfo(packageName, flags, userId);
            if (info == null || info.targetSdkVersion < 26 || isInstantApp(packageName, userId)) {
                return false;
            }
            if (!ArrayUtils.contains(getAppOpPermissionPackages("android.permission.REQUEST_INSTALL_PACKAGES"), packageName)) {
                if (!throwIfPermNotDeclared) {
                    Slog.e(TAG, "Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api");
                    return false;
                }
                throw new SecurityException("Need to declare android.permission.REQUEST_INSTALL_PACKAGES to call this api");
            } else if (sUserManager.hasUserRestriction("no_install_unknown_sources", userId) || sUserManager.hasUserRestriction("no_install_unknown_sources_globally", userId) || (externalSourcesPolicy = this.mExternalSourcesPolicy) == null || externalSourcesPolicy.getPackageTrustedToInstallApps(packageName, uid) != 0) {
                return false;
            } else {
                return true;
            }
        } else {
            throw new SecurityException("Caller uid " + callingUid + " does not own package " + packageName);
        }
    }

    /* access modifiers changed from: private */
    /* access modifiers changed from: public */
    private void parseInstalledPkgInfo(InstallArgs args, PackageInstalledInfo res) {
        StringBuilder pkgPath = new StringBuilder(100);
        int pkgInstallResult = 0;
        int pkgVersionCode = 0;
        String pkgVersionName = "";
        String pkgName = "";
        boolean pkgUpdate = false;
        if (!(args == null || args.origin == null || args.origin.file == null)) {
            pkgPath.append(args.origin.file.toString());
            pkgPath.append(";");
        }
        if (!(args == null || args.installerPackageName == null)) {
            pkgPath.append(args.installerPackageName);
        }
        if (res != null) {
            pkgInstallResult = res.returnCode;
            if (res.pkg != null) {
                pkgVersionCode = res.pkg.mVersionCode;
                pkgVersionName = res.pkg.mVersionName;
                if (res.pkg.applicationInfo != null) {
                    pkgName = res.pkg.applicationInfo.packageName;
                }
            }
            if (res.removedInfo != null) {
                pkgUpdate = res.removedInfo.removedPackage != null;
            }
        }
        mHwPMSEx.parseInstalledPkgInfo(pkgPath.toString(), pkgName, pkgVersionName, pkgVersionCode, pkgInstallResult, pkgUpdate);
    }

    public static String getCallingAppName(Context context, PackageParser.Package pkg) {
        PackageManager pm = context.getPackageManager();
        String displayName = pkg.packageName;
        if (pm != null) {
            return String.valueOf(pm.getApplicationLabel(pkg.applicationInfo));
        }
        return displayName;
    }

    public ComponentName getInstantAppResolverSettingsComponent() {
        return this.mInstantAppResolverSettingsComponent;
    }

    public ComponentName getInstantAppInstallerComponent() {
        ActivityInfo activityInfo;
        if (getInstantAppPackageName(Binder.getCallingUid()) == null && (activityInfo = this.mInstantAppInstallerActivity) != null) {
            return activityInfo.getComponentName();
        }
        return null;
    }

    public String getInstantAppAndroidId(String packageName, int userId) {
        String instantAppAndroidIdLPw;
        this.mContext.enforceCallingOrSelfPermission("android.permission.ACCESS_INSTANT_APPS", "getInstantAppAndroidId");
        this.mPermissionManager.enforceCrossUserPermission(Binder.getCallingUid(), userId, true, false, "getInstantAppAndroidId");
        if (!isInstantApp(packageName, userId)) {
            return null;
        }
        synchronized (this.mPackages) {
            instantAppAndroidIdLPw = this.mInstantAppRegistry.getInstantAppAndroidIdLPw(packageName, userId);
        }
        return instantAppAndroidIdLPw;
    }

    /* access modifiers changed from: package-private */
    public boolean canHaveOatDir(String packageName) {
        synchronized (this.mPackages) {
            PackageParser.Package p = this.mPackages.get(packageName);
            if (p == null) {
                return false;
            }
            return p.canHaveOatDir();
        }
    }

    private String getOatDir(PackageParser.Package pkg) {
        if (!pkg.canHaveOatDir()) {
            return null;
        }
        File codePath = new File(pkg.codePath);
        if (codePath.isDirectory()) {
            return PackageDexOptimizer.getOatDir(codePath).getAbsolutePath();
        }
        return null;
    }

    /* access modifiers changed from: package-private */
    public void deleteOatArtifactsOfPackage(String packageName) {
        PackageParser.Package pkg;
        synchronized (this.mPackages) {
            pkg = this.mPackages.get(packageName);
        }
        String[] instructionSets = InstructionSets.getAppDexInstructionSets(pkg.applicationInfo);
        List<String> codePaths = pkg.getAllCodePaths();
        String oatDir = getOatDir(pkg);
        for (String codePath : codePaths) {
            for (String isa : instructionSets) {
                try {
                    this.mInstaller.deleteOdex(codePath, isa, oatDir);
                } catch (Installer.InstallerException e) {
                    Log.e(TAG, "Failed deleting oat files for " + codePath, e);
                }
            }
        }
    }

    /* access modifiers changed from: package-private */
    public Set<String> getUnusedPackages(long downgradeTimeThresholdMillis) {
        ArrayMap<String, PackageParser.Package> arrayMap;
        Set<String> unusedPackages = new HashSet<>();
        long currentTimeInMillis = System.currentTimeMillis();
        ArrayMap<String, PackageParser.Package> arrayMap2 = this.mPackages;
        synchronized (arrayMap2) {
            try {
                Iterator<PackageParser.Package> it = this.mPackages.values().iterator();
                while (it.hasNext()) {
                    PackageParser.Package pkg = it.next();
                    PackageSetting ps = this.mSettings.mPackages.get(pkg.packageName);
                    if (ps != null) {
                        arrayMap = arrayMap2;
                        if (PackageManagerServiceUtils.isUnusedSinceTimeInMillis(ps.firstInstallTime, currentTimeInMillis, downgradeTimeThresholdMillis, getDexManager().getPackageUseInfoOrDefault(pkg.packageName), pkg.getLatestPackageUseTimeInMills(), pkg.getLatestForegroundPackageUseTimeInMills())) {
                            unusedPackages.add(pkg.packageName);
                        }
                        arrayMap2 = arrayMap;
                        it = it;
                    }
                }
                return unusedPackages;
            } catch (Throwable th) {
                th = th;
                throw th;
            }
        }
    }

    private static boolean isSystemAppGrantByMdmAndNonPreload(PackageParser.Package pkg) {
        if (MDM_SYS_APP_PREALOAD_LIST.containsKey(pkg.packageName) || TextUtils.isEmpty(pkg.codePath)) {
            return false;
        }
        String str = pkg.codePath;
        if (!str.startsWith(Environment.getDataAppDirectory(pkg.volumeUuid) + SliceClientPermissions.SliceAuthority.DELIMITER) || !mHwPMSEx.isSystemAppGrantByMdm(pkg)) {
            return false;
        }
        return true;
    }

    /* access modifiers changed from: private */
    public static boolean isSystemAppGrantByMdmAndNonPreload(String packageName, String codePath, String volumeUuid) {
        if (MDM_SYS_APP_PREALOAD_LIST.containsKey(packageName) || TextUtils.isEmpty(codePath)) {
            return false;
        }
        if (!codePath.startsWith(Environment.getDataAppDirectory(volumeUuid) + SliceClientPermissions.SliceAuthority.DELIMITER) || !mHwPMSEx.isSystemAppGrantByMdm(packageName)) {
            return false;
        }
        return true;
    }

    public void setHarmfulAppWarning(String packageName, CharSequence warning, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "setHarmfulAppInfo");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) == 0) {
            synchronized (this.mPackages) {
                this.mSettings.setHarmfulAppWarningLPw(packageName, warning, userId);
                scheduleWritePackageRestrictionsLocked(userId);
            }
            return;
        }
        throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
    }

    public CharSequence getHarmfulAppWarning(String packageName, int userId) {
        String harmfulAppWarningLPr;
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, true, true, "getHarmfulAppInfo");
        if (callingAppId != 1000 && callingAppId != 0 && checkUidPermission("android.permission.SET_HARMFUL_APP_WARNINGS", callingUid) != 0) {
            throw new SecurityException("Caller must have the android.permission.SET_HARMFUL_APP_WARNINGS permission.");
        } else if (mHwPMSEx.isNeedForbidAppAct(HARMFUL_PACKAGE_FORBIDDEN, null, null, null)) {
            Slog.i(TAG, "forbid harmful package scenes, getHarmfulAppWarning return null");
            return null;
        } else {
            synchronized (this.mPackages) {
                harmfulAppWarningLPr = this.mSettings.getHarmfulAppWarningLPr(packageName, userId);
            }
            return harmfulAppWarningLPr;
        }
    }

    public boolean isPackageStateProtected(String packageName, int userId) {
        int callingUid = Binder.getCallingUid();
        int callingAppId = UserHandle.getAppId(callingUid);
        this.mPermissionManager.enforceCrossUserPermission(callingUid, userId, false, true, "isPackageStateProtected");
        if (callingAppId == 1000 || callingAppId == 0 || checkUidPermission("android.permission.MANAGE_DEVICE_ADMINS", callingUid) == 0) {
            return this.mProtectedPackages.isPackageStateProtected(userId, packageName);
        }
        throw new SecurityException("Caller must have the android.permission.MANAGE_DEVICE_ADMINS permission.");
    }

    public void sendDeviceCustomizationReadyBroadcast() {
        this.mContext.enforceCallingPermission("android.permission.SEND_DEVICE_CUSTOMIZATION_READY", "sendDeviceCustomizationReadyBroadcast");
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent("android.intent.action.DEVICE_CUSTOMIZATION_READY");
            intent.setFlags(DumpState.DUMP_SERVICE_PERMISSIONS);
            try {
                ActivityManager.getService().broadcastIntent((IApplicationThread) null, intent, (String) null, (IIntentReceiver) null, 0, (String) null, (Bundle) null, new String[]{"android.permission.RECEIVE_DEVICE_CUSTOMIZATION_READY"}, -1, (Bundle) null, false, false, -1);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    static class ActiveInstallSession {
        private final String mInstallerPackageName;
        private final int mInstallerUid;
        private final IPackageInstallObserver2 mObserver;
        private final String mPackageName;
        private final PackageInstaller.SessionParams mSessionParams;
        private final PackageParser.SigningDetails mSigningDetails;
        private final File mStagedDir;
        UserHandle mUser;

        ActiveInstallSession(String packageName, File stagedDir, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, PackageParser.SigningDetails signingDetails) {
            this.mPackageName = packageName;
            this.mStagedDir = stagedDir;
            this.mObserver = observer;
            this.mSessionParams = sessionParams;
            this.mInstallerPackageName = installerPackageName;
            this.mInstallerUid = installerUid;
            this.mUser = user;
            this.mSigningDetails = signingDetails;
        }

        public String getPackageName() {
            return this.mPackageName;
        }

        public File getStagedDir() {
            return this.mStagedDir;
        }

        public IPackageInstallObserver2 getObserver() {
            return this.mObserver;
        }

        public PackageInstaller.SessionParams getSessionParams() {
            return this.mSessionParams;
        }

        public String getInstallerPackageName() {
            return this.mInstallerPackageName;
        }

        public int getInstallerUid() {
            return this.mInstallerUid;
        }

        public UserHandle getUser() {
            return this.mUser;
        }

        public PackageParser.SigningDetails getSigningDetails() {
            return this.mSigningDetails;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ArrayMap<String, PackageParser.Package> getPackagesLock() {
        return this.mPackages;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Settings getSettings() {
        return this.mSettings;
    }

    /* JADX WARN: Type inference failed for: r0v0, types: [com.android.server.pm.PackageManagerService$HwInnerPackageManagerService, android.os.IBinder] */
    /* JADX WARNING: Unknown variable types count: 1 */
    public IBinder getHwInnerService() {
        return this.mHwInnerService;
    }

    public IHwPackageManagerServiceEx getHwPMSEx() {
        return mHwPMSEx;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsDefaultPreferredActivityChangedInner() {
        return this.mIsDefaultPreferredActivityChanged;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsDefaultGoogleCalendarInner() {
        return this.mIsDefaultGoogleCalendar;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HwCustPackageManagerService getHwPMSCustPackageManagerService() {
        return getCustPackageManagerService();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean isFirstBootInner() {
        return isFirstBoot();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Installer getInstallerInner() {
        return this.mInstaller;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PackageSetting getPackageSettingByPackageName(String packageName) {
        PackageSetting packageSetting;
        synchronized (this.mPackages) {
            packageSetting = this.mSettings.mPackages.get(packageName);
        }
        return packageSetting;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public String getNameForUidInner(int uid) {
        return getNameForUid(uid);
    }

    public void writeRuntimePermissionsForUser(int userId) {
        synchronized (this.mPackages) {
            this.mSettings.writeRuntimePermissionsForUserLPr(userId, true);
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int checkSignaturesInner(String pkg1, String pkg2) {
        return checkSignatures(pkg1, pkg2);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getCotaFlagInner() {
        return this.mCotaFlag;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setHwPMSCotaApksInstallStatus(int value) {
        setCotaApksInstallStatus(value);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scanPackageFilesLIInner(File[] files, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanPackageFilesLI(files, parseFlags, scanFlags, currentTime, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HashMap<String, HashSet<String>> getHwPMSCotaDelInstallMap() {
        return getCotaDelInstallMap();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ArrayMap<String, FeatureInfo> getAvailableFeaturesInner() {
        return this.mAvailableFeatures;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public ActivityInfo getResolveActivityInner() {
        return this.mResolveActivity;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setUpCustomResolverActivityInner(PackageParser.Package pkg) {
        setUpCustomResolverActivity(pkg);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PackageParser.Package scanPackageLIInner(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user, int hwFlags) throws PackageManagerException {
        return scanPackageLI(scanFile, parseFlags, scanFlags, currentTime, user, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int installExistingPackageAsUserInternalInner(String packageName, int userId, int installFlags, int installReason) {
        return installExistingPackageAsUserInternal(packageName, userId, installFlags, installReason, null, null);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void prepareAppDataAfterInstallLIFInner(PackageParser.Package pkg) {
        prepareAppDataAfterInstallLIF(pkg);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void updateSettingsLIInner(PackageParser.Package newPackage, String installerPackageName, int[] allUsers, PackageInstalledInfo res, UserHandle user, int installReason) {
        updateSettingsLI(newPackage, installerPackageName, allUsers, res, user, installReason);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void updateSharedLibrariesLPrInner(PackageParser.Package pkg, PackageParser.Package changingLib) throws PackageManagerException {
        updateSharedLibrariesLocked(pkg, changingLib, this.mPackages);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public UserManagerInternal getUserManagerInternalInner() {
        return getUserManagerInternal();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void sendPackageBroadcastInner(String action, String pkg, Bundle extras, int flags, String targetPkg, IIntentReceiver finishedReceiver, int[] userIds, int[] instantUserIds) {
        sendPackageBroadcast(action, pkg, extras, flags, targetPkg, finishedReceiver, userIds, instantUserIds);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getSystemReadyInner() {
        return this.mSystemReady;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public HashMap<String, HashSet<String>> getHwPMSCotaInstallMap() {
        return getCotaInstallMap();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void killApplicationInner(String pkgName, int appId, String reason) {
        killApplication(pkgName, appId, reason);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void removePackageLIInner(PackageParser.Package pkg, boolean chatty) {
        removePackageLI(pkg, chatty);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int deletePackageInner(String packageName, long versionCode, int userId, int deleteFlags) {
        return deletePackageX(packageName, versionCode, userId, deleteFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scanDirLIInner(File scanDir, int parseFlags, int scanFlags, long currentTime, int hwFlags) {
        scanDirLI(scanDir, parseFlags, scanFlags, currentTime, hwFlags);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void assertProvidersNotDefined(PackageParser.Package pkg) throws PackageManagerException {
        this.mComponentResolver.assertProvidersNotDefined(pkg);
    }

    public class HwInnerPackageManagerService extends IHwPackageManager.Stub {
        PackageManagerService mPMS;

        HwInnerPackageManagerService(PackageManagerService pms) {
            this.mPMS = pms;
        }

        public boolean setAllAppsUseSideMode(boolean isUse) {
            return PackageManagerService.mHwPMSEx.setAllAppsUseSideMode(isUse);
        }

        public boolean setAllAppsUseSideModeAndStopApps(List<String> pkgs, boolean isUse) {
            return PackageManagerService.mHwPMSEx.setAllAppsUseSideModeAndStopApps(pkgs, isUse);
        }

        public boolean restoreAllAppsUseSideMode() {
            return PackageManagerService.mHwPMSEx.restoreAllAppsUseSideMode();
        }

        public boolean isAllAppsUseSideMode(List<String> packages) {
            return PackageManagerService.mHwPMSEx.isAllAppsUseSideMode(packages);
        }

        public boolean isPerfOptEnable(String packageName, int optType) {
            return PackageManagerService.mHwPMSEx.isPerfOptEnable(packageName, optType);
        }

        public int getAppUseNotchMode(String packageName) {
            return PackageManagerService.mHwPMSEx.getAppUseNotchMode(packageName);
        }

        public void setAppUseNotchMode(String packageName, int mode) {
            PackageManagerService.mHwPMSEx.setAppUseNotchMode(packageName, mode);
        }

        public int getAppUseSideMode(String packageName) {
            return PackageManagerService.mHwPMSEx.getAppUseSideMode(packageName);
        }

        public void setAppUseSideMode(String packageName, int mode) {
            PackageManagerService.mHwPMSEx.setAppUseSideMode(packageName, mode);
        }

        public void setAppCanUninstall(String packageName, boolean canUninstall) {
            PackageManagerService.mHwPMSEx.setAppCanUninstall(packageName, canUninstall);
        }

        public boolean setApplicationAspectRatio(String packageName, String aspectName, float ar) {
            return PackageManagerService.mHwPMSEx.setApplicationAspectRatio(packageName, aspectName, ar);
        }

        public float getApplicationAspectRatio(String packageName, String aspectName) {
            return PackageManagerService.mHwPMSEx.getApplicationAspectRatio(packageName, aspectName);
        }

        public boolean setForceDarkSetting(List<String> packageNames, int forceDarkMode) {
            return PackageManagerService.mHwPMSEx.setForceDarkSetting(packageNames, forceDarkMode);
        }

        public int getForceDarkSetting(String packageName) {
            return PackageManagerService.mHwPMSEx.getForceDarkSetting(packageName);
        }

        public void setVersionMatchFlag(int deviceType, int version, boolean isMatchSuccess) {
            PackageManagerService.mHwPMSEx.setVersionMatchFlag(deviceType, version, isMatchSuccess);
        }

        public boolean getVersionMatchFlag(int deviceType, int version) {
            return PackageManagerService.mHwPMSEx.getVersionMatchFlag(deviceType, version);
        }

        public void setOpenFileResult(Intent intent, int retCode) {
            PackageManagerService.mHwPMSEx.setOpenFileResult(intent, retCode);
        }

        public int getOpenFileResult(Intent intent) {
            return PackageManagerService.mHwPMSEx.getOpenFileResult(intent);
        }

        public List<String> getPreinstalledApkList() {
            return PackageManagerService.mHwPMSEx.getPreinstalledApkList();
        }

        public List<String> getHwPublicityAppList() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppList();
        }

        public ParcelFileDescriptor getHwPublicityAppParcelFileDescriptor() {
            return PackageManagerService.mHwPMSEx.getHwPublicityAppParcelFileDescriptor();
        }

        public int startBackupSession(IBackupSessionCallback callback) {
            return PackageManagerService.mHwPMSEx.getStartBackupSession(callback);
        }

        public int executeBackupTask(int sessionId, String taskCmd) {
            return PackageManagerService.mHwPMSEx.getExecuteBackupTask(sessionId, taskCmd);
        }

        public int finishBackupSession(int sessionId) {
            return PackageManagerService.mHwPMSEx.getFinishBackupSession(sessionId);
        }

        public String getResourcePackageNameByIcon(String pkgName, int icon, int userId) {
            return PackageManagerService.mHwPMSEx.getResourcePackageNameByIcon(pkgName, icon, userId);
        }

        public boolean scanInstallApk(String apkFile) {
            return PackageManagerService.mHwPMSEx.scanInstallApk(apkFile);
        }

        public List<String> getScanInstallList() {
            return PackageManagerService.mHwPMSEx.getScanInstallList();
        }

        public void setHdbKey(String key) {
            PackageManagerService.mHwPMSEx.setHdbKey(key);
        }

        public boolean pmInstallHwTheme(String themePath, boolean setwallpaper, int userId) {
            return PackageManagerService.mHwPMSEx.pmInstallHwTheme(themePath, setwallpaper, userId);
        }

        public boolean isMapleEnv() {
            return ZygoteInit.sIsMygote;
        }

        public String readMspesFile(String fileName) {
            return PackageManagerService.mHwPMSEx.readMspesFile(fileName);
        }

        public boolean writeMspesFile(String fileName, String content) {
            return PackageManagerService.mHwPMSEx.writeMspesFile(fileName, content);
        }

        public String getMspesOEMConfig() {
            return PackageManagerService.mHwPMSEx.getMspesOEMConfig();
        }

        public int updateMspesOEMConfig(String src) {
            return PackageManagerService.mHwPMSEx.updateMspesOEMConfig(src);
        }

        public List<String> getSystemWhiteList(String type) {
            return PackageManagerService.mHwPMSEx.getSystemWhiteList(type);
        }

        public boolean shouldSkipTriggerFreeform(String pkgName, int userId) {
            return PackageManagerService.mHwPMSEx.shouldSkipTriggerFreeform(pkgName, userId);
        }

        public int getPrivilegeAppType(String pkgName) {
            return PackageManagerService.mHwPMSEx.getPrivilegeAppType(pkgName);
        }

        public void clearPreferredActivityAsUser(IntentFilter filter, int match, ComponentName[] set, ComponentName activity, int userId) {
            PackageManagerService.mHwPMSEx.clearPreferredActivityAsUser(filter, match, set, activity, userId);
        }

        public void registerExtServiceProvider(IExtServiceProvider extServiceProvider, Intent filter) {
            PackageManagerService.mHwPMSEx.registerExtServiceProvider(extServiceProvider, filter);
        }

        public void unregisterExtServiceProvider(IExtServiceProvider extServiceProvider) {
            PackageManagerService.mHwPMSEx.unregisterExtServiceProvider(extServiceProvider);
        }

        public boolean getMapleEnableFlag(String packageName) {
            PackageSetting ps;
            int callingUid = Binder.getCallingUid();
            String callingApp = PackageManagerService.this.getNameForUid(callingUid);
            synchronized (PackageManagerService.this.mPackages) {
                ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
            }
            StringBuilder sb = new StringBuilder();
            sb.append((ps == null || !ps.isSharedUser()) ? "" : ps.sharedUser.name);
            sb.append(":");
            String sharedUserIdName = sb.toString();
            if (packageName == null || callingApp == null) {
                return false;
            }
            if (callingApp.equals(packageName) || callingApp.startsWith(sharedUserIdName) || callingUid == 1000) {
                return HwMaplePMServiceUtils.getMapleEnableFlag(packageName);
            }
            return false;
        }

        public void setMapleEnableFlag(String packageName, boolean flag) {
            PackageSetting ps;
            int callingUid = Binder.getCallingUid();
            String callingApp = PackageManagerService.this.getNameForUid(callingUid);
            synchronized (PackageManagerService.this.mPackages) {
                ps = PackageManagerService.this.mSettings.mPackages.get(packageName);
            }
            StringBuilder sb = new StringBuilder();
            sb.append((ps == null || !ps.isSharedUser()) ? "" : ps.sharedUser.name);
            sb.append(":");
            String sharedUserIdName = sb.toString();
            if (packageName != null && callingApp != null) {
                if (callingApp.equals(packageName) || callingApp.startsWith(sharedUserIdName) || callingUid == 1000) {
                    HwMaplePMServiceUtils.setMapleEnableFlag(packageName, flag);
                }
            }
        }

        public Bundle[] canGrantDPermissions(Bundle[] bundles) {
            return PackageManagerService.mHwPMSEx.canGrantDPermissions(bundles);
        }

        public Map<String, String> getHwRenamedPackages(int flags) {
            return PackageManagerService.mHwPMSEx.getHwRenamedPackages(flags);
        }

        public List<ApplicationInfo> getClusterApplications(int flags, int clusterMask, boolean isOnlyDisabled) {
            int callingUid = Binder.getCallingUid();
            int userId = UserHandle.getCallingUserId();
            if (PackageManagerService.this.getInstantAppPackageName(callingUid) == null) {
                return PackageManagerService.mHwPMSEx.getClusterApplications(flags, clusterMask, isOnlyDisabled, userId);
            }
            Slog.e(PackageManagerService.TAG, "Instant app can not query cluster Applications!");
            return Collections.emptyList();
        }

        public List<HwHepPackageInfo> getInstalledHep(int flags) {
            if (PackageManagerService.this.getInstantAppPackageName(Binder.getCallingUid()) == null) {
                return PackageManagerService.mHwPMSEx.getInstalledHep(flags);
            }
            Slog.e(PackageManagerService.TAG, "Instant app can not query installed hep information!");
            return Collections.emptyList();
        }

        public HwPresetPackage getPresetPackage(String packageName) {
            if (PackageManagerService.this.checkUidPermission("com.huawei.permission.QUERY_PRESET_PACKAGE", Binder.getCallingUid()) == 0) {
                return PackageManagerService.mHwPMSEx.getPresetPackage(packageName);
            }
            Slog.e(PackageManagerService.TAG, "Do not have the permission to query Preset package information!");
            return null;
        }

        public int uninstallHep(String packageName, int flags) {
            return PackageManagerService.mHwPMSEx.uninstallHep(packageName, flags);
        }

        public int getDisplayChangeAppRestartConfig(int type, String pkgName) {
            return PackageManagerService.mHwPMSEx.getDisplayChangeAppRestartConfig(type, pkgName);
        }

        public FeatureInfo[] getHwSystemAvailableFeatures() {
            if (PackageManagerService.mHwPMSEx == null) {
                return new FeatureInfo[0];
            }
            return PackageManagerService.mHwPMSEx.getHwSystemAvailableFeatures();
        }

        public boolean hasHwSystemFeature(String featureName, int version) {
            if (PackageManagerService.mHwPMSEx == null) {
                return false;
            }
            return PackageManagerService.mHwPMSEx.hasHwSystemFeature(featureName, version);
        }
    }

    public boolean getHwCertPermission(boolean allowed, PackageParser.Package pkg, String perm) {
        return mHwPMSEx.getHwCertPermission(allowed, pkg, perm);
    }

    public void updateAppsUseSideWhitelist(ArrayMap<String, String> compressApps, ArrayMap<String, String> extendApps) {
        mHwPMSEx.updateAppsUseSideWhitelist(compressApps, extendApps);
    }

    public List<String> getAppsUseSideList() {
        return mHwPMSEx.getAppsUseSideList();
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public Handler getPackageHandler() {
        return this.mHandler;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public PermissionManagerServiceInternal getPermissionManager() {
        return this.mPermissionManager;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public InstallParams createInstallParams(OriginInfo origin, MoveInfo move, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, String volumeUuid, VerificationInfo verificationInfo, UserHandle user, String packageAbiOverride, String[] grantedPermissions, PackageParser.SigningDetails signingDetails, int installReason) {
        return new InstallParams(origin, move, observer, installFlags, installerPackageName, volumeUuid, verificationInfo, user, packageAbiOverride, grantedPermissions, null, signingDetails, installReason, -1);
    }

    @Override // com.android.server.pm.AbsPackageManagerService, com.android.server.pm.IHwPackageManagerInner
    public Signature[] getRealSignature(PackageParser.Package pkg) {
        if (pkg == null || !pkg.mRealSigningDetails.hasSignatures()) {
            return new Signature[0];
        }
        return pkg.mRealSigningDetails.signatures;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void setRealSigningDetails(PackageParser.Package pkg, PackageParser.SigningDetails real) {
        if (real != null) {
            pkg.mRealSigningDetails = real;
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public boolean getIsPreNUpgradeInner() {
        return this.mIsPreNUpgrade;
    }

    /* access modifiers changed from: package-private */
    public CompilerStats getCompilerStats() {
        return this.mCompilerStats;
    }

    /* access modifiers changed from: package-private */
    public List<PackageParser.Package> getOptimizablePkgList() {
        List<PackageParser.Package> pkgs = new ArrayList<>();
        synchronized (this.mPackages) {
            for (PackageParser.Package p : this.mPackages.values()) {
                if (PackageDexOptimizer.canOptimizePackage(p)) {
                    pkgs.add(p);
                }
            }
        }
        return pkgs;
    }

    public int getSdkVersion() {
        return this.tSdkVersion;
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void WritePackageRestrictions(int userId) {
        scheduleWritePackageRestrictionsLocked(userId);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void sendPreferredActivityChangedBroadcast(int userId) {
        if (!updateDefaultHomeNotLocked(userId)) {
            postPreferredActivityChangedBroadcast(userId);
        }
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public int getUidTargetSdkVersionLockedLPrEx(int userId) {
        return getUidTargetSdkVersionLockedLPr(userId);
    }

    @Override // com.android.server.pm.IHwPackageManagerInner
    public void scheduleWriteSettingsInner() {
        synchronized (this.mPackages) {
            scheduleWriteSettingsLocked();
        }
    }
}
